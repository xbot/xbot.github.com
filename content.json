{"meta":{"title":"晴耕雨讀","subtitle":"程序員，最佳實踐和閱讀愛好者，Vim、Archlinux、Mac、iOS擁躉，帝都低端人口。","description":null,"author":"晴耕雨讀","url":"http://0x3f.org"},"pages":[{"title":"博主本紀","date":"2013-05-12T12:46:00.000Z","updated":"2017-02-14T04:27:41.000Z","comments":true,"path":"about/index.html","permalink":"http://0x3f.org/about/index.html","excerpt":"","text":"博主者，故陳國人也，起於閭左，姓名不可考。 少有痴名，喜讀書，涉獵頗雜，不求甚解。弱冠之年，游學淮左，無所成。及長，愈癲痴無知、憊懶無賴。時有西域番國進貢算籌之機，以雷公電母之力驅使，天朝善之，百業咸用，遂渾跡帝都，以操機佐餌。幸天資未泯，頗悉C、PHP、Java、Javascript、Python、Lua、Bash等西域奇技淫巧，尤善Linux、Vim等奇門遁甲之術。以文明之興，皆有主義，遂奉李查德·斯托曼及李納斯·托瓦茲為二聖，厲行KISS、DRY諸原則。 於他事皆甚愚鈍。雖標榜中右政治傾向，然實不聞國事。裹腹之余，唯以晴耕雨讀寄意，喜山水，樂遊歷，以太白「五嶽尋仙不辭遠，一生好入名山游」自命。 偶一日，南柯一夢，為大司馬，大將軍，燕國公，領幽州牧，行驃騎大將軍事，冊拜太師、太傅、太保，假節鉞，受九錫，入朝不拜，過廷不趨，劍履上殿，贊拜不名，使持節、開府、儀同三司，都督冀、青、幽、並、兗、豫、梁、廣、揚九州諸軍事。大悅，為食斗粟。"}],"posts":[{"title":"配置鼠須管的特殊符號輸入","slug":"input-punctuations-with-rime","date":"2018-10-13T03:59:50.000Z","updated":"2018-10-13T04:34:30.408Z","comments":true,"path":"post/input-punctuations-with-rime/","link":"","permalink":"http://0x3f.org/post/input-punctuations-with-rime/","excerpt":"","text":"開源工具最常見的問題就是文檔不全，實現一個需求的時候隻能苦苦Google，甚至連蒙帶猜。這也是我逐漸傾向買用戶體驗更好的收費軟件的原因。 鼠須管是自帶特殊符號碼表的，在用戶配置目錄中的symbols.yaml，但是有的碼表需要手動配置。經過查資料和摸索，關鍵在於以下幾項配置： 1234567punctuator: import_preset: symbolsrecognizer: import_preset: default patterns: punct: \"^/([a-z]+|[0-9]0?)$\" 然後就可以通過【/】+【編碼】的方式顯示符號備選項了，具體的編碼可以到symbols.yaml裏看，當然一般爲了方便定制該碼表，會複制並重命名該文件，然後上述的配置項裏也要做相應的修改。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"}]},{"title":"我叫王戰鬥","slug":"i-am-wang-zhandou","date":"2018-07-01T08:46:32.000Z","updated":"2018-10-13T03:54:06.721Z","comments":true,"path":"post/i-am-wang-zhandou/","link":"","permalink":"http://0x3f.org/post/i-am-wang-zhandou/","excerpt":"","text":"我叫王戰鬥，男，喵星人，狸花族，現年四個半月，折合成你們兩腳獸的年齡算7歲了。 雖然剛降臨你星不久，但是我已經能馴服和駕馭兩腳獸這種低等生物了。因為我發現這種生物本性里有一個致命弱點：對它很好反而不會珍惜，故作高冷卻奴顏婢膝求抱抱！我們喵星管這叫「賤」。 開始的時候，我的馭獸術還不熟練，而且我酷愛往兩腳獸的脖子里鑽，然後蹭它們的臉。結果它們不乾了，在我才兩個月零九天的時候就把我交給了現在這頭兩腳獸。是它們不懂喵星習俗好不好？！而且作為一個剛斷奶的小正太，賣個萌怎麼啦，怪我咯？😹 我一直在暗中觀察現在這頭兩腳獸。發現每隔五天，它都會在巢穴里待上兩天，然後在接下來的五天里每天都消失一段時間。雖然有點好奇，不過也不是什麼大事，只要我有吃有喝、兩腳獸按時鏟屎，每天給它放個風什麼的我也OK，這是我們喵星高等生物的自我修養。 不過還是要測試一下這貨的馴服度。所以我命令它伺候我睡個午覺： 這貨竟然沒有反抗！！！ 有一天我發現它竟然在偷看我練習家傳絕學「黑虎掏心」，我就瞪它，就瞪它： 有時候兩腳獸全神貫注地照鏡子，我就想看看它看的啥，然後它就扒拉我，我想一定是我高大威猛的身軀擋住它了： 這老頭叫馬霸霸，挺能白話的，它的巢穴已經被我軍佔領了： 那天兩腳獸帶回來一隻老鼠，我一眼就看出來是假的，但是這貨一碰就叫啊，然後我就停不下來了，你星管這叫口嫌體正直，看著兩腳獸謎之微笑，我覺得中了奸計： 更有甚者，它竟然趁我睡著的時候拍我裸照，還傳到網上： 生亦何歡，死亦何懼。趁兩腳獸上廁所的時候，叼走了捲紙，然後撕稀碎，有能耐學我們喵星人上完廁所自己舔乾淨啊？！ 沒想到報復來得如此突然，兩腳獸不知道從哪兒搞了一瓶毒氣，走到哪兒揣到哪兒，我一想搞事情就各種噴： 真臭啊，臭到懷疑喵生啊！ 話說回來，大部分時間兩腳獸還是沒那麼討厭。比如這個會噴水的盒子，被我霸佔後就成了我最常喝水的東西兼洗腳盆： 兩腳獸的廚藝也不賴： 吹噓自己慷慨的時候，兩腳獸就指著這口袋說：「比我吃得都好。」其實就是618的打折貨。 兩腳獸就是個肥宅兼Nerd，且不說為了給我做飯專門買了台電動切碎機和保鮮盒。鏟個屎都裝絕命毒師： 某天整了把稀奇古怪的東西在床上、沙發上各種吸，完事非要說是我乾的： 我的天啊！不就掉個毛麼，全宇宙只有你們兩腳獸光著屁股滿世界跑！ 我來，我見，我征服。我是王戰鬥，一個普通的馴兽師。","categories":[{"name":"晴耕雨讀","slug":"晴耕雨讀","permalink":"http://0x3f.org/categories/晴耕雨讀/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"王戰鬥","slug":"王戰鬥","permalink":"http://0x3f.org/tags/王戰鬥/"}]},{"title":"生成PDF的方案調研","slug":"pdf-creating-solutions","date":"2018-05-16T07:41:36.000Z","updated":"2018-05-16T07:45:52.178Z","comments":true,"path":"post/pdf-creating-solutions/","link":"","permalink":"http://0x3f.org/post/pdf-creating-solutions/","excerpt":"","text":"結論傾向於通過wkhtmltopdf+消息隊列實現。 工作流程： 用戶保存表單 推送生成pdf的任務到隊列 同時頁面顯示「正在生成PDF文檔，請稍候」並輪詢後端接口 PDF生成後，頁面顯示下載按鈕 後端dompdf純PHP實現。工作原理是把HTML轉換成PDF。 優點： 不需要PHP調用命令行，安全性高。 缺點： HTML/CSS支持不完全，實測多個網頁轉換後排版錯亂。 中文網頁轉換後，中文都是問號（網上說有解決辦法1、2，未測試）。 CPU佔用比較高（網上的說法，沒有實測具體有多高）。 參考： laravel-dompdf主頁 mpdf純PHP實現。工作原理是把HTML轉換成PDF。 優點： 不需要PHP調用命令行，安全性高。 缺點（未實測）： HTML/CSS支持不完整。 生成PDF耗時長。 參考： laravel-pdf主頁 mpdf文檔 mpdf主頁 mpdf與fpdf的使用比較 PDFtk ServerPDFtk Server是個命令行程序。工作原理是利用FDF表單替換PDF模板中的佔位符。實現方案有：純PHP實現FDF + PDFtk、FPDI + PDFtk。 優點： 直接替換PDF模板，實現成本低，最大程度保證生成的PDF的效果。 缺點： 需要允許PHP調用命令行，有安全隱患。 只能實現簡單的字符串替換（例如公司名稱），不能替換有格式文本。 參考： FPDI PHP的FDF手冊 PDFtk的使用方法 純PHP實現FDF + PDFtk wkhtmltopdfwkhtmltopdf是個命令行程序。工作原理是轉換HTML到PDF。實現方案是laravel-snappy。 優點： 由於內嵌webkit核心，HTML/CSS的支持沒有問題。 缺點： 需要允許PHP調用命令行，有安全隱患。 wkhtmltopdf體積40M，併發較多時影響服務器性能和穩定性（需要考慮用隊列輔助實現，異步執行，需要需求變更交互方式）。 參考： laravel-snappy主頁 CutyCapt命令行程序。工作原理和wkhtmtopdf相同。 優缺點同wkhtmltopdf，但是最近的更新在13年。 參考： CutyCapt主頁 Prince命令行程序。工作原理是轉換HTML到PDF。 優點： HTML/CSS的支持很好。 文檔很全 缺點： 收費，而且很貴。（免費版會在輸出的文檔右上角打一個Logo） 需要允許PHP執行命令行，有安全隱患。 需要考慮用隊列輔助實現，異步執行，需要需求變更交互方式。 參考： Prince官網 前端jsPDF工作原理有兩種：編程方式動態生成和轉換HTML到PDF。有三個插件支持轉換HTML到PDF：fromHTML、addHTML和html2pdf。 fromHTML最老，優點是直接轉換HTML到PDF，缺點是對複雜的HTML/CSS支持得不好。實測結果，UTF-8編碼的中文網頁，轉換到PDF都是亂碼。 addHTML較新，但目前處於deprecated狀態，利用html2canvas/rasterizeHTML創建一個canvas，然後把HTML轉換成圖片、再轉換成PDF。實測結果，對中文網頁和CSS支持得都不錯，但是對分頁支持得不好，指定分頁選項後圖片被拉伸並強行分割，很難看。 html2pdf是正在開發的功能，還沒完成。 參考： https://stackoverflow.com/questions/44778260/what-are-the-differences-between-jspdfs-methods-addhtml-and-fromhtml pdfkit只能通過編程（//調用接口指定內容、分頁等相關屬性//）生成PDF，不支持從HTML轉換到PDF。 pdfmake據說擴展自pdfkit。只能通過編程（//調用接口指定內容、分頁等相關屬性//）生成PDF，不支持從HTML轉換到PDF。而且需要引用字體文件轉換成的js文件，不適合中文內容。 變通方案利用瀏覽器打印PDFChrome、Firefox、Safari的最新版都支持打印網頁到PDF，Edge未測試。 優點： 實現成本低。 缺點： 用戶體驗差。 導出word文檔優點： 實現成本低。（未證實） 缺點： 用戶可更改文檔。 參考 https://blog.stahlmandesign.com/export-html-to-pdf-how-hard-can-it-be/ PHP輸出PDF打印HTML5+CSS3打印格式控制(Prince和wkhtmltopdf)","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"}]},{"title":"少不讀村上","slug":"after-reading-killing-commendatore","date":"2018-04-22T05:55:00.000Z","updated":"2018-04-22T05:56:39.972Z","comments":true,"path":"post/after-reading-killing-commendatore/","link":"","permalink":"http://0x3f.org/post/after-reading-killing-commendatore/","excerpt":"","text":"讀完了《刺殺騎士團長》。 開始一直以為是類似《禁閉島》那樣的表達手法，覺得當個懸疑的故事看也不錯，結果直到最後一頁，才發現連裝神弄鬼都不是，頓時覺得六十塊錢花得有點冤。單從表達手法上說，不喜歡神神叨叨的東西。憑著炒魔幻現實主義的冷飯得諾獎怕是不大可能。 故事的大致情節是：生活平淡的畫家，突遇婚變，逃避現實的過程中經歷一系列魔幻和現實交錯的事，最後解開心結，回到現實，找到救贖。 這本書要表達的東西很多，出現的每一個主體都存在於多條敘事線中，只粗略讀過一遍，大概也就理解了個皮毛。最主要的，是兩個概念和五幅畫。 兩個概念，分別是「理念」和「隱喻」。 理念是人在自我審視下出現的另一個「我」，包括善的和惡的。象徵善的理念的是「騎士團長」，一個時隱時現、身高60釐米的古代日本武士形象。象徵惡的理念的是「白色斯巴魯男子」，隨時提醒「我」：你的惡，我都知道。 隱喻是人生各種經歷的具象化的形象。 五幅畫，分別是《刺殺騎士團長》、《免色肖像畫》、《白色斯巴魯男子》、《雜木林中的洞穴》和《真理惠肖像畫》。 《刺殺騎士團長》的作用很多。首先，從這幅畫引出被遺忘的二戰中的往事，包括雨田具彥在奧地利和雨田繼彥在南京的遭遇。其次，騎士團長於「我」，是善的理念的象徵，於雨田具彥，是隱藏數十年揮之不去的心結。第三，最終「我」刺殺了騎士團長，一方面解了雨田具彥的心結，使其安詳地離世，另一方面，這是「我」進入隱喻世界的前提，也是解救真理惠的必要條件。 《白色斯巴魯男子》象徵「我」的惡的理念，也是所有人的惡的理念。 《免色肖像畫》引出免色這個重要角色。免色是個從世俗的各方面看都臻於完美的男人，然而這幅畫真正打動他的，恰恰是表現出了那些深藏的、消極的、惡的不完美的東西。 《雜木林中的洞穴》既是魔幻的開端，也是魔幻的終點。一切魔幻的開始，源於深夜中聽到的鈴聲。而「我」穿過隱喻世界，逃回現實世界，也發生在這個洞里。 《真理惠肖像畫》。真理惠既是「我」的妹妹「路」的替身，也是免色的心結。「我」通過刺殺騎士團長、穿過隱喻世界「解救」了真理惠，實際上解開了對「路」早逝的心結。 很多年前讀過《挪威的森林》，沮喪得要命，那時就認為少不讀村上春樹，至今如故。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"}]},{"title":"鼠須管的美化","slug":"beautify-squrrel-input-method","date":"2018-04-21T12:52:42.000Z","updated":"2018-04-22T05:58:18.942Z","comments":true,"path":"post/beautify-squrrel-input-method/","link":"","permalink":"http://0x3f.org/post/beautify-squrrel-input-method/","excerpt":"","text":"效果如下： 儘管鼠須管的Github倉庫一直在更新，但釋出版已經很久沒有更新了，所以下面的美化基於網絡上個人編譯的版本。這篇文章里有該版本和「花園明朝」字體的下載鏈接，按照文中的說明替換鼠須管的程序。（注意：官方當前釋出版本鼠須管不支持下文通過patch自定義配置的方式，會造成原配置信息丟失。也不支持圖示的樣式。） 然後參考這篇文章，把新的顏色方案移植到用戶配置中。 圖示樣式使用「dust」方案。原色彩方案的字體設置的有點小，需要把font_point和label_font_point分別從14和10修改成18和14。原方案的第一順序字體是「HYQiHei-55S Book」，要使用圖示的花園明朝字體，可以不安裝或者從配置信息中去掉該字體。由於原方案中已存在的配置項不能通過patch的方式覆蓋，所以只能直接修改squirrel.yaml文件。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"工具","slug":"工具","permalink":"http://0x3f.org/tags/工具/"},{"name":"軟件","slug":"軟件","permalink":"http://0x3f.org/tags/軟件/"}]},{"title":"我在用的Safari擴展","slug":"the-safari-extensions-i-am-using","date":"2018-04-15T14:29:10.000Z","updated":"2018-04-22T05:59:30.084Z","comments":true,"path":"post/the-safari-extensions-i-am-using/","link":"","permalink":"http://0x3f.org/post/the-safari-extensions-i-am-using/","excerpt":"","text":"和Chrome相比，Safari更省電、需要更少的系統資源，而且Chrome還有一些莫名其妙的問題，比如在沒有運行的時候，從Alfred執行搜索會啓動兩個窗口，一個是之前的會話，另一個是當前的搜索頁面。並且，啓用了一些擴展之後Safari的體驗可以改進很多。所以平時用Safari更多一些。 sVim作為注重效率的Vim黨和鍵盤黨，這種擴展是使用任何瀏覽器必備的東西。最常用的就是用標記打開鏈接的功能。 Tampermonkey油猴腳本管理器，應該是任何瀏覽器必備的東西。 AutoPagerize用Google搜索時自動滾動到下一頁。 RSS Menu當發現當前頁面有可訂閱的RSS鏈接時，在工具欄圖標上顯示提示。 Instapaper稍後讀工具。 Turn Off the Lights看視頻時降低網頁其餘部分亮度。 Scroll To Top Button在頁面右下角顯示一個浮動的跳轉到頁首按鈕。 Push for KindleFiveFilters.org的發送到Kindle按鈕。 octotreeGitHub側邊欄。 Translate翻譯當前頁。 WikiWand優化維基百科閱讀體驗。 Xdebug HelperPHP單步調試輔助工具。 AdBlock廣告過濾器。 Sessions網頁會話管理器。如果打開的頁面太多，又可能在將來再用到，可以保存會話後清理掉，用到的時候再打開保存過的會話。雖然沒有Chrome下的Session Buddy和Tab Snooze好用，但是解決關鍵問題也夠了。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"工具","slug":"工具","permalink":"http://0x3f.org/tags/工具/"},{"name":"瀏覽器","slug":"瀏覽器","permalink":"http://0x3f.org/tags/瀏覽器/"},{"name":"軟件","slug":"軟件","permalink":"http://0x3f.org/tags/軟件/"}]},{"title":"廣告過濾工具AdBlock、Adblock Plus和uBlock的簡單對比","slug":"a-simple-comparison-among-adblock-ublock-and-adblock-plus","date":"2018-04-01T14:47:47.000Z","updated":"2018-04-05T17:19:00.703Z","comments":true,"path":"post/a-simple-comparison-among-adblock-ublock-and-adblock-plus/","link":"","permalink":"http://0x3f.org/post/a-simple-comparison-among-adblock-ublock-and-adblock-plus/","excerpt":"","text":"Adblock Plus作者的那篇博客可能會影響很多人。我並不關心那些情懷的東西，只看療效。 簡單地對比了下AdBlock、Adblock Plus、uBlock在Safari for Mac上的效果，所有樣本和環境均為當前最新版本。AdBlock開啓Safari內容過濾後是最好的，成功地過濾掉了我常訪問的一個BT下載網站上的所有廣告，而不開啓Safari內容過濾時，會出現部分廣告先顯示後隱藏的情況。uBlock漏掉了個別不容易屏蔽的。而Adblock Plus最差，缺省設置下一條都沒過濾掉，在選擇更多的過濾規則後才過濾掉一部分。由於樣本很單一，本結論不具有普適性。 說句題外話，我覺得Adblock Plus這名字起得動機就挺不純的，沒有詳細考證過，印象中這個東西是比AdBlock後出現的，而且這名字很容易讓人理解成AdBlock的加強版。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"軟件","slug":"軟件","permalink":"http://0x3f.org/tags/軟件/"}]},{"title":"變形金剛真人電影系列被重置","slug":"transformers-live-action-movie-series-reset","date":"2018-02-18T03:51:13.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/transformers-live-action-movie-series-reset/","link":"","permalink":"http://0x3f.org/post/transformers-live-action-movie-series-reset/","excerpt":"","text":"根據這條消息，變形金剛真人電影系列將會被新團隊重置，原定在明年的第6部被取消。也就是說，看完今年大黃蜂的電影後，2021年前都不會有變形金剛主題的新片了。 這種壯士斷腕的做法多少算是個好消息吧，經歷了變5的失敗，再讓麥克爾貝這麼折騰下去，變形金剛這個IP就完蛋了。 我對這件事是無可無不可的。作為一個八零後，我對變形金剛的情懷來自G1動畫，所以我的關注點主要是還原G1動畫風格的Master Piece系列。在MPM-3出來之前，我對電影系的玩具沒多大興趣。 當年變1上映的時候，我很難認同電影系的風格。但是後來從變1到變3，也逐漸地開始接受它，畢竟隨著技術的進步，審美風格也會發生變化，沒必要固守二、三十年前的東西。我對電影系最大的意見是劇情太爛，有句話很對，說一部戲好不好關鍵看反派角色，《蝙蝠俠之黑暗騎士崛起》之所以口碑不錯，主要是大反派小醜這個角色很立體。回頭說當年的G1動畫最成功的一點也是霸天虎尤其威震天這個角色塑造得比較成功。反觀電影系，相對於汽車人華麗的人形態和隱藏形態，霸天虎陣營就是一群猥瑣的低級生物，而且人物性格的塑造極其臉譜化。 直到後來變4的時候，風格進一步變化，加入大量騎士元素，機械元素的減少導致科技感進一步下降。最要命的是變4的玩具做得實在是一塌糊塗。至於變5，那真是電影做得和玩具一樣爛。 真是成也麥克爾貝，敗也麥克爾貝。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"變形金剛","slug":"變形金剛","permalink":"http://0x3f.org/tags/變形金剛/"}]},{"title":"iQunix F60使用感受","slug":"iqunix-f60","date":"2018-02-17T07:40:47.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/iqunix-f60/","link":"","permalink":"http://0x3f.org/post/iqunix-f60/","excerpt":"","text":"我不喜歡冗余的東西。如果桌子足夠大，我能接受的極限是87鍵。然而我的Filco 87聖手二代黑茶已經吃灰很久了，之前的主力是Poker II白青。所以目前主要的關注點還是在60鍵上。 我對Poker整體上還是比較滿意的，尤其是按鍵編程的功能很方便。但是有兩點讓我很不滿意。一是做工一般，鍵帽的活動幅度較大，遠遠沒有Filco的扎實感。二是不支持藍牙，無線化是一個用了就回不去的東西。 iQunix F60就是這麼個東西，符合我對鍵盤所有的核心需求：支持藍牙、做工好、60%佈局、Cherry軸、PBT鍵帽。用了一段時間，整體是滿意的。 買的銀白色，收到的是側刻，算是個小驚喜吧，雖然不如無刻騷氣，至少不像正刻那麼平庸。鋁合金外框加白色PBT鍵帽的顏值很高，整體很有質感。 做工比Poker好很多，找回了Filco的扎實感。PBT的鍵帽不打油，這一點超過了Filco。 續航一般，輕度使用可以持續一周。信號強度也很一般，一米的距離，已能感受到明顯的延遲。不過這些在實際的使用中不是什麼大問題。 功能上，不支持鍵盤編程，這點不如Poker。但是可以用組合鍵交換左側WIN鍵和ALT鍵，對Mac很友好。代替方向鍵的組合鍵位也比Poker合理。此外，可以用組合鍵切換有線和無線模式，支持在3台設備之間切換。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"數碼","slug":"數碼","permalink":"http://0x3f.org/tags/數碼/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"異地補卡下的北京中年","slug":"story-of-changing-sim-card","date":"2018-02-16T09:24:59.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/story-of-changing-sim-card/","link":"","permalink":"http://0x3f.org/post/story-of-changing-sim-card/","excerpt":"","text":"我媽的老SIM卡不能用在iPhone里。因為我的卡就是從大卡剪過來的，所以騎車轉了一大圈，臨近年關，大部分修手機的店、合作營業廳都關了，最後一個賣手機的店里的老闆說這種老卡不能剪，只能換卡。 之前聽附近移動營業廳里的大堂經理說，換卡需要機主本人、身份證和服務密碼，而且異地補卡只能去部分較大的營業廳。這個可以在網上營業廳里查到。 事先在網上營業廳重置了服務密碼。第二天一早，去了最近的可以異地補卡的營業廳。工作人員給了張紙條，讓寫下手機號、服務密碼，他們查了一下，說是鑒權失敗，讓第二天再去。留了營業廳的電話，事先讓他們查一下，確認可以辦了再去。 第三天早上十點，打電話過去，說是辦異地補卡的人還沒來。十一點再打過去，查了一下，說是可以辦了。去之前差點沒帶手機，因為感覺就是辦張卡，回來裝也一樣。事實證明，不帶會後悔。 補卡也需要用手寫板簽字和人臉識別，因為是2d圖像識別，所以很傻，需要搖頭、點頭、眨眼、張嘴，在張嘴這一步重試了很多次都失敗…… 補的第一張卡插到手機里不能識別，第二張才成功。 總結以上，異地補卡需要注意這些點： 本人、身份證、服務密碼（服務密碼可以去網上營業廳重置，前提是卡還在，還能接到短信） 去能辦理異地補卡的營業廳（可以在網上營業廳查詢，或者打客服電話） 不要去太早，最好事先打電話讓他們查一下，確認可以辦了再去 一定要帶手機和開卡槽的工具，現場裝卡測試","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"}]},{"title":"飛利浦電動牙刷HX9903/42使用感受","slug":"philips-hx9903-42","date":"2018-02-10T09:23:15.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/philips-hx9903-42/","link":"","permalink":"http://0x3f.org/post/philips-hx9903-42/","excerpt":"","text":"效果雖說沒別人說的誇張，也的確刷得很乾淨，再就是緩解了胳膊的疲勞感。 有個問題。剛開始的幾天，雖然電池已經充滿，但是震動強度很一般，而且手柄底部的壓力警示燈一直閃，試過拔掉刷頭，問題還在，說明是手柄的問題。直到提示電量緊張後第二次充電，之後才恢復正常。 App、多種刷頭、多種模式、壓力警示和三級震動強度都是噱頭，刷個牙而已，HX6730足夠了，多交的幾百塊錢除了智商稅，也就顏值和無線充電有點價值了。 電動牙刷不是個用了就回不去的東西，不過體驗確實很好，刷牙不再是例行公事和負擔，而是件挺有意思的事。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"數碼","slug":"數碼","permalink":"http://0x3f.org/tags/數碼/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"器物","slug":"器物","permalink":"http://0x3f.org/tags/器物/"}]},{"title":"用OTP Auth替換了Authy","slug":"migrate-from-authy-to-otp-auth","date":"2018-02-06T14:53:40.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/migrate-from-authy-to-otp-auth/","link":"","permalink":"http://0x3f.org/post/migrate-from-authy-to-otp-auth/","excerpt":"","text":"Authy的界面很花哨，但並不實用，管理多個兩步驗證賬號時查詢效率很低。OTP Auth採用更直觀的列表佈局，並且支持搜索，在用戶體驗和效率上有更大的優勢。兩者之間沒有批量遷移數據的方式，只能逐個手動添加，很麻煩。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"安全","slug":"安全","permalink":"http://0x3f.org/tags/安全/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"對XSS的防禦更適合放在前端","slug":"better-to-do-defenses-against-xss-in-front-end","date":"2018-02-06T07:13:17.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/better-to-do-defenses-against-xss-in-front-end/","link":"","permalink":"http://0x3f.org/post/better-to-do-defenses-against-xss-in-front-end/","excerpt":"","text":"很多項目會把轉義操作放在後端接口獲取參數的地方，從而忽略了這樣一個問題——為什麼主流框架都不在獲取參數的方法里實現這一點？ 以Laravel為例，如果可以這樣獲取轉義後的參數：$request-&gt;escape(&#39;content&#39;)，代碼會顯得更優雅，而實際上只能用自己封裝的函數手工轉義：my_escape($request-&gt;get(&#39;content&#39;))，很醜陋的代碼。 事實上，主流框架並非沒有提供防禦XSS的封裝，只是都放在模板引擎里。這樣做的依據是，XSS的原理是在原本用於展示的數據里包含了可執行的文本，但不是所有展示的位置都不應該包含可執行的文本。從另一角度上說，後端應該校驗前端傳遞的數據，但不應該篡改它。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"架構","slug":"架構","permalink":"http://0x3f.org/tags/架構/"}]},{"title":"十公里租房補貼是個天才的福利制度","slug":"rent-subsides-within-10km-is-wise","date":"2018-02-06T03:12:23.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/rent-subsides-within-10km-is-wise/","link":"","permalink":"http://0x3f.org/post/rent-subsides-within-10km-is-wise/","excerpt":"","text":"十公里以內是個很適合通勤的距離，以任何一種公共交通方式都可以把時間控制在半小時左右。 通勤時間每增加半小時，生活質量都會下降一個量級，而生活質量是會直接影響一個人的工作質量和穩定性的。所以有些公司有十公里內租房補貼的福利，這項制度天才的地方在於，如果把這些補貼以工資的形式發放，員工可能仍然會因為住得遠導致幸福感很差，所以增加了很多不穩定的因素。這項制度間接地強制員工把自己收入的一部分用在提高自己生活質量上面，記得那個朝三暮四、朝四暮三的故事嗎？公司花同樣的錢，卻得到了更大的價值。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"}]},{"title":"癸醜望，月有食之","slug":"lunar-eclipse","date":"2018-01-31T15:54:41.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/lunar-eclipse/","link":"","permalink":"http://0x3f.org/post/lunar-eclipse/","excerpt":"","text":"大概這是我第一次看月全食，暗紅色，挺大個兒，但是拍出來就顯得很小。論效果，iPhone X還不如幾年前的LX5。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"圖片","slug":"圖片","permalink":"http://0x3f.org/tags/圖片/"}]},{"title":"解決Laravel的Facade在被Mock時不自動注入依賴的一種方法","slug":"manual-dependency-injection-with-laravel","date":"2018-01-30T07:41:16.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/manual-dependency-injection-with-laravel/","link":"","permalink":"http://0x3f.org/post/manual-dependency-injection-with-laravel/","excerpt":"","text":"由於集成了Mockery，Laravel的Facade對單元測試非常友好，只需要一行代碼就能實現mocking。 例如，測試目標方法中調用了訂單工具類的一個方法，在使用依賴注入的方式時，需要用三行代碼實現對這個方法的mocking： 123$fakeOrderTool = m::mock(\\App\\Tool\\Order::class);$fakeOrderTool-&gt;shouldReceive('getById')-&gt;once()-&gt;with($id)-&gt;andReturn($fakeOrder);$this-&gt;app-&gt;instance(\\App\\Tool\\Order::class, $fakeOrderTool); 而用Facade是這樣的： 1OrderFacade::shouldReceive('getById')-&gt;once()-&gt;with($id)-&gt;andReturn($fakeOrder); 當測試目標方法也屬於訂單工具類時，需要部分mock這個類，所以還要加上一行： 1OrderFacade::makePartial(); 但如果訂單工具類的構造方法里有需要注入的依賴關係，這里並不會被執行。所以我在工具類基類里封裝了一個方法，用反射機制實現手工注入依賴關係： 1234567891011121314151617181920212223/** * 注入依赖，用于单元测试 * * @return void * @author donieli * @since 5 * @version 5 */public function injectDependencies()&#123; $reflector = new \\ReflectionClass(get_class($this)); $params = $reflector-&gt;getConstructor()-&gt;getParameters(); $args = []; foreach ($params as $param) &#123; $paramClass = $param-&gt;getClass(); if (empty($paramClass)) &#123; throw new \\Exception('Dependency named '.$param-&gt;getName().' cannot be injected.'); &#125; $instance = app()-&gt;make($paramClass-&gt;getName()); $args[] = $instance; &#125; call_user_func_array([$this, '__construct'], $args);&#125; 然後就可以這樣處理： 123OrderFacade::shouldReceive('getById')-&gt;with($id)-&gt;once()-&gt;andReturn($fakeOrder);OrderFacade::makePartial();OrderFacade::injectDependencies();","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://0x3f.org/tags/laravel/"}]},{"title":"從Vultr新加坡遷移到洛杉磯","slug":"migrate-vultr-from-singapore-to-los-angeles","date":"2018-01-28T06:15:57.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/migrate-vultr-from-singapore-to-los-angeles/","link":"","permalink":"http://0x3f.org/post/migrate-vultr-from-singapore-to-los-angeles/","excerpt":"","text":"Vultr新加坡節點掛了兩天了，不能翻牆簡直什麼都乾不了。早上用CloudSpeed看了下，洛杉磯機房的響應速度還不錯，就遷移了過去。 ShadowsocksR這個很簡單，用一鍵安裝腳本。 網絡加速用BBR，一鍵安裝腳本。 Tiny Tiny RSS先按照之前的筆記安裝ttrss。 然後重建一個空的ttrss的數據庫： 12docker exec f6d92ad8efba /usr/bin/psql -c \"drop database ttrss\"docker exec f6d92ad8efba /usr/bin/psql -c \"create database ttrss\" 把數據庫的備份複製到容器里並導入： 12docker cp ttrss.sql f6d92ad8efba:/tmp/ttrss.sqldocker exec f6d92ad8efba /usr/bin/psql -d ttrss -f /tmp/ttrss.sql postgres 以root身份登錄容器並刪除備份文件： 12docker exec -it --user root f6d92ad8efba /bin/shrm /tmp/ttrss.sql","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"}]},{"title":"Unlox：兼顧安全和體驗的東西深得我心","slug":"unlox","date":"2018-01-14T08:52:11.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/unlox/","link":"","permalink":"http://0x3f.org/post/unlox/","excerpt":"","text":"買了Unlox。早就知道MacID，陰差陽錯一直沒買，所以這又是一次後知後覺的行為。 曾經用過一段時間ControlPlane，通過多種條件自動判斷場景以啓用或關閉鎖屏密碼。後來在一次系統升級之後就不能用了。因為這個東西本身體驗也不是很好，免費的東西折騰起來太耗費精力，所以付費買體驗也是個不錯的選擇。 有三個功能對我來說很有用。 首先是用Face ID解鎖Mac。在Mac被喚醒後，iPhone X自動彈出解鎖的通知，點擊後Unlox被打開並自動調用Face ID，驗證通過後Mac即被解鎖。不過兩次Face ID驗證稍顯繁瑣，如果在iPhone鎖屏界面驗證通過後就自動解鎖，體驗會更好。不過我猜應該是iOS在這個地方不會通知到App。 其次是Tap解鎖。用手指點擊觸摸板，點擊次數和每次用的手指數目可以自定義。這個方式確實很方便。為了加強安全性，還可以設置當手機斷開時禁用Tap解鎖。 第三是離開時自動鎖屏。可以設置當手機和Mac之間的藍牙連接信號減弱多少時自動鎖屏。雖然對於Macbook用處不大，也不失為忘記合上屏幕時的一種補救手段。 此外還有其它一些功能，例如通過手機鎖定或解鎖Mac、靠近時自動喚醒Mac等。 今年Apple應該會全系支持Face ID，所以這只是一個過渡方案。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"app","slug":"app","permalink":"http://0x3f.org/tags/app/"}]},{"title":"密碼管理的最佳實踐","slug":"the-best-practice-of-password-management","date":"2017-12-27T09:26:17.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-best-practice-of-password-management/","link":"","permalink":"http://0x3f.org/post/the-best-practice-of-password-management/","excerpt":"","text":"通密之所以不應該被過分指責，是因為有其存在的道理，沒有哪種方案的管理成本比它更低，它不需要購買昂貴的1password，不需要擔心臨時用的時候突然想不起來，而且，只要這個密碼足夠強壯並且使用環境足夠安全，大多數情況下也不會有什麼問題。通密的問題在於它的風險成本太高，一旦一處洩漏，所有使用這個密碼的地方都不安全。 另一個極端是，使用很複雜的密碼，每個賬號都不同，甚至用密碼生成工具生成完全沒有規律的隨機字符串。這種方案的安全性很高，高到連你自己都記不住。 所以我需要這樣一套好的方案，它應該在安全性和易用性之間取得一個比較好的平衡，並且隨著方法論和工具鏈的進化，這個平衡可以無限逼近黃金分割點。 首先，密碼應該是複雜但容易記住的。密碼的複雜度和記憶負擔並不成正比，例如如果你實在記不住“ppnn13%,dkstFeb1st”，那麼這樣呢——“娉娉裊裊十三余，豆蔻梢頭二月初”。密碼只是一個字符串，如果不去死記最終的值，而是字符串背後的規律，記憶的壓力就會小很多。 但考慮到每個賬號都想一個這樣的密碼是不現實的，而且怎麼解決記憶密碼和賬號的對應關係的問題？所以進一步，可以用這樣的密碼當前綴，每個密碼的前綴都一樣，然後針對每個賬號創造一個後綴，這個後綴應該是每個賬號都不同的，且和賬號有某種只有你自己才知道的關聯，這樣你可以隨時根據賬號計算出它的後綴。例如，可以用賬號拼音首字母（當然，實際的規則應該更複雜一點）。 這樣你就有了足夠複雜、每個賬號都不同並且很容易記住的密碼。進一步地，在私有設備上可以利用文本替換功能（例如：Alfred for Mac的Snippets功能）快速輸入通用前綴，某些支持按鍵編程的機械鍵盤會有更好的體驗。 不過好記性不如爛筆頭，為防萬一，還是需要一個Plan B。主流的密碼管理工具主要有這麼幾種： 瀏覽器的賬號記憶功能 操作系統的keychain 在線密碼管理工具 離線密碼管理工具 瀏覽器一般是把密碼以明文存儲在本地的，firefox雖然有個主密碼，但只是個幌子，別人仍然可以拿到它記錄密碼的數據庫文件。這種做法的邏輯在於，設備上存儲的數據的安全性由操作系統和用戶負責，換句話說，用戶不應該允許他人用自己的權限登錄設備。但實際上很難避免這種情況，而且還要考慮到系統被入侵的可能。所以，只應該讓瀏覽器記住那些最不重要的賬號。 相對來說，操作系統的keychain一般有自動鎖定的功能，會更安全一些。但是仍無法完全避免上述問題。而且keychain只能記錄賬號和密碼，無法存儲更多的附加信息。所以這種工具也只應該存儲一些不重要的賬號。 最著名的在線密碼管理工具應該是Lastpass。關於它的安全性有很多種說法，不過我覺得但凡是敏感數據都不要存儲到線上，所以這種方式不予考慮。 我傾向於使用離線的密碼管理工具。1password據說很好用，但是太貴了，而且開源免費的keepass已經完全夠用了。我在Mac上用KeePassXC，在iOS中用MiniKeePass，私鑰文件離線存儲，然後數據庫文件用Dropbox同步就可以了。 此外，對於重要的賬號，如果支持兩步驗證，一定要開啓，然後用OTP Auth管理即可。 最終的方案是： 方法論：統一的複雜但有規律的前綴+根據賬號計算出來的後綴 工具鏈：KeePass + OTP Auth + Dropbox","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"Laravel單元測試錯誤：1205 Lock wait timeout exceeded","slug":"1205-lock-wait-timeout-exceeded","date":"2017-12-22T07:47:32.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/1205-lock-wait-timeout-exceeded/","link":"","permalink":"http://0x3f.org/post/1205-lock-wait-timeout-exceeded/","excerpt":"","text":"錯誤信息： 1205 Lock wait timeout exceeded; try restarting transaction 原因之一是測試用例里重寫的tearDown()方法中沒有調用父類的該方法。因為DatabaseTransaction這個trait自動開啓了事務，對應的回滾方法在測試用例基類的tearDown()中執行。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://0x3f.org/tags/laravel/"},{"name":"單元測試","slug":"單元測試","permalink":"http://0x3f.org/tags/單元測試/"}]},{"title":"用Charles攔截iOS APP HTTPS請求","slug":"ios-app-intercepting-using-charles","date":"2017-12-22T07:17:04.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ios-app-intercepting-using-charles/","link":"","permalink":"http://0x3f.org/post/ios-app-intercepting-using-charles/","excerpt":"","text":"實踐環境 Charles 4.2 iOS 11.2.1 安裝證書按照Charles菜單（Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser）的指示，設置iOS的系統代理。 為了以後使用方便，可以在代理工具（如ShadowRocket）里設置，注意使用時應配置代理工具對全部流量使用代理，如果使用PAC之類動態代理可能會攔截不到。 在iOS的Safari中訪問上面提示中的網址，會彈出提示安裝證書。iOS 10.3以後還要設置信任該證書（設置-&gt;通用-&gt;關於本機-&gt;證書信任設置）。 配置Charles攔截HTTPS請求路徑為：Proxy -&gt; SSL Proxying Settings 可以設置對特定的主機名和端口攔截，也可以直接保存，此時對所有請求均會攔截。 攔截iOS中打開上述代理，APP中發送的請求就會在Charles里列出來。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"}]},{"title":"測試驅動開發的實際收益","slug":"the-real-income-of-tdd","date":"2017-12-17T06:20:02.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-real-income-of-tdd/","link":"","permalink":"http://0x3f.org/post/the-real-income-of-tdd/","excerpt":"","text":"我並不試圖系統地談TDD，因為我在這方面的經驗還不足以做到這一點。但是TDD的一些方法論和工具確實解決了我在實際開發過程中遇到的一些問題。 第一個問題是健壯性。尤其是對於我這樣思維發散、容易迷失又喜歡重構的人，TDD給了我一個明確的目標，在一切剛開始的時候，我要做的只是滿足測試用例，讓它們由紅變綠。到了重構階段，我就可以把精力放到優化代碼上面，且不必對健壯性有過多的擔心。在此之前，由於手動測試比較麻煩，很多時候惰性會說服潛意識告訴自己這部分邏輯很簡單、不會有什麼bug，結果提交測試後卻一再地發生問題。 第二個問題是效率。曾經只有不忙的時候才會寫測試用例，但是現在一般都會寫，因為確實可以提高開發效率，而不只是保證重構的健壯性。可能對於所有對單元測試不熟悉的人來說，這都是匪夷所思的，我也曾認為單元測試只是用來保證健壯性的，必然和開發效率是一對矛盾，因為要花很多時間寫測試代碼。這種想法首先是因為對單元測試不熟悉，所以才需要花很多時間在上面。其次是沒有看到它所帶來的好處。 例如你要實現一整套退款單的功能，退款單是依賴訂單的，這意味著你需要不只一條符合條件的訂單數據。但是訂單是有狀態的，隨著時間的推移、人為的操作或者開發過程中程序的影響，狀態會變得不再符合你的要求，這時候你就必須停下來去做更多符合要求的訂單。而創建訂單也存在很多麻煩，你需要找到有庫存的商品，有時候還要去庫管系統中補充庫存，然後下單並支付。最後花了很多時間做出來的訂單，因為正在開發的退款單的程序出現的一個小問題變得不能使用！時間被大量浪費在創建所依賴的上游數據上。 這時候如果用單元測試並mock出依賴關係，就可以隨時隨地、無限制地執行相關的業務邏輯。對效率的提高不言而喻。 特別的，mock並不是隨時可以抓起的救命稻草，它的原罪在於：不負責任地濫用mock會導致很多問題被掩蓋。因此，對mock的使用應該是節制的、目標明確的。 當然，這並不包括單純地為了提高代碼覆蓋率而使用mock，只所以這是個在很多強制TDD的團隊里的普遍現象，歸根結底是因為KPI是萬惡之源，任何好的方法論，一旦淪為KPI，就離死不遠了。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"BaiduPCS：當前最好用的百度網盤下載工具","slug":"baidupcs","date":"2017-12-12T13:21:16.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/baidupcs/","link":"","permalink":"http://0x3f.org/post/baidupcs/","excerpt":"","text":"BaiduPCS是個命令行工具，用於下載百度網盤中的資源。之前用的是瀏覽器插件，需要先創建分享，再拿到下載鏈接，最後用下載工具下載。這個工具可以直接執行一條命令下載指定的資源，非常方便。 這里有安裝說明，然後按照使用說明操作即可。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"app","slug":"app","permalink":"http://0x3f.org/tags/app/"}]},{"title":"iOS垃圾短信過濾器：熊貓吃短信","slug":"panda-eats-sms","date":"2017-12-10T04:08:47.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/panda-eats-sms/","link":"","permalink":"http://0x3f.org/post/panda-eats-sms/","excerpt":"","text":"“熊貓吃短信”是個新上架的App，用於過濾垃圾短信。據說是基於機器學習訓練出來的，用了一周，識別得非常準確。 之前用的騰訊手機管家，即使把“精准識別”、“上傳到雲端”等選項都打開，還會有漏網之魚，而且會犧牲隱私。這個App聲稱不會主動上傳短信。最重要的是，這一周里所有不關心的短信都被過濾掉了，而且沒有失誤。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"app","slug":"app","permalink":"http://0x3f.org/tags/app/"}]},{"title":"全新Kindle Oasis使用感受","slug":"the-all-new-kindle-oasis","date":"2017-12-09T06:03:08.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-all-new-kindle-oasis/","link":"","permalink":"http://0x3f.org/post/the-all-new-kindle-oasis/","excerpt":"","text":"早在Paperwhite 1的時候我就不喜歡它的工業設計：邊框太寬，屏幕內陷。此外，非人體工學設計和沒有實體翻頁鍵導致單手握持體驗很差。再有就是做工的問題，機身表面接縫處縫隙明顯而不均勻、通體強烈的塑料感。然而還是從一代用到了三代，除了kpw是kindle全系列里性價比最高的產品線之外，還有就是沒有其它任何一款產品解決了kpw的主要問題。 例如Voage，雖然屏幕不內陷了、楔形機身優化了握持感、增加了翻頁鍵，但整體的設計只算是在kpw基礎上的優化，何況各項硬件配置和kpw3幾乎無差。 後來當第一代Oasis發佈的時候，看了第一眼就瞬間失掉了興趣。捆綁的充電保護殼絕對是體驗殺手，裝上殼比kpw還要厚重，不裝的話本體的續航又很差，頻繁拆裝也很不方便，這樣的體驗連kpw都不如。所以我很不看好它，果然很快在今年六月就下架了。 十月剛看到新Oasis的消息時，馬上覺得這回終於有買的價值了。\u0010 首先是7寸的屏幕，瞬間和其它產品線拉開了距離。更大的屏幕意味著能展示更多內容，增加了寬度後也更接近實體書的觀感。 工業設計相對於我的kpw3當然是有了質的改變。玻璃材質的純平表面，金屬背殼，沒有了kpw的塑料感，顯得更精緻。得益於窄邊框，7寸屏的機身長度比6寸的kpw還短。雖然因為加寬了屏幕和增加了單手握持的邊框導致機身寬度超過kpw很多，不過在平時攜帶中並沒有造成很多困擾。 單手握持是ko系列的主要賣點，實際使用體驗當然很好。為握持設計的寬邊框加上實體翻頁鍵非常方便。雖然因為加大屏幕和增加續航導致194g的重量遠遠超過1代的131g，但還是比kpw輕了10g，而且主要重量集中在單手握持的一邊，槓桿效應很小。配合重力感應，隨時換手可以有效緩解疲勞。當然，作為長時間單手握持的閱讀設備，重量自然越輕越好，這一點上，ko還有很大優化的空間。 此外，新ko的做工遠遠好於kpw，沒有了廉價感。12顆背光燈使得背光的均勻度比kpw強了很多，幾乎不會有kpw上明顯的光影。性能上是現在kindle全系列里最高的，翻頁時雖然還會看到閃屏，但比以前已經快了很多。自動亮度調節算是個聊勝於無的功能吧。至於防水和有聲書，我沒有這方面的需求。 如果說缺點的話，還是續航。雖然相對於1代本體，續航已經達到可用的水平，但是對於被其它產品線慣壞的我們來說，新ko電量的消耗還是快了點。我沒有精確的對比，但是能明顯地感覺到比kpw掉得快不少。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"},{"name":"數碼","slug":"數碼","permalink":"http://0x3f.org/tags/數碼/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"清潔手機的最佳實踐","slug":"how-to-clean-a-phone","date":"2017-12-03T14:51:42.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-clean-a-phone/","link":"","permalink":"http://0x3f.org/post/how-to-clean-a-phone/","excerpt":"","text":"以前的做法是先用濕巾清理，再用紙巾擦乾。後來屏幕的觸感逐漸不如開始時順滑，也更容易沾指紋和灰塵，而且不容易清除。估計應該是濕巾的酒精會腐蝕屏幕的塗層，紙巾粗糙的表面也會造成磨損。 現在先用軟毛刷掃除灰塵，然後用3M魔布擦拭。效果應該會更好。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"數碼","slug":"數碼","permalink":"http://0x3f.org/tags/數碼/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"Firefox Quantum：狐狸的反擊","slug":"firefox-quantum","date":"2017-12-03T13:53:18.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/firefox-quantum/","link":"","permalink":"http://0x3f.org/post/firefox-quantum/","excerpt":"","text":"不知不覺已經很多年沒有用過Firefox了。在Chrome發佈之前，這只狐狸以一己之力扛著互聯網承前啓後的大旗。後來被Chrome在網頁加載速度上吊打，逐漸式微。之後還在用Firefox的人一般也只是因為受不了Chrome的內存佔用。 Firefox Quantum剛發佈的時候我就安裝了，以為是個全新的項目，新項目初期往往特性不健全，所以就沒有太多關注。 然後發現版本號接續了舊版，也兼容原Firefox的插件，所以就裝上幾個必要的插件，嘗試了一下。新的UI借鑒了Chrome，不像原來那麼過時。最重要的是內存佔用和網頁打開速度比Chrome有優勢。如官方宣傳語所說——快而不俗。 準備把默認瀏覽器改成FQ，用一段時間看看。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"app","slug":"app","permalink":"http://0x3f.org/tags/app/"},{"name":"瀏覽器","slug":"瀏覽器","permalink":"http://0x3f.org/tags/瀏覽器/"}]},{"title":"Vim最好的PHP語法高亮插件","slug":"the-best-php-syntax-file-of-vim","date":"2017-11-28T07:55:59.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-best-php-syntax-file-of-vim/","link":"","permalink":"http://0x3f.org/post/the-best-php-syntax-file-of-vim/","excerpt":"","text":"StanAngeloff/php.vim應該是目前最新、最全的PHP語法高亮插件了，它解決了舊版本無法高亮@throws的問題。 默認會把方法注釋全部當做普通注釋顯示，也就是沒有高亮，需要專門做配置： 123456789function! PhpSyntaxOverride() hi! def link phpDocTags phpDefine hi! def link phpDocParam phpTypeendfunctionaugroup phpSyntaxOverride autocmd! autocmd FileType php call PhpSyntaxOverride()augroup END","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"iPhone X官方硅膠保護殼使用感受","slug":"iphone-x-silicone-case","date":"2017-11-26T04:50:13.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/iphone-x-silicone-case/","link":"","permalink":"http://0x3f.org/post/iphone-x-silicone-case/","excerpt":"","text":"我相信所有注重體驗的人都不願意用保護殼，我也一樣，所以用iPhone 6的兩年多里絕大部分時間也都是裸奔。 對於給X加殼這件事，我是很矛盾的，然而面對這個既易碎又碎不起的東西，貧窮限制了我對體驗的偏執。 對於殼的選擇，我有這些考慮： 防護性好：畢竟這是加殼的唯一目的，所以那些超薄的殼就在考慮範圍內了。 易裝卸：只有出門時會加殼，在家要去掉，所以這是個很頻繁的行為，既要容易操作，又要不傷手機。 易維護：方便清潔，所以皮質的就不考慮了。 貼合度高，觸感好：體驗還是很重要，軟殼一般很難做到這一點，所以範圍限制在硬殼上。 外觀簡約。 材料安全。 試錯成本低：少花冤枉錢，節省時間精力。 符合這些條件的就只剩下官方硅膠殼了，然而我還是在顏色的選擇上糾結了很長時間。因為硅膠殼容易粘灰，所以越是淺色越不明顯，然而深色可以減少和X黑色前面板的割裂感。最終選擇了鈷藍色。 用了一周的時間，完全符合預期。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"數碼","slug":"數碼","permalink":"http://0x3f.org/tags/數碼/"},{"name":"iphone","slug":"iphone","permalink":"http://0x3f.org/tags/iphone/"}]},{"title":"電影《疾速追殺》","slug":"movie-john-wick","date":"2017-11-26T02:09:34.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/movie-john-wick/","link":"","permalink":"http://0x3f.org/post/movie-john-wick/","excerpt":"","text":"上周看了《疾速追殺》和《疾速特攻》，後者是前者的第二部。 情節比較老套：一個因愛退隱的職業殺手，在妻子病逝、黑道欺凌下，不得以奮起反擊、與整個殺手行業為敵，最後善惡有報、空余蕭索。 知道這部戲是因為和《極寒之城》是同一個導演，賣點都是暴力美學，風格不同。《極寒之城》用不加特效的長鏡頭表現格鬥的殘酷，畫風冷峻。《疾速》系列更像《殺死比爾》，場面華麗，十步殺一人、千里不留行。 關於暴力美學，維基百科是這麼解釋的： 主要在官感上，使暴力以美學的方式呈現，詩意的畫面，甚至幻想中的鏡頭來表現人性暴力面和暴力行為。觀賞者本身往往驚嘆於藝術化的表現形式，無法對內容產生具體的不舒適感。支持人士往往稱「暴力程度與票房收入成正比」，社會道德捍衛者和輿論譴責人士則稱其是對社會道德教化的阻礙和負面影響；恐引發心理未臻成熟的人們，間接以為暴力行為亦是一種美感的呈現。 在眾多香港導演中，吳宇森是運用這種電影表現手法的代表性人物。其標誌性的白鴿漫天飛舞，手持雙槍的英雄人物縱橫在屏幕之上，使象徵和平和安詳的白鴿與血腥暴力的槍彈形成了強烈的視覺反差，吸引了無數的目光。 然而我並不打算馬上去看新《追捕》，炒冷飯的鮮有好戲，等等再說。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"電影","slug":"電影","permalink":"http://0x3f.org/tags/電影/"}]},{"title":"iPhone X使用感受","slug":"iphone-x","date":"2017-11-12T05:10:05.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/iphone-x/","link":"","permalink":"http://0x3f.org/post/iphone-x/","excerpt":"","text":"上手用了兩天，感覺優點多於缺點，總體是進步的。 如果沒有新的工業設計，我可能會把小6繼續用下去。畢竟當初就對小6的白帶和粗邊框很不滿意，雖然8因為改回玻璃背板已經基本解決白帶問題，但是前面板幾乎沒有變化，一個工業設計用了四代，再優秀也審美疲勞了，而且那個屏佔比在現在的千元機里也是倒數了，哪怕把邊框做得再窄一點，8也不至於跳水成現在這樣。 買的銀色，實際觀感更接近乳白色，而深空灰更接近黑色。後者配色的一體性並沒有別人說的那麼好，而前者配色也沒有很強的割裂感。 寬度比6稍大，長度更長，單手握持無壓力，不過單手操作就別想了，即使是6，搭配指環單手操作也不方便。 前面板在息屏狀態下一體性很好。當然我不認為這是個很重要的標準，好像羅永浩說過黑色邊框可以隱藏低成本的做工，白色邊框想做好更難，不管真假，息屏美學就是個營銷手段，有誰會盯著息屏的手機瞅？ 功能方面，這次最大的賣點就是Face ID，體驗真是比Touch ID好太多！尤其是我手汗多，指紋解鎖失敗率很高，不過這些年倒是因此養成了一天洗幾十次手的習慣…… 性能上，找回了6在iOS8時的流暢度。如果沒有意外，6在iOS11下就現在這德性了，追求流暢度的在10.3.3止步吧。 拍照方面，「世界第二」的攝像頭效果搭配人像模式效果比6好很多。 至於續航，雖然免不了一天一充，起碼比6在iOS11下強多了，畢竟多了一千毫安。 此外，作為古老的小6的用戶，3D Touch、抬手亮屏、隨時喊Siri也有更好的體驗。 屏幕方面，全面屏+OLED效果拔群。看久了X的屏幕，再看6的會覺得模糊很多。另外，True Tone比起Night Shift也更智能了。 異形屏不是蘋果的首創，全面屏也不是小米的首創，而它們連同三星S8已然成了全面屏的三個流派。我個人更傾向於異形屏，雖然iPhone X的屏佔比實際上並不是非常高，不過觀感上更徹底。S8用曲面屏把左右邊框做到視覺上寬度接近零，不過三星的供貨問題是這個流派最大的障礙。至於小米MIX，完全就是在低成本、供應鏈和軟件生態話語權弱、硬件技術落後等因素作用下、利用普通LCD面板追全面屏熱度的怪胎。MIX1就是個半成品，到了MIX2才算基本可用。所以小米不是第一個做全面屏的，但是是第一個不要臉的，還是老羅實在，「全面屏」後面還加個「almost」。 未來一兩年，從千元機到高端機會全面普及全面屏。中低端機型主流應該會選擇堅果Pro2的風格，用普通面板，然後盡量把邊框做窄。高端機型在異型屏和曲面屏之間會有一場好戲。 取消Home鍵換來的新的交互方式，整體上是進步了。回到主界面和切換任務這兩個常用操作改用觸摸手勢，取消了到實體鍵的依賴，也提高了效率。側邊鍵得到了更充分的利用，呼出Siri和Apple Pay從Home鍵挪了過來。如果同時按側邊鍵+音量減能自定義或者實現像堅果Pro2閃念膠囊按鍵那樣的功能會更好。 缺點主要是邊框和厚度，原本我對小6的厚度是很滿意的，只是希望把邊框做窄點。現在不但祖傳的粗邊還在，還越做越厚是什麼毛病？！","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"數碼","slug":"數碼","permalink":"http://0x3f.org/tags/數碼/"},{"name":"iphone","slug":"iphone","permalink":"http://0x3f.org/tags/iphone/"}]},{"title":"電影《極寒之城》","slug":"movie-atomic-blonde","date":"2017-10-29T02:14:56.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/movie-atomic-blonde/","link":"","permalink":"http://0x3f.org/post/movie-atomic-blonde/","excerpt":"","text":"這是最近看的電影里讓我印象最深的一部。 故事背景是1989年柏林牆倒塌前發生在德國的一場諜戰。劇情組織得很一般，冷戰和諜戰這兩個賣點做得都不成功，雖然塞隆和波多拉兩位女神的床戲輓救了一切，但是女同的賣點只是一道開胃菜，最精彩的部分是中後段的一場動作戲，塞隆單挑一群克格勃，同時還要保護一個東德叛諜，長達數分鐘的一個長鏡頭，場面極為真實，一改一般好萊塢動作片里打不死的風格。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"電影","slug":"電影","permalink":"http://0x3f.org/tags/電影/"}]},{"title":"讀完《談美》","slug":"after-reading-tan-mei","date":"2017-10-29T01:21:58.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-tan-mei/","link":"","permalink":"http://0x3f.org/post/after-reading-tan-mei/","excerpt":"","text":"這本書講的是「什麼是美」。讀完後對美有了一些基本的概念，才知道我的審美水平還停留在「以快感為美」的階段。 朱自清的序里的一些話說得很好：「新文化是「外國的影響」，自然不錯；但說一般青年不留餘地地鄙棄舊的文學藝術，卻非真理。」、「許多青年膩味了，索性一切不管，只抱著一條道理，「有文藝的嗜好就可以談文藝」。這是「以不了了之」，究竟「談」不出什麼來。」","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"美","slug":"美","permalink":"http://0x3f.org/tags/美/"}]},{"title":"用Tiny Tiny RSS搭建私人閱讀器的步驟","slug":"ttrss","date":"2017-10-27T06:12:16.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ttrss/","link":"","permalink":"http://0x3f.org/post/ttrss/","excerpt":"","text":"優勢 自定義過濾器 全功能，無限制 利用已有VPS，無需額外費用 安裝安裝並啓動docker1234curl https://get.docker.com/ | sh// centos7systemctl start docker 安裝postgre1docker run -d --name ttrssdb nornagon/postgres 安裝tiny tiny rss1docker run -d --link ttrssdb:db -p 80:80 -e SELF_URL_PATH=http://example.org/ttrss fischerman/docker-ttrss example.org替換成VPS的IP或者對應的域名。 配置配置主程序訪問http://example.org/ttrss，用戶名admin，密碼password。 偽裝成fever如果RSS閱讀器不支持ttrss，但支持fever，例如reeder，可以通過安裝插件偽裝成fever： 123git clone https://github.com/rannen/tinytinyrss-fever-plugin.gitdocker cp fever [[CONTAINER ID]]:/var/www/plugins 然後去設置見面啓用fever插件，並在fever插件的配置欄設置單獨的密碼，該欄目中會顯示在RSS閱讀器中使用的接口地址，用戶名就是admin。 備份每天凌晨3點備份數據庫到dropbox。 下載dropbox上傳腳本在VPS的/root下執行： 1wget https://raw.github.com/andreafabrizi/Dropbox-Uploader/master/dropbox_uploader.sh 執行命令並按提示操作： 1./dropbox_uploader.sh info 創建備份腳本創建/root/backup.sh： 12345678910111213141516171819202122232425#!/bin/bashSCRIPT_DIR=\"/root\"NOW=$(date +\"%Y%m%d\")TMP_PATH='/tmp'DOCKER_ID_TTRSS='39cec6a7xcb7'TTRSS_DB=\"$TMP_PATH/ttrss.sql\"BAK_FILE_NAME=\"vps-$NOW.tar.gz\"BAK_FILE=\"$TMP_PATH/$BAK_FILE_NAME\"DROPBOX_DIR=\"\"docker exec \"$DOCKER_ID_TTRSS\" /usr/bin/pg_dump ttrss &gt; \"$TTRSS_DB\"echo \"數據庫備份完成，打包網站數據中...\"tar cfzP \"$BAK_FILE\" \"$TTRSS_DB\"echo \"所有數據打包完成，準備上傳...\"# 用腳本上傳到dropbox\"$SCRIPT_DIR\"/dropbox_uploader.sh upload \"$BAK_FILE\" \"$DROPBOX_DIR/$BAK_FILE_NAME\"if [ $? -eq 0 ];then echo \"上傳完成\"else echo \"上傳失敗，重新嘗試\"fi# 刪除本地的臨時文件rm -f \"$TTRSS_DB\" \"$BAK_FILE\" 39cec6a7xcb7替換成實際的postgresql容器的ID。 創建定時任務在crontab -e里添加： 10 3 * * * /bin/bash /root/backup.sh &gt; /dev/null","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"}]},{"title":"過度優化和過度設計","slug":"talk-about-excessive-design","date":"2017-10-22T13:38:08.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/talk-about-excessive-design/","link":"","permalink":"http://0x3f.org/post/talk-about-excessive-design/","excerpt":"","text":"我見過兩種程序員，一種是想做事的，一種是混飯吃的。 第一種人最容易犯兩個錯誤，一是過度優化，二是過度設計。兩種錯誤共同的原因是經驗不足，不同的地方是過度優化往往出於知其然不知其所以然，而過度設計一般是想得太遠從而脫離實際。 比如我見過的一個人，凡是聯表的語句，都要拆開來寫，完全不考慮這些聯表語句實際會不會發生性能問題。這就是過度優化，只記住一些成例和範式，不從實際出發，膠柱鼓瑟，刻舟求劍。聯表當然會造成數據量以笛卡爾積的形式增長，但如果所聯表的數據量並不大，或者通過限制條件過濾後的數據量不大，並不會出現性能問題，而拆開SQL語句會導致代碼量增大、可讀性下降，是得不償失的。 至於過度設計，我自己就是個很好的反面教材。剛工作的時候，我在寫程序之前和過程中會不斷地冒出新的想法，設想到很多種可能，為了照顧到這些可能性，我會不斷地重構程序，導致出活很慢。多數人並不會認真瞭解別人，只是從結果上武斷地下結論。所以關於我寫程序太慢的說法就悄悄流傳開，而那些程序寫得很爛、混飯吃但出活很快的人反而獲利頗豐。最可笑的是過了很長時間後回顧曾經設想到的可能性，幾乎全部沒有發生。為一些將來可能發生而實際沒有發生的可能性，在一開始就花費更多的成本，這就是過度設計。 不過經驗作為知識存量，是不值錢的，假以時間，有一定認知水平、不甘於庸俗的人總可以積累得到。所以相對於第二種人，我寧願和第一種共事。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"}]},{"title":"搭好了SSR","slug":"ready-for-ssr","date":"2017-10-18T07:34:33.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ready-for-ssr/","link":"","permalink":"http://0x3f.org/post/ready-for-ssr/","excerpt":"","text":"搭在vultr東京節點的SS在家裏的網絡上已經不能用了，lantern和大殺器也不穩定到基本沒有可用性的程度。短短幾天時間，三把梯子挂了仨。 搭好了SSR，等着晚上回去測試。 SSR一鍵部署腳本：https://github.com/91yun/shadowsocks_install Mac的SSR客戶端：https://github.com/qinyuhang/ShadowsocksX-NG-R/releases iOS的SSR客戶端：ShadowRocket","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"翻牆","slug":"翻牆","permalink":"http://0x3f.org/tags/翻牆/"}]},{"title":"用gv.vim查看git提交歷史","slug":"gv-vim","date":"2017-10-18T05:28:16.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/gv-vim/","link":"","permalink":"http://0x3f.org/post/gv-vim/","excerpt":"","text":"gv.vim是fugitive的插件，用於查看git提交歷史，特點是速度快、好用。我现在用它做code review。 1234nnoremap &lt;leader&gt;gll :GV --no-merges&lt;CR&gt;nnoremap &lt;leader&gt;glc :GV!&lt;CR&gt;nnoremap &lt;leader&gt;gla :GV --no-merges --author&lt;space&gt;nnoremap &lt;leader&gt;glg :GV --no-merges --grep&lt;space&gt;","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"git","slug":"git","permalink":"http://0x3f.org/tags/git/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"解決phpqa和fugitive不兼容的問題","slug":"solve-the-incompatablility-between-fugitive-and-phpqa","date":"2017-10-18T03:05:12.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/solve-the-incompatablility-between-fugitive-and-phpqa/","link":"","permalink":"http://0x3f.org/post/solve-the-incompatablility-between-fugitive-and-phpqa/","excerpt":"","text":"在:Gstatus中查看diff時，報錯： Error detected while processing function Phpqa#PhpLint:line 8:E684: list index out of range: 0E116: Invalid arguments for function match(l:php_list[0],”No syntax errors”) == -1E15: Invalid expression: 0 != v:shell_error &amp;&amp; match(l:php_list[0],”No syntax errors”) == -1 這是phpqa的bug，有人創建了PR，但作者沒有合併，需要手工合併： 1curl -L https://github.com/joonty/vim-phpqa/pull/43.patch | git am","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"讀完《美的歷程》","slug":"after-reading-historical-evolution-of-aesthetics","date":"2017-09-25T08:43:08.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-historical-evolution-of-aesthetics/","link":"","permalink":"http://0x3f.org/post/after-reading-historical-evolution-of-aesthetics/","excerpt":"","text":"這是我讀過的第一本美學書。梳理了中國文藝和審美髮展的歷史脈絡，淺顯易懂。 多讀點美學還是很有必要的，能減少點俗氣，那就最好了。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"美學","slug":"美學","permalink":"http://0x3f.org/tags/美學/"}]},{"title":"為什麼不應該給表名加前綴","slug":"why-prefixes-are-not-needed-for-table-names","date":"2017-09-25T06:12:41.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/why-prefixes-are-not-needed-for-table-names/","link":"","permalink":"http://0x3f.org/post/why-prefixes-are-not-needed-for-table-names/","excerpt":"","text":"表前綴是個過時的東西。在計算機資源比較昂貴的時代，出於節約成本的需要，會把多個系統的數據放在同一個數據庫實例里，所以才會用前綴區分。如今各種雲的普及，使這個問題早已經不存在，大家的資源都是冗余的，沒有人會把多個系統的表放到同一個庫里，這會給運維帶來不必要的麻煩。 然而身邊總是會遇到膠柱鼓瑟的人，知其然而不知其所以然。表前綴既非必要，又會導致一些問題。 其一是寫代碼時的困擾。比如我經常會在用查詢構造器時忘了給表別名加前綴，直到程序報錯才突然想起來。 其二是代碼重構的問題。在構造SQL語句的過程中，總是免不了會寫原生的語句，這時就得寫死表前綴。如果將來表前綴發生變化，重構代碼時會麻煩而容易出錯。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"}]},{"title":"用AlfredTweet發推","slug":"tweet-with-alfredtweet","date":"2017-09-17T01:26:41.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/tweet-with-alfredtweet/","link":"","permalink":"http://0x3f.org/post/tweet-with-alfredtweet/","excerpt":"","text":"AlfredTweet是用來解決“最後一公里”問題的東西，有了它就可以隨時發推了。 需要修改源碼指定代理： 123456789// twitteroauth.phpfunction http($url, $method, $postfields = NULL) &#123; // ... curl_setopt($ci, CURLOPT_HTTPPROXYTUNNEL, TRUE); curl_setopt($ci, CURLOPT_PROXY, '127.0.0.1:1086'); curl_setopt($ci, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5); // ...&#125;","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"},{"name":"工具","slug":"工具","permalink":"http://0x3f.org/tags/工具/"}]},{"title":"讀完《漢書》","slug":"after-reading-han-shu","date":"2017-09-10T15:34:19.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-han-shu/","link":"","permalink":"http://0x3f.org/post/after-reading-han-shu/","excerpt":"","text":"一周前讀完了《漢書》。 因為讀過《資治通鑒》，這次並沒有發現太多新鮮的東西，印象最深的是班氏父子的嚴謹，超過了兩個司馬。比如對於成帝的死，作為通史的《通鑒》居然寫得比斷代的《漢書》還詳細，對於史書，詳和實似乎是一對矛盾，前者自然更好看，而後者顯然更嚴謹。 秦漢之際，中國先後完成了兩次宏大的社會實踐。一次是秦的法家實踐，一次是王莽的儒家改制。歷史先後把機會給了構成中國日後民族性格最主要的兩個思想流派，又用殘酷的現實給這兩個處處針鋒相對的對頭以當頭棒喝。兩家對對方缺陷的研究都在對方的失敗里得到印證，而同時對自身的問題又都視而不見。這是非常戲劇性的一幕，儒法之爭作為中國兩千年政治的基本矛盾和規律，在一開始就被證明誰都不能獨力承擔給這個國家指明出路的責任。 按照錢穆在《中國歷代政治得失》里的說法，昂揚向上的知識分子在先秦百家爭鳴最大成就的儒法兩家全部失敗後就頹了，懷疑和茫然蔓延開來，第一帝國也由此走向衰亡。而從另一角度，李泽厚在《美的歷程》里卻認為，社會實踐的失敗引發了思想的解放和自我意識的覺醒，第一帝國在政治上的失敗並沒有影響其文化向心力，胡塵狼煙中的北方仍以文弱江南為衣冠正朔所在。 對於接下來的《後漢書》，我的期待不高，憑借門閥起家的光武帝一改前漢打壓豪強的政策，章帝之後再無中興，然後是在無休止的宦戚之爭、鮮卑盜邊和羌亂中回響的桓靈的嘆息。 第一帝國在巔峰中死去。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"}]},{"title":"什麼是docker","slug":"what-is-docker","date":"2017-09-07T07:31:11.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/what-is-docker/","link":"","permalink":"http://0x3f.org/post/what-is-docker/","excerpt":"","text":"什麼是dockerdocker是一種容器，這篇文章對容器的定義是： 容器是一組運行在Linux操作系統上並使用命名空間進程進行分隔的進程，有了容器就無需再啓動和維護虛擬機。與虛擬機技術相比，容器的最大不同之處在於打包格式和可移植性。構建容器的目的在於為現代基礎設施降低佔用空間和啓動時間、提供重用性、更好地利用服務器資源，並更好地集成到整個開發生態系統中（例如持續集成和交付生命週期）。 容器相對於虛擬機有以下優點： 更高效地利用系統資源 更快的啓動速度 一致的運行環境 持續的交付和部署 更輕鬆的遷移 維護和擴展的便利性 基本概念鏡像Docker 鏡像是一個特殊的文件系統，除了提供容器運行時所需的程序、庫、資源、配置等文件外，還包含了一些為運行時準備的一些配置參數（如匿名卷、環境變量、用戶等）。鏡像不包含任何動態數據，其內容在構建之後也不會被改變。 鏡像分為黑箱鏡像和dockerfile。 前者通過實際創建和配置docker容器並通過docker commit記錄每個版本的變更，優點是簡單直觀，缺點是不能記錄在基礎鏡像上做了哪些操作，並且在多次修改之後，鏡像會變得很臃腫。 dockerfile是鏡像的配置文件，部署時docker根據配置內容生成容器，優點是可以清楚地記錄每次修改的內容、鏡像體積很小，缺點是編寫時比較複雜。 容器容器是鏡像運行的實體。 倉庫分發鏡像的服務。 編排容器的編排包含如下一系列任務： 調度（包括部署、複製、擴展、復活、重新調度、升級、降級等） 資源管理（內存、CPU、存儲空間、端口、IP、鏡像等） 服務管理（即使用標籤、分組、命名空間、負載均衡和準備就緒檢查將多個容器編排在一起） 安裝我在黑蘋果下安裝。Mac下安裝docker有兩種方式：Docker for Mac或Docker Toolbox。前者最簡單，後者在前者的系統要求不能被滿足的情況下使用。後者的卸載比較麻煩，具體參照這裡。 我用前種方式安裝，啓動時報錯： com.docker.osx.hyperkit.linux failed to start 解決方法是到BIOS里打開VT特性，有說法說黑蘋果不支持VT，我這裡是可以的。 鏡像加速器一般用阿里雲的鏡像服務。 docker的使用拉取鏡像1docker pull base/archlinux 列出鏡像1docker images 創建容器1docker run --name arch --it base/archlinux bash 終止容器exit或ctrl-d 啓動已終止容器1docker start arch attach運行中的容器1docker attach arch detach運行中的容器ctrl+p ctrl+q或者： 1docker detach arch 查看容器12345# 查看運行中的容器docker ps -q# 查看所有，包括已終止的docker ps -a 刪除已終止容器1docker rm arch","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"},{"name":"容器","slug":"容器","permalink":"http://0x3f.org/tags/容器/"},{"name":"docker","slug":"docker","permalink":"http://0x3f.org/tags/docker/"}]},{"title":"讓hexo使用小寫文件名","slug":"let-hexo-use-lowercase-filename","date":"2017-08-15T05:25:50.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/let-hexo-use-lowercase-filename/","link":"","permalink":"http://0x3f.org/post/let-hexo-use-lowercase-filename/","excerpt":"","text":"hexo在生成tag目錄時默認保持大小寫，如果tag名稱摻雜了大小寫，會導致用tag索引文章的鏈接無法訪問。解決的辦法是強制hexo使用小寫的文件或目錄名，修改_config.yml： 1filename_case: 1 即便如此，還要把之前生成的結果從托管服務器上刪除，不過在Mac這樣的不區分大小寫的文件系統中，直接部署新生成的結果是無效的，這時需要刪除hexo目錄下的.deploy_git目錄並重新部署： 1234rm -rf .deploy_githexo cleanhexo d -g","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://0x3f.org/tags/hexo/"}]},{"title":"用vim-test簡化單元測試的編寫","slug":"make-writing-unit-tests-easier-with-vim-test","date":"2017-08-14T08:43:59.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/make-writing-unit-tests-easier-with-vim-test/","link":"","permalink":"http://0x3f.org/post/make-writing-unit-tests-easier-with-vim-test/","excerpt":"","text":"vim-test允許在Vim中直接執行一個或多個單元測試，並使用預設的或自定義的執行策略。 例如，命令:TestNearest可以執行當前測試文件中離光標最近的一個測試方法。而:TestFile、:TestSuite和:TestLast分別執行整個測試文件、測試項目和最近一次執行過的測試。這在編寫測試代碼時能很大地提高效率。 執行策略是執行測試的方式和環境。例如缺省狀態下，將使用:!執行測試命令，這會從Vim切換回終端。而在MacVim下，可以選擇在iTerm或者系統自帶的Terminal中執行。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"單元測試","slug":"單元測試","permalink":"http://0x3f.org/tags/單元測試/"}]},{"title":"把博客字體改成了方正北魏楷書","slug":"set-blog-webfont-to-fzbeiweikaishu","date":"2017-08-14T08:05:30.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/set-blog-webfont-to-fzbeiweikaishu/","link":"","permalink":"http://0x3f.org/post/set-blog-webfont-to-fzbeiweikaishu/","excerpt":"","text":"我曾說過方正北魏楷書是最佳的閱讀字體，不過後來感覺長時間閱讀的體驗還是普通的楷體更好。但這並不妨礙在Reeder、博客這種短時閱讀場合突出頁面的設計感。 今天把博客（hexo）的webfont改成了方正北魏楷書，用font-spider壓縮後，從13M縮減到1.4M。方法是這樣的： 首先把完整的字體複製到主題的字體目錄中（themes/crisp/source/fonts），文件名為FZBeiWeiKaiShu-full.ttf。 在CSS中加入webfont配置： 12345@font-face &#123; font-family: 'FZBeiWeiKaiShu'; src: url('../fonts/FZBeiWeiKaiShu.ttf') format('truetype'), url('../fonts/FZBeiWeiKaiShu-full.ttf') format('truetype');&#125; FZBeiWeiKaiShu.ttf是壓縮後的字體文件名，這樣訪問時瀏覽器會優先下載壓縮後的字體。 然後把CSS中使用字體的地方都指定為FZBeiWeiKaiShu。 在博客根目錄下創建腳本update_fonts.sh： 123456789101112#!/bin/shhexo cleanhexo gfind public -name \"*.html\" |xargs sed -i '' \"s#/styles/crisp.css#$HOME/Projects/blog/public/styles/crisp.css#g\"find public -name \"*.html\"|xargs font-spidercp -f public/fonts/FZBeiWeiKaiShu.ttf themes/crisp/source/fonts/FZBeiWeiKaiShu.ttfhexo cleanhexo s -g 除非用到新的字符，否則不需要經常更新字體。 font-spider會提示一共使用了多少種字符，我這麼多年也只用到三千多種，真是太沒文化了。🤥","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"}]},{"title":"Mock Laravel的DB Facade的方法","slug":"how-to-mock-the-db-facade-of-laravel","date":"2017-08-14T07:51:41.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-mock-the-db-facade-of-laravel/","link":"","permalink":"http://0x3f.org/post/how-to-mock-the-db-facade-of-laravel/","excerpt":"","text":"關於數據庫操作是否應該mock的問題，我認為查詢一般不應該mock，可以避免一些問題，但如果查詢的結果可能影響到斷言，就應該mock了。 Laravel的DB facade完整的mock實例是這樣的：","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://0x3f.org/tags/laravel/"},{"name":"單元測試","slug":"單元測試","permalink":"http://0x3f.org/tags/單元測試/"}]},{"title":"用vim-laravel簡化laravel下的開發","slug":"speed-up-artisan-with-vim-laravel","date":"2017-08-11T07:05:30.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/speed-up-artisan-with-vim-laravel/","link":"","permalink":"http://0x3f.org/post/speed-up-artisan-with-vim-laravel/","excerpt":"","text":"vim-laravel是個極簡而實用的插件，只提供一個:Artisan命令。但它並不僅僅是artisan的一個wrapper，還可以實現一些貼心的自動化，利如自動打開artisan make:*創建的文件。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"用vim-php-namespace管理PHP的命名空間","slug":"manage-php-namespaces-with-vim-php-namespace","date":"2017-08-11T06:56:12.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/manage-php-namespaces-with-vim-php-namespace/","link":"","permalink":"http://0x3f.org/post/manage-php-namespaces-with-vim-php-namespace/","excerpt":"","text":"vim-php-namespace是個簡單實用的插件，提供三種功能： 自動用use語句導入光標下的類 自動把光標下的類名擴展成完整命名空間的格式 自動排序use語句 此外，還提供一個選項控制是否在導入類後自動排序use語句。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"使neocomplete和ultisnips共用tab鍵的方法","slug":"reconcile-neocomplete-with-ultisnips","date":"2017-08-11T06:43:14.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/reconcile-neocomplete-with-ultisnips/","link":"","permalink":"http://0x3f.org/post/reconcile-neocomplete-with-ultisnips/","excerpt":"","text":"昨天用vim-clevertab換掉了supertab，但是實際使用中總是出莫名其妙的問題。看了一下插件源碼，使用全局變量判斷狀態，這是個很不靠譜的方案，所以還是卸掉了。 下面的配置可以很好的解決問題： 12345678910111213141516171819let g:UltiSnipsExpandTrigger=\"&lt;c-tab&gt;\"let g:UltiSnipsJumpForwardTrigger=\"&lt;c-tab&gt;\"let g:UltiSnipsJumpBackwardTrigger=\"&lt;s-tab&gt;\"let g:UltiSnipsSnippetsDir='~/.vim/UltiSnips'let g:ulti_expand_or_jump_res = 0function! CleverTab()\"&#123;&#123;&#123; call UltiSnips#ExpandSnippetOrJump() if g:ulti_expand_or_jump_res return \"\" else if pumvisible() return \"\\&lt;c-n&gt;\" else return neocomplete#start_manual_complete() endif endifendfunction\"&#125;&#125;&#125;inoremap &lt;silent&gt; &lt;tab&gt; &lt;c-r&gt;=CleverTab()&lt;cr&gt;snoremap &lt;silent&gt; &lt;tab&gt; &lt;esc&gt;:call UltiSnips#ExpandSnippetOrJump()&lt;cr&gt; ultisnips沒有禁用按鍵映射的開關，而默認的映射會干擾上述配置，所以這裡把默認的映射改成了&lt;c-tab&gt;。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"GraphQL：RESTful之外的接口實現方案","slug":"graphql-vs-restful","date":"2017-08-01T09:36:27.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/graphql-vs-restful/","link":"","permalink":"http://0x3f.org/post/graphql-vs-restful/","excerpt":"","text":"和RESTfull一樣，GraphQL也是一種基於HTTP的接口實現方式。它區別於前者的主要有兩點：數據格式的自定義和請求的合併。 本質上，GraphQL是為了解決RESTful中前後端在業務邏輯上的耦合關係。在RESTful中，接口是為前端具體的業務需求定制的，從實現什麼樣的功能，到返回哪些數據，都是既定的，所以很難被其它業務邏輯共用，即使可以共用，前端也必須發送多個請求到後端，因而造成資源浪費、效率下降。 GraphQL實現的是一套邏輯積木，每個封裝好的業務邏輯都是原子的，前端可以自由選擇使用哪些，也可以定制返回數據的格式。並且這一切，都可以通過一次請求實現。 當然，GraphQL也有一些短板。比如緩存，對於RESTfull接口，可以根據操作的冪等性實現負載均衡層面的緩存，而對於GraphQL，由於請求數據格式靈活且可能很大，請求會用POST方式發送，這樣就必須改變緩存的實現方式。再一點是嵌套的層級問題，GraphQL的靈活性允許查詢類型之間彼此嵌套，如果層級過多，可能導致嚴重的性能和可用性問題，因此需要注意限制嵌套的層級。還有就是GraphQL的實現複雜度比RESTful要高，需要權衡使用哪種實現方案。 GraphQL用schema管理接口，可以根據業務等因素劃分schema，例如需要權限驗證的和公開的。每個schema包含兩類接口：query和mutation，分別用來查詢和變更數據。 下面在Laravel中簡單實現一個query接口。 先安裝folklore/graphql庫。 實現文章類型： 123456789101112131415161718192021222324252627namespace App\\GraphQL\\Type;use GraphQL\\Type\\Definition\\Type;use Folklore\\GraphQL\\Support\\Type as GraphQLType;class PostType extends GraphQLType &#123; public function fields() &#123; return [ 'id' =&gt; [ 'type' =&gt; Type::nonNull(Type::string()), 'description' =&gt; 'The id of the post' ], 'title' =&gt; [ 'type' =&gt; Type::string(), 'description' =&gt; 'Post title' ] ]; &#125; protected function resolveTitleField($root, $args) &#123; return $root-&gt;post_title; &#125;&#125; 實現文章的查詢邏輯： 123456789101112131415161718192021222324namespace App\\GraphQL\\Query;use GraphQL;use GraphQL\\Type\\Definition\\Type;use Folklore\\GraphQL\\Support\\Query;use App\\Models\\Post;class PostQuery extends Query &#123; public function type() &#123; return Type::listOf(GraphQL::type('Post')); &#125; public function resolve($root, $args) &#123; if(isset($args['id'])) &#123; return Post::where('id' , $args['id'])-&gt;get(); &#125; else &#123; return Post::all(); &#125; &#125;&#125; 在config/graphql.php中註冊類型和邏輯： 1234567891011121314'schemas' =&gt; [ 'default' =&gt; [ 'query' =&gt; [ 'posts' =&gt; 'App\\GraphQL\\Query\\PostQuery' ], 'mutation' =&gt; [ ] ],],'types' =&gt; [ 'Post' =&gt; 'App\\GraphQL\\Type\\PostType',], 請求及結果如下： GraphQL並不是RESTful的替代方案，是否用前者替代後者，取決於是否願意為了靈活性而增加複雜度。兩者有各自的適用領域，GraphQL更適合用來實現開放接口。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"}]},{"title":"用vim-plug換掉了vim-addon-manager","slug":"replaced-vam-with-vim-plug","date":"2017-07-31T14:44:16.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/replaced-vam-with-vim-plug/","link":"","permalink":"http://0x3f.org/post/replaced-vam-with-vim-plug/","excerpt":"","text":"四年零兩個月前，我在Vim的郵件組中徵詢pathogen和vundle的優劣。一個人建議我試試VAM，語氣幽怨——他是它的作者。 試過之後就從pathogen遷移到了VAM，因為它兼有前者和vundle的優點，在當時，這是最好的插件管理器。就這樣用了很久，期間還寫了點腳本簡化插件的管理，VAM工作得很好。 最近發現越來越多的插件的文檔里提到vim-plug，亮點是支持並行安裝和更新，這真是解決了VAM最大的痛點：我疊代了十年的vimrc里用了很多插件，串行的VAM每次更新都讓我很痛苦。 另外，vim-plug較VAM的另一個優勢是簡單。這倒不是說後者很難用，只是作者過於追求靈活性，導致有些工作實現起來相對更複雜。例如，有的插件安裝之後需要做一些額外的操作，VAM需要自己實現回調函數，然後掛到post-install鈎子上。而對於vim-plug，只需要在註冊插件的地方增加一個選項。對於插件的懶加載，也是同樣。 VAM也有自己的優勢。其中之一是可以自動處理依賴關係：當一個要被安裝的插件依賴別的插件時，相應的依賴也會被自動安裝。還有就是對多源的支持：既可以拉取github上的插件，也可以從vim.org或其它源安裝。而vim-plug就只支持github。 所以，vim-plug並沒有全面超過VAM，只是沒有明顯的短板、功能又剛剛夠用。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"用choosewin.vim切換窗口","slug":"choosewin-vim","date":"2017-07-30T12:48:46.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/choosewin-vim/","link":"","permalink":"http://0x3f.org/post/choosewin-vim/","excerpt":"","text":"輸入-顯示每個窗口的hint，輸入hint跳轉，簡單而高效：","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"Python 2還是3是個糾結的問題","slug":"bothered-by-python-2-vs-3","date":"2017-07-30T00:40:11.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/bothered-by-python-2-vs-3/","link":"","permalink":"http://0x3f.org/post/bothered-by-python-2-vs-3/","excerpt":"","text":"前些天用denite取代unite，用--with-python3重裝了vim，結果發現vdebug只支持python 2。 vim同時只能在py2和py3中選一個，據說可以通過重新編譯python實現共存，但是我在編譯py3的時候失敗。 neovim同時支持兩個版本，但是嘗試deoplete失敗，報「Invalid Channel」的錯誤，似乎是python-neovim的鍋。而且由於neovim內建lua、不支持has(&#39;lua&#39;)，所以不能fall back到neocomplete。 萬般無奈，只好換回unite。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"給Thinkpad X220裝了黑蘋果","slug":"installed-hackintosh-in-thinkpad-x220","date":"2017-07-29T09:44:16.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/installed-hackintosh-in-thinkpad-x220/","link":"","permalink":"http://0x3f.org/post/installed-hackintosh-in-thinkpad-x220/","excerpt":"","text":"閑魚上突然收到詢價消息，于是突發奇想，在閑置很久的X220上裝個黑蘋果玩玩。 過程很簡單，參考這兩個鏈接：link1和link2。 内置的無線網卡不能驅動，用了個閑置的USB卡。藍牙能用耳機，但不能airdrop。關機會變重啓。此外沒别的問題了。 現在計算機性能真是過剩的，n年前的機器，除了機械硬盤慢了點，其它毫無壓力。 我在twitter上說：“似可再戰三年。”","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"},{"name":"apple","slug":"apple","permalink":"http://0x3f.org/tags/apple/"}]},{"title":"利用goyo.vim專注寫作","slug":"distraction-free-writing-in-vim","date":"2017-07-29T08:48:45.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/distraction-free-writing-in-vim/","link":"","permalink":"http://0x3f.org/post/distraction-free-writing-in-vim/","excerpt":"","text":"goyo.vim是給vim提供專注寫作模式的插件，配合markdown效果不錯： 最好在單獨的vim實例中使用，已發現和vim-workspace配合不好的情況。 對markdown文件自動開啓goyo的配置如下： 1234567891011121314function! s:auto_goyo() if &amp;ft == 'markdown' Goyo 80 else let bufnr = bufnr('%') Goyo! execute 'b '.bufnr endifendfunctionaugroup goyo_markdown autocmd! autocmd BufNewFile,BufRead * call s:auto_goyo()augroup END","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"用vim-workspace換掉了session.vim","slug":"replace-session-vim-with-vim-workspace","date":"2017-07-19T09:47:30.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/replace-session-vim-with-vim-workspace/","link":"","permalink":"http://0x3f.org/post/replace-session-vim-with-vim-workspace/","excerpt":"","text":"用session.vim一直有幾個痛點。一是保存會話後，退出時仍然會提示保存。二是會話會記錄vimrc，恢復會話後用的仍然是舊的配置。 vim-workspace沒有這些問題，而且實現了更多功能。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"用neocomplete換掉了YouCompleteMe","slug":"replace-youcompleteme-with-neocomplete","date":"2017-07-15T02:29:48.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/replace-youcompleteme-with-neocomplete/","link":"","permalink":"http://0x3f.org/post/replace-youcompleteme-with-neocomplete/","excerpt":"","text":"在嘗試了多種方案後，我又一次換掉了自動補全插件。 工具應該是能提高生產力的，而不是相反，很長一段時間以來，YouCompleteMe帶給我的卻是個疑惑，真不知道這個東東到底是提高了我的生產力，還是反之。自動補全在提高輸入速度和準確度上都有助益，但是有時候補全選項彈出的又很慢。 測試了nvim-complete-manager+LanguageClient-neovim+LanguageServer-php-neovim、deoplete+phpcd、deoplete+padawan、neocomplete+phpcomplete-extended，效果都非常不理想。最後選擇了neocomplete+phpcomplete，速度可以接受，表現比YCM穩定，功能該有的都有。 相關閱讀： How to Make YouCompleteMe Compatible with UltiSnips Vim的終極自動補全插件：NeoComplCache","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"LeaderF，也許是Vim最好的模糊查詢插件","slug":"leaderf-currently-the-best-fuzzy-finder-of-vim","date":"2017-07-13T08:45:15.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/leaderf-currently-the-best-fuzzy-finder-of-vim/","link":"","permalink":"http://0x3f.org/post/leaderf-currently-the-best-fuzzy-finder-of-vim/","excerpt":"","text":"之前對比過幾個模糊查詢插件（Fuzzy Finder），最後選定了ctrlp。 用了下LeaderF，在速度和匹配的準確度上都明顯超過了ctrlp，所以用它換掉了後者。 只是在交互方式上，我更喜歡ctrlp，文件列表高度是動態變化的，最匹配的行和輸入焦點都在窗口的最下方。LeaderF是定高的，最匹配的行在最上方，個人認為不如前者自然。 能解決痛點的才是好東西，什麼時候能換掉YouCompleteMe就好了。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"怎樣測試PHP的Private或Protected方法","slug":"how-to-test-private-or-protected-methods-in-php","date":"2017-07-03T05:17:30.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-test-private-or-protected-methods-in-php/","link":"","permalink":"http://0x3f.org/post/how-to-test-private-or-protected-methods-in-php/","excerpt":"","text":"利用閉包綁定： 1234567$ctrlr = new UserController;$tester = function () use ($uid) &#123; $this-&gt;getUser($uid);&#125;;$runner = $tester-&gt;bindTo($ctrlr, $ctrlr);$runner();","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"測試","slug":"測試","permalink":"http://0x3f.org/tags/測試/"}]},{"title":"白鹿原、外鄉人和窗外","slug":"routine-talk-170629","date":"2017-06-29T14:51:52.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/routine-talk-170629/","link":"","permalink":"http://0x3f.org/post/routine-talk-170629/","excerpt":"","text":"今年端午恰好是開公眾號一週年，成績就不曬了，因為沒有成績，當初的目標好像一個都沒實現，想著端午寫幾句話，結果又拖了一個月…… 這一年跌宕起伏，卻是不足與人道，倒是最近看了兩部劇，感覺還不錯。 《白鹿原》前段時間很火，我沒看過原著，好像我骨子裡不是個喜歡小說的，十幾年前聽說這本書的時候也沒什麼去讀的衝動。這次看拍得還不錯，就買了樂視的會員，每天追到凌晨一點。整體來說質量不錯，陣容不算豪華，主演的幾位演技都挺好，適合我這種沒看過原著又很龜毛的。看過的就不用追了，影視劇永遠趕不上原著。 《外鄉人》的知名度就差遠了，我也是從豆瓣上翻高分劇翻出來的。幾年前的一部冷門劇，題材就很冷，講滬漂的。劇情貼近現實，演員的表演也很真實，分數就高在這兒了，能做到這兩點的太少了。 題圖是我的窗外，前段時間天氣好的時候拍的，Snapseed真是個好東西，嗯。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"照片","slug":"照片","permalink":"http://0x3f.org/tags/照片/"},{"name":"電視劇","slug":"電視劇","permalink":"http://0x3f.org/tags/電視劇/"}]},{"title":"爲每個GTK3應用指定單獨的主題","slug":"specify-a-theme-for-each-gtk-3-app","date":"2017-06-27T07:37:43.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/specify-a-theme-for-each-gtk-3-app/","link":"","permalink":"http://0x3f.org/post/specify-a-theme-for-each-gtk-3-app/","excerpt":"","text":"指定GVim 8使用Numix主題并最小程度影響既有的腳本、快捷鍵。 我這裏gvim安裝在/usr/bin/gvim，$PATH中/usr/local/bin在/usr/bin前面，所以在/usr/local/bin下創建gvim： 123#!/bin/shGTK_THEME=Numix /usr/bin/gvim \"$@\" 同理，對gvimdiff也做同樣處理。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"桌面環境","slug":"桌面環境","permalink":"http://0x3f.org/tags/桌面環境/"}]},{"title":"調校mycli","slug":"fine-tune-mycli","date":"2017-06-26T10:05:31.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/fine-tune-mycli/","link":"","permalink":"http://0x3f.org/post/fine-tune-mycli/","excerpt":"","text":"做以下配置，使mycli按需使用pager，并在數據過多時不破壞表格格式： 1234# ~/.my.cnf[client]pager = less -FSXR","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"數據庫","slug":"數據庫","permalink":"http://0x3f.org/tags/數據庫/"},{"name":"工具","slug":"工具","permalink":"http://0x3f.org/tags/工具/"}]},{"title":"用MySQL的全文檢索實現相關性排序","slug":"fulltext-searching-in-mysql","date":"2017-06-19T15:10:41.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/fulltext-searching-in-mysql/","link":"","permalink":"http://0x3f.org/post/fulltext-searching-in-mysql/","excerpt":"","text":"實現根據文章的關鍵詞搜索出相關的文章，並按相關性排序。 數據庫版本是5.6.x，還不能像5.7那樣支持中文的全文檢索，所以另外創建一列保存關鍵詞的編碼。方法為base64轉碼並去掉「%」符號： 1234567891011121314151617&lt;?php/** * 轉換關鍵詞到全文檢索的格式 * * @param mixed $keywords 關鍵詞數組或英文逗號分隔的字符串 * @return string */function encode_keywords($keywords)&#123; $encoder = function ($keyword) &#123; return str_replace('%', '', urlencode(trim($keyword))); &#125;; if (!is_array($keywords)) &#123; $keywords = explode(',', $keywords); &#125; return implode(' ', array_map($encoder, $keywords));&#125; 對該列創建全文檢索的索引： 1CREATE FULLTEXT INDEX idx_post_keywords ON posts (keywords_ft); 查詢語句： 1234567891011SELECT id, title, keywords, (MATCH (keywords_ft) AGAINST ('E697B6E5B09A E5A8B1E4B990E59C88' IN NATURAL LANGUAGE MODE)) AS `score`FROM postsWHERE MATCH (keywords_ft) AGAINST ('E697B6E5B09A E5A8B1E4B990E59C88' IN NATURAL LANGUAGE MODE)ORDER BY score DESCLIMIT 10","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"數據庫","slug":"數據庫","permalink":"http://0x3f.org/tags/數據庫/"},{"name":"mysql","slug":"mysql","permalink":"http://0x3f.org/tags/mysql/"},{"name":"全文檢索","slug":"全文檢索","permalink":"http://0x3f.org/tags/全文檢索/"}]},{"title":"CopyQ，也許是Linux最好的剪貼板管理工具","slug":"copyq","date":"2017-06-19T13:49:14.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/copyq/","link":"","permalink":"http://0x3f.org/post/copyq/","excerpt":"","text":"我對剪貼板管理工具的核心需求有四個： 記錄文本 記錄圖片 快速搜索 獨立軟件包 CopyQ是Linux上唯一滿足這些需求的實現，雖然體驗上跟Mac下的競品還有差距。 用法： copyq：運行 copyq menu：顯示剪貼板歷史管理菜單 copyq show：顯示剪貼板歷史管理窗口","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"工具","slug":"工具","permalink":"http://0x3f.org/tags/工具/"}]},{"title":"手機鎖屏後自動斷開WiFi的解決辦法","slug":"solve-the-auto-breaking-problem-of-huawei-e5573s","date":"2017-06-17T15:13:33.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/solve-the-auto-breaking-problem-of-huawei-e5573s/","link":"","permalink":"http://0x3f.org/post/solve-the-auto-breaking-problem-of-huawei-e5573s/","excerpt":"","text":"我的iPhone 6總是在鎖屏後不久就從華為E5573S斷開，但是連接家裡的WiFi不會有這個問題，iOS同版本的iPad mini 4連接E5573S也正常。 兩台機器里E5573S的連接屬性界面有差異，iPhone 6里有「自動加入」等兩個選項，這在同機其它WiFi連接里是沒有的，iPad里也沒有。所以猜測應該是iPhone里連接本身的問題，忽略掉該連接，再重新連，就好了。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[]},{"title":"用Tmux的控制模式提高生產力","slug":"improve-productivity-with-tmux-control-mode","date":"2017-06-11T02:40:06.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/improve-productivity-with-tmux-control-mode/","link":"","permalink":"http://0x3f.org/post/improve-productivity-with-tmux-control-mode/","excerpt":"","text":"Tmux的控制模式（Control Mode）可以把tmux的窗口映射為本地虛擬終端的窗口，也就是說，用戶可以像操作本地虛擬終端一樣操作tmux。這對備受tmux的emacs風格的熱鍵綁定折磨或需要嵌套tmux的人來說非常有用。 在支持這個特性的虛擬終端（例如「iTerm」）里，執行tmux -CC即可。當然也可以tmux -CC a恢復會話。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"工具","slug":"工具","permalink":"http://0x3f.org/tags/工具/"}]},{"title":"用SwitchHosts!切換主機映射方案","slug":"switch-hosts-with-switchhosts","date":"2017-06-11T01:57:54.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/switch-hosts-with-switchhosts/","link":"","permalink":"http://0x3f.org/post/switch-hosts-with-switchhosts/","excerpt":"","text":"最近在Archlinux上開始用SwitchHosts!管理主機映射方案，它可能是Linux下做這件事的最好的工具了。 在Mac下也用它替換掉了Gas Mask，因為支持Alfred Workflow。相對的缺點是不支持在狀態欄圖標上顯示當前方案名稱，不過Alfred里可以，一定程度上緩解了這個問題。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"工具","slug":"工具","permalink":"http://0x3f.org/tags/工具/"}]},{"title":"自定義GVIM 8標籤欄樣式的方法","slug":"how-to-customize-gvim8-tab-style","date":"2017-06-04T04:42:12.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-customize-gvim8-tab-style/","link":"","permalink":"http://0x3f.org/post/how-to-customize-gvim8-tab-style/","excerpt":"","text":"GVim 8用的是GTK 3，原來在~/.gtkrc-2.0里加樣式的方法不能用了。 GTK 3的樣式在~/.config/gtk-3.0/gtk.css里： 123456789101112131415161718192021222324252627/** * Adapt to the nova colorscheme */@define-color VIM_BG_FIX #3C4C55;window#vim-main-window &#123; background-color: @VIM_BG_FIX;&#125;window#vim-main-window notebook header &#123; background-color: #1E272C; border-bottom-width: 0;&#125;window#vim-main-window notebook tab &#123; border-bottom-width: 0;&#125;window#vim-main-window notebook tab label &#123; padding-left:5px; padding-right:5px; padding-top:1px; padding-bottom:2px; color: #7CBDC6;&#125;window#vim-main-window notebook tab:checked label &#123; background-color: #7CBDC6; color: #1E272C;&#125; 查看GTK 3程序的樣式結構的方法是用GTK Inspector： 1GTK_DEBUG=interactive gvim","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"網站簽到的最佳實踐","slug":"the-best-practice-of-checking-in","date":"2017-05-24T03:42:52.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-best-practice-of-checking-in/","link":"","permalink":"http://0x3f.org/post/the-best-practice-of-checking-in/","excerpt":"","text":"v2ex、優酷、什麼值得買用qiandao.today實現。優點是依賴少，速度快，支持的範圍廣，可擴展。缺點是對京東和京東金融無效。 京東和京東金融使用daily-signin。缺點是依賴docker，速度慢。 淘寶簽到沒有有效的腳本，用淘金幣一鍵領取。 飛豬也沒有有效腳本，手工簽： http://trip.taobao.com/mytrip/?tvm=tvip http://trip.taobao.com/mytrip/ http://h5.m.taobao.com/trip/member/index.html","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"通過比較截圖檢查網頁變化","slug":"check-changes-of-webpage-by-comparing-screenshots","date":"2017-04-30T09:21:52.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/check-changes-of-webpage-by-comparing-screenshots/","link":"","permalink":"http://0x3f.org/post/check-changes-of-webpage-by-comparing-screenshots/","excerpt":"","text":"有時候我們希望檢查代碼或數據的更新對網頁產生的影響，如果能把這個過程集成到git等版本控制系統中，在提交成果的同時自動批量執行，將會極大地提高生產力。 首先網頁的截圖可以用PhantomJS、Headless Chrome實現： 12345var page = require('webpage').create();page.open('http://github.com/', function() &#123; page.render('github.png'); phantom.exit();&#125;); 圖片的差異比較用GraphicsMagick實現： 1gm compare old.png new.png -file diff.png -highlight-style assign 為方便查看，還可以把截圖做成gif動圖： 1gm convert -delay 20 old.png diff.png new.png diff.gif","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"測試","slug":"測試","permalink":"http://0x3f.org/tags/測試/"}]},{"title":"PHPUnit代碼覆蓋率的統計方法","slug":"how-to-count-code-coverage-of-phpunit","date":"2017-04-30T06:20:41.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-count-code-coverage-of-phpunit/","link":"","permalink":"http://0x3f.org/post/how-to-count-code-coverage-of-phpunit/","excerpt":"","text":"關於PHPUnit代碼覆蓋率的很多概念，官方文檔中講的十分清楚，本文僅就部分語焉不詳的細節做些補充。 雖然phpunit.xml不是必需，但每次都輸入完整的命令很不方便，所以一般都要生成這個配置文件。用phpunit --generate-configuration生成的phpunit.xml默認包含forceCoversAnnotation=&quot;true&quot;，它表示必須在測試方法頭部的注釋里顯式使用@covers標籤聲明統計範圍，例如： 12345678910/** * @covers Ox3f\\LaravelUtils\\Log\\Log::&lt;public&gt; * @covers Ox3f\\LaravelUtils\\Log\\Log::parseCallStack * @covers Ox3f\\LaravelUtils\\Log\\Log::__construct * @covers Ox3f\\LaravelUtils\\Log\\Log::__callStatic */public function testAll()&#123; // ...&#125; 否則在執行統計代碼覆蓋率的命令時，會報risk： There was 1 risky test: 1) Ox3f\\LaravelUtils\\Log\\LogTest::testAllThis test does not have a @covers annotation but is expected to have one 如果希望單元測試覆蓋全部代碼、且不用一一顯式聲明，可以將此選項的值改成false。 之後即可使用明令phpunit —coverage-html ./report統計代碼覆蓋率，統計結果保存在report目錄中。 參考 官方文檔：第11章-代碼覆蓋率分析","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"測試","slug":"測試","permalink":"http://0x3f.org/tags/測試/"}]},{"title":"利用依賴注入Mock PHP的內建函數","slug":"mock-php-built-in-functions-using-dependency-injection","date":"2017-04-30T01:57:50.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/mock-php-built-in-functions-using-dependency-injection/","link":"","permalink":"http://0x3f.org/post/mock-php-built-in-functions-using-dependency-injection/","excerpt":"","text":"簡述上篇文章討論了如何利用命名空間實現對PHP內建函數的mocking，本文介紹另一種實現方法——依賴注入。 出於編寫可測試代碼的需要，依賴注入是經常使用的一種技術。通過把代碼中依賴的其它數據獲取服務提取出來、和原有邏輯解耦，提高代碼的可測試性。只需mock這些依賴並注入到測試對象中即可。 實現對原有代碼的重構先把原有代碼用依賴注入的方式重構（為突出重點，省略了和上篇文章中重復的部分）： 12345678910111213141516171819202122232425262728293031323334353637383940414243// ...use Ox3f\\LaravelUtils\\Services\\Builtins;/** * Class Log * @author donie */class Log&#123; // ... private $builtins; // Builtin functions private function __construct() &#123; $this-&gt;builtins = new Builtins(); // ... &#125; // ... public static function inject($key, $service) &#123; self::getInstance()-&gt;$key = $service; &#125; /** * Parse the call stack * * @return void */ private function parseCallStack() &#123; $traceInfo = $this-&gt;builtins-&gt;debug_backtrace(DEBUG_BACKTRACE_PROVIDE_OBJECT|DEBUG_BACKTRACE_IGNORE_ARGS, 5); // ... &#125; // ... &#125; Builtins類的實現： 123456789101112131415&lt;?phpnamespace Ox3f\\LaravelUtils\\Services;/** * Class Builtins * @author donie */class Builtins&#123; public function debug_backtrace() &#123; return call_user_func_array('debug_backtrace', func_get_args()); &#125; &#125; 把debug_backtrace()封裝進了Builtins類，並在測試對象中通過這個類調用內建函數。inject()用於注入依賴，這樣可以在測試類中把mock注入到測試對象中。 測試類的實現代碼如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?phpuse PHPUnit\\Framework\\TestCase;use Illuminate\\Support\\Facades\\Auth;use Illuminate\\Support\\Facades\\Request;use Illuminate\\Support\\Facades\\Log as LaravelLog;use Ox3f\\LaravelUtils\\Log\\Log;use \\Mockery as m;class LogTest extends TestCase&#123; public function setUp() &#123; Auth::shouldReceive('user') -&gt;once() -&gt;andReturn((object)['name' =&gt; 'jim',]); &#125; public function tearDown() &#123; m::close(); &#125; /** * @covers Ox3f\\LaravelUtils\\Log\\Log::saveInput * @covers Ox3f\\LaravelUtils\\Log\\Log::saveOutput * @covers Ox3f\\LaravelUtils\\Log\\Log::parseCallStack * @covers Ox3f\\LaravelUtils\\Log\\Log::getInstance * @covers Ox3f\\LaravelUtils\\Log\\Log::__construct * @covers Ox3f\\LaravelUtils\\Log\\Log::__callStatic */ public function testAll() &#123; $mock = m::mock('Ox3f\\LaravelUtils\\Services\\Builtins'); $mock-&gt;shouldReceive('debug_backtrace') -&gt;andReturnUsing(function() use ($mock) &#123; if ($mock-&gt;calledInController) &#123; return json_decode('[&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/vendor\\/xbot\\/laravel-utils\\/src\\/Log\\/Log.php\",\"line\":85,\"function\":\"parseCallStack\",\"class\":\"Ox3f\\\\\\LaravelUtils\\\\\\Log\\\\\\Log\",\"object\":&#123;&#125;,\"type\":\"-&gt;\"&#125;,&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/app\\/Api\\/V1\\/Controllers\\/WorkController.php\",\"line\":29,\"function\":\"saveInput\",\"class\":\"Ox3f\\\\\\LaravelUtils\\\\\\Log\\\\\\Log\",\"type\":\"::\"&#125;,&#123;\"function\":\"save\",\"class\":\"App\\\\\\Api\\\\\\V1\\\\\\Controllers\\\\\\WorkController\",\"object\":&#123;&#125;,\"type\":\"-&gt;\"&#125;,&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Routing\\/Controller.php\",\"line\":55,\"function\":\"call_user_func_array\"&#125;,&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Routing\\/ControllerDispatcher.php\",\"line\":44,\"function\":\"callAction\",\"class\":\"Illuminate\\\\\\Routing\\\\\\Controller\",\"object\":&#123;&#125;,\"type\":\"-&gt;\"&#125;]', true); &#125; else &#123; return json_decode('[&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/vendor\\/xbot\\/laravel-utils\\/src\\/Log\\/Log.php\",\"line\":85,\"function\":\"parseCallStack\",\"class\":\"Ox3f\\\\\\LaravelUtils\\\\\\Log\\\\\\Log\",\"object\":&#123;&#125;,\"type\":\"-&gt;\"&#125;,&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/app\\/Notation.php\",\"line\":21,\"function\":\"saveInput\",\"class\":\"Ox3f\\\\\\LaravelUtils\\\\\\Log\\\\\\Log\",\"type\":\"::\"&#125;,&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/app\\/Api\\/V1\\/Controllers\\/NotationController.php\",\"line\":32,\"function\":\"incrNo\",\"class\":\"App\\\\\\Notation\",\"type\":\"::\"&#125;,&#123;\"function\":\"save\",\"class\":\"App\\\\\\Api\\\\\\V1\\\\\\Controllers\\\\\\NotationController\",\"object\":&#123;&#125;,\"type\":\"-&gt;\"&#125;,&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Routing\\/Controller.php\",\"line\":55,\"function\":\"call_user_func_array\"&#125;]', true); &#125; &#125;); Log::inject('builtins', $mock); // test being called in a plain method $mock-&gt;calledInController = false; LaravelLog::shouldReceive('debug') -&gt;once() -&gt;with('jim | App\\Notation::incrNo | Input:1'); Log::saveInput(1); LaravelLog::shouldReceive('debug') -&gt;once() -&gt;with('jim | App\\Notation::incrNo | Output:2'); Log::saveOutput(2); // test being called in a controller action $mock-&gt;calledInController = true; Request::shouldReceive('path') -&gt;once() -&gt;andReturn('api/user'); Request::shouldReceive('except') -&gt;once() -&gt;with('_url') -&gt;andReturn(['id' =&gt; 18,]); LaravelLog::shouldReceive('debug') -&gt;once() -&gt;with('jim | api/user | Input:&#123;\"id\":18&#125;'); Log::saveInput(); Request::shouldReceive('path') -&gt;once() -&gt;andReturn('api/user'); LaravelLog::shouldReceive('debug') -&gt;once() -&gt;with('jim | api/user | Output:2'); Log::saveOutput(2); Request::shouldReceive('path') -&gt;once() -&gt;andReturn('api/user'); LaravelLog::shouldReceive('error') -&gt;once() -&gt;with('jim | api/user | this is an error'); Log::error('this is an error'); $this-&gt;assertEquals(0, 0); &#125;&#125; Builtins是個普通類，很容易mock。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"測試","slug":"測試","permalink":"http://0x3f.org/tags/測試/"}]},{"title":"利用命名空間Mock PHP的內建函數","slug":"mock-php-built-in-functions-using-namespace","date":"2017-04-30T01:06:17.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/mock-php-built-in-functions-using-namespace/","link":"","permalink":"http://0x3f.org/post/mock-php-built-in-functions-using-namespace/","excerpt":"","text":"簡述Mock PHP的內建函數一般有兩種方法：命名空間法和依賴注入法。 命名空間法是利用PHP優先使用同命名空間內函數的特性，在測試對象的命名空間內重載內建函數來實現。前提是內建函數在被調用時沒有使用命名空間，例如：\\debug_backtrace()是不能使用本方法的。 上篇文章《接口編程中記錄日誌的最佳實踐》中實現的日誌類中，核心部分調用了debug_backtrace()函數獲取方法調用堆棧。下面討論下如何利用命名空間法實現對此函數的mock。 實現先看代碼： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?phpnamespace Ox3f\\LaravelUtils\\Log;use PHPUnit\\Framework\\TestCase;use Illuminate\\Support\\Facades\\Auth;use Illuminate\\Support\\Facades\\Request;use Illuminate\\Support\\Facades\\Log as LaravelLog;use Ox3f\\LaravelUtils\\Log\\Log;$calledInController = false;function debug_backtrace() &#123; global $calledInController; if ($calledInController) &#123; return json_decode('[&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/vendor\\/xbot\\/laravel-utils\\/src\\/Log\\/Log.php\",\"line\":85,\"function\":\"parseCallStack\",\"class\":\"Ox3f\\\\\\LaravelUtils\\\\\\Log\\\\\\Log\",\"object\":&#123;&#125;,\"type\":\"-&gt;\"&#125;,&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/app\\/Api\\/V1\\/Controllers\\/WorkController.php\",\"line\":29,\"function\":\"saveInput\",\"class\":\"Ox3f\\\\\\LaravelUtils\\\\\\Log\\\\\\Log\",\"type\":\"::\"&#125;,&#123;\"function\":\"save\",\"class\":\"App\\\\\\Api\\\\\\V1\\\\\\Controllers\\\\\\WorkController\",\"object\":&#123;&#125;,\"type\":\"-&gt;\"&#125;,&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Routing\\/Controller.php\",\"line\":55,\"function\":\"call_user_func_array\"&#125;,&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Routing\\/ControllerDispatcher.php\",\"line\":44,\"function\":\"callAction\",\"class\":\"Illuminate\\\\\\Routing\\\\\\Controller\",\"object\":&#123;&#125;,\"type\":\"-&gt;\"&#125;]', true); &#125; else &#123; return json_decode('[&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/vendor\\/xbot\\/laravel-utils\\/src\\/Log\\/Log.php\",\"line\":85,\"function\":\"parseCallStack\",\"class\":\"Ox3f\\\\\\LaravelUtils\\\\\\Log\\\\\\Log\",\"object\":&#123;&#125;,\"type\":\"-&gt;\"&#125;,&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/app\\/Notation.php\",\"line\":21,\"function\":\"saveInput\",\"class\":\"Ox3f\\\\\\LaravelUtils\\\\\\Log\\\\\\Log\",\"type\":\"::\"&#125;,&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/app\\/Api\\/V1\\/Controllers\\/NotationController.php\",\"line\":32,\"function\":\"incrNo\",\"class\":\"App\\\\\\Notation\",\"type\":\"::\"&#125;,&#123;\"function\":\"save\",\"class\":\"App\\\\\\Api\\\\\\V1\\\\\\Controllers\\\\\\NotationController\",\"object\":&#123;&#125;,\"type\":\"-&gt;\"&#125;,&#123;\"file\":\"\\/Users\\/xbot\\/Sites\\/sample-project\\/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Routing\\/Controller.php\",\"line\":55,\"function\":\"call_user_func_array\"&#125;]', true); &#125;&#125;class LogTest extends TestCase&#123; public function setUp() &#123; Auth::shouldReceive('user') -&gt;once() -&gt;andReturn((object)['name' =&gt; 'jim',]); &#125; /** * @covers Ox3f\\LaravelUtils\\Log\\Log::saveInput * @covers Ox3f\\LaravelUtils\\Log\\Log::saveOutput * @covers Ox3f\\LaravelUtils\\Log\\Log::parseCallStack * @covers Ox3f\\LaravelUtils\\Log\\Log::getInstance * @covers Ox3f\\LaravelUtils\\Log\\Log::__construct * @covers Ox3f\\LaravelUtils\\Log\\Log::__callStatic */ public function testAll() &#123; global $calledInController; // test being called in a plain method $calledInController = false; LaravelLog::shouldReceive('debug') -&gt;once() -&gt;with('jim | App\\Notation::incrNo | Input:1'); Log::saveInput(1); LaravelLog::shouldReceive('debug') -&gt;once() -&gt;with('jim | App\\Notation::incrNo | Output:2'); Log::saveOutput(2); // test being called in a controller action $calledInController = true; Request::shouldReceive('path') -&gt;once() -&gt;andReturn('api/user'); Request::shouldReceive('except') -&gt;once() -&gt;with('_url') -&gt;andReturn(['id' =&gt; 18,]); LaravelLog::shouldReceive('debug') -&gt;once() -&gt;with('jim | api/user | Input:&#123;\"id\":18&#125;'); Log::saveInput(); Request::shouldReceive('path') -&gt;once() -&gt;andReturn('api/user'); LaravelLog::shouldReceive('debug') -&gt;once() -&gt;with('jim | api/user | Output:2'); Log::saveOutput(2); Request::shouldReceive('path') -&gt;once() -&gt;andReturn('api/user'); LaravelLog::shouldReceive('error') -&gt;once() -&gt;with('jim | api/user | this is an error'); Log::error('this is an error'); $this-&gt;assertEquals(0, 0); &#125;&#125; 最重要的是第一行，這裡把測試類的命名空間設置得和測試對象一致，這樣在下面重載的debug_backtrace()函數就會在測試對象中被優先使用。 在重載的函數中，通過全局變量$calledInController選擇輸出事先捕獲的真實數據，從而mock出符合我們需要的函數。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"測試","slug":"測試","permalink":"http://0x3f.org/tags/測試/"}]},{"title":"接口編程中記錄日誌的最佳實踐","slug":"the-best-practice-of-logging-in-api-programming","date":"2017-04-25T07:50:41.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-best-practice-of-logging-in-api-programming/","link":"","permalink":"http://0x3f.org/post/the-best-practice-of-logging-in-api-programming/","excerpt":"","text":"解決什麼問題 快速定位日誌 降低記錄成本 提高代碼可讀性 日誌框架是項目開始階段應該最先搭建好的內容之一，有助於極大地節約以後解決問題的時間和成本。但這也是最讓我頭疼的問題之一，因為記日誌不光包括用什麼記、怎麼記，也包括記什麼內容，這恰恰是最容易被忽略的問題。 一條好的日誌需要做到能讓問題的跟蹤者快速定位它在程序中的位置且包含關鍵數據。工作中不乏這樣的團隊成員，在移交接口問題的時候沒有主動提供關鍵信息的意識，所謂關鍵信息，是指像問題發生的環境、接口名、傳遞的實參和返回結果這樣的內容，使得面向契約編程本來是很好的開發模式，卻得不到最好的應用。這時我們可以從自己接口的日誌中得到一些彌補。 但是日誌的記錄不應該佔用很大的代碼量，一來降低了代碼的可讀性，二來會耗費太多的時間精力。 本文目的在於討論一種日誌記錄的最佳實踐方式，使得可以兼顧以上這些問題。 實踐這裡針對Laravel實現一個日誌工具類，實現以下功能： 兼容Laravel自己的日誌系統 自動記錄關鍵的業務數據 自動記錄日誌所屬的接口名 自動記錄接口的實參 記錄接口的返回值 生成簡潔規範的日誌內容 代碼： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?phpnamespace Ox3f\\LaravelUtils\\Log;use Illuminate\\Support\\Facades\\Log as LaravelLog;use Illuminate\\Support\\Facades\\Auth;use Illuminate\\Support\\Facades\\Request;/** * Class Log * @author donie */class Log&#123; private static $instance; private $id; // Identity of the log, username by default. private $referer; // Request path for RESTful APIs, method name for ordinary class methods. private $isHttp; // True for RESTful APIs, otherwise, false. private $callStackParsed; // Whether call stack has been parsed. private function __construct() &#123; $user = Auth::user(); $this-&gt;id = !empty($user-&gt;name) ? $user-&gt;name : 'anonymous'; &#125; private function __clone() &#123;&#125; public static function getInstance() &#123; if (!self::$instance) &#123; self::$instance = new self; &#125; return self::$instance; &#125; /** * Parse the call stack * * @return void */ private function parseCallStack() &#123; $traceInfo = debug_backtrace(DEBUG_BACKTRACE_PROVIDE_OBJECT|DEBUG_BACKTRACE_IGNORE_ARGS, 5); $this-&gt;referer = ''; $this-&gt;isHttp = false; foreach ($traceInfo as $callInfo) &#123; if ($callInfo['class'] != __CLASS__) &#123; if (preg_match('/Controller$/', $callInfo['class'])) &#123; $this-&gt;referer = Request::path(); $this-&gt;isHttp = true; &#125; else &#123; $this-&gt;referer = $callInfo['class'].$callInfo['type'].$callInfo['function']; &#125; break; &#125; &#125; $this-&gt;callStackParsed = true; &#125; /** * Wrapper of the laravel log facade * * @return void */ public static function __callStatic($name, $args) &#123; if (!self::getInstance()-&gt;callStackParsed) self::getInstance()-&gt;parseCallStack(); $id = self::getInstance()-&gt;id; $referer = self::getInstance()-&gt;referer; $msg = !empty($args) ? $args[0] : ''; LaravelLog::$name(\"&#123;$id&#125; | &#123;$referer&#125; | &#123;$msg&#125;\"); self::getInstance()-&gt;callStackParsed = false; &#125; /** * Save parameters of the request or arguments of the method to log at debug level * * @param mixed $args Empty for HTTP calls, needed for ordinary class methods * @return void */ public static function saveInput($args=null) &#123; self::getInstance()-&gt;parseCallStack(); if (self::getInstance()-&gt;isHttp) $args = Request::except('_url'); self::debug('Input:'.json_encode($args)); &#125; /** * Save the output to log at debug level * * @param mixed $result Result to be saved * @return void */ public static function saveOutput($result) &#123; self::getInstance()-&gt;parseCallStack(); self::debug('Output:'.json_encode($result)); &#125;&#125; 這是一個單例類，核心在於parseCallStack()方法，通過debug_backtrace()函數獲取日誌所在的接口，對於REST接口，得到HTTP請求的路徑，對於接口類的方法，得到包含類名的接口名。此外，日誌中還會記錄當前的用戶名，方便定位和復現問題。 saveInput()和saveOutput()是在此基礎上封裝的兩個高級方法，用於記錄接口的輸入和輸出，對於界定問題是否出在自己的接口或復現問題都有很重要的作用。對於REST接口，saveInput()可以自動獲取請求中的參數，而對於接口類的方法，出於性能和內存佔用考慮，沒有允許debug_backtrace()返回參數信息，需要用戶手動指定要記錄的數據。 使用方法安裝1composer require xbot/laravel-utils 使用123456use Ox3f\\LaravelUtils\\Log\\Log;Log::saveInput(); // REST接口中自動保存請求數據Log::saveInput(func_get_args()); // 接口類的方法中保存實參Log::error('This is an error.'); // 記錄一條錯誤日誌Log::saveOutput($result); // 保存接口返回值 日誌示例12[2017-04-25 06:46:11] local.DEBUG: donie | users/groups/33 | Input:&#123;&quot;check&quot;:&quot;1&quot;&#125;[2017-04-25 06:46:11] local.ERROR: donie | users/groups/33 | This is an error. 待討論的問題最佳實踐需要持續改進，以下問題有待討論： 關鍵業務數據中是否應該包含Request ID？是否有必要對每次請求生成一個ID？這樣可以很簡單地過濾出一次請求中所有的日誌。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"laravel","slug":"laravel","permalink":"http://0x3f.org/tags/laravel/"}]},{"title":"Google BBR和銳速在Vultr上的對比","slug":"google-bbr-is-awesome","date":"2017-04-23T15:48:21.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/google-bbr-is-awesome/","link":"","permalink":"http://0x3f.org/post/google-bbr-is-awesome/","excerpt":"","text":"BBR比銳速略快，看YouTube的1080p效果差別不大，SSH操作反應改善明顯。 兩個都不用的情況：12345678910$ speedtest Retrieving speedtest.net configuration...Testing from Choopa (xx.xx.xx.xx)...Retrieving speedtest.net server list...Selecting best server based on ping...Hosted by Allied Telesis Capital Corporation (Fussa-shi) [41.04 km]: 88.085 msTesting download speed................................................................................Download: 1.81 Mbit/sTesting upload speed....................................................................................................Upload: 7.48 Mbit/s 使用銳速的情況：12345678910$ speedtestRetrieving speedtest.net configuration...Testing from Choopa (xx.xx.xx.xx)...Retrieving speedtest.net server list...Selecting best server based on ping...Hosted by Allied Telesis Capital Corporation (Fussa-shi) [41.04 km]: 96.395 msTesting download speed................................................................................Download: 3.45 Mbit/sTesting upload speed....................................................................................................Upload: 4.56 Mbit/s 用BBR的情況：12345678910$ speedtestRetrieving speedtest.net configuration...Testing from Choopa (xx.xx.xx.xx)...Retrieving speedtest.net server list...Selecting best server based on ping...Hosted by ASEINet (Tokyo) [12.58 km]: 340.353 msTesting download speed................................................................................Download: 4.54 Mbit/sTesting upload speed....................................................................................................Upload: 5.71 Mbit/s","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"翻墙","slug":"翻墙","permalink":"http://0x3f.org/tags/翻墙/"}]},{"title":"Cross-site Request Forgery簡介","slug":"introduction-of-cross-site-request-forgery","date":"2017-04-23T12:55:58.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/introduction-of-cross-site-request-forgery/","link":"","permalink":"http://0x3f.org/post/introduction-of-cross-site-request-forgery/","excerpt":"","text":"什麼是CSRFCross-site Request Forgery（簡稱CSRF），意思是跨站請求偽造。原理是利用網站服務器對瀏覽器的信任，通過一些技術手段欺騙用戶的瀏覽器訪問自己曾經認證過的網站，並執行一些危害用戶利益的操作。 例如，假設網站的會話信息保存在cookie中，提現的請求是GET http://www.sample.com/withdraw?toCard=123456&amp;amount=10000，攻擊者在自己的網頁中通過img標籤、iframe或者AJAX訪問這個鏈接，並誘使用戶訪問這個網頁，如果用戶剛剛登錄過sample.com，餘額就會被轉走。 防止CSRF的方法CSRF的關鍵在於用戶的鑒權信息保存在cookie中，或攻擊者可以拿到它。目前防止CSRF攻擊的方法主要有兩種：JWT和表單校驗token。 JWT的token通過HTTP請求的header傳遞，且由於瀏覽器的跨站限制，釣魚網頁中的JS無法拿到token，從而達到防止CSRF的目的。關於JWT更詳細的介紹在「JSON Web Token簡介」。 表單校驗token通常是存儲在表單的隱藏字段中的一個隨機字符串，服務器端通過比對表單提交的token判斷請求是否偽造，此時需要注意服務器端的CORS配置，即便在有需要的情況下開放了，也應該嚴格限制允許的HTTP方法和域，否則，釣魚網頁的JS就可以拿到這個token，從而實現CSRF。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"}]},{"title":"JSON Web Token簡介","slug":"introduction-of-json-web-token","date":"2017-04-23T10:29:06.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/introduction-of-json-web-token/","link":"","permalink":"http://0x3f.org/post/introduction-of-json-web-token/","excerpt":"","text":"什麼是JWT？JSON Web Token（簡稱JWT）是一種token格式，通常用來解決身份認證的問題，和會話（session）作用相同，常用在RESTful API或者OAuth認證上。 和session相比，JWT有以下優勢： 服務器端的開銷低 服務器端擴展方便 不用專門處理CSRF 由於session的實現方式需要在服務器端存儲會話數據，所以當存在大量會話時，服務器端的存儲壓力會很大，並由此帶來擴展上的複雜度（共享session）。而JWT可以把這些數據存儲在token里，不需要服務器端存儲，優勢自然很明顯。 對於CSRF，由於session一般使用cookie實現，所以需要專門處理這個安全隱患。JWT借助HTTP請求的header傳遞，所以偽造成本更高。 JWT和Bearer Token的關係JWT在使用的時候要在token前面加上字符串「bearer」再填到HTTP請求的header里，這個值就是「Bearer Token」。為什麼要這麼做？它和JWT是什麼關係？ 簡單地說，JWT是一種token格式，Bearer Token是一種鑒權方案。 HTTP的header項「Authorization」是在HTTP 1.0引入的，它的值的格式是類型+token，支持多種鑒權方案，bearer只是其中的一種。bearer方案中使用的token是JWT格式，這就是它們之間的關係。 JWT的格式JWT是一個用英文點號連接起來的、分成三個部分的字符串：header、payload和signature。 headerheader是個base64字符串，解密後是個JSON對象，包含一些元數據。例如：1234&#123; 'typ': 'JWT', 'alg': 'HS256'&#125; 「typ」是格式，「alg」是加密方法。 payloadpayload也是個base64字符串，解密後也是個JSON對象，一般包含兩種數據：JWT標準數據和自定義數據。 JWT標準數據常見的有： iss：提供方。 sub：主題，一般是用戶ID。 exp：過期時間。 iat：創建時間。 jti：token的唯一標識。 此外，和session一樣，可以把一些自定義的數據存儲在payload里。但由於token存儲在客戶端，所以不應該在這裡存儲敏感數據。 signaturesignature也是個base64字符串，解密後是個使用header里描述的加密方法針對header和payload加密的字符串。目的是防止這兩部分的數據被篡改。 JWT的使用原則 不存放敏感信息 保護好私鑰 結合https使用 都是出於安全角度考慮。token存儲在客戶端，而且base64可以被解密，所以不能存儲敏感數據。如果私鑰洩漏，意味著簽名可以被隨意偽造。使用https可以更好的保護數據，防止中間人攻擊。 JWT相關開發資源jwt.io有各種語言的JWT開發資源。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"}]},{"title":"得草根者得天下","slug":"get-the-inferior-class-get-the-throne","date":"2017-04-21T03:05:50.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/get-the-inferior-class-get-the-throne/","link":"","permalink":"http://0x3f.org/post/get-the-inferior-class-get-the-throne/","excerpt":"","text":"國內移動支付是劣質的繁榮，量很大，但是水平低。 我個人對移動支付偏愛的程度依次是：Apple Pay &gt; 支付寶 &gt; 微信。Apple Pay的體驗最好，後兩個都多出一個掃碼的步驟，微信更是很奇葩地要多一步選卡的操作。 不過採訪過一些人，結果是用微信的最多。 原因當然是微信的社交切入點帶來的普及程度，還有紅包的成功，讓這個體驗最差的東西後來居上。支付寶因為意識到這一點，才不斷焦慮地效顰，自亂陣腳，越做越爛。 我自己平時使用的情況是，能用信用卡支付的一般用支付寶，只能轉賬的才用微信。而且線下支付還是微信居多。主要原因還是線下的收款方都是小商小販，大多只會用微信。 中國正在形成階層社會，但草根仍是主流，得草根者得天下。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"互聯網","slug":"互聯網","permalink":"http://0x3f.org/tags/互聯網/"}]},{"title":"設計RESTful API的幾個原則","slug":"some-principles-on-designing-restful-api","date":"2017-04-21T02:07:29.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/some-principles-on-designing-restful-api/","link":"","permalink":"http://0x3f.org/post/some-principles-on-designing-restful-api/","excerpt":"","text":"REST不是一項技術，而是一種設計風格。它的核心思想是實現一種清晰明確的語義，用來描述Web操作。包含兩個主要因素：HTTP動詞和資源地址。 HTTP動詞的使用原則參與Web操作的HTTP動詞主要有GET、POST、DELETE、PUT、HEAD、PATCH。實際上，幾乎所有的操作只需GET和POST就可以實現，為什麼還要有其它幾種呢？目的就是為了實現清晰明確的語義：DELETE /api/v1/post/18肯定比GET /api/v1/post?id=18&amp;action=delete更清楚。 因此HTTP動詞使用的重點在於明確語義。例如更新操作，很多文章會說創建資源用POST、修改用PUT，實際上是對REST風格理解不透徹。 總體上，HTTP動詞分為兩類：冪等和非冪等。冪等是個數學概念，對於一元操作，如果它作用於任一元素兩次以上後所得的結果和第一次相同，就認為它是冪等的。簡單地說，如果一個接口，傳遞同樣的實參，多次請求的結果和一次沒有不同，就認為它是安全的、冪等的，反之，就是不安全、非冪等的。 GET、DELETE、PUT、HEAD是冪等操作，POST和PATCH是非冪等操作。因此，修改操作用POST還是PUT，要看操作本身的冪等與否。舉個例子，對於修改用戶描述的接口，調用任意次得到的結果都是相同的，所以它是冪等的，應該用PUT。而對於修改用戶登錄積分的操作，假設每次登錄加十分，重復調用會導致分數重復增加，這就是不安全、非冪等的，應該用POST。 資源地址的命名原則資源地址是對被操作資源位置的描述，因此應該有以下幾個原則： 全部使用名詞 不使用駝峰風格 資源名稱統一使用複數 對於前兩個，因為對資源的操作已由HTTP動詞表述，資源地址里不應該存在動詞，否則會造成語義的混亂。此外，不存在動詞也就不需要使用駝峰風格。例如，GET /api/v1/getUser/89，「get」在語義上就重復了。 關於資源名稱用複數的原則，主要是為了API在風格上的統一，同一種資源用同一個單詞表示，單、複數用資源的id表示，URI里有id的就是單數，否則是複數。 結論REST是風格而不是技術，出bug的可能性不大，並不是能實現業務邏輯、沒有bug就是好代碼。風格錯了，連REST都不算。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"}]},{"title":"Postman的Pre-request Script和Tests","slug":"pre-request-script-and-tests-in-postman","date":"2017-04-19T09:05:55.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/pre-request-script-and-tests-in-postman/","link":"","permalink":"http://0x3f.org/post/pre-request-script-and-tests-in-postman/","excerpt":"","text":"Pre-request Script和Tests都是Javascript代碼塊。前者在請求發起前執行，通常用來生成請求數據，例如對用戶註冊接口隨機生成用戶名。後者在請求結束後執行，通常用來測試和處理返回值。 以下是隨機生成用戶名的Pre-request Script：1postman.setEnvironmentVariable(\"random_username\", \"測試用戶\" + Math.floor(Math.random()*1000000)); 產生的值存儲在環境變量里，表單里直接引用環境變量即可。 對於REST接口普遍使用的JWT，可以在登錄接口的Tests里直接把返回的token更新到環境變量里，這樣其它接口直接引用這個環境變量即可：1234var data = JSON.parse(responseBody);tests[\"token is returned\"] = typeof(data.token) == \"string\" &amp;&amp; data.token.length &gt; 0postman.setEnvironmentVariable(\"token\", data.token);","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"測試","slug":"測試","permalink":"http://0x3f.org/tags/測試/"}]},{"title":"用Raspberry Pi實現音頻Airplay","slug":"implement-airplay-with-raspberry-pi","date":"2017-04-17T02:19:51.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/implement-airplay-with-raspberry-pi/","link":"","permalink":"http://0x3f.org/post/implement-airplay-with-raspberry-pi/","excerpt":"","text":"用樹莓派做音頻airplay效果不錯，老書架音箱又可以用起來了。 實現方式是shairplay-sync，利用HDMI轉VGA線上的3.5mm音頻輸出孔，因為我的樹莓派2B的3.5mm音視頻輸出口沒有合適的轉接頭。 我用的是Arch Linux ARM，需要手動開啓HDMI輸出。修改/boot/config.txt： 1234hdmi_force_hotplug=1hdmi_drive=2config_hdmi_boost=4dtparam=audio=on 重啓後，用alsamixer把樹莓派音量調整到最大值。 AUR里沒有針對ARM的shairplay-sync，需要手動編譯： 1git clone https://github.com/mikebrady/shairport-sync.git 12# 生成configureautoreconf -i -f 123456# 針對systemd編譯./configure --sysconfdir=/etc --with-alsa --with-avahi --with-ssl=openssl --with-metadata --with-soxr --with-systemd# END 12345678# 如果shairport-sync用戶不存在，新增用戶和用戶組getent group shairport-sync &amp;&gt;/dev/null || sudo groupadd -r shairport-sync &gt;/dev/nullgetent passwd shairport-sync &amp;&gt; /dev/null || sudo useradd -r -M -g shairport-sync -s /usr/bin/nologin -G audio shairport-sync &gt;/dev/null# END airplay默認的服務名和樹莓派的hostname一致，可以到/etc/shairport-sync.conf里修改： 123general = &#123; name = &quot;pi&quot;;&#125; FAQALSA lib confmisc.c:767:(parse_card) cannot find card ‘0’樹莓派沒聲音，嘗試用mpg123播放mp3時報這個錯。解決辦法是在/boot/config.txt里增加dtparam=audio=on。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"樹莓派","slug":"樹莓派","permalink":"http://0x3f.org/tags/樹莓派/"}]},{"title":"編寫接口文檔的最佳實踐","slug":"the-best-practice-of-writing-api-documents","date":"2017-04-10T08:36:27.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-best-practice-of-writing-api-documents/","link":"","permalink":"http://0x3f.org/post/the-best-practice-of-writing-api-documents/","excerpt":"","text":"前言傳統的做法是用office寫接口文檔，這種方式的缺點很多： 格式混亂事實上，所有的傳統富文本文檔都存在這個問題，富文本的跨平台兼容性很差，很容易造成格式錯亂。 版本管理困難依賴文件系統管理文檔是很落後的做法，很難保證手頭的文檔是最新的版本。 兼容性差不是所有人都用windows。 低效對效率的負面影響很大程度上已經包含在前面幾項里。此外，編輯工具的臃腫、編輯內容的同時還要調整樣式、缺少全文檢索等，也是導致效率下降的原因。 理想情況理想的接口文檔應該有以下特徵： 方便創作文檔編輯最重要的是文檔的內容，而不是編輯操作本身。所以編寫文檔的過程應該是簡單快捷的，而且最好不需要額外的學習成本。 排版簡潔規範技術文檔的排版，簡潔規範是最重要的，花哨的排版會降低效率。 方便查閱應該有目錄或者大綱視圖，並且可以方便地全文檢索。 在線協作傳統的離線文檔不方便協作。 多端兼容允許在大多數常見平台編輯和使用文檔。 版本管理可以查看什麼人在什麼時間改了哪些內容。 交互式文檔所見即所得。可以修改參數、發送請求並查看接口返回值。 可訂閱可以給接口打標籤。用戶可以訂閱任意標籤下的接口變更，也可以針對接口訂閱。 自動生成如果代碼的可讀性足夠好，何必浪費時間寫文檔？或者至少可以自動生成。 當前實踐理想很豐滿，但是目前還沒有能滿足以上所有需求的解決方案。權衡之下，markdown和wiki是目前比較合適的方案。 markdown用markdown寫文檔有以下特點： 適合單文檔形式 主流git托管平台都支持 適合個人創作 適合小型項目、需要移交開發成果的項目 下面是用markdown寫的接口文檔的例子： 主流markdown編輯器在轉換過程中會為標題添加錨點，利用這個特性可以實現從接口列表跳轉到接口詳情。 最佳工具Cmd Markdown 美觀 跨平台 編輯操作支持Vim模式 wiki用wiki寫文檔有這些特點： 方便多層級文檔 需要自己搭建平台 適合團隊創作 適合長期、大型項目 最佳工具dokuwiki 剛剛好 結論綜上，小型的、托管在主流git平台的項目適合用markdown，公司級項目用wiki更好。但這還達不到理想的標準，需要繼續探索更好的解決方案。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"wiki","slug":"wiki","permalink":"http://0x3f.org/tags/wiki/"},{"name":"markdown","slug":"markdown","permalink":"http://0x3f.org/tags/markdown/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"一次對Workflow不完全成功的抓包過程","slug":"a-failed-attempt-to-capture-workflow-requests","date":"2017-04-04T12:19:52.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/a-failed-attempt-to-capture-workflow-requests/","link":"","permalink":"http://0x3f.org/post/a-failed-attempt-to-capture-workflow-requests/","excerpt":"","text":"一個workflow對https鏈接的請求總是失敗，而同樣的接口在postman里是成功的。所以想對比一下兩個請求的差異。 嘗試了兩種抓包方式，都不成功。一種是用中間人攻擊的原理，用的是mitmproxy，類似的還有charles、fiddler等。另一種是從網卡直接抓取，用的是wireshark。 第一種情況，雖然在iOS里安裝並信任了mitmproxy的偽證書、safari里也是可以正常訪問https鏈接的，但在workflow里仍然不認。 第二種情況，wireshark支持兩種解密TLS包的方式：一是使用https服務的私鑰，二是用瀏覽器輸出的「SSLKEYLOGFILE」。這裡需要用第二種。但是這種方式只對本機發送的請求有效，而且在實際操作中還發現有時候本機也解密不了。 最後只能採用臨時方案，把https鏈接改成http，然後用mitmproxy抓取，雖然請求是失敗的，但是可以拿到請求本身的數據。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"},{"name":"網絡","slug":"網絡","permalink":"http://0x3f.org/tags/網絡/"}]},{"title":"玉淵潭的櫻花","slug":"sakura-in-yuyuantan-park","date":"2017-04-04T02:23:43.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/sakura-in-yuyuantan-park/","link":"","permalink":"http://0x3f.org/post/sakura-in-yuyuantan-park/","excerpt":"","text":"終於還是去了。 十年，不喜鬧市，或宅，或遠方。 期望本不高，故無驚亦無喜。 有一小片集中的地方還是不錯的，風來，落英繽紛。","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"旅行","slug":"旅行","permalink":"http://0x3f.org/tags/旅行/"},{"name":"圖片","slug":"圖片","permalink":"http://0x3f.org/tags/圖片/"}]},{"title":"迄今最好的發送網頁到Kindle的workflow","slug":"send-to-kindle-with-workflow","date":"2017-03-30T03:12:02.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/send-to-kindle-with-workflow/","link":"","permalink":"http://0x3f.org/post/send-to-kindle-with-workflow/","excerpt":"","text":"轉換成PDF和fivefilters都不完美，send.reabble.com是迄今最好的解決方案，所以寫了這個workflow： Send to Kindle 注意： 參照reabble的說明做相關配置 用kindle接收郵箱創建一個聯繫人，並在workflow里選擇他","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://0x3f.org/tags/效率/"},{"name":"iOS","slug":"ios","permalink":"http://0x3f.org/tags/ios/"},{"name":"workflow","slug":"workflow","permalink":"http://0x3f.org/tags/workflow/"}]},{"title":"Shadowrocket下優酷無法播放的解決辦法","slug":"how-to-play-youku-under-shadowrocket","date":"2017-03-25T16:03:10.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-play-youku-under-shadowrocket/","link":"","permalink":"http://0x3f.org/post/how-to-play-youku-under-shadowrocket/","excerpt":"","text":"導入這里提供的配置文件。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://0x3f.org/tags/shadowsocks/"},{"name":"翻牆","slug":"翻牆","permalink":"http://0x3f.org/tags/翻牆/"},{"name":"iOS","slug":"ios","permalink":"http://0x3f.org/tags/ios/"}]},{"title":"自動探測RSS地址的workflow","slug":"find-rss-with-workflow","date":"2017-03-24T13:09:13.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/find-rss-with-workflow/","link":"","permalink":"http://0x3f.org/post/find-rss-with-workflow/","excerpt":"","text":"RSS真是沒落了，很多網站都沒有明確輸出Feed地址，每次想訂閱都要浪費不少時間，所以寫了這個Workflow。 列出頁面中所有的Feed地址，點擊後複製到剪貼板 如果頁面中的Feed地址是相對地址，自動轉換為絕對地址 如果頁面中沒有Feed地址，列出常見的幾種地址，並偵測被點選的地址，偵測成功後自動複製到剪貼板","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://0x3f.org/tags/效率/"},{"name":"iOS","slug":"ios","permalink":"http://0x3f.org/tags/ios/"},{"name":"workflow","slug":"workflow","permalink":"http://0x3f.org/tags/workflow/"}]},{"title":"用Keyboard Maestro自動登錄MAS","slug":"auto-login-mas-with-keyboard-maestro","date":"2017-03-21T14:51:32.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/auto-login-mas-with-keyboard-maestro/","link":"","permalink":"http://0x3f.org/post/auto-login-mas-with-keyboard-maestro/","excerpt":"","text":"","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"},{"name":"效率","slug":"效率","permalink":"http://0x3f.org/tags/效率/"}]},{"title":"MacOS中切換輸入法的最佳實踐","slug":"the-best-practice-of-switching-input-methods-in-macos","date":"2017-03-20T06:25:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-best-practice-of-switching-input-methods-in-macos/","link":"","permalink":"http://0x3f.org/post/the-best-practice-of-switching-input-methods-in-macos/","excerpt":"","text":"原則： 一鍵切換 可以對特定應用設定初始輸入狀態 可以方便地確認當前輸入狀態 兼容外接鍵盤 思路： 用Karabiner Elements把右Shift修改成F19，在系統里設置用F19切換輸入法 用isHUD顯示輸入法狀態 用Keyboard Maestro自動切換鍵盤佈局 Karabiner Elements會使系統的鍵盤佈局失效，且不能對不同的鍵盤使用不同的佈局，所以只有用Keyboard Maestro自動切換。 isHUD只在切換輸入法時有效，理想情況是用Caps Lock鍵燈表示輸入狀態，不過目前沒找到可用的解決辦法。 鼠須管可以對不同的應用設置初始輸入狀態，但只是在切換輸入法後，例如對於Alfred，如果上次鼠須管處於中文輸入狀態，再次打開輸入框的時候不會變成英文狀態，因此需要在Alfred中設置初始輸入法為英文。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"}]},{"title":"MacOS下自動切換Karabiner Elements配置","slug":"auto-switch-keyboard-layouts-in-macos","date":"2017-03-20T05:14:18.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/auto-switch-keyboard-layouts-in-macos/","link":"","permalink":"http://0x3f.org/post/auto-switch-keyboard-layouts-in-macos/","excerpt":"","text":"Karabiner Elements不支持對不同的鍵盤自動使用不同的配置，所以本文通過監聽USB鍵盤插拔事件實現自動切換。 依賴： Keyboard Maestro php 腳本Karabiner Elements會監聽配置文件~/.config/karabiner/karabiner.json，如果有變動，會自動重新加載。 切換配置的腳本在這里。 Keyboard Maestro鍵盤插入事件： 鍵盤拔出事件：","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"}]},{"title":"嘗新，明前碧螺春","slug":"try-biluochun-2017","date":"2017-03-19T10:19:40.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/try-biluochun-2017/","link":"","permalink":"http://0x3f.org/post/try-biluochun-2017/","excerpt":"","text":"近年明前都要試一種新茶，今年是碧螺春。 不覺得有什麼特別的地方，就是不耐泡。","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"茶","slug":"茶","permalink":"http://0x3f.org/tags/茶/"}]},{"title":"一碗酸湯面","slug":"noodles-in-acid-soup","date":"2017-03-19T10:12:36.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/noodles-in-acid-soup/","link":"","permalink":"http://0x3f.org/post/noodles-in-acid-soup/","excerpt":"","text":"繼續清淡。 依賴： 掛面 小蔥 香油、鹽、陳醋、生抽 實現： 小蔥切丁，碗里放醋、生抽、鹽 水燒開，下面，點一次水 撈面，澆湯","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"私房菜","slug":"私房菜","permalink":"http://0x3f.org/tags/私房菜/"}]},{"title":"沙發椅，讓閱讀更有趣","slug":"my-new-sofa-chair","date":"2017-03-18T14:48:35.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/my-new-sofa-chair/","link":"","permalink":"http://0x3f.org/post/my-new-sofa-chair/","excerpt":"","text":"心水沙發椅很久了，終於拔草。 因為喜歡極簡，之前一直用著一張雙人小沙發，但是不夠舒適，也不便移動。後來坐過一間餐廳的沙發椅感覺包覆感很好，就想著換一下，於是出掉了沙發，準備入一把伊姆斯椅，偶然看到現在這把，瞬間慶幸沒有草率地買前者。 在陽台上閱讀變得更有趣了，這椅子和小抱枕很搭（不是照片中這個）。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"家居","slug":"家居","permalink":"http://0x3f.org/tags/家居/"},{"name":"傢具","slug":"傢具","permalink":"http://0x3f.org/tags/傢具/"}]},{"title":"一碗陽春面","slug":"noodles-in-a-simple-sauce","date":"2017-03-18T12:49:07.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/noodles-in-a-simple-sauce/","link":"","permalink":"http://0x3f.org/post/noodles-in-a-simple-sauce/","excerpt":"","text":"想吃點清淡的。 依賴： 掛面 小蔥 香油、鹽 實現： 小蔥切丁 水燒開，下面，點一次水 撈面瀝水，撒蔥花、鹽，澆開水","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"私房菜","slug":"私房菜","permalink":"http://0x3f.org/tags/私房菜/"}]},{"title":"乾鍋土豆片","slug":"new-dish-dry-pot-potato","date":"2017-03-16T03:11:59.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/new-dish-dry-pot-potato/","link":"","permalink":"http://0x3f.org/post/new-dish-dry-pot-potato/","excerpt":"","text":"沒有平底鍋和夾子是硬傷啊。 依賴： 土豆 黃豆醬、乾辣椒、花椒、姜、蒜、油 實現： 土豆切片，乾辣椒掰兩半，姜切絲，蒜切塊 土豆片放沸水30秒，煎黃取出 放油、黃豆醬、乾辣椒、花椒、姜、蒜，炒香 放土豆片，翻炒，太乾的話放一點水","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"私房菜","slug":"私房菜","permalink":"http://0x3f.org/tags/私房菜/"}]},{"title":"鼠須管實現簡繁轉換的方法","slug":"switch-cn-tw-in-rime","date":"2017-03-11T15:42:11.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/switch-cn-tw-in-rime/","link":"","permalink":"http://0x3f.org/post/switch-cn-tw-in-rime/","excerpt":"","text":"鼠須管默認輸出繁體，可以通過自帶的過濾器轉換成簡體。這樣做是科學的，因為繁體的異體字較多，從簡轉繁容易轉錯。 對於只有簡體的碼表，可以轉換成繁體，再通過過濾器轉簡體，但是會導致在簡體狀態下無法自造詞。所以最好的辦法是給繁體單獨配一個碼表。 步驟為： 複製簡體碼表的schema.yaml和dict.yaml文件 修改兩個yaml文件的名稱 文件內容中和文件名對應的內容也都改為和新文件名一致 修改schema.yaml中輸入法的名稱，使之和簡體碼表區分開 轉換dict.yaml中的內容到繁體 重新部署 如果需要給繁體碼表增加臨時輸出簡體的功能，方法如下： 1234567891011121314# 在碼表的schema.yaml中# switches下增加 - name: simplification states: [ 漢字, 漢字 ]# engine下增加 filters: - simplifier - uniquifier#key_binder下增加 - &#123; when: always, accept: Control+Shift+4, toggle: simplification &#125; - &#123; when: always, accept: Control+Shift+dollar, toggle: simplification &#125;","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"輸入法","slug":"輸入法","permalink":"http://0x3f.org/tags/輸入法/"},{"name":"mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"}]},{"title":"乾鍋菜花","slug":"dry-pot-cauliflower","date":"2017-03-08T12:55:54.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/dry-pot-cauliflower/","link":"","permalink":"http://0x3f.org/post/dry-pot-cauliflower/","excerpt":"","text":"去年學的。 依賴： 菜花 姜、乾辣椒、花椒 黃豆醬、生抽、料酒、油 實現： 菜花泡鹽水 放油、姜、花椒、乾辣椒、豆瓣醬，炒香 放菜花，翻炒入味 放生抽、料酒","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"私房菜","slug":"私房菜","permalink":"http://0x3f.org/tags/私房菜/"}]},{"title":"胡蘿卜炒杏鮑菇","slug":"new-dish-mushroom-carrot-pepper","date":"2017-03-07T13:10:05.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/new-dish-mushroom-carrot-pepper/","link":"","permalink":"http://0x3f.org/post/new-dish-mushroom-carrot-pepper/","excerpt":"","text":"去年學的，今天忘買蒜了，也挺好吃的。 依賴： 杏鮑菇 胡蘿卜 青椒 姜、蒜、黑胡椒粉、澱粉、生抽、鹽、油 實現： 杏鮑菇、胡蘿卜、蒜切片，青椒、姜切絲，澱粉勾芡 放油、蒜、姜，油熱後放胡蘿卜，炒至半熟 放杏鮑菇，炒軟 芡汁入鍋，放黑胡椒粉、生抽、鹽 放青椒 炒至色澤出現、湯汁量合適出鍋","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"私房菜","slug":"私房菜","permalink":"http://0x3f.org/tags/私房菜/"}]},{"title":"加速Homebrew","slug":"speed-up-homebew","date":"2017-03-06T15:14:02.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/speed-up-homebew/","link":"","permalink":"http://0x3f.org/post/speed-up-homebew/","excerpt":"","text":"兩個方法：走代理和使用國內鏡像。鏡像有同步時間差，而且遇到國外資源還是慢。 homebrew用curl下載，用proxychains和環境變量http_proxy都沒用，需要在~/.curlrc里配置： 1socks5 = &quot;127.0.0.1:1080&quot;","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"},{"name":"homebrew","slug":"homebrew","permalink":"http://0x3f.org/tags/homebrew/"}]},{"title":"CORS：另一種前端跨域請求方式","slug":"cors","date":"2017-02-27T09:07:17.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/cors/","link":"","permalink":"http://0x3f.org/post/cors/","excerpt":"","text":"CORS的全稱是「Cross-Origin Resource Sharing」，即跨域資源共享。 CORS是比JSONP更強大的前端跨域請求的實現方式。JSONP只支持GET請求，而CORS支持更多種類。JSONP的優勢是支持老版本的瀏覽器。 實現CORS需要瀏覽器和服務器同時支持，主流框架有實現CORS的中間件，如：laravel-cors。 具體參考：http://www.ruanyifeng.com/blog/2016/04/cors.html","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"},{"name":"前端","slug":"前端","permalink":"http://0x3f.org/tags/前端/"}]},{"title":"怎樣在Vim中刪除引號文本對象","slug":"how-to-delete-quoted-text-object-in-vim","date":"2017-02-25T11:33:18.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-delete-quoted-text-object-in-vim/","link":"","permalink":"http://0x3f.org/post/how-to-delete-quoted-text-object-in-vim/","excerpt":"","text":"假設有這樣一段代碼（光標在「|」位置）： $title = “Article:|” . $realTitle; 要刪除引號及其內容，並進入插入模式準備輸入其它內容。 如果執行ca&quot;，會得到如下的結果： $title = |. $realTitle; 連引號旁邊的空格也刪除了。 如果不想刪除空格，可以用c2i&quot;。 參考：Is it possible to exclude surrounding whitespace from the word-object a&quot;?","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"技術團隊的兩個最佳實踐","slug":"the-best-practices-of-developing","date":"2017-02-24T05:27:57.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-best-practices-of-developing/","link":"","permalink":"http://0x3f.org/post/the-best-practices-of-developing/","excerpt":"","text":"在以往的開發和管理中遇到很多問題，以至於我對理想中的技術團隊有了一些想法。其中有兩點經過實踐證明有很強的可操作性，值得拿出來討論一下： 能用規則解決的問題就不要靠人解決 能用機器完成的任務就不要用人處理 這兩點都反映了我的一個妄念，就是相信規則和機器，不相信人。人是最不靠譜的生產者，你永遠無法保證團隊中的每個人都處於很好的狀態、擁有相近的技術水平和情商，這也是為什麼我不覺得結對編程有什麼可操作性。但如果有簡單可行的規則，用來規範開發過程中的行為，那麼解決開發過程中的衝突就不需要人為地和稀泥，生產效率也會得到提升。此外，機器最適合用來做重復性的任務，很多花大量的人力、物力、時間都沒做得很好的事，交給機器來做恰恰是最好的解決辦法。 這些以往都只是我自己的想法，雖然在團隊裡有過很好的實踐效果，但是並不指望和別人有所共鳴。國內的技術團隊大多靠堆人、堆時間，很少有團隊會把健康的世界觀和可操作的方法論放在重要的位置，技術和技術從業者都是芻狗。當然這也無可厚非，畢竟先要解決生存問題，在模式創新為主的國內互聯網行業，更新換代如此之快，產品早一天上線就多一分生存的可能。但是有沒有可能既解決生存問題，又做出一個有榮譽感的團隊呢？世間安得雙全法，這是個值得持續討論的問題。 最近和別人聊天，竟然聽到相同的想法，在具體的方法論上還得到很多補充。 對於第一點。一個項目按業務線劃分開發組、按功能模塊劃分開發任務本來是個很好的模式，但是接口的對接往往會有很多問題，例如術語使用的不嚴謹導致高昂的溝通成本、問題處理方法的不規範導致扯皮、衝突和低效。 在我的團隊裡，用wiki維護著一套術語詞典，開發過程中所有的文檔、溝通都必須使用既定的用語，例如「退單」包括「退款單」和「退貨單」，這三個術語分別表示不同而精確的概念，如果因為自己造詞產生歧義或錯用術語導致開發事故，責任是清楚的，問責對象也沒有怨言。讓有責任的人承擔責任，比和稀泥對解決問題更有利。 再比如，問題在流轉過程中很容易出現接口人之間的扯皮甚至衝突，問題的根源並不是別人說你的代碼有問題導致你不爽，而是別人做得不夠專業讓你覺得對方不負責任。在我的團隊裡，大家約定處理問題的規則是： 誰接手，誰處理 轉交問題時必須提供四項信息：復現問題的環境、完整的接口名、傳遞的實參和返回結果 首先當一個問題被反饋過來的時候，分配人會有一個初步的判斷，指派給誰，誰處理，不能踢皮球。處理人如果界定問題發生在別人的接口裡，應該把上述四項信息連同問題移交給相關責任人。這樣做的好處是，一來可以避免誤判給別人造成不必要的麻煩，二來讓下游接口人可以馬上復現並解決問題，而無須考慮上游的業務邏輯。這個規則的效果很好，團隊裡從來沒有因為接口問題出現不愉快。 對於第二點。代碼質量是日常開發中最讓人頭疼的問題之一，出現頻率高而且代價昂貴。不管是靠開發人員的經驗，還是測試人員的工作，都對人的依賴很大，既不穩定又低效。以下這些方法能很好地解決這樣的問題： 使用Git，先進的生產關係需要更好的生產資料才能帶來更高的生產力 提交代碼時自動檢查語法錯誤和代碼規範 高覆蓋率、自動化的單元測試 用模擬工具給單元測試供給測試數據 用腳本測試網頁交互 用腳本給網頁截圖，用圖片diff工具比較某次修改給網頁帶來的變化","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"}]},{"title":"Git的衍合","slug":"git-rebase","date":"2017-02-22T10:44:37.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/git-rebase/","link":"","permalink":"http://0x3f.org/post/git-rebase/","excerpt":"","text":"合併分支有兩種方式，merge和rebase。merge是根據三方合併的差異，創建一個新的提交。rebase是將上游分支的各個提交在比較差異後在下游分支上重演一遍。 rebase適合對沒有推送到遠程的提交對象做合併，這樣可以保持一個整潔的提交歷史。若對已推送的提交對象使用rebase，可能導致其它已經拉取並創建了新的提交的人不得不重新合併，進而導致提交歷史變得很混亂。 基本的rebase： 123git rebase master unstablegit checkout mastergit merge unstable 複雜的情況：存在三個分支，unstable基於master的某個提交創建，feature基於unstable的某個提交創建，要把feature合併到master而不合併unstable。更多分支時方法也一樣。 123git rebase --onto master unstable featuregit checkout mastergit merge feature rebase過程中如果存在衝突，合併後用git add標記已解決，再用git rebase --continue繼續。如果解決衝突後仍然不能繼續，可能是當前補丁的內容在下游分支已存在，可以用git rebase --skip跳過。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"},{"name":"git","slug":"git","permalink":"http://0x3f.org/tags/git/"}]},{"title":"在Vim中格式化Javascript、HTML和CSS","slug":"vim-js-beautify","date":"2017-02-21T06:58:08.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/vim-js-beautify/","link":"","permalink":"http://0x3f.org/post/vim-js-beautify/","excerpt":"","text":"依賴 vim-jsbeautify js-beautify js-beautify的安裝： 123npm -g install js-beautify# 或pip install jsbeautifier 配置快捷鍵1234vmap &lt;leader&gt;jsb :'&lt;,'&gt;!js-beautify -i&lt;CR&gt;autocmd FileType javascript noremap &lt;buffer&gt; &lt;leader&gt;jsb :call JsBeautify()&lt;CR&gt;autocmd FileType html noremap &lt;buffer&gt; &lt;leader&gt;htmlb :call HtmlBeautify()&lt;CR&gt;autocmd FileType css noremap &lt;buffer&gt; &lt;leader&gt;cssb :call CSSBeautify()&lt;CR&gt;","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"html","slug":"html","permalink":"http://0x3f.org/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"http://0x3f.org/tags/javascript/"},{"name":"css","slug":"css","permalink":"http://0x3f.org/tags/css/"}]},{"title":"Vim搜索的最佳實踐","slug":"the-best-practice-of-searching-in-vim","date":"2017-02-19T12:37:18.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-best-practice-of-searching-in-vim/","link":"","permalink":"http://0x3f.org/post/the-best-practice-of-searching-in-vim/","excerpt":"","text":"目标 使用PCRE正则表达式在当前目录下递归搜索 将选定内容自动转换成正则表达式 有较高的搜索速度 依賴 Ferret：實現用PCRE正則表達式遞歸搜索 The Silver Searcher：搜索速度快 配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859\" 在当前缓冲区中查找與替換nmap &lt;leader&gt;ff yiw/\\&lt;&lt;C-R&gt;\"\\&gt;\\Cvmap &lt;leader&gt;ff y/&lt;C-R&gt;=XEscapeRegex(@\")&lt;CR&gt;\\Cnmap &lt;leader&gt;rr yiw:%s/\\&lt;&lt;C-R&gt;\"\\&gt;\\C//g&lt;LEFT&gt;&lt;LEFT&gt;vmap &lt;leader&gt;rr y:%s/&lt;C-R&gt;=XEscapeRegex(@\")&lt;CR&gt;\\C//g&lt;LEFT&gt;&lt;LEFT&gt;nmap &lt;leader&gt;rl yiw:s/\\&lt;&lt;C-R&gt;\"\\&gt;\\C//g&lt;LEFT&gt;&lt;LEFT&gt;vmap &lt;leader&gt;rl y:s/&lt;C-R&gt;=XEscapeRegex(@\")&lt;CR&gt;\\C//g&lt;LEFT&gt;&lt;LEFT&gt;\" 在当前目录下递归搜索和替换let g:FerretExecutable='ag'nmap &lt;leader&gt;ak &lt;Plug&gt;(FerretAck)nmap &lt;leader&gt;lak &lt;Plug&gt;(FerretLack)nmap &lt;leader&gt;aw &lt;Plug&gt;(FerretAckWord)nmap &lt;leader&gt;as &lt;Plug&gt;(FerretAcks)vmap &lt;leader&gt;ak y:Ack &lt;C-R&gt;=XEscapeRegex(@\", 2)&lt;CR&gt;vmap &lt;leader&gt;lak y:Lack &lt;C-R&gt;=XEscapeRegex(@\", 2)&lt;CR&gt;nnoremap &lt;leader&gt;a :set operatorfunc=GrepOperator&lt;CR&gt;g@vnoremap &lt;leader&gt;a :&lt;c-u&gt;call GrepOperator(visualmode())&lt;CR&gt;function! GrepOperator(type)\"&#123;&#123;&#123; if a:type ==# 'v' normal! `&lt;v`&gt;y elseif a:type ==# 'char' normal! `[v`]y else return endif exec \"Ack \".XEscapeRegex(@@, 2) \" exec \"Grep \".XEscapeRegex(@@, 2)endfunction\"&#125;&#125;&#125;\" 转义正则表达式特殊字符，以便在正则表达式中使用\" a:1 是否转义为vimgrep的pattern格式，1，2\" a:2 是否用shellescape()转义，1是转义，2是转义并去掉两侧单引号function! XEscapeRegex(str, ...)\"&#123;&#123;&#123; let pattern = a:str let pattern = escape(pattern, '/\\.*$^~[]\"') if a:0 &amp;&amp; a:1 let pattern = escape(pattern, '()+?') if a:1 == 2 let pattern = escape(pattern, '\\') endif endif if a:0 &gt; 1 &amp;&amp; a:2 let pattern = shellescape(pattern) if a:2 == 2 let pattern = pattern[1:-2] endif endif let whitespacePattern = a:0 &amp;&amp; a:1 ? '\\\\s\\+' : '\\\\s\\\\+' let pattern = substitute(pattern, '\\s\\+', whitespacePattern, 'g') return patternendfunction\"&#125;&#125;&#125; FerretFerret是我用過的vim搜索擴展里最接近理想的一個，最大的優點是不用引號包裹搜索內容，且較大程度地支持PCRE正則表達式。 EasyGrep的缺點是正則表達式必須是shellescape()過的，手寫不方便，也不直觀。Ferret在底層做了shellescape()，所以比EasyGrep簡單一些。不過Ferret對反斜槓的處理仍然不直觀，例如搜索App\\Link，正則表達式是App\\\\Link，而Ferret里只能用App\\\\\\\\Link。原因是從輸入到執行，存在著三層轉義：Vim命令行、Shell、grep/ag。所以對於EasyGrep，要搜索一個\\，必須輸入\\\\\\\\\\\\\\\\。對於Ferret，由於底層做了shellescape()，只需要兩層轉義，即\\\\\\\\。當然這樣也不方便，所以我用自定義函數XEscapeRegex()對選擇的內容做這個事，不過最完美的方法當然是Ferret自己支持，或者自己再封裝一下Ferret的命令，這樣輸入的正則表達式可讀性就正常了。 The Silver Searcherag是我用過的搜索工具里對速度和功能兼顧得最好的。 搜索運算符GrepOperator是從Learn Vimscript the Hard Way里扒出來的，可以實現自動搜索指定範圍的內容： &lt;leader&gt;aiw：搜索光標下的詞 &lt;leader&gt;a$：搜索從光標到行末的內容 &lt;leader&gt;at;：搜索從光標到下一個分號的內容 轉換選定內容到正則表達式XEscapeRegex()根據參數轉換字符串到不同格式的正則表達式。主要用途為轉換成給搜索當前緩衝區的Vim格式的正則，或給Ferret使用的PCRE格式。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"Bose QC35，這安靜有毒","slug":"the-experience-of-bose-qc35","date":"2017-02-18T12:23:28.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-experience-of-bose-qc35/","link":"","permalink":"http://0x3f.org/post/the-experience-of-bose-qc35/","excerpt":"","text":"我很容易受環境影響，即便在家裡比較安靜的時候，也經常集中不了注意力。小時候總是可以連續幾個小時讀一本書，現在已經很久沒有長時間專心做一件事了。戴了一段時間QC35，又重新找回了這種感覺，幹什麼事都很專心，感覺很安靜，心態平和很多。 之前先入手了森海大饅頭，不過沒有降噪的功能，所以必須一直配合白噪聲使用，時間長了還是有點累的。另外，有線耳機實在不方便，所有的數碼設備都應該無線化，對生活品質的提升會很大。雖然大饅頭作為出街向的東西，手機也推得動，但是要發揮音質，還是得上耳放，我不是發燒友，這木耳就算了。 所以對QC35長草很久了，後來大法又出了MDR 1000X，作為對標QC35的東西，有這些優點： 獨立的降噪開關 手勢操作 快速反應模式 音質 QC35的優勢： 穿戴更舒適 同時連接兩個設備 關於耳機，我的核心需求是： 降噪效果好 無線 舒適 在滿足核心需求的基礎上，選擇有價格優勢的東西。1000X肯定更方便，不過沒有這些功能好像問題也不大。而且有些噱頭的實際體驗究竟有多好，我是有疑問的，比如手勢的誤操作問題。在我看來，為這些噱頭買單不值，所以最後選了QC35。 使用一段時間下來體驗確實很好，已經對這久違的安靜上癮了，長時間戴也沒有不適感，同時連接電腦和手機也很方便。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"數碼","slug":"數碼","permalink":"http://0x3f.org/tags/數碼/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"耳機","slug":"耳機","permalink":"http://0x3f.org/tags/耳機/"}]},{"title":"Postman: Could Not Get Any Response","slug":"postman-could-not-get-any-response","date":"2017-02-14T06:37:54.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/postman-could-not-get-any-response/","link":"","permalink":"http://0x3f.org/post/postman-could-not-get-any-response/","excerpt":"","text":"Postman如果不顯示API返回結果，而是報錯： Could not get any response 有一種原因是響應的header存在錯誤： 圖中以雙引號開頭的第一行是有問題的。 PS：httpie是個好東西。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"restful","slug":"restful","permalink":"http://0x3f.org/tags/restful/"}]},{"title":"用NGINX實現WSS","slug":"implement-wss-with-nginx","date":"2017-02-14T05:35:41.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/implement-wss-with-nginx/","link":"","permalink":"http://0x3f.org/post/implement-wss-with-nginx/","excerpt":"","text":"實現基於SSL的安全的WebSocket。 NGINX配置12345678910111213141516171819202122server &#123; listen 4431; server_name ws.sample.com; ssl on; ssl_certificate ssl/server.crt; ssl_certificate_key ssl/server.key; ssl_session_timeout 5m; ssl_session_cache shared:SSL:50m; ssl_protocols SSLv3 SSLv2 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; location / &#123; proxy_pass http://127.0.0.1:4759; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; proxy_set_header X-Real-IP $remote_addr; proxy_read_timeout 60s; &#125;&#125; 常見問題連不上或連接時報錯 WebSocket network error: OSStatus Error -9807: Invalid certificate chain 如果使用的是自簽證書或者證書針對的域名和連接所指定的不符，會出這種問題。 wss一分鐘自動斷開NGINX里設置proxy_read_timeout或者程序實現心跳。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://0x3f.org/tags/nginx/"},{"name":"websocket","slug":"websocket","permalink":"http://0x3f.org/tags/websocket/"},{"name":"ssl","slug":"ssl","permalink":"http://0x3f.org/tags/ssl/"},{"name":"编程","slug":"编程","permalink":"http://0x3f.org/tags/编程/"}]},{"title":"WebSocket: Connection Header Value Must Contain Upgrade","slug":"websocket-connection-header-value-must-contain-upgrade","date":"2017-02-11T13:52:30.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/websocket-connection-header-value-must-contain-upgrade/","link":"","permalink":"http://0x3f.org/post/websocket-connection-header-value-must-contain-upgrade/","excerpt":"","text":"用NGINX反向代理實現WSS後，創建連接時報錯： Error during WebSocket handshake: ‘Connection’ header value must contain ‘Upgrade’ 根據官方文檔，NGINX從1.3.13開始才支持這個特性，所以解決方法是升級到最新版。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"websocket","slug":"websocket","permalink":"http://0x3f.org/tags/websocket/"}]},{"title":"Git Reset、Revert和Checkout的區別","slug":"differences-among-reset-checkout-revert-of-git","date":"2017-02-09T11:27:47.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/differences-among-reset-checkout-revert-of-git/","link":"","permalink":"http://0x3f.org/post/differences-among-reset-checkout-revert-of-git/","excerpt":"","text":"reset在提交層面，是將HEAD設定到指定的提交，通常用來捨棄最新的幾個提交。在文件層面，是將指定的提交中的該文件保存到暫存區，工作區中的文件不變。 reset有三個常用的參數：--mixed、--soft和--hard。 在提交層面，--mixed是默認值，影響暫存區，不影響工作區；--soft將HEAD版本保存到暫存區，並將HEAD設定到指定的提交，用來合併提交歷史；--hard既影響暫存區，也影響工作區。 在文件層面，--soft和--hard均會報錯，不支持這兩個選項。 在提交層面，執行過reset後如果需要撤銷，使用reflog命令查看之前HEAD的hash，通過reset --hard恢復到該版本。 checkout在提交層面，用來切換分支或檢出到指定的提交。對於後者，如果增加了新的提交，在切換到其它分支後，再切換回來時，這些提交將會丟失，如果希望保存這些提交，在切換到其它分支前，創建一個新的分支。 revert用來通過創建一個新的提交來回滾一個提交，因此，和reset不同，並不會改變提交的歷史。 對於回滾一次提交的場景，revert比reset安全，所以revert適用於公共分支，reset適用於私有分支。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"},{"name":"git","slug":"git","permalink":"http://0x3f.org/tags/git/"}]},{"title":"從Octopress遷移到Hexo","slug":"migrate-octopress-to-hexo","date":"2017-02-08T12:24:16.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/migrate-octopress-to-hexo/","link":"","permalink":"http://0x3f.org/post/migrate-octopress-to-hexo/","excerpt":"","text":"因為原來的主題沒有針對中文優化，顯示效果不太好，在搜索新主題的時候順便瞭解了一下其它幾個靜態博客生成工具，發現Hexo比Octopress有很大的優勢，就遷移了過來。 Hexo的優勢： 速度快：幾百篇文章只需要幾秒，而Octopress需要幾十秒 易用：配置、部署簡單，文章被修改後會立即更新瀏覽器中的預覽頁面 輕量：基於node.js，目錄結構簡明 遷移的過程不算順利，先是遇到「MODULE_NOT_FOUND」的問題，搜到的方法都不起作用，原因大概是因為牆的問題導致dtrace模塊安裝出錯，理論上用代理安裝是可以解決的，結果在反復安裝的過程中莫名其妙地就好了。 再一個問題是選主題，喜歡極簡的風格，但是極簡又大氣的主題很少，相對最喜歡的是kael，不過生成速度非常慢，而且生成的頁面有大量亂碼。於是退而求其次，選擇了crisp。然而還是有不滿意的地方，比如過於簡單、沒有搜索、不區分首頁和歸檔等，還有待自己修改。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"octopress","slug":"octopress","permalink":"http://0x3f.org/tags/octopress/"},{"name":"hexo","slug":"hexo","permalink":"http://0x3f.org/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://0x3f.org/tags/blog/"}]},{"title":"Calibre排版的最佳實踐","slug":"best-practices-of-calibre-on-formatting","date":"2017-01-27T10:15:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/best-practices-of-calibre-on-formatting/","link":"","permalink":"http://0x3f.org/post/best-practices-of-calibre-on-formatting/","excerpt":"","text":"雖然如今左Kindle、右iPad，但是再也沒有在課堂上用文曲星看《此間的少年》的感覺。 忘了前段時間看池建強還是和菜頭的文章，說很討厭中文排版中段落首行縮進的風格，深有同感。我一般在讀前會先用Calibre修改一下書的格式，段落首行不縮進、用空白行分割段落、嵌入好看的字體，否則強迫症表示根本看不下去。 本文分享幾則平時積累的Calibre排版的最佳實踐，順帶吐槽一下亞馬遜電子書的排版質量，早已經被微信讀書、多看這些APP吊打了。 一、最佳排版最小行高：140%。 使用空白行分段，段落首行不縮進。 要嵌入字體，必須轉換成KF8格式的類型，例如azw3或者both類型的mobi： 注意：KF8格式在點選文字時，默認選中一句，而不是單字，不方便查字典。要默認選中單字，須轉換成old類型的mobi。 二、最佳字體索尼楷書 方正北魏楷書 方正宋三 在微信讀書iOS上顯示效果很好，但是在Kindle里比較一般。 本文最早发布在公众号：两司马门下走狗","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"}]},{"title":"兩條分組的SQL語句","slug":"two-grouping-sql-statements","date":"2017-01-27T09:51:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/two-grouping-sql-statements/","link":"","permalink":"http://0x3f.org/post/two-grouping-sql-statements/","excerpt":"","text":"最近做訪問統計解決的兩個問題： 根據日期分組123456789101112131415161718select ( case when visit_at &gt;= 1485014400 then from_unixtime(visit_at, '%Y-%m-%d') when visit_at &gt;= 1484928000 and visit_at &lt; 1485014400 then from_unixtime(visit_at, '%Y-%m-%d') else 0 end ) col, count(*) as pv, count(distinct session_id) as uv from `statistics` where `visit_at` &gt;= 1484496000 group by ( case when visit_at &gt;= 1485014400 then from_unixtime(visit_at, '%Y-%m-%d') when visit_at &gt;= 1484928000 and visit_at &lt; 1485014400 then from_unixtime(visit_at, '%Y-%m-%d') else 0 end ) 選擇每組數據的第一條12345678910111213select a.session_id,a.created_at,a.province,a.referer,a.uri,a.ipv4, a.user_id,b.duration,b.num from statistics as a inner join ( select session_id, max(created_at) as latest_time, count(*) as num,sum(duration) as duration from statistics group by session_id ) as b on a.session_id=b.session_id and a.created_at=b.latest_time ORDER BY a.created_at desc","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"sql","slug":"sql","permalink":"http://0x3f.org/tags/sql/"}]},{"title":"用OpenResty自動轉換silk到MP3","slug":"convert-silk-to-mp3-with-openresty","date":"2017-01-25T10:59:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/convert-silk-to-mp3-with-openresty/","link":"","permalink":"http://0x3f.org/post/convert-silk-to-mp3-with-openresty/","excerpt":"","text":"PHP沒有原生的轉換silk格式音頻到mp3的方案，所以考慮用NGINX+Lua調用命令行工具實現。 思路當訪問以「.silk.mp3」為後綴的文件時，查找對應的mp3文件，存在則返回，否則，如果對應的silk文件存在，調用命令行工具轉換文件格式，然後內部重定向到新生成的mp3。 安裝 OpenResty silk-v3-decoder ffmpeg NGINX配置123location ~* /.*\\.silk\\.mp3$ &#123; content_by_lua_file \"/opt/script/silk2mp3.lua\";&#125; Lua腳本1234567891011121314151617181920212223242526function file_exists(name) local f=io.open(name,\"r\") if f~=nil then io.close(f) return true else return false endendlocal resource = ngx.var.request_filename;local realResource = resource:sub(1, #resource - 9)..\".mp3\";local realURI = ngx.var.uri:sub(1, #ngx.var.uri - 9)..\".mp3\";if file_exists(realResource) then return ngx.exec(realURI);endlocal silk = resource:sub(1, #resource - 4);if not file_exists(silk) then return ngx.exit(404);endos.execute(\"/bin/sh /opt/silk-v3-decoder/converter.sh \\\"\"..silk..\"\\\" mp3 &gt; /dev/null 2&gt;&amp;1\");if file_exists(realResource) then return ngx.exec(realURI);else return ngx.exit(404)end 遇到的問題OpenResty調用命令轉換失敗，而手工可以silk-v3-decoder的converter.sh把所有錯誤信息都屏蔽了，需要修改腳本查看。 實際情況是OpenResty的運行用戶沒有音頻文件所在目錄的權限。 編譯的ffmpeg轉換PCM到MP3時報錯silk-v3-decoder自己的decoder只是把silk轉換成PCM，然後調用ffmpeg轉換成mp3。系統中的ffmpeg是自己編譯的，在這一步報錯，大意是mp3的encoder不存在。 原因是ffmpeg編譯時默認不激活mp3編碼器（猜測）或者沒安裝libmp3lame-dev，需要安裝這個開發庫並給configure指定參數「–enable-libmp3lame」。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"openresty","slug":"openresty","permalink":"http://0x3f.org/tags/openresty/"},{"name":"nginx","slug":"nginx","permalink":"http://0x3f.org/tags/nginx/"},{"name":"lua","slug":"lua","permalink":"http://0x3f.org/tags/lua/"}]},{"title":"微軟識花和形色","slug":"two-plant-identification-apps","date":"2016-12-28T04:12:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/two-plant-identification-apps/","link":"","permalink":"http://0x3f.org/post/two-plant-identification-apps/","excerpt":"","text":"由於微軟的名氣，「微軟識花」剛推出的時候就眾所周知。很好用的App，我成功地用它識別出了母上的長春花： 不過我養的主要是觀葉植物，只能識別花對我來說意義不大。直到最近發現了「形色」。識別率還不錯，對特徵不明顯的植物容易誤報，比如我的空鳳就被識別成了吊蘭…… 這就是「微軟識花」狡猾的地方。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"app","slug":"app","permalink":"http://0x3f.org/tags/app/"}]},{"title":"小確幸，用Vim編輯當前命令行","slug":"edit-command-with-vim","date":"2016-12-26T03:58:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/edit-command-with-vim/","link":"","permalink":"http://0x3f.org/post/edit-command-with-vim/","excerpt":"","text":"修改很長的命令是件痛苦的事，在Linux下，可以通過快捷鍵Ctrl+X Ctrl+E調用$EDITOR快速編輯當前命令行的內容，保存退出後，結果會呈現在光標下。 不過在Mac OS的iTerm2下，似乎是因為Ctrl+X被佔用而不能生效。誤打誤撞地發現了另外一個方法，使用oh-my-zsh並且開啓了vi mode的話，先進入vi mode，然後輸入v，同樣可以實現這樣的功能。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"},{"name":"cli","slug":"cli","permalink":"http://0x3f.org/tags/cli/"}]},{"title":"用銳速加速Shadowsocks","slug":"accelerate-shadowsocks-with-serverspeeder","date":"2016-12-25T07:39:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/accelerate-shadowsocks-with-serverspeeder/","link":"","permalink":"http://0x3f.org/post/accelerate-shadowsocks-with-serverspeeder/","excerpt":"","text":"各種VPS加速方案一般都是重復發包的原理，也就是用流量換速度。 先嘗試了kcptun，因為據說資源佔用很低，不過部署後打不開網頁。然後試了一下銳速，用一鍵腳本安裝，很方便，而且不像kcptun，不需要客戶端。部署前在Youtube只能看最低清晰度，現在在網絡條件好的情況下，720p也不卡，效果很明顯。 不過銳速不支持OpenVZ，所以搬瓦工用不了，我用的 Vultr 東京機房的基礎配置。 參考 銳速破解版linux一鍵自動安裝包","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vps","slug":"vps","permalink":"http://0x3f.org/tags/vps/"},{"name":"vultr","slug":"vultr","permalink":"http://0x3f.org/tags/vultr/"},{"name":"bandwagon","slug":"bandwagon","permalink":"http://0x3f.org/tags/bandwagon/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://0x3f.org/tags/shadowsocks/"}]},{"title":"Vultr基配可以部署Gitlab","slug":"setup-gitlab-on-vultr-basic-vps","date":"2016-12-24T09:18:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/setup-gitlab-on-vultr-basic-vps/","link":"","permalink":"http://0x3f.org/post/setup-gitlab-on-vultr-basic-vps/","excerpt":"","text":"想在Vultr上部署Gitlab，但是官方文檔上說最低要求1GB RAM + 3GB swap，而我的VPS是基礎配置：768MB RAM。 忐忑地試了一下，居然可以用，只是重啓防火牆的時候CPU一直100%，最後reboot了事。 環境 CentOS 7 x64 Gitlab CE 8.15 參考 Setup Swap File on Linux - Vultr.com Installation Guide of GitLab Community Edition | GitLab","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Git","slug":"git","permalink":"http://0x3f.org/tags/git/"},{"name":"VPS","slug":"vps","permalink":"http://0x3f.org/tags/vps/"},{"name":"Gitlab","slug":"gitlab","permalink":"http://0x3f.org/tags/gitlab/"},{"name":"Vultr","slug":"vultr","permalink":"http://0x3f.org/tags/vultr/"}]},{"title":"關於李陵的更多細節","slug":"more-about-li-ling","date":"2016-12-22T11:41:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/more-about-li-ling/","link":"","permalink":"http://0x3f.org/post/more-about-li-ling/","excerpt":"","text":"上次聊了李陵敗降的細節。在此之後，還發生了幾件有意思的事。 第一個細節，是武帝並沒有馬上殺掉李陵全家，甚至在第二年，還派一支軍隊營救他。 畢竟累世將門，李陵的軍事才能武帝是很欣賞的，況且對於李廣的死，武帝不能沒有一點愧疚。五千步兵深入匈奴，仗打成這個樣子已經是雖敗尤勝了，這一點，武帝自己是知道的，之所以遷怒司馬遷，主要是因為李陵沒有死，而是降了。 在這次戰役中，武帝本來給李陵安排的任務是給李廣利作後勤保障，是李陵自己不乾，非要率五千步兵涉單于庭。按武帝的想法，李陵真要打贏也行，畢竟事關生死存亡，再不濟也得戰死沙場。領導給安排的活你不乾，你自己吹那麼大的牛又沒做到，最後還投降了，這是武帝生氣的主要原因。 不過武帝還是惜才的，所以第二年就派了一支軍隊去救李陵。不過這支軍隊轉了一圈沒撈著匈奴人的影子，只帶回來一個傳聞——李陵在教匈奴人對付漢軍的方法。武帝隨即大怒，並處決了李陵一家。 後來，漢朝有人出使匈奴，李陵趁機問漢使：「我自問戰功不負朝廷，為什麼殺我全家？」漢使就說出了這個傳聞。李陵大恨，說這事是一個叫李緒的乾的。李緒也是一個漢朝的降將，因為這件事，李陵痛恨李緒，就派人把他刺殺了。可能李緒是大閼氏的人，所以大閼氏就要殺李陵。因為匈奴有濃重的母系氏族的風俗殘留，所以大閼氏的勢力很大，連單于也要讓三分。於是單于只能把李陵藏到很遠的地方，直到後來大閼氏死了，才敢接回來。 第二個細節，是霍光曾經試圖策反李陵。 李陵在漢朝的時候跟霍光私交不錯，所以武帝死後，霍光輔政，就想著把李陵接回來，於是以出使的名義派人到匈奴和李陵接頭。李陵沈吟良久，說了一句話：「大丈夫不能再次受辱。」最終拒絕了。 李陵的決定是正確的，作為一個有污點的人，回到漢朝縱然有權臣罩著，一旦靠山倒了，覆巢之下也無完卵。何況至親已死，在漢朝已無牽掛，哪比得上在那天高原闊的地方做一個部落王。 本文最早发布在公众号：两司马门下走狗","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"}]},{"title":"哪個時代都看臉","slug":"judge-by-face","date":"2016-12-09T13:39:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/judge-by-face/","link":"","permalink":"http://0x3f.org/post/judge-by-face/","excerpt":"","text":"漢書卷四十二： 蒼當斬，解衣伏質，身長大，肥白如瓠，時王陵見而怪其美士，乃言沛公，赦勿斬。 高曉松特喜歡說一句話——這是個看臉的時代。其實哪個時代都看臉，所以張蒼因為高胖白，撿了一條命。 昨天讀漢書司馬相如傳，講到撩妹那段（以琴心挑之），後面緊接著就是： 相如時從車騎，雍容閒雅，甚都。 翻譯成人話就是：相如經常開著跑車，逼格滿滿，很帥。所以你以為光琴彈得好就行了麼，想想貝多芬的《獻給愛麗絲》。 看臉本無可厚非，有意思的是看臉的規律：因時而異，因境而異。 先說後者。家世好的喜瘦，苦出身的喜肥。所以楚王好細腰，宮人多餓死。所以趙飛燕能作掌中舞，於是漢成帝死在趙合德的床上。所以屌絲出身的劉邦和王陵饒了張胖子一命。 因時而異。亂世尚剛，治世尚柔。季世喪亂，生存是第一命題，社會的整體審美一定是趨於陽剛的，最好臉上再有道疤，活活美死。而由亂入治，公共審美一定趨於女性化。最典型的就是魏晉南北朝，這時期的男人，要剃須、薰香、塗胭脂，甚至頭上還插花。 有個南北互飈花美男的故事。大致的情節是這樣的：南方派了一個花美男出使北方，結果都城萬人空巷，北方朝廷一看，心說不能讓人給比下去啊，就也挑了一個小鮮肉出使南方，於是南方都城裡也萬頭攢動。 這個故事我不記得出處了，不過《世說新語》的《容止》篇里隨便挑一條，都不忍直視： 王丞相見衛洗馬曰：「居然有羸形，雖復終日調暢，若不堪羅綺。」 不堪羅綺，羨殺韓國歐巴和國產小鮮肉們。 本文最早发布在公众号：两司马门下走狗","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"}]},{"title":"李陵是作死的","slug":"no-zuo-no-die","date":"2016-12-01T12:47:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/no-zuo-no-die/","link":"","permalink":"http://0x3f.org/post/no-zuo-no-die/","excerpt":"","text":"漢書卷五十四： 陵對：「無所事騎，臣願以少擊眾，步兵五千人涉單於庭。」上壯而許之…… 關於李陵的遭遇，多數人從司馬遷身上多少都是知道的：祖上是追殺燕太子丹的秦將李信，祖父是飛將軍李廣，出身將門世家的李陵自然驍武憑陵，以五千步兵力戰十萬匈奴精騎，最後矢盡援絕，不得已才投降。即便對於信仰「文死諫，武死戰」的中國人，多數也是同情的。 然而這個故事主要來自於史記，這就尷尬了。從某種意義上說，李陵是給史記定下基調的人。這就決定了它展示給讀者的不會是故事的全貌。比如很多年前，我第一次看到這個故事的時候就想不明白一個問題：用五千步兵孤軍遠徵遊牧的匈奴，傻子都知道勝算很小，劉徹和李陵的智商同時下線了？ 最近讀到漢書的李陵傳，發現了更多有趣的細節。 天漢二年，武帝命二師將軍李廣利出兵三萬攻打在天山的匈奴右賢王，想讓李陵監押輜重。如果把武帝的軍事史濃縮成一句話，那就是劉徹和他的小舅子們。李廣利就是因為裙帶關係上位的，所以將門世家的李陵恥於為其搞後勤，就跟武帝說：「我本部的軍隊都是精銳，希望能單獨出兵一路，這樣可以迫使匈奴人分兵，二師將軍那邊的壓力也會輕一些。」武帝多精啊，一眼就識破李陵的小九九，說：「這次我出兵很多，沒有富余的騎兵給你。」 於是李陵就開始作了，就有了本文開頭的那句話。以少擊眾、步兵打騎兵、孤軍深入，哪一條都是兵家大忌，估計李陵說這句話時頭皮都是硬的。 當然李陵也不是完全沒有資本，漢軍的戰鬥力是超過匈奴人的。硬碰硬的正規戰爭，匈奴人敗多勝少。因為戰爭打的是綜合實力，無論是經濟實力、人口、技術，漢朝都遠超匈奴，即使三歲騎馬五歲彎弓的匈奴人的單兵素質超過漢朝的民兵。 後來的戰事就證明了這一點。首戰浚稽山，匈奴人就損失數千人，漢軍步兵還追著騎兵打。主要原因就是經濟和技術水平的落差太大。匈奴人主要裝備的是弓箭，箭頭是用獸骨和石頭磨成的片狀，漢軍裝備的是連弩，箭頭是金屬質三稜狀，無論在射速、穿透力還是精准度上，前者都遠遠落後於後者。所以轉戰上千里，堅持很多天，直到最後漢軍的箭用完了，匈奴人才在距離邊境五十公里的地方吃掉這支孤軍。換句話說，如果箭量充足，十萬匈奴騎兵都打不過五千漢軍步兵，這個戰力的對比，很明顯吧。 最後不服從領導安排的李陵還是敗了，敗在距離邊境只有五十公里的地方。據說最後的日子里，他還單獨出營一次，理由是想刺殺單于，搞個斬首行動，回來後就徹底喪失了戰鬥意志。我覺得這又是個疑點，是不是想溜啊。 本文最早发布在公众号：两司马门下走狗","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"}]},{"title":"改用Bear記筆記","slug":"switch-to-bear","date":"2016-11-14T15:32:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/switch-to-bear/","link":"","permalink":"http://0x3f.org/post/switch-to-bear/","excerpt":"","text":"再次證明我是後知後覺的。 曾經對印象筆記不屑一顧，因為對所見即所得的偏見和印象筆記對技術人員的不友好。所以這些年一直用DokuWiki。 DW的編輯模式不是傳統的所見即所得，自己的wiki標記簡潔好用。能針對段落進行修改。可以列出大綱。插件和主題較多。使用文件存儲數據，方便同步。平台無關，對Linux友好。 不過DW自身也存在一些問題： 需要搭建服務 自行處理同步 移動端訪問不便 編輯和查看操作有割裂感 最近開始琢磨記筆記的最佳實踐。考慮到用DW的痛點，感覺對於記筆記最重要的是是否方便記錄和查看。在這點上，所見即所得的確有優勢。所以我嘗試轉換到這類工具上。 選擇Bear而不是印象筆記的原因主要是： 支持代碼語法高亮 支持導出Markdown格式 極簡風和多種主題 代碼語法高亮是剛需，沒什麼可說的。導出Markdown格式可以方便寫博客，這樣就不需要Cmd Markdown了。極簡的風格和包括Solarized在內的多種主題很毒我。 不過Bear也有不少問題： 沒有大綱視圖，不適合長筆記 標籤只支持兩級，大量標籤不好管理 不支持掃描 對Linux不友好 用標籤替代分類的方式我很喜歡，不過兩級的限制讓筆記分類很傷腦筋，而且容易造成標籤太多、難以管理。掃描也是剛需，印象筆記的掃描就很好用，Bear目前沒有這個功能，只能用掃描全能王暫補，割裂感很強，而且還增加了APP。 希望Bear盡快變得更好用。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"},{"name":"bear","slug":"bear","permalink":"http://0x3f.org/tags/bear/"},{"name":"印象筆記","slug":"印象筆記","permalink":"http://0x3f.org/tags/印象筆記/"}]},{"title":"JSON是對象還是字符串？","slug":"what-is-json","date":"2016-11-08T02:46:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/what-is-json/","link":"","permalink":"http://0x3f.org/post/what-is-json/","excerpt":"","text":"前兩天，一個前端跟我爭論說JSON是對象。我在接口文檔里的數據格式寫的是JSON，結果對方真就傳了個對象過來。 要搞清楚JSON是什麼，先得知道JSON是為瞭解決什麼問題的。維基百科里的定義是： JSON（JavaScript Object Notation）是一種由道格拉斯·克羅克福特構想設計、輕量級的數據交換語言，以文字為基礎，且易於讓人閱讀。儘管JSON是Javascript的一個子集，但JSON是獨立於語言的文本格式，並且採用了類似於C語言家族的一些習慣。 所以說，JSON是為瞭解決語言之間數據交換的一種文本格式，體現在數據上，JSON就是字符串類型。那麼為什麼需要為數據交換制訂一種通用的文本格式呢？可以做一個簡單的試驗： 用JavaScript建立一個到PHP的WebSocket併發送一個對象： 12var ws = new WebSocket('ws://127.0.0.1:4759');ws.send(&#123;name:\"hello\"&#125;); PHP接收並打印對象： 123456use Workerman\\Worker;$worker = new Worker('websocket://0.0.0.0:4759');$worker-&gt;onMessage = function($connection, $data) &#123; var_dump($data);&#125;Worker::runAll(); 得到的結果是： [object Object] 所以，一種語言的對象的實例以二進制形式直接傳遞給另一種語言是無法識別的，因此需要把對象數據用文本描述之後再行傳遞。 此外，相對於XML等其它格式，JSON有可讀性上的優勢，如果是對象，二進制的數據哪來的可讀性？","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"}]},{"title":"在Vim窗口标題中顯示會話名","slug":"show-session-name-in-vim-window-title","date":"2016-10-23T03:52:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/show-session-name-in-vim-window-title/","link":"","permalink":"http://0x3f.org/post/show-session-name-in-vim-window-title/","excerpt":"","text":"同時處理多個項目時，在窗口标題中顯示會話名，方便區分，需用session管理會話。 1234567891011\" custom the window titlefun! MyTitleString() let sessionName = xolox#session#find_current_session() let sessionStr = '' if len(sessionName)&gt;0 let sessionStr = ' ['.sessionName.'] ' endif return 'VIM'.sessionStr.': %-25.55F %a%r%m'endfunau BufEnter * let &amp;titlestring=MyTitleString()set titlelen=70","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"時人食狗亦與羊豕同","slug":"thinkings-about-eating-dogs","date":"2016-10-21T05:21:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/thinkings-about-eating-dogs/","link":"","permalink":"http://0x3f.org/post/thinkings-about-eating-dogs/","excerpt":"","text":"漢書卷四十一：「樊噲，沛人也，以屠狗為事。」 顏師古注：「時人食狗亦與羊豕同。」 狗對於中國古人的意義和西方人不同。西方人，確切的說是美國人，對狗的感情完全是因為發展的時間太晚。美國開國也就二百來年，從印地安人手裡奪來的大量耕地和牧場保證了充足的食物來源，而狗為地廣人稀的美國在開拓過程中提供了重要的陪伴和保護，所以美國人不吃狗。 中國發展的時間遠早於美國，而且沒有大片的牧場提供穩定的肉食來源，大型牲畜作為農業主要替代勞力一般也不會用於食用，甚至歷朝長期立法禁止宰殺大型牲畜。所以狗長期是作為一種重要的肉食來源。 「失我祈連山，使我六畜不藩息」，「六畜」分別是豬、牛、羊、馬、雞、狗，這是最早被中國人馴化並作為肉食來源的牲畜，而且長期作為祭祀天地祖宗的高檔祭品。《道德經》里說：「天地不仁，以萬物為芻狗」。「芻狗」就是草扎的狗，是祭祀時當祭品用的，祭祀的時候高高在上、被人們頂禮膜拜，祭祀之後被棄之如敝履，所以說天地不仁。之所以用草狗做祭品，是生產力進步的表現，最初一定是用真狗的，只是後來更高檔的肉食逐漸普及，狗肉上不了台面了，才逐漸被抽象成草偶。 所以中國人是有吃狗的傳統的，美國人不吃狗肉也並不表示更文明，至於「狗是人類的朋友」，更是道德綁架，誰也不能隨便替別人認朋友，最多只能說你的狗是你的朋友，如果別人吃的不是你的朋友，即便自以為站在道德的高度，你也沒有任何權力干涉別人的自由，有句話說的好：自由，就是我有不和你一樣高尚的權利。 我個人也不吃狗肉，但我不覺得別人吃來源合法的狗肉有什麼問題。事實上，吃狗肉的問題並不在於吃不吃本身，而是在這個問題上表現出來的人性的惡，人總是自以為站在道德的高度就可以踐踏別人的權利，每個暴政無不是利用人性的這個弱點。 切記，儒以文亂法。 本文最早发布在公众号：两司马门下走狗","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"}]},{"title":"Archlinux安裝過程中的幾個坑","slug":"pits-of-archlinux","date":"2016-10-17T05:14:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/pits-of-archlinux/","link":"","permalink":"http://0x3f.org/post/pits-of-archlinux/","excerpt":"","text":"安裝方案Archboot是比官方鏡像更友好的安裝媒介，此外還有AUI和Arch Anywhere，沒有試過。 分區Archboot使用parted處理分區任務。 第一個分區不能從sector 0開始，否則安裝完成後系統玩法啓動，報如下錯誤： no operating system found 正確的姿勢： (parted) mkpart primary 2048s 512 以上假設第一個分區用來掛載/boot，分配512M。 還需要設置/boot所在的分區可啓動： (parted) set 1 boot on 啓動引導器GRUB的兼容性比較好。 如果是syslinux，對於沒有單獨對/boot分區並且根分區使用ext4的情況，會無法啓動，報如下錯誤： failed to load ldlinux.c32 此時，應對/boot單獨分區並使用fat格式。 圖形界面安裝X不會連帶安裝顯卡驅動，要單獨安裝，否則啓動圖形界面會黑屏。 在VirtualBox中安裝時，驅動在「virtualbox-guest-utils」。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"},{"name":"操作系統","slug":"操作系統","permalink":"http://0x3f.org/tags/操作系統/"}]},{"title":"小確幸，用shift切換輸入法","slug":"little-happiness-from-replacing-ctrl-space-with-shift","date":"2016-09-17T07:36:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/little-happiness-from-replacing-ctrl-space-with-shift/","link":"","permalink":"http://0x3f.org/post/little-happiness-from-replacing-ctrl-space-with-shift/","excerpt":"","text":"把Alfred升級到3，就想著把切換中英輸入狀態的問題一塊解決掉。 Alfred可以設置默認使用英文輸入狀態，然後用Karabiner把Shift_L映射成Ctrl+Space。現在切換輸入狀態和用Alfred的效率都高多了。 1234567&lt;item&gt;&lt;name&gt;Shift_L to Shift_L&lt;/name&gt;&lt;appendix&gt; + When you type Shift_L only,change to previous system input method&lt;/appendix&gt;&lt;appendix&gt;Shift_L == (Ctrl-Space)&lt;/appendix&gt;&lt;identifier&gt;private.change_input_source_to_squirrel.Rime&lt;/identifier&gt;&lt;autogen&gt;__KeyOverlaidModifier__ KeyCode::SHIFT_L, ModifierFlag::SHIFT_L | ModifierFlag::NONE, KeyCode::SHIFT_L, KeyCode::SPACE,ModifierFlag::CONTROL_L&lt;/autogen&gt;&lt;/item&gt;","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"}]},{"title":"讀完《走出帝制》","slug":"after-reading-walking-out-of-the-imperial","date":"2016-06-30T08:19:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-walking-out-of-the-imperial/","link":"","permalink":"http://0x3f.org/post/after-reading-walking-out-of-the-imperial/","excerpt":"","text":"用了四天時間，讀完了這本書。之所以叫「這本書」，是因為這是本在豆瓣里都找不到記錄的書，去年上市不久即被下架，通常意義上，叫禁書。 一般走狗君讀的書，作者不是死了兩千年，至少也有八百年，連渣渣都不剩的那種。所以如果不是禁書，我還真不一定知道它，更不會讀。不過既然是禁書，又是歷史方面的，那就好玩兒了，他們不想讓我知道的，一定是我應該瞭解的，他越恐懼，我越好奇。 讀完的感覺嘛，確實是本好書，每個人都應該讀一下，如果你能找到的話。 本文最早发布在公众号：两司马门下走狗","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"}]},{"title":"Kindle Paperwhite 1代與3代白色版對比","slug":"compare-kindle-paperwhite-v1-and-v3-white","date":"2016-06-13T08:01:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/compare-kindle-paperwhite-v1-and-v3-white/","link":"","permalink":"http://0x3f.org/post/compare-kindle-paperwhite-v1-and-v3-white/","excerpt":"","text":"如果說2代相對於1代的改進微乎其微，3代在屏幕和配置上的升級是效果顯著的。 從原來的212 PPI升級到300PPI，屏幕像素增加了一倍，加上對比度的提升，顯示效果相對1代的變化還是相當明顯的，文字更加犀利。內存從256M增加到512M，操作流暢度也有較大的提升，尤其是在用輸入法的時候，已經可以基本流暢的輸入了。 然而3代剛推出的時候我還是沒有換。一方面以上所說的提升和價格的增量並不匹配。另一面，前代在外觀和材質上有很大的問題。 首先是顏色，黑色稍微粘上點灰就很明顯，對於像我這樣的強迫症患者，擦灰的時間幾乎和閱讀一樣多。另外，前代的背面採用的是磨砂處理，在乾淨的前提下手感是不錯，不過很容易粘灰，而且粘灰後手感很差，最要命的是，磨砂加上黑色就是指紋收集器！ 所以白色版的出現簡直就是一次救贖。白色粘灰後並不明顯，背板採用顆粒較大、質感較硬的做工，手感比前代好很多。加上前面所說的在閱讀體驗上的提升，可以升級了。 本文最早发布在公众号：两司马门下走狗","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"Kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"}]},{"title":"讀完《史記》","slug":"after-reading-records-of-the-grand-historian","date":"2016-06-13T07:52:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-records-of-the-grand-historian/","link":"","permalink":"http://0x3f.org/post/after-reading-records-of-the-grand-historian/","excerpt":"","text":"之前讀通鑒，用了四年，這次用了七個月。終於是名正言順的兩司馬門下走狗了，哦耶。 史記這本書，說到底還是個人修史，主觀性是很大的。因為坐李陵案，司馬遷是有悲憤的情結的，所以他特別喜歡悲劇英雄，很多名篇都是寫這種人的抒情散文，比如《屈原賈誼列傳》、《項羽本紀》。主觀的愛憎過多，一定會失之客觀。所以項羽以一暴君成垓下悲歌，劉邦以一英主成千古屌絲。褒貶無需作假，有所取捨足矣。 另外，史料的真實性是值得商榷的。因為秦始皇的焚書坑儒，六國史書盡毀，司馬遷的史料來源駁雜，有些事情甚至不同章節互相矛盾。比如黃池之會，左傳就只說「遂長吳國」，史記也是照抄這句，究竟晉吳誰做了盟主，還是有爭議的。 史記的成功，在於司馬遷的文採和宏觀的大體真實。魯迅說它是無韻之離騷，因為司馬遷用了大量小說家的筆法寫文章。比如講齊威王的一生，說此人繼位後，好為淫樂長夜之飲，諸侯交侵，相聲演員淳於髡看不下去了，跟威王說，我聽說國中飛來一隻大鳥，三年不飛，三年不鳴，你說這是腫麼了？威王說，這只鳥啊，三年不飛，一飛沖天，三年不鳴，一鳴驚人。於是罷飲宴，召集大臣，殺一人，賞一人，全國肅然。然後發兵四境，奪回失地，齊國大振。了了幾十字，搖人心旌。 然而史實肯定不是這麼簡單，戲劇之所以好看，就在於它將所有出場的人物臉譜化、劇情簡單化。比如講到冒頓單于，主要講了兩件事。 第一件是鳴鏑弒父。依次射野獸、愛馬、愛妾、單于坐騎，確保鳴鏑已有足夠的威信，然後完成致命一擊。 第二件是擊滅東胡。東胡利用冒頓剛繼位的時機，來索要千里馬。冒頓召集臣屬商量，都說馬是遊牧民族的命，不能給。冒頓說，不能因為一匹馬讓大家冒生命的危險，妥協了。然後東胡又來要冒頓的媳婦兒，冒頓如法炮製。最後東胡說，有塊廢地也給我們吧。當大家都說反正是廢地給就給了的時候，冒頓拍案而起，說土地是國家根本，雖廢地寸土必爭，然後發兵突襲東胡，一舉成功。 把歷史戲劇化，這就是史記好看的地方。馬未都先生說，歷史沒有真相，只殘存一個道理。對於大部分人來說，歷史細節的真相並不重要，大框架對就可以了，宏觀層面的東西足以讓人受益匪淺，追本溯源的事留給專業做學問的就好。 本文最早发布在公众号：两司马门下走狗","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"}]},{"title":"「食其」是什麼？","slug":"what-is-yi-ji","date":"2016-06-06T08:48:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/what-is-yi-ji/","link":"","permalink":"http://0x3f.org/post/what-is-yi-ji/","excerpt":"","text":"「食其」音「異基」，人名。 讀漢初的歷史，有三個人都叫這個名字：酈食其、審食其和趙食其。這似乎在當時是個很流行的名字，儼然就是漢代的麗麗、芳芳啊。 這兩個字為什麼念這個音？又是什麼意思？ 《康熙字典》里只是明確了兩個字的讀音，並沒有解釋和考證出處。 《史記索隱》說：「食音異。酈、審、趙三人同名，其音合並同，以六國時衛有司馬食其，並慕其名。」意即出自戰國時衛國司馬食其，後人因為仰慕此人，就取他的名字來用。此外比如司馬相如因為仰慕藺相如而改名也是一例，宋人王楙在《野客叢書》里也持這個觀點。 也有人說出自子路所說「食其食者不避其難」。子路做衛國貴族孔悝的家宰時，衛國發生政變，孔悝被劫持，子路聽說後隻身赴難，在打鬥過程中帽子被打掉，說「君子死，冠不免」，在丟下兵器扶帽子的時候被殺。子路去救孔悝時說的這句話，簡單說就是吃人嘴短。然而食字在發yi音時並沒有吃的意思，所以這種說法當是附會。 比較來看，《史記索隱》的說法最靠譜，但是也沒有從根本上解釋清楚這個名字的意思。不過考慮到先秦人名普遍比較樸拙和文、言異路的因素，這個名字應該出自當時的口語或方言，只是寫到書上時拿「食其」兩個字做假借。 本期封面：我的貝克利要🌼了 本文最早发布在公众号：两司马门下走狗","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"},{"name":"公眾號","slug":"公眾號","permalink":"http://0x3f.org/tags/公眾號/"}]},{"title":"兩司馬門下走狗創刊號","slug":"the-first-post-of-running-dog","date":"2016-06-06T08:22:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-first-post-of-running-dog/","link":"","permalink":"http://0x3f.org/post/the-first-post-of-running-dog/","excerpt":"","text":"算是開始玩自媒體了麼？ 如果從寫博客算起，十年前就算了。從一開始和大多數人一樣，把博客當成公開日記寫，到後來很快明白博客的定位，我的自媒體時代很快從0.1升級到1.0。 後來，因為博客托管網站的所見即所得編輯器生成的HTML代碼格式太死板，自己定義了一套簡單的標記，然後寫了個轉換程序，然而沒過多久就發現，已經有了類似的東西–輕量型標記語言。 很快，托管的服務已經不能滿足個性化要求。自然而然地，就有了獨立博客。這算是我的自媒體2.0時代吧。 就這樣一直持續了很多年。內容基本上是日常的總結和筆記，總之是給自己看的成分居多。 公眾號怎麼定位呢？首先應該是寫給別人看的，所以不能過於自由，想什麼時候寫什麼時候寫，有時候一月一次，有時候一月幾次，有時候幾個月不來一次（😱）。其次應該是個專欄，所以主題應該集中，不能想寫什麼寫什麼。 那麼寫點啥呢？在一個理工宅少得可憐的愛好里，翻翻故紙堆是唯一比較能算得上文藝的東西了。其實在接觸電腦之前，我一直是想學考古的（💀），現在看來其實人還是最好不要忘了初心（😳）。 好了，都閃開，我要進（kai）入（shi）3.0時（zhuang）代（bi）了！ 本文最早发布在公众号：两司马门下走狗","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"},{"name":"公眾號","slug":"公眾號","permalink":"http://0x3f.org/tags/公眾號/"}]},{"title":"Kindle Lazybones: Control Kindle From Your Phone","slug":"kindle-lazybones","date":"2016-06-06T02:33:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/kindle-lazybones/","link":"","permalink":"http://0x3f.org/post/kindle-lazybones/","excerpt":"","text":"Kindle Lazybones .-. _ ( `. .&apos; ) `\\ ` .&apos; | | | | | 66|_ | ,__) |(,_| | | | \\_, | | | | .&apos; \\ ( , ) &apos;--&apos; &apos;-&apos; Remote controlling utilities for Kindle. Feature Flip over Kindle with your smartphone. Issues Currently only Kindle PaperWhite is supported, PW2/PW3 are not yet. Kindle still goes to sleep after 10 minutes, a temporary solution is running the searchbox command ~ds to disable screensaver, but only a restart can resume it. The other way is changing 10 minutes to longer by modifying /etc/kdb/system/daemon/powerd/t1_timeout, but it’s readonly although I’ve run mntroot rw. Button sizes won’t be adjusted correctly when the orientation of Android smartphones changes (from landscape to portrait or vice versa), a temporary solution is refreshing the page. iOS devices don’t have this problem. Project Architechture kindle/ Server-side files for Kindle. User GuideJailbreak KindleJailbreaking Kindle allows you to access its operating system. For how to do that, refer to Kindle 5.6.5 越狱教程：支持所有 5.6.5 固件 in chinese or 5.6.5 Jailbreak (closed-kindle) – released! in english. Install KUAL, MRPI and USBNetworkKUAL is an application launcher for Kindle, MRPI is a package installer plugin for KUAL and USBNetwork is a package which provides SSH service for Kindle. For how to do that, refer to Kindle 5.6.5 越狱插件资源下載及详细安装步骤 in chinese or the following in english: KUAL: Kindle Unified Application Launcher (v 2.6) MobileRead Package Installer Kindle Touch/PW1/PW2 5.0.x - 5.4.4.2 JailBreak. Plus FW 5.x USBNetwork. Install PythonAs this project is mainly written in Python, so refer to FW 5.x ScreenSavers Hack. Open Access to Port 8080Lazybones communicates with remote controllers on port 8080, so add the following line to /etc/sysconfig/iptables: -A INPUT -p TCP –dport 8080 -j ACCEPT Install LazybonesPut kindle/ under /opt/ and rename it to lazybones. As Kindle uses Upstart to handle system startup jobs, run the following command to make Lazybones run automatically on OS startup: 1cp /opt/lazybones/etc/upstart/lazybones.conf /etc/init/ UsageRestart Kindle, enable WIFI and it should works. Type ;711 in the search box in Kindle and press Enter, this shows its WIFI infomation, find the IP address (assuming that’s 192.168.1.103) and visit http://192.168.1.103:8080 on your smartphone.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"}]},{"title":"奇怪的決戰","slug":"a-strange-decisive-battle","date":"2016-05-01T02:59:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/a-strange-decisive-battle/","link":"","permalink":"http://0x3f.org/post/a-strange-decisive-battle/","excerpt":"","text":"前兩天讀史記王翦列傳，覺得秦楚的決戰很奇怪。 王翦果代李信擊荊。荊聞王翦益軍而來，乃悉國中兵以拒秦。王翦至，堅壁而守之，不肯戰。荊兵數出挑戰，終不出。王翦日休士洗沐，而善飲食撫循之，親與士卒同食。久之，王翦使人問軍中戲乎？對曰：「方投石超距。」於是王翦曰：「士卒可用矣。」荊數挑戰而秦不出，乃引而東。翦因舉兵追之，令壯士擊，大破荊軍。至蘄南，殺其將軍項燕，荊兵遂敗走。秦因乘勝略定荊地城邑。歲余，虜荊王負芻，竟平荊地為郡縣。 稍微有點軍事常識就知道，防守方最好的辦法是堅守不戰，在自己的地盤上，對方的後勤補給要比自己困難得多，一旦補給不繼，軍心必亂，勢必撤兵，這時候再追上去打，勝算很大，也就是所謂以逸待勞。比如秦趙長平之戰，一開始，廉頗先用小股部隊跟秦軍接觸，一看打不贏，馬上收縮防線，避免決戰，搞得秦軍進也不是、退也不是，軍力損耗極大，不得以只好用反間換掉廉頗。 所以戰爭中的進攻方是處於劣勢的，要扭轉不利的態勢，就要把主動權握在自己手裡，所以一般會用反客為主的辦法。雖然我是進攻方，但我不著急進攻你，讓你自己沈不住氣來打我，這時候攻守易形，我成了防守方，你成了進攻方，形勢就對我有利了。 所以王翦反客為主是正常的，項燕急著打就很奇怪了。老項家累世將門，項燕沙場宿將，不可能連常識都不懂。 也許唯一合理的解釋是楚國國力衰敗，撐不下去了。 以前秦國伐楚很困難，因為楚國西有江漢之險，北有諸夏扞蔽。不過自白起破鄢郢，江漢天險盡失；自三晉覆滅，中原逐鹿之勢已成。秦國伐楚，後勤補給已經不是問題。 另外，讓秦國擁有支持百萬級滅國戰役能力的，還有伐蜀的決策。自商君變法，秦國勢平地起飛，此後相當長的一段時間，秦國雖說是戰國首強，但也不能佔據壓倒性的優勢，直到秦滅六國前的三十年，還有信陵君收天下之兵扣關攻秦的事。戰爭不是戰鬥，決定成敗的主要還是國力。李信的二十萬大軍覆滅後，秦國可以馬上再把六十萬人送上前線，這個國力，不贏沒有天理。所以司馬錯論伐蜀，同時擁有關中、蜀中兩塊天府之國，是秦國國力質變的關鍵。 這個時候的楚國，已經是冢中枯骨。在秦國連年的攻勢下，大片國土淪喪，鄢郢破而遷陳，三晉亡而遷壽春，幾十年間，顛沛流離，沒有喘息的機會，靠吃戰略縱深的老本苟延殘喘。所以在這次決戰之前，可能國力已經難以為繼了，但是楚國自己也知道八百年國運繫於這一戰，所以不得不起傾國之兵應戰。空虛的國力和浩大的戰爭消耗最終迫使項燕選擇速戰速決，戰還有一線生機，不戰只能坐以待斃。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"史記","slug":"史記","permalink":"http://0x3f.org/tags/史記/"}]},{"title":"Alfred-pushbullet: Push a text to your phone","slug":"alfred-pushbullet","date":"2016-04-13T09:30:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/alfred-pushbullet/","link":"","permalink":"http://0x3f.org/post/alfred-pushbullet/","excerpt":"","text":"Pushbullet workflow for Alfred. Features Push a text to another device. Installation Download the latest release and rename it to pushbullet.alfredworkflow. Double click it to import it into Alfred. Double click the “Run Script” button and replace “ACCESS_TOKEN” and “DEVICE_NAME” according to your pushbullet settings. Activate alfred and input “push blablabla”, then press enter. Authorbase64decode IkRvbmllIExlaWdoIiA8ZG9uaWUubGVpZ2hAZ21haWwuY29tPgo= Downloadhttps://github.com/xbot/alfred-pushbullet/","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"},{"name":"alfred","slug":"alfred","permalink":"http://0x3f.org/tags/alfred/"}]},{"title":"Linux下做Mac OSX安裝U盤的步驟","slug":"create-mac-bootable-usb-stick-on-linux","date":"2016-03-08T04:22:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/create-mac-bootable-usb-stick-on-linux/","link":"","permalink":"http://0x3f.org/post/create-mac-bootable-usb-stick-on-linux/","excerpt":"","text":"假設U盤對應/dev/sdb1、OSX安裝包是osx.dmg。整個過程就是提取出一系列文件，然後複制到U盤裏。 1234567891011121314151617181920212223# 格式化U盤爲hfs+文件系統sudo mkfs.hfsplus -v EICaptianInstall /dev/sdb1 # 提取和挂載第一個光盤鏡像dmg2img -p 5 osx.dmg osx.imgmkdir raw &amp;&amp; sudo mount -o loop osx.img raw # 提取和挂載第二個光盤鏡像dmg2img -p 5 raw/Install\\ OS\\ X\\ El\\ Capitan.app/Contents/SharedSupport/InstallESD.dmg InstallESD.imgmkdir esd &amp;&amp; sudo mount -o loop InstallESD.img esd # 提取和挂載第三個光盤鏡像dmg2img -p 4 esd/BaseSystem.dmg BaseSystem.imgmkdir base &amp;&amp; sudo mount -o loop BaseSystem.img base # 挂載U盤mkdir usb &amp;&amp; sudo mount /dev/sdb1 usb # 複制一系列文件sudo cp -r base/* usb/sudo rm usb/System/Installation/Packagessudo cp -r esd/Packages usb/System/Installation/sudo cp esd/BaseSystem.* usb/ 注意dmg2img的參數-p表示提取dmg的第幾個分區，似乎不同的OSX版本提取哪個分區也不一樣，判斷方法就是先執行dmg2img osx.dmg，看哪個分區提取得最慢就選哪個。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"},{"name":"mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"}]},{"title":"FastFold：Vim折疊功能的救贖","slug":"fastfold-for-vim","date":"2016-02-24T03:06:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/fastfold-for-vim/","link":"","permalink":"http://0x3f.org/post/fastfold-for-vim/","excerpt":"","text":"設置Vim的折疊規則爲syntax存在兩個問題。一是如果源碼中有大量折疊區域，在插入模式中輸入會變得很卡。二是剛輸入一個折疊區域的起始符号，後面所有的折疊都會被打開。 第一個問題是因爲Vim的syntax折疊規則處理過于低效。而後一個問題對于所有自動折疊規則都會存在，原因是Vim對折疊的更新過早。 傳統的解決辦法是将折疊規則置爲manual，并在合适的時機重置爲syntax或其它相應規則。但是工作繁複而且往往問題很多。 FastFold是遵循上面所說的方法解決這些問題的插件，不過默認會在所有與折疊相關的時機更新折疊，會導緻相關的操作變慢，例如zc和zo時都會有明顯的卡頓。鑒于其它時機對折疊的更新已經足夠及時，可以通過配置取消受在到明顯影響的時機更新折疊： 12\" FastFold隻在za/zA/zx/zX時更新折疊信息let g:fastfold_fold_command_suffixes = ['x','X','a','A']","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://0x3f.org/tags/插件/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"FZF: 又一個文件模糊查詢工具","slug":"fzf-yet-another-fuzzy-finder","date":"2016-02-01T03:42:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/fzf-yet-another-fuzzy-finder/","link":"","permalink":"http://0x3f.org/post/fzf-yet-another-fuzzy-finder/","excerpt":"","text":"fzf是個獨立的命令行工具，索引速度很快，可以通過fzf-vim配合使用。 特性功能支持還是比較全的： Command List Files [PATH] Files (similar to :FZF ) GitFiles Git files Buffers Open buffers Colors Color schemes Ag [PATTERN] {ag}{5} search result (ALT-A to select all, ALT-D to deselect all) Lines Lines in loaded buffers BLines Lines in the current buffer Tags Tags in the project ( ctags -R ) BTags Tags in the current buffer Marks Marks Windows Windows Locate PATTERN locate command output History v:oldfiles and open buffers History: Command history History/ Search history Snippets Snippets ({UltiSnips}{6}) Commits Git commits (requires {fugitive.vim}{7}) BCommits Git commits for the current buffer Commands Commands Maps Normal mode mappings Helptags Help tags [1] 結論fzf需要在終端中執行，在vim中使用時需要另外啓動一個xterm實例，UI的割裂感很強，而且xterm本身的操性你懂的。另外Tags模式需要兩次回車。所以暫不會用它取代ctrlp和unite。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://0x3f.org/tags/插件/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"ctags vs gtags vs phpctags","slug":"ctags-vs-gtags-vs-phpctags","date":"2016-01-29T09:55:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ctags-vs-gtags-vs-phpctags/","link":"","permalink":"http://0x3f.org/post/ctags-vs-gtags-vs-phpctags/","excerpt":"","text":"這兩天把源碼分析工具從ctags向gtags遷移，另外嘗試了一下phpctags。 之前用ctags有兩個問題，一個是如果同一tag有多個定義，按Ctrl+]隻能跳轉到第一處。另一個是用cscope查詢tag的調用記錄時，有些tag查不到結果。 幾年前接觸過gtags，因爲當時還不支持宇宙最好語言，所以沒用。這次測試了一下，前面兩個ctags的問題都可以解決。 安裝後需要手工拷貝gtags.vim和gtags-cscope.vim到vim的plugin目錄，然後配置如下： 1234567let Gtags_Close_When_Single = 1let Gtags_Auto_Update = 0let g:cscope_silent = 1au FileType php,python,c,cpp,javascript,go map &lt;C-]&gt; :Gtags&lt;CR&gt;&lt;CR&gt;au FileType php,python,c,cpp,javascript,go map &lt;C-[&gt; :Gtags -r&lt;CR&gt;&lt;CR&gt;nnoremap &lt;leader&gt;&lt;C-]&gt; :execute 'Unite gtags/def:'.expand('&lt;cword&gt;')&lt;CR&gt;nnoremap &lt;leader&gt;&lt;C-[&gt; :execute 'Unite gtags/ref:'.expand('&lt;cword&gt;')&lt;CR&gt; 其它選項參見前面兩個文件裏的注釋。 另外嘗試了一下phpctags，據說和ctags兼容并對php做了優化。實際使用效果和ctags沒發現有什麽區别，不過tagbar-phpctags倒是比tagbar用ctags時效果更好。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://0x3f.org/tags/插件/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"CtrlP vs Unite vs Command-T vs FuzzyFinder","slug":"ctrlp-vs-unite-vs-command-t-vs-fuzzyfinder","date":"2016-01-27T08:16:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ctrlp-vs-unite-vs-command-t-vs-fuzzyfinder/","link":"","permalink":"http://0x3f.org/post/ctrlp-vs-unite-vs-command-t-vs-fuzzyfinder/","excerpt":"","text":"簡述Sublime在文件打開速度上的表現很驚豔，Vim有幾個擴展可以實現類似功能，本文對這些擴展做個對比。 雖然每個擴展都或多或少地實現了一些功能，我個人用得最多的也就文件、Tag、Buffer Tag的模糊查找這三個，像MRU、buffer之類的查找不覺得有多大用處，所以提高工作效率的工具一定是在熱度環節有很好表現，其餘偏門功能可以交給插件實現，在這點上CtrlP和Unite做得很好。所以下面針對最常用的這三個功能做下對比，更多功能的對比見下表： 文件模糊查找Command-T的文件索引速度最快，各方面在這幾個擴展中的表現都是最好的。 CtrlP默認使用VIM自建的globpath()，需要手工配置使用ag以獲取更快的速度，據說使用find命令效率更高，實際感覺和ag差别不大。 Unite也需要手工設置使用ag，而且可以實現異步索引，在這一點的體驗上好于前兩個，但是在模糊匹配的排序上表現不好，比如輸入“php”，當然希望“/etc/php.ini”這樣的結果排在“/home/peter/host/tmp.txt”前面，實際往往不是這樣，Unite的幾個sorter裏，數rank的排序結果最接近于這個要求，但是表現仍然不如前兩個。 Tag模糊查找三個擴展都是通過ctags實現，雖然Unite的排序問題仍然存在，對于Tag這麽簡短的東西，問題不大。 Buffer Tag模糊查找CtrlP的表現是最好的。 Unite需要通過unite-outline這個source實現，但是隻能列出類和方法，無法定制列舉類型。而且默認選中排在第一位的類名，查詢方法時很不方便。 Command-T不支持此功能。 我的選擇FuzzyFinder是該類擴展裏的老前輩，不過早已不維護，功能上不比其它幾個出彩。Command-T雖然在文件索引速度上表現最好，但是優勢并不很明顯，而且支持功能最少。所以排除這兩個。 在最常用的三個功能上，CtrlP的綜合表現是最均衡的，所以留下它。Unite本身是一種統一的交互方式和界面，很多擴展（source）可以實現五花八門的功能，像unite-outline雖然在Buffer Tag上表現不佳，對于Markdown和Vim文檔還是很有用的。 Update: 2016-02-01FZF: 又一個文件模糊查詢工具","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"最佳實踐","slug":"最佳實踐","permalink":"http://0x3f.org/tags/最佳實踐/"}]},{"title":"簡化Vim Addons Manager安裝擴展的操作","slug":"simplify-vim-addon-installation-issues","date":"2016-01-20T10:05:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/simplify-vim-addon-installation-issues/","link":"","permalink":"http://0x3f.org/post/simplify-vim-addon-installation-issues/","excerpt":"","text":"相對Sublime的Package Control，VAM安裝和卸載擴展的操作很煩瑣。以下腳本在安裝完擴展後自動註冊，無須手工添加到vimrc，另外增加命令:UninstallAddons，從註冊表中刪除擴展。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546set runtimepath+=~/.vim/addons/vim-addon-managerlet active_addons = []let s:vamRegistryFile = expand('~').'/.vim/vam_registry'if filereadable(s:vamRegistryFile) let active_addons += readfile(s:vamRegistryFile)endifcall vam#ActivateAddons(active_addons)\" Addon post-install hook.fun! MyAddonPostActivateHook(info, repository, pluginDir, opts) if filereadable(s:vamRegistryFile) let regLines = readfile(s:vamRegistryFile) call add(regLines, a:repository.name) call sort(regLines) call uniq(regLines) else let regLines = [a:repository.name] endif call writefile(regLines, s:vamRegistryFile)endfunlet g:vim_addon_manager.post_install_hook_functions = ['MyAddonPostActivateHook']\" Complete the addon name.fun! MyDoActivatedAddonsCompete(...) let fullList = keys(g:vim_addon_manager.activated_plugins) call filter(fullList, 'v:val =~ \".*'.a:1.'.*\"') return fullListendfun\" Remove records of addons from the registry.fun! MyUninstallAddons(...) if filereadable(s:vamRegistryFile) let regLines = readfile(s:vamRegistryFile) else echo \"Registry is empty.\" return endif for addonName in a:000 let idx = index(regLines, addonName) if idx &gt;= 0 call remove(regLines, idx) echo addonName.' is removed from the registry.' else echo addonName.' cannot be found in the registry.' endif endfor call writefile(regLines, s:vamRegistryFile)endfuncommand! -complete=customlist,MyDoActivatedAddonsCompete -nargs=* UninstallAddons :call MyUninstallAddons(&lt;f-args&gt;)","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"BiuBiu: A Chrome Extension Blocking AJAX Requests","slug":"chrome-extension-biubiu","date":"2015-12-31T06:19:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/chrome-extension-biubiu/","link":"","permalink":"http://0x3f.org/post/chrome-extension-biubiu/","excerpt":"","text":"BiuBiuBiuBiu is an extension for Google Chrome Browser which intends to make life easier for debugging and profiling. For now, it only blocks AJAX requests made by JQuery, more features may be added in the future. Features Toggle to enable or disable BiuBiu. Block requests made by JQuery by URL. Author1Donie Leigh &lt;donie.leigh at gmail.com&gt; Links Project: https://github.com/xbot/chrome-biubiu FAQ Change Logversion 1.0.1 (2015-12-31) Fix the complaining when there is no jQuery or jQuery.cookie.js loaded in the injected page. version 1.0.0 (2015-12-30) Initial release.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"javascript","slug":"javascript","permalink":"http://0x3f.org/tags/javascript/"},{"name":"chrome","slug":"chrome","permalink":"http://0x3f.org/tags/chrome/"}]},{"title":"讀完《春秋左傳注》","slug":"after-reading-zuo-zhuan","date":"2015-11-15T10:24:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-zuo-zhuan/","link":"","permalink":"http://0x3f.org/post/after-reading-zuo-zhuan/","excerpt":"","text":"讀這本書，用了一年時間。前面讀《通鑑》，用了四年，平均一年五本書的節奏，讀盡相斫書的偉大理想不知道這輩子能不能實現了。漢以後的書都好讀，也不一定。 總結一下，主要有兩個心得吧。一個是梳理了一下春秋的脈絡，把以前知道的片斷都連了起來，抓住“蠻夷與戎狄交，中國不絕若線”的大背景，整個春秋時代大家都忙啥呢就清楚了，然後分成三段看，齊桓始霸、晉楚爭霸、吳越爭霸，比從五巨頭切入清晰。第二個是加深了對禮樂文化的認識，貴族時代幹啥都跟鬧著玩似的，反映出我們屌絲的世界太低俗，整本《詩經》就是貴族圈的黑話，搞得我老想叉開去讀《詩經原始》，剁手剁手，不然更看不完了。 讀《通鑑》算是用通史貫穿一下脈絡，《左傳》是第一本讀完的斷代史，本來想接著讀《戰國策》，看了一眼，文章寫得太爛，又是縱橫家的書，所以直接讀《史記》，司馬遷的小說寫得還是不錯的，遷兒哥，我來了！","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"},{"name":"春秋","slug":"春秋","permalink":"http://0x3f.org/tags/春秋/"}]},{"title":"尋找失落的匈奴（201409）","slug":"a-trip-to-tongwan-city","date":"2015-08-20T15:07:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/a-trip-to-tongwan-city/","link":"","permalink":"http://0x3f.org/post/a-trip-to-tongwan-city/","excerpt":"","text":"行程 D1.AM 失落的匈奴匈奴是中國統一後的第一個大敵，極盛時号稱控弦四十萬，以至于漢武帝窮高、文、景三代積蓄，鏖戰數十年，延及元帝，郅支授首，才終于換來一句“犯強漢者，雖遠必誅”。 東漢招引外族入居内地，想同化并加以利用，至于魏晉，欺壓各族，又不加防備。 西晉初年，由封建制的複興導緻的八王之亂，紛纭十六年，耗盡了皇族勢力。被壓制已久的民族矛盾于是爆發，匈奴、鮮卑、羯、氐、羌五族先後建立十六個國家，混戰一百三十多年，史稱五胡十六國。 其中，匈奴鐵弗部赫連勃勃建立大夏國，橫行秦晉，役民十萬蒸土築城，号統萬城。蒸土就是在土中混入生石灰，然後澆水夯築，所以城牆是白色的，當地人至今都叫白城子。築城要求極爲嚴格，工程驗收人以鐵錐刺牆，刺入一寸殺築者，屍體填入城牆，所以城牆極爲堅固，是夯土建築的巅峰之作。後來北魏太武帝拓跋焘滅夏入城，說“統馭萬邦，在德不在險”。 統萬城遺址在陝西靖邊。我喜歡去這種沒有被過度商業化開發的地方，再過幾年，也許就再也見不到這種荒草孤城的景象了。 早上四點火車到站，車站門口有很多黑車，會漫天要價，事先做好功課就不會被宰，議定一百五，要說明白包往返，到地方等兩個小時。 路上停車吃洋芋擦擦，就是炒土豆絲…… 火車站到統萬城大概三十公裏，所以不會用太長時間，五點多到的時候，天還沒有亮，這個時候沒人收費，可以直接開進去。 天色微亮，從停車場走向統萬城還是條土路。 遺址正在進行小規模的修複。 城墩填充的外表被刻畫成磚的樣子，而夯土建築的輪廓應該是一層一層的。 像這樣： 走在質地堅硬的城牆上，可以想象當年它曾是怎樣的堅不可摧。 凸出的城墩和城牆形成有縱深的防禦體系，可以分割敵人的陣形，将攻城者置于被三面夾擊的死地。殘存的城牆尚且這麽高，不知道當年是如何雄偉的一座城！ 荒原晨露，日出統萬。 沿着小路走向城中的高台，沙深露重，很不好走。 土墩離外城城門不遠，可能是内城的一部分。高處的洞裏，栖滿了野鴿子。 城的中部，據說是宮殿遺址。 城北一處正在發掘的現場。 北角的城墩，淹沒在一望無際的荒草中。 我在這裏休息，讀完了《晉書·赫連勃勃載記》。 東角的城墩已經破壞得快消失了。 回望城内。 東南城牆已經快消失在荒草中了。 南角墩曾被挖做窯洞。 隻有西角殘存的遺迹最完整。 因爲去得早，而且遺址少有人去，所以整個早上隻有我一個人，不緊不慢地走遍全城，用了三個小時，好在司機沒有催我，如果能帶着帳篷來這裏紮營，重讀通鑒永嘉南渡後三百年的烽火狼煙，一定很刺激，不過可能再也沒有機會了。 D1.PM 龍洲丹霞（波浪谷）從統萬城出來，時間還很早，上車直奔龍洲丹霞，車上議價，往返加等待，100￥。 路上還有一段長城的遺迹，隻剩下壟起的一條痕迹，可能是漢長城。 景區已經修了觀景台和公路，不過還沒有收費。 看這個就知道爲什麽叫波浪谷了。 下面是深溝，岩石表面是風化的沙土，走在上面很驚險。 靖邊有石油，能看到遠方油井噴出的火。 其它地方見到的丹霞都是在地上的，這裏是在地下，要從公路邊的野路下去，所以找個知道路口在哪的司機很重要。 有的小路不好走，隻能手腳屁股并用。 下到谷底。 很美，真的很美。 中間有一段很窄，一隻腳都插不下。 像什麽，我當時自然地想到了大地的菊花…… 下面這一段更難走，順着溝再往前是懸崖，隻能從左手邊的崖壁上繞過去。 這段很危險，旁邊就是懸崖，石頭風化嚴重，我爬得很慢、很糾結。 過了這段就好了，前面谷底别有洞天。 谷裏的水是從這個谷口裏流出來的，水源是人工的，源頭有隻死貓，惡心死我了，因爲溯源前用溪水洗了手，還挺涼。 前面這個山包就是傳說中的土匪窩，山體已經被挖空了，在前朝是土匪的藏身之地。 谷底再多些草和野花就好了。 水流經過的地方倒是水草豐茂。 土匪窩下的人工湖可以坐船。 從土匪窩旁的土路上到公路路口就很容易了，在路口吃了碗荞麥涼粉，挺好吃的。 波浪谷不大，不過确實很漂亮，據說雨後初晴時來更好看，丹霞會呈現通紅的顔色。由于野路不好走，而且我慢慢玩兒、拍照多，用了大概三個小時。 大概下午兩三點的樣子，時間還早，所以讓司機把我拉到縣城裏的電影院，看了場《猩球崛起2》，小縣城因爲有石油，居然就可以看3D，而且是眼鏡夾片，真是我大四眼黨的福音，比3D眼鏡舒服多了。隻是小縣城的影院不打折，于是看了自《阿凡達》以來最貴的電影。 看完電影，步行去之前司機推薦的“喬溝灣老婆風幹羊肉剁荞面”館吃剁荞面（23￥），離電影院不遠。然後就醬紫了： 沒想到吃面可以這麽鋪張，不知道從哪開始發動，恬着臉問了服務員，吃得好爽，也很撐。 出門邊散步邊打車，時間還早，慢慢講價，這小縣城的出租車死貴，到火車站沒多遠，要價20￥，後來終于找到一個15￥的。 D2.AM 晉祠一夜火車，早上4點到太原，在車站門口等804路公交到晉祠，大概七點多到的。 相機沒電了，隻拍了這一張。 剩下的隻能用手機拍了，效果很差。 李世民和其功臣塑像。李唐以國号始自周成王弟叔虞所封的唐國，所以大修晉祠。 難老泉，就是奔它來的。 從晉祠出來大概十一點，吃完飯坐公交到山西博物館。 D2.PM 山西省博物館博物館最能看出一個地方的底蘊。山西省博在國内算是一流的，不可不看。 山西省博東西很多，走馬觀花也沒看完，到閉館時還有一個展廳沒看。 出門打車奔火車站，差一點沒趕上高鐵。 費用火車：北京到靖邊215￥，靖邊到太原114.5￥，太原到北京197￥包車：靖邊250￥打車：靖邊縣城到火車站15￥，山西省博到火車南站35￥公交：太原火車站到晉祠2.5￥，晉祠到山西省博2.5￥門票：晉祠75￥導遊：山西省博自動講解器10￥旅遊保險：3￥","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://0x3f.org/tags/旅行/"},{"name":"古城","slug":"古城","permalink":"http://0x3f.org/tags/古城/"}]},{"title":"自駕雞鳴驿、草沿天路（201507）","slug":"a-drive-to-jimingyi-and-caoyantianlu","date":"2015-08-12T13:05:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/a-drive-to-jimingyi-and-caoyantianlu/","link":"","permalink":"http://0x3f.org/post/a-drive-to-jimingyi-and-caoyantianlu/","excerpt":"","text":"行程D1：上午，北京到懷來，土木之變戰場遺址和雞鳴驿；下午，宣化，清遠樓、鎮朔樓、時恩寺、遼代古墓壁畫群。 D2：草沿天路，張北野狐嶺入，崇禮桦皮嶺出。 D1.AM 土木堡、雞鳴驿雖然起得很早，上京藏線也七點多了，趕上草原音樂節，出城的車巨多，在居庸關前面一段堵了半小時。 到土木堡的時候已經十點多了，唯一的标志物就是這個路邊的牌樓。 裏面是一片荒地，可能是土木之變的戰場遺址。當年一戰，二十萬大軍覆沒，大明精銳盡喪，英宗北狩，瓦剌圍城。可惜于謙，打赢了北京保衛戰，卻輸掉了奪門之變。所以老子說：“持而盈之，不若其已。揣而群之，不可長保也。金玉盈室，莫能守也。富貴而驕，自遺咎也。功遂身退，天之道也。”，實在是金玉良言，不過知進易，知退難，幾千年來，有幾個張良？ 數百年的烽火狼煙，劫波度盡，誰能想到土木堡真正的被毀發生在本朝。路的另一邊就是土木村，據說還有土木堡殘存的遺迹，時間關系，沒有去看。 事實證明，沿G110奔雞鳴驿不是個好選擇，路況不太好，大貨車很多，應該走高速的。 城門被修成這樣也是醉了，我頭回見城門口橫着一影壁牆的。 反而從城内看城門，才有點兒意思。 城門口的塑像，後面是驿城博物館，主要介紹一下驿城的曆史。 城門要遠看才有意境。 城中主幹道旁的戲台，其它地方還有兩個，小小的驿城，修那麽多戲台幹嘛，規劃有問題。 多久沒見這種風格的房子了。 驿城署，現在是一家人的住處，可以進去參觀，有人剪票，不過裏面什麽都沒有。 文昌宮，當年是驿城的學校。 晴耕雨讀，用的殘體字…… 龍神廟裏也有個戲台，得是多喜歡看戲！ 範家大院，庚子國變慈禧逃跑時曾在這住了一宿，現在也就剩這麽一進。敢向全世界宣戰的隻有兩個人，一個是天朝聖母皇太後，一個是巴格達迪。 伏瞰驿城，懷疑原來真有這麽大麽，似乎和西夏黑水城和統萬城差不多。 坐在城頭等日落。 我懷疑這城牆是做舊，明朝以後，大多數城牆已經換用磚石結構，應該不會用這種過時的夯土建築了吧。 城外的雞鳴山形态突兀，很顯眼，如果是下雨的天氣，真有“風雨如晦，雞鳴不已”的感覺。 城外不知道爲什麽弄了幾截綠皮火車，很不搭。 D1.PM 宣化古城、遼代古墓壁畫從雞鳴驿出來奔宣化，三點多到，吃莜面窩窩，又叫栲姥姥，據說是當地特色，在電視上見過。蘸着羊肉臊子，味道很不錯。 清遠樓和鎮朔樓是宣化古城的标志性建築，始建于明朝，氣勢恢宏，不可不看。 清遠樓是鍾樓，在維修。 鎮朔樓是鼓樓，門票5￥，我包場。 一層是個展廳，居然是介紹宣化當代發展的。 二樓很空，隻有一面大鼓。 樓外就是時恩寺。 殿裏正在做法事，很多人，順時針轉圈，口宣佛号，淨土宗的路子。 就是奔這塊匾來的。 從寺裏出來，開始下雨，趕緊鑽到車裏，奔遼代古墓壁畫群，路經大新門，這是一排新修的城牆，今天已經逛夠城牆了，時間也不夠，于是繼續趕路。 穿過又窄又爛的土路，深入下八裏村，就是遼代古墓壁畫群，如果不是導航，誰能找到這鬼地方。時間已經是5點後，售票處沒有人，墓道鎖門了，隻能看看園子，看售票處的标價，票價要50￥，比滿城漢墓黑多了。不過這種地方遊人很少，即便白天來，一個人逛古墓是一種什麽樣的體驗？或者如何優雅的和古人神交？這是知乎看多了。 D2 草沿天路第二天，早五點起床，奔天路東線，從張北野狐嶺入，崇禮桦皮嶺出。 現在這條路知名度越來越高，來的人很多，七點多到的時候，野狐嶺入口的一段路，車就已經一輛接一輛了。路的兩邊越來越多地被開發旅遊項目，中國旅遊模式正在再次被複制，草原旅遊就那麽幾項，燒烤、騎馬、射箭、沙灘摩托，毫無新意，而且同質化嚴重。使天路出名的原生态自然風光，正在慢慢消退。 費用北京到宣化過路費：65￥雞鳴驿門票：35￥鎮朔樓門票：5￥宣化經天路回北京過路費：120￥加油：416￥","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://0x3f.org/tags/旅行/"},{"name":"自駕","slug":"自駕","permalink":"http://0x3f.org/tags/自駕/"},{"name":"古墓","slug":"古墓","permalink":"http://0x3f.org/tags/古墓/"},{"name":"草原","slug":"草原","permalink":"http://0x3f.org/tags/草原/"},{"name":"古城","slug":"古城","permalink":"http://0x3f.org/tags/古城/"}]},{"title":"變形金剛：電影4領袖級大黃蜂","slug":"tf-m4-leader-class-bumble-bee","date":"2015-08-01T10:30:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/tf-m4-leader-class-bumble-bee/","link":"","permalink":"http://0x3f.org/post/tf-m4-leader-class-bumble-bee/","excerpt":"","text":"當電影2那堆玩具已經成為神物，入個4的L級大黃蜂也未嘗不是一種自我安慰。 電影4的L級BB是3的同模異涂，但是閹割了武器背包，也就是說，這貨沒有聲光效果！雖然3的背包很雞肋，但是本著先看有沒有，再看好不好的原則，4的玩具再一次見證了大縮水時代，我不敢想下一代會做成什麼樣。多麼懷念那個連D級玩具都遠超現在L級的時代。 雖然電影2的U級和戰刃是公認最經典的BB模具，退而求其次，3的模具也不錯。人形很有層次感和曲線感。塗裝較3有改進的地方，黑色部件的引入增強了色彩對比，比3的非灰即黃要好很多；最大的亮點是臉和觸角的銀柒塗裝，3的灰臉看著像骷髏頭，很恐怖。不過退步和進步一樣明顯，首先面具改成了V形描邊，遠不如之前的面部橫描好看，現在一點都不想把面具拉下來了；此外，腳尖沒有涂色也是個敗筆。 頭雕的細節刻畫不錯，還是BB一貫的嗪奶嘴的骷髏頭，面具的塗裝也很差，銀柒塗裝是唯一能挽回點兒顏面的地方。 手臂採用非對稱設計，右手手炮，左手是個半假手，只有大拇指可動，什麼都握不住，只是個擺設，看看當年電影2的D級的戰刃，完全不能比啊。 腳的設計很漂亮，不過雖然看起來支撐面很大，但由於踝關節不可左右擺動，導致接地性不好。 所有BB模具都不能解決的大背包，現在似乎已經成為BB的特征了，好吧，即便接受這一點，這一整塊棺材板好意思跟戰刃的兩級背板比麼？ 關節的鬆緊度沒有問題，可動性也不錯，不過腰部不能轉，頭部只能左右轉，不能抬頭、低頭。 武器就是右手手炮，這貨沒有任何配件，如果說噱頭的話，也就是手炮可以拉長和縮短，這點連D級玩具都不如啊。 載具形態也不錯，滾動性良好，可以擺出3的武裝爆甲的形態，但是武裝呢？！ 底部隱藏度一般，似乎電影系所有BB都有頭無法隱藏的問題。 最後放一張3的武裝爆甲照，緬懷BB入宮前的崢嶸歲月。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"玩物","slug":"玩物","permalink":"http://0x3f.org/tags/玩物/"},{"name":"變形金剛","slug":"變形金剛","permalink":"http://0x3f.org/tags/變形金剛/"}]},{"title":"自駕白石山、滿城漢墓（201507）","slug":"a-drive-to-baishi-mountain-and-a-kings-tomb-of-han","date":"2015-07-29T12:15:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/a-drive-to-baishi-mountain-and-a-kings-tomb-of-han/","link":"","permalink":"http://0x3f.org/post/a-drive-to-baishi-mountain-and-a-kings-tomb-of-han/","excerpt":"","text":"行程D1：北京到白石山，爬山，到滿城住宿。D2：看滿城漢墓，回京。 D1 白石山原計劃早上6點出發，該死的拖延症，收拾東西花了點時間，七點多才走。 途徑南六環、京石高速、廊涿高速、張石高速。易縣以後進入山區，隧道又多又長，本着不超速、不随意變道、做中國好司機的原則，走得比較慢，十點多才到涞源。涞源出口很窄，堵了二十分鍾。出高速到景區已經不遠了，在東門停車場停好車。 來前天氣預報說有小雨，心說很好啊，我就喜歡下着小雨爬山，所以沒帶速幹帽，結果是個悶熱天兒，我去。 十點四十，出發。我的藝名叫不逃票不舒服斯基，因爲走正門太low了。不過逃票要早上四五點走野路，時間緊，任務重，還是low吧。頭一天同程訂的門票，比現買便宜十塊，據說發表評價再退十塊。坐擺渡車到祥雲門，也可以坐索道。然後順時針走環線。 山裏大部分路口都是局部路标，帶張完整的路線圖還是有必要的。 我對所有以“傳說”開頭介紹的東西不感冒，總之這個塑像是環線的起點和終點。 一開始就走下坡，沿着峽壁的棧道下到飛狐峽，這一線主要是峽谷半山的棧道，是全環線最好的一段，我喜歡峽谷。 飛狐峽走的人少，多數時間太陽不直曬，風吹着，涼快。 我喜歡峽谷。 每個山谷都應該有一條河，可惜。 逆風如解意，容易莫摧殘。 仙人曬靴。不喜歡這種附會的東西。 太行之神。這貨跟神有一毛錢關系麽。 好吧，這才是重點，玻璃棧道。一點兒都不吓銀，而且很短，而且收費，看我的斯卡帕美不美。 回望走過的棧道，敢問路在何方。 過了玻璃棧道就是雙雄石，好内涵的名字，剩下的路已經不多了，而且都是平路。 豬八戒背媳婦兒。雖然附會，确實比較像，就是這媳婦兒砢碜了點兒。 走一圈環線用了4個小時。剛下山，到停車場，毫無征兆的一場暴雨，這酸爽，山裏的天氣真是孩子臉。 驅車奔滿城，走高速要繞很遠，于是奔S332，看地圖隻有一百多公裏。結果又幹了三個多小時，天落黑才到酒店。 剛開始的一段路還可以。小公路在太行山裏蜿蜒，重山夾路，車少，路況也不錯，偶爾掠過幾個石築的村落，甚至有牧人和羊群鑲嵌在陡峭的青山上，恍如隔世。 中間一段路況很差，再往下走，人煙逐漸增多，更多的是成群結隊的重卡，很耽誤時間，有時候走着走着停了，還以爲前面堵車了，哪知道這孫子站路中間噓噓呢，知道燕趙民風骠悍，沒想到這麽骠悍。省道真練技術。 D2 滿城漢墓我喜歡破破爛爛的地方，滿城漢墓早在我的怨念單裏。漢墓十墓九空，唯獨這個是極少沒被盜過的之一，光這個墓的陪葬，撐起了整個河北省博物館。另外墓主人很有名，中山靖王，漢景帝庶子，漢武帝異母兄，劉備号稱的祖宗。平生三大愛好，喝酒、吃肉、叮叮當當造小人兒。《史記》載其有子百二十人，按照正态分布，女兒也得有百二十人，劉營長辛苦。 景區大門，我喜歡人少的地方。頭一天在同程上訂好的園區門票、窦绾墓、劉勝墓的聯票，比現買便宜十塊，一個景點分段收費，旅遊業非常黑。 石像生和翁仲應該不是漢墓的原物。 有索道，不過山不高，沒必要。 夫人窦绾墓在靖王墓北一百多米處，容積比靖王墓大，大概是靖王死在先，窦绾墓多施工了幾年。 墓門用磚砌牆，然後注入熔鐵封死。倒這樣的鬥确實不容易。 窦绾墓平面圖。仿宮殿式布局，兩個耳室一存車馬，一存飲食。中室是客廳。側室是帶浴室的主卧。 墓道裏非常涼快，和外面完全兩個世界。兩千年前的人，先用火灼燒石壁，再用水激，最後用鐵器鑿掉碎石，這樣的工藝也算是巧奪天工了。 南耳室是車庫。 北耳室存放飲食。 中室灰常大。 滲水井和室内排水溝相連，組成很完善的排水系統。 金縷玉衣，仿品。 側室，窦绾的金縷玉衣和傳說中的長信宮燈原本停放在這裏。 靖王墓的容積雖然比窦绾墓小，不過規制似乎更大。中室有木瓦結構的建築，卧室在中室正後方，卧室後甚至有回廊。 中室内的木瓦建築，象征宴會廳。 南耳室，車庫。 北耳室，倉庫。 中室，宴會廳。 後室回廊。 後室，劉勝的金縷玉衣和傳說中的錯金博山爐原本停放在這裏。 費用北京到白石山高速過路費：95￥白石山門票：140￥白石山停車費：20￥白石山擺渡車票：20￥×2滿城漢墓門票：65￥滿城漢墓停車費：10￥加油：233￥保定到北京高速過路費：75￥","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://0x3f.org/tags/旅行/"},{"name":"自駕","slug":"自駕","permalink":"http://0x3f.org/tags/自駕/"},{"name":"爬山","slug":"爬山","permalink":"http://0x3f.org/tags/爬山/"},{"name":"古墓","slug":"古墓","permalink":"http://0x3f.org/tags/古墓/"}]},{"title":"Swoole與PHP-FPM性能對比","slug":"swoole-vs-php-fpm","date":"2015-07-14T08:40:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/swoole-vs-php-fpm/","link":"","permalink":"http://0x3f.org/post/swoole-vs-php-fpm/","excerpt":"","text":"測試環境： CPU: Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz MEM: 4G OS: Archlinux 64bit 測試命令： 1ab -c 200 -n 200000 -k http://127.0.0.1/test NGINX + PHP-FPMRequests per second: 16240.50 [#/sec] (mean)Time per request: 12.315 [ms] (mean) NGINX + SwooleRequests per second: 31284.57 [#/sec] (mean)Time per request: 6.393 [ms] (mean) SwooleRequests per second: 99926.55 [#/sec] (mean)Time per request: 2.001 [ms] (mean) 結論對一個最簡單的PHP腳本做測試，排除業務邏輯的消耗的影響。Swoole威武。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"swoole","slug":"swoole","permalink":"http://0x3f.org/tags/swoole/"}]},{"title":"變形金剛：KO電鍍嘴炮OP","slug":"transformers-optimus-prime-ko-edition","date":"2015-06-22T12:35:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/transformers-optimus-prime-ko-edition/","link":"","permalink":"http://0x3f.org/post/transformers-optimus-prime-ko-edition/","excerpt":"","text":"嘴炮OP這個模具應該是電影系列十年來最好的模具，經典到一再複刻和改模，和原色雙刀、DA28一起都屬同模或改模版本。相比之下，這款模具在塗裝上勝過同模其它版本，電鍍件和銀柒使人形、車形在色彩上對比鮮明，和銀色飛翼搭配很自然。 人形正面比例協調，領袖級的大小更顯霸氣。腰部和小腿部的兩對輪子太累贅，腰部的輪子完全可以設計成收納到腰裡。 塗裝上，除紅藍主色調外，其它位置主要填充銀色金屬柒，對比鮮明，很有質感。 上下肢都採用齒輪關節，關節的鬆緊度方面表現很好。除了腰部不能轉動，四肢和頭部的轉動輻度都很大。 作為一款經典的L級模具，手居然是假手，很不可理解。 踝關節可以左右擺動，所以腳的接地性沒有問題，不過全身最大的兩塊電鍍件居然踩在腳底板當鞋墊，真是無語了。 這款模具之所以叫嘴炮OP，就是因為有嘴有炮。一般OP的模具的頭雕都是帶口罩的，而這款是露嘴的。其實我更喜歡帶口罩的形象，機器人要嘴沒什麼用，尤其像大黃蜂那種嗪奶頭的嘴，見一次吐一次。 頭雕很精細，細節的刻畫和塗裝都很到位，隻是這長了鳃的OP是要配合天火馬甲搞個海陸空三棲麼。 背包不算大，不過還是過於突兀，尤其是這交叉的造型個人覺得很難看。 炮是由兩個油箱組合變形而成，雖然炮形比較奇葩，但是構思確實很新穎。 受G1動畫的影響，我覺得樸實無華的平頭卡車更能顯現OP的威嚴，電影版的狗頭卡車多少有點浮誇。不過從還原電影的角度來說，這款模具的載具形態還是很不錯的。尤其是兩部分電鍍件，遮光闆和進氣面闆，非常閃亮。白色描邊的火焰紋的刻畫也很到位。 由於車輪沒有卡扣固定，並且有的車輪不能著地，所以載具形態的滾動性不好。 L級模具的噱頭一般是聲光效果。這款模具有三個，一是人形狀态下，扳下腹部機關，胸甲聳起的同時，胸部和眼睛會亮，OP喊：“I am Optimus Prime !”（其實不如喊那句最經典的：“Autobots, transform and roll out !”，向G1緻敬會讓很多人喪失抵抗力……）；第二個是人形變車形時，上半身和下半身分離時，發出叽叽咔叽的變形音效；第三個是在車形狀态下，扳動車頭背部的開關，發出機槍掃射的聲音。平心而論，這款模具的聲光效果設計得還是不錯的，人形、變形、車形三種狀态都有照顧，不像變3的L級大黃蜂，所有聲光效果都在那個巨大無比的雞肋背包上。 把玩性方面，由于体形较大，变形复杂度高，把玩起来流畅度并不高，不过这是L级模具的通病。 此外，KO版的普遍問題都有，像左遮光闆卡不緊、胸甲滑動不流暢。 總之，這款KO雙刀電鍍嘴炮OP在模具、塗裝、做工、用料等各方面的表現都不錯，非神物而神物，壓箱底還是可以勝任的。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"玩物","slug":"玩物","permalink":"http://0x3f.org/tags/玩物/"},{"name":"變形金剛","slug":"變形金剛","permalink":"http://0x3f.org/tags/變形金剛/"}]},{"title":"PHP擴展框架的創建","slug":"create-php-extension-skeleton","date":"2015-06-18T06:15:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/create-php-extension-skeleton/","link":"","permalink":"http://0x3f.org/post/create-php-extension-skeleton/","excerpt":"","text":"創建項目在PHP源碼目錄下的ext目錄下執行： 1./ext_skel --extname=foobar 修改foobar/config.m4，移除以下三行前的dnl： dnl PHP_ARG_WITH(foobar, for foobar support,dnl Make sure that the comment is aligned:dnl [ –with-foobar Include foobar support]) 編譯與安裝在foobar目錄下執行以下命令，生成configure腳本： 1/usr/bin/phpize 執行configure： 1./configure --with-php-config=/usr/bin/php-config 編譯安裝： 1sudo make install 修改php.ini，啟用擴展： 1extension=foobar.so","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"源碼","slug":"源碼","permalink":"http://0x3f.org/tags/源碼/"}]},{"title":"PHP流的上下文和過濾器的實現","slug":"contexts-and-filters-implementation-of-php","date":"2015-06-15T11:15:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/contexts-and-filters-implementation-of-php/","link":"","permalink":"http://0x3f.org/post/contexts-and-filters-implementation-of-php/","excerpt":"","text":"上下文的實現和應用上下文包含流的選項和流的參數兩部分內容。 1php_stream_context *php_stream_context_alloc(void); 流的選項是一系列鍵值對。 123int php_stream_context_set_option(php_stream_context *context, const char *wrappername, const char *optionname, zval *optionvalue);int php_stream_context_get_option(php_stream_context *context, const char *wrappername, const char *optionname, zval ***optionvalue); 流的參數目前只實現對流的事件的回調，php_stream_context-&gt;notifier存儲如下結構： 1234567typedef struct &#123; php_stream_notification_func func; void (*dtor)(php_stream_notifier *notifier); void *ptr; int mask; size_t progress, progress_max;&#125; php_stream_notifier; 回調函數的原型為： 12345typedef void (*php_stream_notification_func)(php_stream_context *context, int notifycode, int severity, char *xmsg, int xcode, size_t bytes_sofar, size_t bytes_max, void * ptr TSRMLS_DC); notifycode包含如下： PHP_STREAM_NOTIFY_RESOLVE：主機名解析完成 PHP_STREAM_NOTIFY_CONNECT：socket連接建立 PHP_STREAM_NOTIFY_AUTH_REQUIRED：需要驗證 PHP_STREAM_NOTIFY_MIME_TYPE_IS：遠程資源的MIME-Type可用 PHP_STREAM_NOTIFY_FILE_SIZE_IS：遠程資源的大小可用 PHP_STREAM_NOTIFY_REDIRECTED：原始地址被跳轉 PHP_STREAM_NOTIFY_PROGRESS：php_stream_notifier-&gt;progress和progress_max（可能的）已更新 PHP_STREAM_NOTIFY_COMPLETED：流中已無可用數據 PHP_STREAM_NOTIFY_FAILURE：請求失敗 PHP_STREAM_NOTIFY_AUTH_RESULT：遠程驗證已完成，並且可能是成功的 severity包含如下： PHP_STREAM_NOTIFY_SEVERITY_INFO PHP_STREAM_NOTIFY_SEVERITY_WARN PHP_STREAM_NOTIFY_SEVERITY_ERR php_stream_notifier-&gt;ptr用於存儲附加數據，如果該數據需要手工回收，需指定php_stream_notifier-&gt;dtor。 php_stream_notifier-&gt;mask如果被賦值severity，其它severity的事件將不會觸發回調函數。 過濾器的實現和應用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include \"ext/standard/php_string.h\"typedef struct &#123; char is_persistent; char *from_chars; char *to_chars; int tr_len;&#125; php_donie_filter_data;static php_stream_filter_status_t php_donie_stream_filter( php_stream *stream, php_stream_filter *thisfilter, php_stream_bucket_brigade *buckets_in, php_stream_bucket_brigade *buckets_out, size_t *bytes_consumed, int flags TSRMLS_DC) &#123; php_donie_filter_data *data = thisfilter-&gt;abstract; php_stream_bucket *bucket; size_t consumed = 0; while(buckets_in-&gt;head) &#123; bucket = php_stream_bucket_make_writeable(buckets_in-&gt;head TSRMLS_CC); php_strtr(bucket-&gt;buf, bucket-&gt;buflen, data-&gt;from_chars, data-&gt;to_chars, data-&gt;tr_len); consumed += bucket-&gt;buflen; php_stream_bucket_append(buckets_out, bucket TSRMLS_CC); &#125; if (bytes_consumed) &#123; *bytes_consumed = consumed; &#125; return PSFS_PASS_ON;&#125;static void php_donie_stream_filter_dtor( php_stream_filter *thisfilter TSRMLS_DC) &#123; php_donie_filter_data *data = thisfilter-&gt;abstract; pefree(data, data-&gt;is_persistent);&#125;static php_stream_filter_ops php_donie_stream_filter_ops = &#123; php_donie_stream_filter, php_donie_stream_filter_dtor, \"donie.to_upper_case\"&#125;;static php_stream_filter *php_donie_stream_filter_create( const char *name, zval *param, int persistent TSRMLS_DC) &#123; php_donie_filter_data *data; data = pemalloc(sizeof(php_donie_filter_data), persistent); if (!data) &#123; return NULL; &#125; data-&gt;is_persistent = persistent; data-&gt;from_chars = \"abcdefghijklmnopqrstuvwxyz\"; data-&gt;to_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; data-&gt;tr_len = strlen(data-&gt;from_chars); return php_stream_filter_alloc(&amp;php_donie_stream_filter_ops, data, persistent);&#125;static php_stream_filter_factory php_donie_stream_uppercase_factory = &#123; php_donie_stream_filter_create&#125;;PHP_MINIT_FUNCTION(donie)&#123; /* register a filter */ php_stream_filter_register_factory(\"donie.to_upper_case\", &amp;php_donie_stream_uppercase_factory TSRMLS_CC); return SUCCESS;&#125;PHP_MSHUTDOWN_FUNCTION(donie)&#123; /* unregister the filter */ php_stream_filter_unregister_factory(\"donie.to_upper_case\" TSRMLS_CC); return SUCCESS;&#125; 註冊和註銷分別在MINIT和MSHUTDOWN函數中調用php_stream_filter_register_factory()和php_stream_filter_unregister_factory()註冊和註銷過濾器。 過濾器的執行過程當過濾器被調用時，調用方將使用php_donie_stream_filter_create()函數創建過濾器的實例。該函數在被執行時初始化過濾器的相關數據，並指定過濾器的相關操作。 調用方然後將過濾器實例添加到對應的流的讀過濾器鏈或寫過濾器鏈中，當流中發生讀或寫的操作時，過濾器鏈將數據放到一或多個php_stream_bucket結構中，並傳遞給過濾器處理。 業務邏輯結構體php_donie_stream_filter_ops指定了過濾器的名稱和相關業務邏輯。php_donie_stream_filter_ops-&gt;php_donie_stream_filter_dtor是過濾器的析構函數。php_donie_stream_filter_ops-&gt;php_donie_stream_filter是過濾器的主要業務邏輯。 在php_donie_stream_filter()中，函數接收一個php_stream_bucket鏈表buckets_in，並將處理後的php_stream_bucket追加到鏈表buckets_out中輸出。 php_stream_bucket_make_writeable()將一個bucket從鏈表中移除，如果必要，複製其內部緩衝數據，以獲得對內容的寫權限。此外，對bucket的相關操作還有： 1234567891011php_stream_bucket *php_stream_bucket_new(php_stream *stream, char *buf, size_t buflen, int own_buf, int buf_persistent TSRMLS_DC);int php_stream_bucket_split(php_stream_bucket *in, php_stream_bucket **left, php_stream_bucket **right, size_t length TSRMLS_DC);void php_stream_bucket_delref(php_stream_bucket *bucket TSRMLS_DC);void php_stream_bucket_addref(php_stream_bucket *bucket);void php_stream_bucket_prepend(php_stream_bucket_brigade *brigade, php_stream_bucket *bucket TSRMLS_DC);void php_stream_bucket_append(php_stream_bucket_brigade *brigade, php_stream_bucket *bucket TSRMLS_DC);void php_stream_bucket_unlink(php_stream_bucket *bucket TSRMLS_DC); 若過濾器已準備好輸出的數據，返回PSFS_PASS_ON；若還需要更多數據才能結束過濾操作，返回PSFS_FEED_ME；若遇到嚴重問題，返回PSFS_ERR_FATAL。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"源碼","slug":"源碼","permalink":"http://0x3f.org/tags/源碼/"}]},{"title":"使用gn操作增強Vim的搜索","slug":"enhance-search-with-gn-in-vim","date":"2015-06-14T13:16:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/enhance-search-with-gn-in-vim/","link":"","permalink":"http://0x3f.org/post/enhance-search-with-gn-in-vim/","excerpt":"","text":"gn是Vim 7.4新增的一個操作（motion），作用是跳到並選中下一個搜索匹配項。 具體說，Vim裡執行搜索後，執行n操作只會跳轉到下一個匹配項，而不選中它。但是我們往往需要對匹配項執行一些修改操作，例如替換、刪除或修改大小寫等，如果先跳轉再執行對應操作，會比較繁瑣。gn可以和相應的操作結合，簡化這些過程。 舉個栗子。如果要把所有的win、linux替換成大寫，可以先用正則搜索“\\(win|linux\\)\\C”，然後執行“gUgn”，此時下一個匹配的結果就會被替換成大寫，然後直接執行“.”重複上次操作即可。 此外，常用的組合有： cgn: 刪除下一個匹配項，並進入插入模式。 dgn: 刪除下一個匹配項，並保持常規模式。 和操作“N”相同，執行“gN”是逆向操作。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"在i3wm狀態欄顯示股票信息","slug":"show-stocks-in-i3status","date":"2015-06-12T09:39:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/show-stocks-in-i3status/","link":"","permalink":"http://0x3f.org/post/show-stocks-in-i3status/","excerpt":"","text":"效果如圖： 創建腳本，並賦可執行權限： ~/.i3/myi3status.sh123456789101112131415161718192021#!/bin/sh# shell script to prepend i3status with more stuffSTOCK_SCRIPT=`realpath \"$0\"|xargs dirname`/stock.phpi3status | while :do stock_info=\"\" if [[ -x \"$STOCK_SCRIPT\" ]]; then stock_info=`$STOCK_SCRIPT` fi read line # if output_format = i3bar in i3status.conf stock_info=\"[&#123; \\\"full_text\\\": \\\"$&#123;stock_info&#125;\\\" &#125;,\" echo \"$&#123;line/[/$stock_info&#125;\" || exit 1 # # if not output_format = i3bar in i3status.conf # echo \"$stock_info | $line\" || exit 1done 如果i3status.conf中啟用了JSON格式輸出（支持顏色），應啟用上面腳本中第一塊的代碼，否則使用後面的。啟動JSON格式輸出的內容具體如下： ~/.i3status.conf1234general &#123; colors = true output_format = i3bar&#125; 在i3wm的配置文件中用以上腳本替換i3status： ~/.i3/config12345678910bar &#123; # ... # status_command i3status status_command ~/.i3/myi3status.sh # ...&#125; 在和上面腳本同路徑下創建腳本： ~/.i3/stock.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#!/bin/env php&lt;?phpclass PinYin&#123; public static function utf8To($ss, $isfirst = false) &#123; return self::convert(self::utf8ToGB2312($ss), $isfirst); &#125; public static function utf8ToGB2312($ss) &#123; return iconv('UTF-8', 'GB2312//IGNORE', $ss); &#125; // 字符串必须为GB2312编码 public static function convert($ss, $isfirst = false) &#123; $res = ''; $len = strlen($ss); $pinyinArr = self::get_pinyin_array(); for ($i=0; $i&lt;$len; $i++) &#123; $ascii = ord($ss[$i]); if ($ascii &gt; 0x80) &#123; $asciiB = ord($ss[++$i]); $ascii = $ascii * 256 + $asciiB - 65536; &#125; if ($ascii &lt; 255 &amp;&amp; $ascii &gt; 0) &#123; if (($ascii &gt;= 48 &amp;&amp; $ascii &lt;= 57) || ($ascii &gt;= 97 &amp;&amp; $ascii &lt;= 122)) &#123; $res .= $ss[$i]; // 0-9 a-z &#125; elseif ($ascii &gt;= 65 &amp;&amp; $ascii &lt;= 90) &#123; $res .= strtolower($ss[$i]); // A-Z &#125; else &#123; $res .= '_'; &#125; &#125; elseif ($ascii &lt; -20319 || $ascii &gt; -10247) &#123; $res .= '_'; &#125; else &#123; foreach ($pinyinArr as $py=&gt;$asc) &#123; if ($asc &lt;= $ascii) &#123; $res .= $isfirst ? $py[0] : $py; break; &#125; &#125; &#125; &#125; return $res; &#125; public static function toFirst($ss) &#123; $ascii = ord($ss[0]); if ($ascii &gt; 0xE0) &#123; $ss = self::utf8ToGB2312($ss[0].$ss[1].$ss[2]); &#125; elseif ($ascii &lt; 0x80) &#123; if ($ascii &gt;= 65 &amp;&amp; $ascii &lt;= 90) &#123; return strtolower($ss[0]); &#125; elseif ($ascii &gt;= 97 &amp;&amp; $ascii &lt;= 122) &#123; return $ss[0]; &#125; else &#123; return false; &#125; &#125; if (strlen($ss) &lt; 2) &#123; return false; &#125; $asc = ord($ss[0]) * 256 + ord($ss[1]) - 65536; if($asc&gt;=-20319 &amp;&amp; $asc&lt;=-20284) return 'a'; if($asc&gt;=-20283 &amp;&amp; $asc&lt;=-19776) return 'b'; if($asc&gt;=-19775 &amp;&amp; $asc&lt;=-19219) return 'c'; if($asc&gt;=-19218 &amp;&amp; $asc&lt;=-18711) return 'd'; if($asc&gt;=-18710 &amp;&amp; $asc&lt;=-18527) return 'e'; if($asc&gt;=-18526 &amp;&amp; $asc&lt;=-18240) return 'f'; if($asc&gt;=-18239 &amp;&amp; $asc&lt;=-17923) return 'g'; if($asc&gt;=-17922 &amp;&amp; $asc&lt;=-17418) return 'h'; if($asc&gt;=-17417 &amp;&amp; $asc&lt;=-16475) return 'j'; if($asc&gt;=-16474 &amp;&amp; $asc&lt;=-16213) return 'k'; if($asc&gt;=-16212 &amp;&amp; $asc&lt;=-15641) return 'l'; if($asc&gt;=-15640 &amp;&amp; $asc&lt;=-15166) return 'm'; if($asc&gt;=-15165 &amp;&amp; $asc&lt;=-14923) return 'n'; if($asc&gt;=-14922 &amp;&amp; $asc&lt;=-14915) return 'o'; if($asc&gt;=-14914 &amp;&amp; $asc&lt;=-14631) return 'p'; if($asc&gt;=-14630 &amp;&amp; $asc&lt;=-14150) return 'q'; if($asc&gt;=-14149 &amp;&amp; $asc&lt;=-14091) return 'r'; if($asc&gt;=-14090 &amp;&amp; $asc&lt;=-13319) return 's'; if($asc&gt;=-13318 &amp;&amp; $asc&lt;=-12839) return 't'; if($asc&gt;=-12838 &amp;&amp; $asc&lt;=-12557) return 'w'; if($asc&gt;=-12556 &amp;&amp; $asc&lt;=-11848) return 'x'; if($asc&gt;=-11847 &amp;&amp; $asc&lt;=-11056) return 'y'; if($asc&gt;=-11055 &amp;&amp; $asc&lt;=-10247) return 'z'; return false; &#125; public static function get_pinyin_array() &#123; static $pyArr; if(isset($pyArr)) return $pyArr; $kk = 'a|ai|an|ang|ao|ba|bai|ban|bang|bao|bei|ben|beng|bi|bian|biao|bie|bin|bing|bo|bu|ca|cai|can|cang|cao|ce|ceng|cha|chai|chan|chang|chao|che|chen|cheng|chi|chong|chou|chu|chuai|chuan|chuang|chui|chun|chuo|ci|cong|cou|cu|cuan|cui|cun|cuo|da|dai|dan|dang|dao|de|deng|di|dian|diao|die|ding|diu|dong|dou|du|duan|dui|dun|duo|e|en|er|fa|fan|fang|fei|fen|feng|fo|fou|fu|ga|gai|gan|gang|gao|ge|gei|gen|geng|gong|gou|gu|gua|guai|guan|guang|gui|gun|guo|ha|hai|han|hang|hao|he|hei|hen|heng|hong|hou|hu|hua|huai|huan|huang|hui|hun|huo|ji|jia|jian|jiang|jiao|jie|jin|jing|jiong|jiu|ju|juan|jue|jun|ka|kai|kan|kang|kao|ke|ken|keng|kong|kou|ku|kua|kuai|kuan|kuang|kui|kun|kuo|la|lai|lan|lang|lao|le|lei|leng|li|lia|lian|liang|liao|lie|lin|ling|liu|long|lou|lu|lv|luan|lue|lun|luo|ma|mai|man|mang|mao|me|mei|men|meng|mi|mian|miao|mie|min|ming|miu|mo|mou|mu|na|nai|nan|nang|nao|ne|nei|nen|neng|ni|nian|niang|niao|nie|nin|ning|niu|nong|nu|nv|nuan|nue|nuo|o|ou|pa|pai|pan|pang|pao|pei|pen|peng|pi|pian|piao|pie|pin|ping|po|pu|qi|qia|qian|qiang|qiao|qie|qin|qing|qiong|qiu|qu|quan|que|qun|ran|rang|rao|re|ren|reng|ri|rong|rou|ru|ruan|rui|run|ruo|sa|sai|san|sang|sao|se|sen|seng|sha|shai|shan|shang|shao|she|shen|sheng|shi|shou|shu|shua|shuai|shuan|shuang|shui|shun|shuo|si|song|sou|su|suan|sui|sun|suo|ta|tai|tan|tang|tao|te|teng|ti|tian|tiao|tie|ting|tong|tou|tu|tuan|tui|tun|tuo|wa|wai|wan|wang|wei|wen|weng|wo|wu|xi|xia|xian|xiang|xiao|xie|xin|xing|xiong|xiu|xu|xuan|xue|xun|ya|yan|yang|yao|ye|yi|yin|ying|yo|yong|you|yu|yuan|yue|yun|za|zai|zan|zang|zao|ze|zei|zen|zeng|zha|zhai|zhan|zhang|zhao|zhe|zhen|zheng|zhi|zhong|zhou|zhu|zhua|zhuai|zhuan|zhuang|zhui|zhun|zhuo|zi|zong|zou|zu|zuan|zui|zun|zuo'; $vv = '-20319|-20317|-20304|-20295|-20292|-20283|-20265|-20257|-20242|-20230|-20051|-20036|-20032|-20026|-20002|-19990|-19986|-19982|-19976|-19805|-19784|-19775|-19774|-19763|-19756|-19751|-19746|-19741|-19739|-19728|-19725|-19715|-19540|-19531|-19525|-19515|-19500|-19484|-19479|-19467|-19289|-19288|-19281|-19275|-19270|-19263|-19261|-19249|-19243|-19242|-19238|-19235|-19227|-19224|-19218|-19212|-19038|-19023|-19018|-19006|-19003|-18996|-18977|-18961|-18952|-18783|-18774|-18773|-18763|-18756|-18741|-18735|-18731|-18722|-18710|-18697|-18696|-18526|-18518|-18501|-18490|-18478|-18463|-18448|-18447|-18446|-18239|-18237|-18231|-18220|-18211|-18201|-18184|-18183|-18181|-18012|-17997|-17988|-17970|-17964|-17961|-17950|-17947|-17931|-17928|-17922|-17759|-17752|-17733|-17730|-17721|-17703|-17701|-17697|-17692|-17683|-17676|-17496|-17487|-17482|-17468|-17454|-17433|-17427|-17417|-17202|-17185|-16983|-16970|-16942|-16915|-16733|-16708|-16706|-16689|-16664|-16657|-16647|-16474|-16470|-16465|-16459|-16452|-16448|-16433|-16429|-16427|-16423|-16419|-16412|-16407|-16403|-16401|-16393|-16220|-16216|-16212|-16205|-16202|-16187|-16180|-16171|-16169|-16158|-16155|-15959|-15958|-15944|-15933|-15920|-15915|-15903|-15889|-15878|-15707|-15701|-15681|-15667|-15661|-15659|-15652|-15640|-15631|-15625|-15454|-15448|-15436|-15435|-15419|-15416|-15408|-15394|-15385|-15377|-15375|-15369|-15363|-15362|-15183|-15180|-15165|-15158|-15153|-15150|-15149|-15144|-15143|-15141|-15140|-15139|-15128|-15121|-15119|-15117|-15110|-15109|-14941|-14937|-14933|-14930|-14929|-14928|-14926|-14922|-14921|-14914|-14908|-14902|-14894|-14889|-14882|-14873|-14871|-14857|-14678|-14674|-14670|-14668|-14663|-14654|-14645|-14630|-14594|-14429|-14407|-14399|-14384|-14379|-14368|-14355|-14353|-14345|-14170|-14159|-14151|-14149|-14145|-14140|-14137|-14135|-14125|-14123|-14122|-14112|-14109|-14099|-14097|-14094|-14092|-14090|-14087|-14083|-13917|-13914|-13910|-13907|-13906|-13905|-13896|-13894|-13878|-13870|-13859|-13847|-13831|-13658|-13611|-13601|-13406|-13404|-13400|-13398|-13395|-13391|-13387|-13383|-13367|-13359|-13356|-13343|-13340|-13329|-13326|-13318|-13147|-13138|-13120|-13107|-13096|-13095|-13091|-13076|-13068|-13063|-13060|-12888|-12875|-12871|-12860|-12858|-12852|-12849|-12838|-12831|-12829|-12812|-12802|-12607|-12597|-12594|-12585|-12556|-12359|-12346|-12320|-12300|-12120|-12099|-12089|-12074|-12067|-12058|-12039|-11867|-11861|-11847|-11831|-11798|-11781|-11604|-11589|-11536|-11358|-11340|-11339|-11324|-11303|-11097|-11077|-11067|-11055|-11052|-11045|-11041|-11038|-11024|-11020|-11019|-11018|-11014|-10838|-10832|-10815|-10800|-10790|-10780|-10764|-10587|-10544|-10533|-10519|-10331|-10329|-10328|-10322|-10315|-10309|-10307|-10296|-10281|-10274|-10270|-10262|-10260|-10256|-10254'; $key = explode('|', $kk); $val = explode('|', $vv); $pyArr = array_combine($key, $val); arsort($pyArr); return $pyArr; &#125;&#125;define('STOCKS_FILE', $_SERVER['HOME'].'/.stocks');if (!file_exists(STOCKS_FILE)) &#123; exit('File not found: '.STOCKS_FILE);&#125;$stockCodeArr = explode(\"\\n\", trim(file_get_contents(STOCKS_FILE)));if (empty($stockCodeArr)) &#123; exit('No stock code found.');&#125;$context = stream_context_create( [ 'http'=&gt;[ 'method'=&gt;\"GET\", 'timeout' =&gt; 3 ] ]);$response = file_get_contents(\"http://hq.sinajs.cn/list=\".implode(',', $stockCodeArr), false, $context);if (empty($response)) &#123; exit('Failed fetching stock info with API.');&#125;$result = [];$lines = explode(\"\\n\", trim(iconv('gbk', 'utf-8', $response)));foreach ($lines as $line) &#123; $matches = []; preg_match('/\".*\"/', $line, $matches); if (!empty($matches)) &#123; $stock = explode(',', trim($matches[0], '\"')); if (!empty($stock)) &#123; $result[] = strtoupper(PinYin::utf8To($stock[0], true)).\": &#123;$stock[3]&#125;, &#123;$stock[4]&#125;, &#123;$stock[5]&#125;\"; &#125; &#125;&#125;echo implode('; ', $result); 腳本從~/.stocks中讀取股票代碼： ~/.stocks12sh601985sz002024","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"i3wm","slug":"i3wm","permalink":"http://0x3f.org/tags/i3wm/"},{"name":"股票","slug":"股票","permalink":"http://0x3f.org/tags/股票/"}]},{"title":"PHP流的操作","slug":"stream-operations-of-php","date":"2015-06-01T07:33:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/stream-operations-of-php/","link":"","permalink":"http://0x3f.org/post/stream-operations-of-php/","excerpt":"","text":"實現123456789101112131415161718192021/* reimplement fopen using stream */ZEND_FUNCTION(donie_stream_fopen)&#123; php_stream *stream; char *path, *mode; int path_len, mode_len; int options = ENFORCE_SAFE_MODE|REPORT_ERRORS; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &amp;path, &amp;path_len, &amp;mode, &amp;mode_len) == FAILURE) &#123; return; &#125; stream = php_stream_open_wrapper(path, mode, options, NULL); if (!stream) &#123; RETURN_FALSE; &#125; php_stream_to_zval(stream, return_value);&#125; php_stream_open_wrapper()是對文件類型資源創建流的方法，此外還有基於socket的流、目錄流和特殊流三種。php_stream_to_zval()用於把流實例轉換成zval結構。 創建文件類型的流12#define php_stream_open_wrapper(path, mode, options, opened) _php_stream_open_wrapper_ex((path), (mode), (options), (opened), NULL STREAMS_CC TSRMLS_CC)#define php_stream_open_wrapper_ex(path, mode, options, opened, context) _php_stream_open_wrapper_ex((path), (mode), (options), (opened), (context) STREAMS_CC TSRMLS_CC) 參數path是文件名或URL，mode是模式字符串，options是選項組合。php_stream_open_wrapper_ex()允許指定一個流的上下文。 options包含以下選項： USE_PATH：應用ini中的include_path到相對路徑。內建的fopen()的第三個參數置True時使用此選項。 STREAM_USE_URL：只有遠程URL才允許打開，%%file://, php://, compress.zlib://%%這樣的本地URL會報錯。 ENFORCE_SAFE_MODE：只有設置了此選項且ini中的safe_mode開啟時，才會使safe_mode生效，不設置此選項，則不論ini中是否開啟都不會生效。 REPORT_ERRORS：若開啟流出錯，生成錯誤信息。 STREAM_MUST_SEEK：不是所有流都允許seek，若置此選項，且流不允許seek，則包裝器不會開啟流。 STREAM_WILL_CAST：置此參數將要求流可被轉換成posix或stdio類型的文件描述符，若流不可轉換，可在IO開始前失敗。 STREAM_ONLY_GET_HEADERS：http包裝器使用此參數，只獲取資源的元數據，不獲取內容。 STREAM_DISABLE_OPEN_BASEDIR：當ini中的open_basedir開啟時，置此參數跳過open_basedir檢查。 STREAM_OPEN_PERSISTENT：要求流和相關資源都創建為持久數據。 IGNORE_PATH：不從include_path中搜索。 IGNORE_URL：只有本地文件才可以被打開。 創建傳輸類型的流1php_stream *_php_stream_xport_create(const char *name, size_t namelen, int options, int flags, const char *persistent_id, struct timeval *timeout, php_stream_context *context, char **error_string, int *error_code) 參數： name：URL。 options：參數，與php_stream_open_wrapper()的相同。 flags：STREAM_XPORT_CLIENT或STREAM_XPORT_SERVER與其它STREAMXPORT*常量的組合。 persistent_id：鍵值，置此參數將使流在多次請求間持久存在。 timeout：置NULL將使用ini中設置的值。 errstr：用於向外傳遞錯誤信息，初始應置為NULL，若有錯誤信息傳出，調用方有責任釋放錯誤信息佔用的內存。 errcode：錯誤碼。 flags： STREAM_XPORT_CLIENT：工作為客戶端，向遠程發起連接。 STREAM_XPORT_SERVER：工作為服務器，接受連接。 STREAM_XPORT_CONNECT：傳輸建立的同時發起對遠程的連接，否則，需手動調用php_stream_xport_connect()。 STREAM_XPORT_CONNECT_ASYNC：發起異步遠程連接。 STREAM_XPORT_BIND：将传输流绑定到本地资源. 用在服务端传输流时,这将使得accept连接的传输流准备端口, 路径或特定的端点标识符等信息。 STREAM_XPORT_LISTEN：%%Listen for inbound connections on the bound transport endpoint. This is typically used with stream-based transports such as tcp://, ssl://, and unix://%%. 創建目錄類型的流1php_stream php_stream_opendir(const char *path, int options, php_stream_context *context) 創建特殊類型的流12345php_stream *php_stream_fopen_tmpfile(void);php_stream *php_stream_fopen_temporary_file(const char *dir, const char *pfx, char **opened_path);php_stream *php_stream_fopen_from_fd(int fd, const char *mode, const char *persistent_id);php_stream *php_stream_fopen_from_file(FILE *file, const char *mode);php_stream *php_stream_fopen_from_pipe(FILE *file, const char *mode); 讀流123456789101112131415// 讀一個字符int php_stream_getc(php_stream *stream);// 讀取指定數量的字符size_t php_stream_read(php_stream *stream, char *buf, size_t count);// 讀取直到行末、或流末、或最多maxlen個字符char *php_stream_get_line(php_stream *stream, char *buf, size_t maxlen, size_t *returned_len);char *php_stream_gets(php_stream *stream, char *buf, size_t maxlen);// 與php_stream_get_line相同，可指定截止標記char *php_stream_get_record(php_stream *stream, size_t maxlen, size_t *returned_len, char *delim, size_t delim_len TSRMLS_DC);// 讀取一個目錄項php_stream_dirent *php_stream_readdir(php_stream *dirstream, php_stream_dirent *entry); 寫流123456789// 寫非阻塞流可能寫入的數據比傳入的短；_string要求傳入的字符串以NULL結尾size_t php_stream_write(php_stream *stream, char *buf, size_t count);size_t php_stream_write_string(php_stream *stream, char *stf);int php_stream_putc(php_stream *stream, int c);// 與_string不同的是會自動追加一個換行符到字符串末尾int php_stream_puts(php_string *stream, char *buf);size_t php_stream_printf(php_stream *stream TSRMLS_DC, const char *format, ...); 1int php_stream_flush(php_stream *stream); 在關閉流的時候，flush會被自動調用，並且大部分無過濾的流因無內部緩沖而不需flush，所以單獨flush一般是不需要的。 尋址1234int php_stream_seek(php_stream *stream, off_t offset, int whence);int php_stream_rewind(php_stream *stream);int php_stream_rewinddir(php_stream *dirstream);off_t php_stream_tell(php_stream *stream); offset是相對於whence的位移量，whence包含： SEEK_SET：文件開頭。置offet為負值被認為是個錯誤並導致不可預料的行為。offset超出文件範圍會導致一個錯誤，或文件被增大。 SEEK_CUR：當前位置。 SEEK_END：文件末尾。offset一般為負，正值的行為因流的實現而異。 獲取額外信息1int php_stream_stat(php_stream *stream, php_stream_statbuf *ssb); 關閉流12#define php_stream_close(stream) php_stream_free((stream), PHP_STREAM_FREE_CLOSE)#define php_stream_pclose(stream) php_stream_free((stream), PHP_STREAM_FREE_CLOSE_PERSISTENT) 包含以下選項： PHP_STREAM_FREE_CALL_DTOR：銷毀流時調用php_stream-&gt;ops-&gt;close PHP_STREAM_FREE_RELEASE_STREAM：銷毀流時調用php_stream_wrapper-&gt;ops-&gt;stream_close PHP_STREAM_FREE_PRESERVE_HANDLE：php_stream-&gt;ops-&gt;close不銷毀句柄 PHP_STREAM_FREE_RSRC_DTOR：用於流內部資源列表垃圾回收 PHP_STREAM_FREE_PERSISTENT：用於持久流，所有操作的結果在多次請求間持久有效 PHP_STREAM_FREE_CLOSE：CALL_DTOR和RELEASE_STREAM的組合，用於非持久流的常規選項 PHP_STREAM_FREE_CLOSE_CASTED：CLOSE和PRESERVE_HANDLE的組合 PHP_STREAM_FREE_CLOSE_PERSISTENT：CLOSE和PERSISTENT的組合，用於持久流的常規選項","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"源碼","slug":"源碼","permalink":"http://0x3f.org/tags/源碼/"}]},{"title":"變形金剛：祖國合金放大版探長","slug":"hound-of-transformers-4","date":"2015-05-31T09:39:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/hound-of-transformers-4/","link":"","permalink":"http://0x3f.org/post/hound-of-transformers-4/","excerpt":"","text":"探長可以和平頭OP並列變四最好的模具，人形和車形俱佳。但是官版的V級神物實在雞肋，所以祖國版准L級模具實在是拯救巨大控的好物。除了放大，探長的整個車頭都是合金件，既有質感又有份量。涂裝較官版也有改進，胸甲和輪軲上了銀柒，槍管上了金柒，車形後部增加了火焰紋，不像官版那麼素。最重要的是祖國版的做工很好，關節鬆緊適度，車形閉合得很好。 祖國版的探長目前有三個版本，普通版、叼煙版和藍色版。普通版和官版是一致的。叼煙版的頭雕是叼著煙的。藍色版的外形和普通版一樣，但是涂成了深藍色，而且附送兩個塑料小人。我最喜歡的叼煙版，不知道帝都禁煙後還能不能買到…… 雖然祖國版整體而言是很好的東東，不過廠家的品控做得很不好，我玩兒過幾個實體才挑到合適的，有的車頭背部塑料板開盒就是爛的，有的輪軲個別沒有涂銀柒，比較普遍的現象是大槍插不進背部凹槽，還有個別關節比較松。所以買祖國版還是蠻拼人品的。 人形體格勻稱，沒有背包，除了門板手外，沒有累贅部件，雖然門板可以卸掉，但並沒有地方收納。 頭雕精細度一般，不過雪茄的加入是個大大的加分項。 塗裝方面，用軍綠色作為基色，銀灰搭配，很不錯。 雖然沒有用到齒輪關節，不過鬆緊度都很好。腿部向前可以平抬，不能後踢。由於膝關節較高，做不了跪姿。腰部可以360度旋轉。手臂大風車沒有問題。頭部可以左右轉動很小的角度，不能抬頭、低頭。 前腳掌可以左右擺動，提供了一定的接地性。 一般比較用心的模具都會在可玩性上加一個噱頭，比如平頭OP的槍是可以發射子彈的。探長的噱頭就是組合武器，拼裝後的大槍還是很霸氣的，只是一只手舉不起來，必須雙手托槍。武器的收納方面做得很好，無論是人形還是載具形態，都可以完美收納所有武器。 拆開掛滿身，不愧是個武器庫。 車形的原型是奧什科什防務軍用戰術裝甲車，也非常帥。有兩個輪子不能著地，不過整體滾動性不錯。 武器的偷膠有點過頭，胯部的兩把槍和大槍都有很大程度的偷膠，這是個很大的扣分項。 玩具變形流暢，把玩性的表現非常好。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"玩物","slug":"玩物","permalink":"http://0x3f.org/tags/玩物/"},{"name":"變形金剛","slug":"變形金剛","permalink":"http://0x3f.org/tags/變形金剛/"}]},{"title":"PHP流的實現","slug":"stream-implementation-in-php","date":"2015-05-29T09:33:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/stream-implementation-in-php/","link":"","permalink":"http://0x3f.org/post/stream-implementation-in-php/","excerpt":"","text":"流的概念流是一系列概念的集合，包括流包裝器、流資源、流操作、上下文等內容。流是對不同資源進行操作的抽象，允許線性地從指定位置讀取或寫入數據，通過一套統一的API簡化對資源操作的實現。 流由scheme://target指代，scheme是包裝器（Wrapper）的名字，target是流的目標地址。 PHP的流的實現較Java簡單，後者可以通過嵌套實現更靈活的應用。 流的實現存儲結構123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct _php_stream &#123; php_stream_ops *ops; void *abstract; /* convenience pointer for abstraction */ php_stream_filter_chain readfilters, writefilters; php_stream_wrapper *wrapper; /* which wrapper was used to open the stream */ void *wrapperthis; /* convenience pointer for a instance of a wrapper */ zval *wrapperdata; /* fgetwrapperdata retrieves this */ int fgetss_state; /* for fgetss to handle multiline tags */ int is_persistent; char mode[16]; /* \"rwb\" etc. ala stdio */ int rsrc_id; /* used for auto-cleanup */ int in_free; /* to prevent recursion during free */ /* so we know how to clean it up correctly. This should be set to * PHP_STREAM_FCLOSE_XXX as appropriate */ int fclose_stdiocast; FILE *stdiocast; /* cache this, otherwise we might leak! */#if ZEND_DEBUG int __exposed; /* non-zero if exposed as a zval somewhere */#endif char *orig_path; php_stream_context *context; int flags; /* PHP_STREAM_FLAG_XXX */ /* buffer */ off_t position; /* of underlying stream */ unsigned char *readbuf; size_t readbuflen; off_t readpos; off_t writepos; /* how much data to read when filling buffer */ size_t chunk_size; int eof;#if ZEND_DEBUG const char *open_filename; uint open_lineno;#endif struct _php_stream *enclosing_stream; /* this is a private stream owned by enclosing_stream */&#125;; /* php_stream */typedef struct _php_stream_ops &#123; /* stdio like functions - these are mandatory! */ size_t (*write)(php_stream *stream, const char *buf, size_t count TSRMLS_DC); size_t (*read)(php_stream *stream, char *buf, size_t count TSRMLS_DC); int (*close)(php_stream *stream, int close_handle TSRMLS_DC); int (*flush)(php_stream *stream TSRMLS_DC); const char *label; /* label for this ops structure */ /* these are optional */ int (*seek)(php_stream *stream, off_t offset, int whence, off_t *newoffset TSRMLS_DC); int (*cast)(php_stream *stream, int castas, void **ret TSRMLS_DC); int (*stat)(php_stream *stream, php_stream_statbuf *ssb TSRMLS_DC); int (*set_option)(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC);&#125; php_stream_ops; php_stream結構體最重要的成員是ops和abstract。ops包含了流實例的所有操作邏輯，特別地，php_stream_ops-&gt;close在php_stream結構被回收前提供了回收與該流實例相關的資源的機會。abstract用來存儲一個自定義結構的數據，在流的操作邏輯裡可以方便的訪問。 實現1234567891011121314151617181920212223242526272829303132333435363738#define PHP_DONIESTREAM_STREAMTYPE \"doniestream\"static size_t php_doniestream_write(php_stream *stream, const char *buf, size_t count TSRMLS_DC)&#123; donie_stream_data *data = stream-&gt;abstract; php_printf(\"Write to stream: %s\\n\", buf); return count;&#125;static size_t php_doniestream_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)&#123; donie_stream_data *data = stream-&gt;abstract; zval **val; size_t read_size = count; php_printf(\"Read from stream: %s\\n\", data-&gt;key); return read_size;&#125;static int php_doniestream_close(php_stream *stream, int close_handle TSRMLS_DC)&#123; donie_stream_data *data = stream-&gt;abstract; efree(data-&gt;key); efree(data); return 0;&#125;static php_stream_ops php_doniestream_ops = &#123; php_doniestream_write, php_doniestream_read, php_doniestream_close, NULL, /* flush */ PHP_DONIESTREAM_STREAMTYPE, NULL, /* seek */ NULL, /* cast */ NULL, /* stat */ NULL, /* set_option */&#125;; 主要是流的操作邏輯的實現，最後構建的php_stream_ops結構用於後面流包裝器中初始化流實例時賦給php_stream-&gt;ops。 包裝器的實現Wrapper是對某一協議的封裝，主要包含對該類型的流的一系列操作邏輯的實現。 存儲結構12345678910111213141516171819202122232425262728struct _php_stream_wrapper &#123; php_stream_wrapper_ops *wops; /* operations the wrapper can perform */ void *abstract; /* context for the wrapper */ int is_url; /* so that PG(allow_url_fopen) can be respected */&#125;;typedef struct _php_stream_wrapper_ops &#123; /* open/create a wrapped stream */ php_stream *(*stream_opener)(php_stream_wrapper *wrapper, const char *filename, const char *mode, int options, char **opened_path, php_stream_context *context STREAMS_DC TSRMLS_DC); /* close/destroy a wrapped stream */ int (*stream_closer)(php_stream_wrapper *wrapper, php_stream *stream TSRMLS_DC); /* stat a wrapped stream */ int (*stream_stat)(php_stream_wrapper *wrapper, php_stream *stream, php_stream_statbuf *ssb TSRMLS_DC); /* stat a URL */ int (*url_stat)(php_stream_wrapper *wrapper, const char *url, int flags, php_stream_statbuf *ssb, php_stream_context *context TSRMLS_DC); /* open a \"directory\" stream */ php_stream *(*dir_opener)(php_stream_wrapper *wrapper, const char *filename, const char *mode, int options, char **opened_path, php_stream_context *context STREAMS_DC TSRMLS_DC); const char *label; /* delete a file */ int (*unlink)(php_stream_wrapper *wrapper, const char *url, int options, php_stream_context *context TSRMLS_DC); /* rename a file */ int (*rename)(php_stream_wrapper *wrapper, const char *url_from, const char *url_to, int options, php_stream_context *context TSRMLS_DC); /* Create/Remove directory */ int (*stream_mkdir)(php_stream_wrapper *wrapper, const char *url, int mode, int options, php_stream_context *context TSRMLS_DC); int (*stream_rmdir)(php_stream_wrapper *wrapper, const char *url, int options, php_stream_context *context TSRMLS_DC); /* Metadata handling */ int (*stream_metadata)(php_stream_wrapper *wrapper, const char *url, int options, void *value, php_stream_context *context TSRMLS_DC);&#125; php_stream_wrapper_ops; php_stream_wrapper中最重要的是ops成員，它包含了所有該類型的流的操作邏輯的實現。其中最重要的是stream_opener和stream_closer，前者是流的實例化邏輯，後者是流的析構邏輯。特別的，stream_closer主要是用來銷毀php_stream結構，而php_stream_ops-&gt;close是用來回收所有和該流實例相關的資源。 實現1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#define PHP_DONIESTREAM_WRAPPER \"donie\"typedef struct _donie_stream_data &#123; off_t position; char *key; int key_len;&#125; donie_stream_data;static php_stream *php_doniestream_wrapper_open( php_stream_wrapper *wrapper, const char *filename, const char *mode, int options, char **opened_path, php_stream_context *context STREAMS_DC TSRMLS_DC)&#123; donie_stream_data *data; php_url *url; if (options &amp; STREAM_OPEN_PERSISTENT) &#123; php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Unable to open %s persistently.\", filename); return NULL; &#125; url = php_url_parse(filename); if (!url) &#123; php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Unable to parse url %s.\", filename); return NULL; &#125; data = emalloc(sizeof(donie_stream_data)); data-&gt;position = 0; data-&gt;key_len = strlen(url-&gt;host); data-&gt;key = estrndup(url-&gt;host, data-&gt;key_len+1); php_url_free(url); return php_stream_alloc(&amp;php_doniestream_ops, data, 0, mode);&#125;static php_stream_wrapper_ops php_doniestream_wrapper_ops = &#123; php_doniestream_wrapper_open, NULL, /* stream_closer */ NULL, /* stream_stat */ NULL, /* url_stat */ NULL, /* dir_opener */ PHP_DONIESTREAM_WRAPPER, NULL, /* unlink */ NULL, /* rename */ NULL, /* mkdir */ NULL, /* rmdir */ NULL /* stream_metadata */&#125;;static php_stream_wrapper php_doniestream_wrapper = &#123; &amp;php_doniestream_wrapper_ops, NULL, /* abstract */ 0, /* is_url */&#125;;PHP_MINIT_FUNCTION(donie)&#123; /* register stream wrapper */ if (php_register_url_stream_wrapper(PHP_DONIESTREAM_WRAPPER, &amp;php_doniestream_wrapper TSRMLS_CC) == FAILURE) &#123; return FAILURE; &#125; return SUCCESS;&#125;PHP_MSHUTDOWN_FUNCTION(donie)&#123; /* unregister stream wrapper */ if (php_unregister_url_stream_wrapper(PHP_DONIESTREAM_WRAPPER TSRMLS_CC) == FAILURE) &#123; return FAILURE; &#125; return SUCCESS;&#125; PHP_DONIESTREAM_WRAPPER定義了協議名“donie”，所有對格式為“donie://XXX”地址的操作將由這個流實現。 donie_stream_data是一個自定義的結構體，在創建流實例的時候初始化並賦給php_stream-&gt;abstract，為以後對流的操作提供方便。 這裡只實現了最關鍵的stream_opener函數，其中，用php_stream_alloc()創建新的流實例。 最後在模塊的MINIT中用php_register_url_stream_wrapper()註冊包裝器，並在MSHUTDOWN中用php_unregister_url_stream_wrapper()註銷。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"源碼","slug":"源碼","permalink":"http://0x3f.org/tags/源碼/"}]},{"title":"在Archlinux ARM上使用DS18B20溫度傳感器","slug":"setup-ds18b20-on-archlinux","date":"2015-05-25T07:30:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/setup-ds18b20-on-archlinux/","link":"","permalink":"http://0x3f.org/post/setup-ds18b20-on-archlinux/","excerpt":"","text":"線路圖： 修改/boot/config.txt，啟用w1內核模塊。配置文件中有兩部分關於w1的內容，一個只使用一個GPIO引腳，需要自行添加上拉電阻，另一個使用一個額外的GPIO引腳作上拉。 使用Python模塊w1thermsensor讀數，用法見這裡。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"},{"name":"樹苺派","slug":"樹苺派","permalink":"http://0x3f.org/tags/樹苺派/"},{"name":"傳感器","slug":"傳感器","permalink":"http://0x3f.org/tags/傳感器/"},{"name":"geek","slug":"geek","permalink":"http://0x3f.org/tags/geek/"}]},{"title":"變形金剛：原大祖國合金版平頭OP","slug":"transformers-optimus-prime","date":"2015-05-09T13:26:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/transformers-optimus-prime/","link":"","permalink":"http://0x3f.org/post/transformers-optimus-prime/","excerpt":"","text":"一開始我不太喜歡電影版變形金剛，因為太像人就缺少科技感，我至今都認為G1是不可踰越的經典。不過變4的這款V級平頭OP確實是個經典的模具，一個好的變形金剛玩具應有標準幾乎都符合。 人形身材勻稱、沒有冗餘部件，關鍵是無背包，很少有能做到這一點的模具，幾乎所有大黃蜂最大的敗筆都是有個巨大的背包。塗裝鮮豔、視覺效果強烈，作為一個Prime，搞得滿身火焰紋、花裡胡哨的真的好麼？ 關節的鬆緊度方面，四肢主關節採用齒輪關節，表現不錯，不過肘關節是圓形關節，轉動次數多了不知道會不會松。 由於人形沒有太多的累贅，所以可動性方面沒有問題，腰部也是可以360度旋轉的。 手腳方面，一個V級的玩具，用假手也就不說什麼了。不過由於踝關節不能左右擺動，所以腳的接地性不好。 頭雕不夠精細，眼睛是可以透光的。 車形也是個亮點。我一直不喜歡電影版裡那種狗頭車，太張揚，反而G1裡那種平頭車更顯內斂，才有大哥氣質。 做工和用料很不錯。我不是孩控，做工和價格都很重要，祖國版用料很紮實，而且有合金部件，做工也不弱於孩版，再加上這白菜價，孩版就呵呵噠了。 滾動性不好，有的車輪不能著地，而且部分車輪本身轉動不暢。 槍是可以發射子彈的，可玩性有加分。另買的審判之劍真的很帥，否則堂堂Prime單持一把大手槍顯得太素了。 變形的複雜度恰到好處，只是手臂收納到車頭時很緊，流暢度上有扣分。 這是款很經典的模具，很期待放大的祖國合金版。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"玩物","slug":"玩物","permalink":"http://0x3f.org/tags/玩物/"},{"name":"變形金剛","slug":"變形金剛","permalink":"http://0x3f.org/tags/變形金剛/"}]},{"title":"PHP全局變量的實現和操作","slug":"globals-implementation-in-php","date":"2015-05-08T09:23:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/globals-implementation-in-php/","link":"","permalink":"http://0x3f.org/post/globals-implementation-in-php/","excerpt":"","text":"擴展內部的全局變量php_donie.h1234ZEND_BEGIN_MODULE_GLOBALS(donie) unsigned long global_long; char *global_string;ZEND_END_MODULE_GLOBALS(donie) donie.c123456789101112131415161718192021222324252627282930313233ZEND_DECLARE_MODULE_GLOBALS(donie);static void php_donie_init_globals(zend_donie_globals *donie_globals)&#123; donie_globals-&gt;global_long = 2015; donie_globals-&gt;global_string = \"Long live Donie Leigh !\";&#125;static void php_donie_globals_dtor(zend_donie_globals *donie_globals)&#123; php_printf(\"php_donie_globals_dtor triggered.\");&#125;PHP_MINIT_FUNCTION(donie)&#123; /* init extension globals */ ZEND_INIT_MODULE_GLOBALS(donie, php_donie_init_globals, php_donie_globals_dtor); return SUCCESS;&#125;PHP_RSHUTDOWN_FUNCTION(donie)&#123;#ifndef ZTS php_donie_globals_dtor(&amp;donie_globals);#endif return SUCCESS;&#125;ZEND_FUNCTION(donie_test_ext_globals)&#123; php_printf(\"%s\", DONIE_G(global_string));&#125; 聲明ZEND_BEGIN_MODULE_GLOBALS和ZEND_END_MODULE_GLOBALS及其間的內容實際上聲明了一個結構體zend_donie_globals。 根據是否開啟線程安全的情況，ZEND_DECLARE_MODULE_GLOBALS做不同的事：未開啟線程安全，直接聲明zend_donie_globals類型的變量；已開啟線程安全，聲明一個整形變量donie_globals_id。 初始化在未開啟線程安全時，ZEND_INIT_MODULE_GLOBALS調用第二個參數指定的函數初始化全局變量；已開啟線程安全時，調用ts_allocate_id()分配一個資源ID，並調用第二個參數代表的函數。 訪問DONIE_G在擴展的頭文件裡，生成擴展框架時默認就有。 銷毀開啟線程安全時，ZEND_INIT_MODULE_GLOBALS的第三個參數指定的析構函數會自動被調用。未開啟線程安全時，由於該宏只調用第二個參數初始化全局變量，第三個參數沒有用，所以需要在MSHUTDOWN中手工調用析構函數。 用戶空間的超級全局變量1234567891011121314151617static zend_bool php_donie_autoglobal_callback(const char *name, uint name_len TSRMLS_DC)&#123; zval *donie_val; MAKE_STD_ZVAL(donie_val); array_init(donie_val); add_next_index_string(donie_val, \"Hello autoglobals !\", 1); ZEND_SET_SYMBOL(&amp;EG(symbol_table), \"_DONIE\", donie_val); return 0;&#125;PHP_MINIT_FUNCTION(donie)&#123; /* declare userspace super globals */ zend_register_auto_global(\"_DONIE\", sizeof(\"_DONIE\")-1, 0, php_donie_autoglobal_callback TSRMLS_CC); return SUCCESS;&#125; zend_register_auto_global()註冊了$_DONIE這樣一個全局變量。在代碼的編譯時，如果PHP內核發現代碼中沒有使用這個全局變量，不會進行初始化；若有使用，會調用php_donie_autoglobal_callback進行初始化。PHP4中沒有php_donie_autoglobal_callback這個參數。 php_donie_autoglobal_callback做的事就是初始化一個zval並加入符號表。如果此函數返回0，則只會被調用一次，如果返回非0，在代碼編譯時，每發現一次該全局變量，就調用一次這個函數。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"源碼","slug":"源碼","permalink":"http://0x3f.org/tags/源碼/"}]},{"title":"PHP常量的實現和操作","slug":"constant-implementation-in-php","date":"2015-05-07T08:29:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/constant-implementation-in-php/","link":"","permalink":"http://0x3f.org/post/constant-implementation-in-php/","excerpt":"","text":"存儲結構常量存儲在哈希表EG(zend_constants)中。 常量的結構定義為： 1234567typedef struct _zend_constant &#123; zval value; int flags; char *name; uint name_len; int module_number;&#125; zend_constant; value是常量的值，是一個zval。name是常量名。module_number是模塊被加載時，PHP內核在MINIT和RINIT方法的原型裡默認傳遞的一個值，作為模塊清理時的線索，在註冊常量的接口裡直接傳遞即可。 flags是常量的標識或標識組合： CONST_CS CONST_PERSISTENT CONST_CT_SUBST CONST_CS表示常量名對大小寫敏感，對應PHP函數define()的第三個參數，TRUE、FALSE、NULL這些常量名對大小寫是不敏感的。CONST_PERSISTENT表示常量在請求結束後被保存，只在PHP進程結束時才銷毀，一般在MINIT中定義的常量應該指定此參數，RINIT中定義的不指定。CONST_CT_SUBST表示在編譯時可替換，TRUE、FALSE、NULL、ZEND_THREAD_SAFE、ZEND_DEBUG_BUILD屬於此類。 常量的聲明常量的聲明方法有兩種，簡單的使用宏函數族REGISTER_*_CONSTANT()： REGISTER_NULL_CONSTANT(name, flags)REGISTER_BOOL_CONSTANT(name, bval, flags)REGISTER_LONG_CONSTANT(name, lval, flags)REGISTER_DOUBLE_CONSTANT(name, dval, flags)REGISTER_STRING_CONSTANT(name, str, flags)REGISTER_STRINGL_CONSTANT(name, str, len, flags) 由於不需指定常量名長度，所以name參數應直接使用字符串，而不是char*。 如需使用變量作為name參數，使用zend_register_*_constant()函數族，並指定變量名長度（sizeof(name)）。上面的宏函數其實是對這族函數的封裝。 void zend_register_long_constant(char *name, uint name_len, long lval, int flags, int module_number TSRMLS_DC)void zend_register_double_constant(char *name, uint name_len, double dval, int flags, int module_number TSRMLS_DC)void zend_register_bool_constant(const char *name, uint name_len, zend_bool bval, int flags, int module_number TSRMLS_DC)void zend_register_string_constant(char *name, uint name_len, char *strval, int flags, int module_number TSRMLS_DC)void zend_register_stringl_constant(char *name, uint name_len, char *strval, uint strlen, int flags, int module_number TSRMLS_DC) 除此之外，還有REGISTER_MAIN_*_CONSTANT和REGISTER_NS_*_CONSTANT兩組宏函數。前者用於定義像E_ERROR這樣的PHP標準常量，後者定義有命令空間的常量。 define()和const define()是函數，在運行時定義常量 不能定義類常量 可以在條件語句中使用 可以指定常量是否對大小寫敏感 可以用表達式作為常量值 只定義全局常量，不支持命名空間 const是語句，在編譯時定義常量 可以定義類常量 不能在條件語句中使用 定義的常量對大小寫敏感 不支持表達式作為常量值 若腳本定義了命名空間，聲明的常量屬於該命名空間 魔術常量 __LINE____FILE____DIR____FUNCTION____CLASS____METHOD____NAMESPACE__ 魔術常量是在編譯時（具體地說是詞法分析時，見Zend/zend_language_scanner.l）被替換，確切地說，這些不是真正意義上的常量，只是個模板佔位符。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"源碼","slug":"源碼","permalink":"http://0x3f.org/tags/源碼/"}]},{"title":"PHP资源的實現和操作","slug":"resource-implementation-in-php","date":"2015-05-05T10:53:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/resource-implementation-in-php/","link":"","permalink":"http://0x3f.org/post/resource-implementation-in-php/","excerpt":"","text":"存儲結構資源變量也是一個zval結構，zval-&gt;type == IS_RESOURCE，zval-&gt;value-&gt;lval存儲一個整數，此整數為資源數據在存儲資源的哈希表中的索引。 資源數據的結構為： 123456typedef struct _zend_rsrc_list_entry&#123; void *ptr; int type; int refcount;&#125;zend_rsrc_list_entry; 常規資源與持久資源有兩個存儲資源數據的哈希表。EG(regular_list)存儲常規資源，EG(persistent_list)存儲持久資源。 常規資源對應的變量在作用域結束後會被內核回收，對應的資源數據也會被銷毀。持久資源可以保持並被多次請求使用。持久資源的自動析構發生在PHP進程退出時。 實現重新實現基本的文件句柄和相關操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// 資源名稱#define PHP_DONIE_RES_NAME_FILE \"Donie's File Descriptor\"// 資源類型static int le_donie_file_descriptor;static int le_donie_file_descriptor_persist;// 資源析構函數static void php_donie_file_descriptor_dtor(zend_rsrc_list_entry *rsrc TSRMLS_CC)&#123; FILE *fp = (FILE*)rsrc-&gt;ptr; fclose(fp);&#125;// 在擴展的MINIT方法裡創建資源類型PHP_MINIT_FUNCTION(donie)&#123; /* create a new resource type */ le_donie_file_descriptor = zend_register_list_destructors_ex( php_donie_file_descriptor_dtor, NULL, PHP_DONIE_RES_NAME_FILE, module_number ); /* create a persistent resource type */ le_donie_file_descriptor_persist = zend_register_list_destructors_ex( NULL, php_donie_file_descriptor_dtor, PHP_DONIE_RES_NAME_FILE, module_number ); return SUCCESS;&#125;// 文件打開操作PHP_FUNCTION(donie_fopen)&#123; FILE *fp; char *filename, *mode; int filename_len, mode_len; zend_bool persist = 0; char *hash_key; int hash_key_len; list_entry *persist_file; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|b\", &amp;filename, &amp;filename_len, &amp;mode, &amp;mode_len, &amp;persist) == FAILURE) &#123; RETURN_NULL(); &#125; if (!filename_len || !mode_len) &#123; php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid file name or mode.\"); RETURN_FALSE; &#125; /* reuse persistent resource if exists */ hash_key_len = spprintf(&amp;hash_key, 0, \"php_donie_file_descriptor:%s-%s\", filename, mode); if (zend_hash_find(&amp;EG(persistent_list), hash_key, hash_key_len+1, (void **)&amp;persist_file) == SUCCESS) &#123; ZEND_REGISTER_RESOURCE(return_value, persist_file-&gt;ptr, le_donie_file_descriptor_persist); efree(hash_key); return; &#125; fp = fopen(filename, mode); if (!fp) &#123; php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed opening %s with mode %s.\", filename, mode); RETURN_FALSE; &#125; /* this is the key point for registering resources */ if (persist) &#123; ZEND_REGISTER_RESOURCE(return_value, fp, le_donie_file_descriptor_persist); list_entry le; le.type = le_donie_file_descriptor_persist; le.ptr = fp; zend_hash_update(&amp;EG(persistent_list), hash_key, hash_key_len+1, (void*)&amp;le, sizeof(list_entry), NULL); &#125; else &#123; ZEND_REGISTER_RESOURCE(return_value, fp, le_donie_file_descriptor); &#125; efree(hash_key);&#125;// 文件寫操作PHP_FUNCTION(donie_fwrite)&#123; FILE *fp; zval *file_resource; char *data; int data_len; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &amp;file_resource, &amp;data, &amp;data_len) == FAILURE) &#123; RETURN_NULL(); &#125; ZEND_FETCH_RESOURCE2(fp, FILE*, &amp;file_resource, -1, PHP_DONIE_RES_NAME_FILE, le_donie_file_descriptor, le_donie_file_descriptor_persist); RETURN_LONG(fwrite(data, 1, data_len, fp));&#125;// 文件關閉操作PHP_FUNCTION(donie_fclose)&#123; FILE *fp; zval *file_resource; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &amp;file_resource) == FAILURE) &#123; RETURN_NULL(); &#125; ZEND_FETCH_RESOURCE2(fp, FILE*, &amp;file_resource, -1, PHP_DONIE_RES_NAME_FILE, le_donie_file_descriptor, le_donie_file_descriptor_persist); zend_hash_index_del(&amp;EG(regular_list), Z_RESVAL_P(file_resource)); RETURN_TRUE;&#125; 創建新資源類型zend_register_list_destructors_ex()創建新資源類型，並註冊該資源類型的析構函數、資源名稱。第一個參數是常規資源的析構函數，第二個是持久資源的析構函數，此處創建的是常規資源類型，故第二個參數不指定。 註冊資源宏函數ZEND_REGISTER_RESOURCE()註冊新生成的資源到EG(regular_list)，並保存資源的索引到zval-&gt;value-&gt;lval中。 雙重引用計數資源變量zval中存在一個引用計數，資源數據zend_rsrc_list_entry中也存在一個。前者遵循與其它變量一致的計數原則，後者取決於資源數據被幾個資源變量zval引用。 例如對於以下場景： 12345&lt;?php$a = donie_fopen('/tmp/donie.txt', 'r');$b = $a;$c = &amp;$a;?&gt; a賦值給b時，zval的引用計數加一。a的引用賦值給c時，發生zval的拆分，b獲得新的zval，引用計數是1，a和c共用一個zval，引用計數是2。此時，資源數據的引用計數加一。 獲取資源ZEND_FETCH_RESOURCE()根據資源變量zval取出資源數據的ptr並驗證資源類型。ZEND_FETCH_RESOURCE2()可以同時指定兩個資源類型，任一類型匹配成功都可以。 銷毀資源根據上述二重計數原則，只有當資源數據的引用計數為0時，資源的析構函數才會被調用，而銷毀資源變量不一定能銷毀資源，所以需要手工強制銷毀資源。 zend_hash_index_del()從EG(regular_list)中刪除資源時，該資源類型註冊的dtor會被自動調用，從而析構資源。 持久資源存儲EG(persistent_list)是個用字符串索引的哈希表。需要自行定義鍵的命名規則，做到全局唯一。 創建持久資源類型zend_register_list_destructors_ex()註冊資源類型時，將析構函數指定為第二個參數，第一個參數為NULL。析構持久資源時，會自動調用該函數。 註冊持久資源EG(persistent_list)中的資源數據並不被直接使用，對資源的操作仍然使用EG(regular_list)。故在註冊持久資源時，兩個哈希表中都需要保存一份。 往EG(persistent_list)中存資源數據： 1234567char *hash_key;int hash_key_len;zend_rsrc_list_entry le;le.type = le_donie_file_descriptor_persist;le.ptr = fp;hash_key_len = spprintf(&amp;hash_key, 0, \"php_donie_file_descriptor:%s-%s\", filename, mode);zend_hash_update(&amp;EG(persistent_list), hash_key, hash_key_len+1, (void*)&amp;le, sizeof(list_entry), NULL); 獲取持久資源對持久資源的常規操作和操作常規資源一樣，仍使用EG(regular_list)，因為變量zval中存儲的是EG(regular_list)中的索引。所以需要先在EG(persistent_list)中查詢，若資源存在，先註冊到EG(regular_list)中，再進行後續操作。 手動析構持久資源用zend_hash_del()從EG(persistent_list)中刪除資源數據即可自動觸發析構函數。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"源碼","slug":"源碼","permalink":"http://0x3f.org/tags/源碼/"}]},{"title":"PHP對象的實現和操作","slug":"object-implementation-in-php","date":"2015-04-29T15:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/object-implementation-in-php/","link":"","permalink":"http://0x3f.org/post/object-implementation-in-php/","excerpt":"","text":"Object的存儲結構對象實例用zval存儲。zval-&gt;type == IS_OBJECT，zval-&gt;value-&gt;obj存儲zend_object_value類型的結構體變量。 1234typedef struct _zend_object_value &#123; zend_object_handle handle; const zend_object_handlers *handlers;&#125; zend_object_value; zend_object_handle是一個unsigned int，是對象的ID。zend_object_handlers存儲對象所有的行為。 Object的實例化過程Object的初始化用以下幾個宏函數： object_init(zval *arg) object_init_ex(zval *arg, zend_class_entry *class_type) object_and_properties_init(zval *arg, zend_class_entry *class_type, HashTable *properties) 底層都是調用_object_and_properties_init(zval *arg, zend_class_entry *class_type, HashTable *properties)實現。這個函數做以下幾件事： 檢查類是否可實例化（例如接口、抽象類等不允許初始化） 處理類常量 檢查類是否存在自定義實例化邏輯 若存在，調用自定義實例化邏輯 若不存在，調用缺省的函數zend_objects_new(zend_object **object, zend_class_entry *class_type) 把實例化的zend_object類型的數據存入zval中 zend_objects_new()做這些事： 分配一個zend_object類型的內存空間 初始化zend_object類型數據 把zend_object類型數據存入對象倉庫（Objects Store） zend_objects_store_put(void *object, zend_objects_store_dtor_t dtor, zend_objects_free_object_storage_t free_storage, zend_objects_store_clone_t clone） zend_object的存儲結構123456typedef struct _zend_object &#123; zend_class_entry *ce; HashTable *properties; zval **properties_table; HashTable *guards; /* protects from __get/__set ... recursion */&#125; zend_object; ce是類的定義。properties_table存儲類裡預定義的屬性。properties存儲非預定義屬性。 guards存儲屬性名到zend_guard結構的映射關係。 1234567typedef struct _zend_guard &#123; zend_bool in_get; zend_bool in_set; zend_bool in_unset; zend_bool in_isset; zend_bool dummy; /* sizeof(zend_guard) must not be equal to sizeof(void*) */&#125; zend_guard; 此結構用於在操作屬性時，防止遞歸調用。例如給對象一個新屬性賦值時，__set()函數理論上會遞歸調用自己，所以此結構用於判斷該屬性是否已在__set()中。 屬性的存儲結構在zend_object的存儲結構裡，哈希表properties存儲類的非預定義屬性的名称和值。 對於預定義的屬性，由於PHP的哈希表的存儲開銷很大，所以把屬性信息（即下面的zend_property_info結構體）存儲在zend_class_entry裡，對象裡用C的數組存儲所有預定義屬性的zval的指針，並把偏移量記錄在屬性信息裡，這就是properties_table。 12345678910typedef struct _zend_property_info &#123; zend_uint flags; const char *name; int name_length; ulong h; /* hash of name */ int offset; /* storage offset */ const char *doc_comment; int doc_comment_len; zend_class_entry *ce; /* CE of declaring class */&#125; zend_property_info; 屬性名的編碼在類的繼承關係中，同名不同類型（public，private等）的屬性各自單獨存儲，所以屬性名在底層是經過編碼的，規則如下： class Foo { private $prop; } =&gt; “\\0Foo\\0prop”class Bar { private $prop; } =&gt; “\\0Bar\\0prop”class Rab { protected $prop; } =&gt; “\\0*\\0prop”class Oof { public $prop; } =&gt; “prop” 大部分情況下，對屬性操作的API自動處理屬性名的編碼。只有當需要直接訪問propertyinfo-&gt;name或zobj-&gt;properties時才需要自行處理，此時使用zend(un)mangle_property_name()函數。 Objects Store的存儲結構對象倉庫是一個可變數組，存儲多個zend_object_store_bucket結構。 123456typedef struct _zend_objects_store &#123; zend_object_store_bucket *object_buckets; zend_uint top; zend_uint size; int free_list_head;&#125; zend_objects_store; size是對象倉庫的容量。top是下一個可用的對象句柄，對象句柄從1開始，以保證所有句柄都為真。對象倉庫通過每個Bucket的free_list結構維護一個可用的Bucket鏈表，free_list_head記錄鏈表的頭部。 zend_object_store_bucket的存儲結構每個對象的信息存儲在一個bucket裡。 123456789101112131415161718typedef struct _zend_object_store_bucket &#123; zend_bool destructor_called; zend_bool valid; union _store_bucket &#123; struct _store_object &#123; void *object; zend_objects_store_dtor_t dtor; zend_objects_free_object_storage_t free_storage; zend_objects_store_clone_t clone; const zend_object_handlers *handlers; zend_uint refcount; gc_root_buffer *buffered; &#125; obj; struct &#123; int next; &#125; free_list; &#125; bucket;&#125; zend_object_store_bucket; 桶被佔用的時候，valid為1，否則為0。 對象被銷毀時，dtor被調用後，destructor_called被置為1，防止在被free時重複調用dtor，具體見Object的二階銷毀邏輯。 _store_object裡存儲對象的主要信息。zend_objects_store_put()傳入的zend_object結構體存儲在object裡。dtor和free_storage見Object的二階銷毀邏輯。clone是對象的克隆函數。handlers存儲對象的一系列操作函數，缺省為std_object_handlers。refcount是對象的引用計數。buffered是垃圾回收需要用到的數據。 free_list記錄對象倉庫中可用的Bucket鏈表中下一個可用的Bucket。 Object Store的操作 zend_objects_store_put()：註冊對象到倉庫 zend_object_store_get_object_by_handle()：通過對象句柄取對象 zend_object_store_get_object()：通過zval取對象，返回void* zend_objects_get_address()：和zend_object_store_get_object()一樣，但返回zend_object* Object的二階銷毀邏輯對象的銷毀分兩個步驟，一是對象的析構，一是內存的釋放。前者調用對象的dtor，後者調用free_storage。一般先析構，再釋放內存，但兩者可各自分開執行。 dtor中可以執行用戶空間的PHP代碼，主要是PHP類的__destruct()。PHP腳本執行完成後銷毀對象並結束進程（executor shutdown），在這個過程進行到一半的時候執行用戶空間代碼可能會出問題，所以這麼區別主要是為了在進程結束過程中不會調用用戶空間代碼。 此外，dtor並不是必須執行的，如果一個對象的dtor調用的用戶空間代碼裡執行了die()，後續對象的dtor不會被執行。所以大部分情況下，開發者可以自定義free_storage函數，而使用缺省的zend_objects_destroy_object作為dtor。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"源碼","slug":"源碼","permalink":"http://0x3f.org/tags/源碼/"}]},{"title":"PHP類和接口的實現","slug":"class-interface-implementation-in-php","date":"2015-04-28T10:38:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/class-interface-implementation-in-php/","link":"","permalink":"http://0x3f.org/post/class-interface-implementation-in-php/","excerpt":"","text":"Class的實現類的註冊是在擴展的MINIT方法裡。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/* * this pointer should be put into the header file, * so other modules can access this class. */zend_class_entry *c_leigh;/* just a simple method. */PHP_METHOD(Leigh, helloWorld)&#123; if (zend_parse_parameters_none() == FAILURE) &#123; return; &#125; php_printf(\"Hello World !\\n\");&#125;/* getting handle of this object. */PHP_METHOD(Leigh, getObjectHandle)&#123; zval *obj; if (zend_parse_parameters_none() == FAILURE) &#123; return; &#125; obj = getThis(); RETURN_LONG(Z_OBJ_HANDLE_P(obj));&#125;/* get value of the property 'bloodType' */PHP_METHOD(Leigh, getBloodType)&#123; zval *obj, *blood_type; if (zend_parse_parameters_none() == FAILURE) &#123; return; &#125; obj = getThis(); blood_type = zend_read_property(c_leigh, obj, \"bloodType\", sizeof(\"bloodType\") - 1, 1 TSRMLS_CC); RETURN_ZVAL(blood_type, 1, 0);&#125;/* set value of the property 'bloodType' */PHP_METHOD(Leigh, setBloodType)&#123; zval *obj, *new_value; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &amp;new_value) == FAILURE) &#123; return; &#125; obj = getThis(); zend_update_property(c_leigh, obj, \"bloodType\", sizeof(\"bloodType\")-1, new_value TSRMLS_CC);&#125;const zend_function_entry leigh_functions[] = &#123; PHP_ME(Leigh, helloWorld, NULL, ZEND_ACC_PUBLIC) PHP_ME(Leigh, getObjectHandle, NULL, ZEND_ACC_PUBLIC) PHP_ME(Leigh, getBloodType, NULL, ZEND_ACC_PUBLIC) PHP_ME(Leigh, setBloodType, NULL, ZEND_ACC_PUBLIC) /* PHP_ABSTRACT_ME(Leigh, abstractMethod, NULL) // abstract method */ PHP_FE_END&#125;;/* * create a new class inheriting Leigh */zend_class_entry *c_hero;/* * create an interface */zend_class_entry *i_superman;const zend_function_entry superman_functions[] = &#123; PHP_ABSTRACT_ME(ISuperman, saveEarth, NULL) PHP_FE_END&#125;;/* PHP_MINIT_FUNCTION */PHP_MINIT_FUNCTION(donie)&#123; /* If you have INI entries, uncomment these lines REGISTER_INI_ENTRIES(); */ time_of_minit = time(NULL); /* register a class */ zend_class_entry tmp_leigh; INIT_CLASS_ENTRY(tmp_leigh, \"Leigh\", leigh_functions); c_leigh = zend_register_internal_class(&amp;tmp_leigh TSRMLS_CC); /* declare a property initialized as null */ zend_declare_property_null(c_leigh, \"bloodType\", sizeof(\"bloodType\")-1, ZEND_ACC_PUBLIC TSRMLS_CC); /* declare a class constant */ zend_declare_class_constant_double(c_leigh, \"PI\", sizeof(\"PI\")-1, 3.1415926 TSRMLS_CC); /* declare an interface */ zend_class_entry tmp_superman; INIT_CLASS_ENTRY(tmp_superman, \"ISuperman\", superman_functions); i_superman = zend_register_internal_interface(&amp;tmp_superman TSRMLS_CC); /* inherit a class and implement an interface*/ zend_class_entry tmp_hero; INIT_CLASS_ENTRY(tmp_hero, \"Hero\", NULL); c_hero = zend_register_internal_class_ex(&amp;tmp_hero, c_leigh, NULL TSRMLS_CC); zend_class_implements(c_hero TSRMLS_CC, 1, i_superman); return SUCCESS;&#125; 方法修飾符 ZEND_ACC_PUBLICZEND_ACC_PROTECTEDZEND_ACC_PRIVATEZEND_ACC_STATICZEND_ACC_FINALZEND_ACC_ABSTRACT 不直接在PHP_ME裡使用ZEND_ACC_ABSTRACT定義抽象方法，用PHP_ABSTRACT_ME()。 取對象句柄在方法的定義裡使用getThis()拿當前對象的句柄。 屬性的聲明和存取 zend_declare_property_null(… TSRMLS_DC)zend_declare_property_bool(…, long value TSRMLS_DC)zend_declare_property_long(…, long value TSRMLS_DC)zend_declare_property_double(…, double value TSRMLS_DC)zend_declare_property_string(…, const char value TSRMLS_DC)zend_declare_property_stringl(…, const char value, int value_len TSRMLS_DC) 屬性的修飾符和方法相同。 屬性的獲取使用zend_readproperty*()這組函數。 屬性的更新使用zend_updateproperty*()這組函數。 靜態屬性的獲取和更新分別使用zend_read_static_property_*()函數組和zend_update_static_property_*()函數組。與以上不同的是，參數中不需要對象句柄。 類常量的聲明使用zend_declare_classconstant*()函數組，參數與聲明屬性相同，只是不需要修飾符。 繼承類用zend_register_internal_class_ex()。 聲明接口和聲明類一樣，先聲明一組抽象方法，然後用zend_register_internal_interface()註冊。 實現接口用zend_class_implements()。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"源碼","slug":"源碼","permalink":"http://0x3f.org/tags/源碼/"}]},{"title":"變形金剛：俺鋼鎖才是老大","slug":"transformers-grim-lock","date":"2015-04-26T12:55:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/transformers-grim-lock/","link":"","permalink":"http://0x3f.org/post/transformers-grim-lock/","excerpt":"","text":"變形金剛是工業藝術的巔峰之作。不僅僅是懷舊和補童年。理工宅兩大圖騰，恐龍和機器人。從沒有一個東西像汽車人恐龍部隊一樣，把這兩樣完美地融為一體。 孩之寶的東西很多時候不盡如人意，價格又太貴。有一些第三方的仿品，不乏精品。像威將的這個鋼鎖，是孩之寶V級的放大版，幾乎與L級等身，頭部和大腿根部是合金部件，很有質感。有美版和黑暗兩個塗裝，結合放大後的形象，黑暗塗裝更顯霸氣。 美版L級人形。整體精緻，但是太瘦，兩條腿細得跟小兒麻痺似的，盈盈一掬的小蠻腰，這是要走長腿歐巴路線啊。這個比例，如果放大一號效果會更好，不過鋼鎖老大比其它L級大一號不是理所當然的麼。最討厭的是電鍍，又俗又易脫落。 美版L級龍形。非常失敗。身體比例失調，趴耳朵，塌脊梁，短尾巴。不忍直視。 祖國版V級人形。V級鋼鎖是不以人形見長的，不過放大後觀感尚可。 祖國版V級龍形。V級鋼鎖的龍形完爆L級，體形霸氣，立耳，隆背，翹尾。孩版V級最大的遺憾就是體形太小，祖國版龍形堪稱完美。 不知道是不是我中獎了，祖國版人形的大腿根部雖然是球齒關節，但是球齒無效，關節比較松，容易劈叉。不過這個做工、用料，只要幾十軟妹幣，相對幾倍價格的孩版來說，威將良心之作啊。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"玩物","slug":"玩物","permalink":"http://0x3f.org/tags/玩物/"},{"name":"變形金剛","slug":"變形金剛","permalink":"http://0x3f.org/tags/變形金剛/"},{"name":"恐龍","slug":"恐龍","permalink":"http://0x3f.org/tags/恐龍/"}]},{"title":"PHP數組的實現與操作","slug":"array-implementation-in-php","date":"2015-04-24T04:09:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/array-implementation-in-php/","link":"","permalink":"http://0x3f.org/post/array-implementation-in-php/","excerpt":"","text":"存儲結構和其它變量一樣，PHP的數組也是一個zval。存儲數據的哈希表存放在zval-&gt;value-&gt;ht中。 符號表操作為實現可轉換成整數的字符串鍵與整數鍵指向同一個元素，在哈希表操作的基礎上封裝了一層，對可轉換成整數的字符串鍵轉換成整數，然後調用zend_hashindex\\*操作，否則調用zendhash\\*操作。這就是符號表操作。 用ZEND_HANDLE_NUMERIC處理整數字符串鍵： 123456static inline int zend_symtable_find( HashTable *ht, const char *arKey, uint nKeyLength, void **pData) &#123; ZEND_HANDLE_NUMERIC(arKey, nKeyLength, zend_hash_index_find(ht, idx, pData)); return zend_hash_find(ht, arKey, nKeyLength, pData);&#125; 其它符號表操作函數： 12345678static inline int zend_symtable_exists(HashTable *ht, const char *arKey, uint nKeyLength);static inline int zend_symtable_del(HashTable *ht, const char *arKey, uint nKeyLength);static inline int zend_symtable_update( HashTable *ht, const char *arKey, uint nKeyLength, void *pData, uint nDataSize, void **pDest);static inline int zend_symtable_update_current_key_ex( HashTable *ht, const char *arKey, uint nKeyLength, int mode, HashPosition *pos); 數組操作初始化123456789// 初始化數組zval *zv1;array_init(zv1);// 初始化數組並指定哈希表nTableSize的值array_init_size(zv1, 100);// 在函數中返回數組：把返回值初始化為數組array_init(return_value); 插入和更新12345678/* Insert at next index */int add_next_index_*(zval *arg, ...);/* Insert at specific index */int add_index_*(zval *arg, ulong idx, ...);/* Insert at specific key */int add_assoc_*(zval *arg, const char *key, ...);/* Insert at specific key of length key_len (for binary safety) */int add_assoc_*_ex(zval *arg, const char *key, uint key_len, ...); 星號表示類型名，可用類型名如下： Type Additional arguments null none bool int b long long n double double d string const char *str, int duplicate stringl const char *str, uint length, int duplicate resource int r zval zval *value 字符串長度的處理上述操作對字符串鍵和字符串值的長度的要求不同。_ex函數要求傳入字符串鍵的長度，此長度包含NUL字節。_stringl函數要求傳入字符串值的長度，此長度不包含NUL字節。 栗子12345678910111213141516171819202122PHP_FUNCTION(donie_get_arr)&#123; array_init(return_value); // add an integer to the given position add_index_long(return_value, 1, 2015); // append a string to the array add_next_index_string(return_value, \"dummy string\", 1); // add a boolean value to the given key add_assoc_bool(return_value, \"rightOrWrong\", 0); // take care of string lengths add_assoc_stringl_ex(return_value, \"keyStringL\\0\", sizeof(\"keyStringL\\0\")-1, \"valueEx\\0\", sizeof(\"valueEx\\0\"), 1); // store an object in the array zval *obj; MAKE_STD_ZVAL(obj); object_init(obj); add_next_index_zval(return_value, obj);&#125;","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"源碼","slug":"源碼","permalink":"http://0x3f.org/tags/源碼/"}]},{"title":"PHP哈希表的實現與操作","slug":"hashtable-implementation-of-php","date":"2015-04-23T07:56:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/hashtable-implementation-of-php/","link":"","permalink":"http://0x3f.org/post/hashtable-implementation-of-php/","excerpt":"","text":"結構12345678910111213141516171819202122232425262728293031// 哈希表結構typedef struct _hashtable &#123; uint nTableSize; uint nTableMask; uint nNumOfElements; // 全部元素數 ulong nNextFreeElement; // 下一個可用的整數鍵 Bucket *pInternalPointer; // 枚舉操作時使用，指向當前Bucket Bucket *pListHead; Bucket *pListTail; Bucket **arBuckets; dtor_func_t pDestructor; // 元素的析構函數 zend_bool persistent; // 是否在本次請求結束後保留哈希表 unsigned char nApplyCount; // 循環級別，防止循環引用導致遍歷哈希表時死循環 zend_bool bApplyProtection; // 是否防止死循環#if ZEND_DEBUG int inconsistent;#endif&#125; HashTable;// Bucket結構typedef struct bucket &#123; ulong h; uint nKeyLength; void *pData; void *pDataPtr; struct bucket *pListNext; struct bucket *pListLast; struct bucket *pNext; struct bucket *pLast; char *arKey;&#125; Bucket; 哈希衝突處理哈希表通過計算鍵值的哈希值，將對應的數據映射到對應的槽上。理論上會存在不同的鍵的哈希值相同的情況。 處理哈希衝突的方法一般有兩種：開放尋址和鏈表。開放尋址法是將衝突的元素順序放到下一個空槽，理論上會導致衝突越來越多，性能快速下降。鏈表法是將衝突的元素插入對應的槽，與前一個元素組成一個鏈表。PHP使用鏈表法。 PHP的哈希表中的Buckets組成兩種雙向鏈表。一種由每個槽中的所有Bucket分別組成，一種是整個哈希表中的Bucket組成一個。Bucket結構裡，pNext指向該槽的鏈表中的下一個Bucket，pLast指向上一個；pListNext指向整個哈希表鏈表的下一個Bucket，pListLast指向上一個。 pData與pDataPtr賦值到Bucket時，數據會被複製一份，pData中保存指向該數據拷貝的指針。特別地，如果保存一個指針到Bucket，會先將該指針保存到pDataPtr，然後將pData指向pDataPtr，即pData中保存的是指向pDataPtr中保存的指針的指針。這樣可以避免一次拷貝數據時分配內存的操作，提高效率。 nTableSize與nTableMasknTableSize保存的是arBuckets的Bucket個數。它的值永遠是個大於等於8的、2的n次方的整數。當現有容量不滿足需要時，arBuckets會重新分配一個大小是原來兩倍的空間，nTableSize相應地被更新為新的數值。 nTableMask = nTableSize - 1 哈希值h一般比nTableSize大，所以要用哈希值對nTableSize取模，以確定對應的Bucket。由於取模操作運算量大，且nTableSize永遠是2的n次冪，所以用“h &amp; (nTableSize - 1)”替代。 初始化與銷毀12345678910111213// init hashtableHashTable *myht;ALLOC_HASHTABLE(myht);if (zend_hash_init(myht, 100, NULL, NULL, 0) == FAILURE)&#123; FREE_HASHTABLE(myht); return FAILURE;&#125;// destroy hashtablezend_hash_destroy(myht);FREE_HASHTABLE(myht);return SUCCESS; 初始化哈希表ALLOC_HASHTABLE就是用emalloc()分配內存。 zend_hash_init() zend_hash_init(HashTable *ht, uint nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC) nSize是哈希表的初始長度，實際分配為最接近指定值的2的n次方，最小為8。 pDestructor是被存儲數據的析構函數，默認為ZVAL_PTR_DTOR，對於一般情況（Bucket中存儲的是zval）適用。 persistent，1表示本次請求結束後保留哈希表，0反之。 銷毀哈希表zend_hash_clean()對HT所有Bucket調用析構函數，並重置HT的所有指針。 zend_hash_destroy()除了銷毀所有Bucket存儲的數據，連arBuckets的空間也釋放掉。 FREE_HASHTABLE宏其實就是efree()。 操作數字鍵1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// add a string with an integer key 2 to myhtzval *zv1;MAKE_STD_ZVAL(zv1);ZVAL_STRING(zv1, \"Hello HT !\", 1);zend_hash_index_update(myht, 2, &amp;zv1, sizeof(zval *), NULL);// get the next free keyphp_printf(\"The next free key will be %ld.\\n\", zend_hash_next_free_element(myht));// append an integer to myhtzval *zv2;MAKE_STD_ZVAL(zv2);ZVAL_LONG(zv2, 2015);if (zend_hash_next_index_insert(myht, &amp;zv2, sizeof(zval *), NULL) == FAILURE)&#123; php_printf(\"HashTable appendation failed.\\n\");&#125;else&#123; php_printf(\"HashTable appendation succeeded.\\n\");&#125;// get the sizephp_printf(\"HashTable has a size of %d.\\n\", zend_hash_num_elements(myht));// check if an integer key existsint idx = 3;if (zend_hash_index_exists(myht, idx))&#123; php_printf(\"HashTable has an index of the value %ld.\\n\", idx);&#125;else&#123; php_printf(\"HashTable does not have an index of the value %ld.\\n\", idx);&#125;// get a value by its keyzval **zval_dest;if (zend_hash_index_find(myht, idx, (void **) &amp;zval_dest) == SUCCESS)&#123; php_printf(\"The value indexed by %ld is %Z.\\n\", idx, *zval_dest);&#125;else&#123; php_printf(\"The value indexed by %ld does not exist.\\n\", idx);&#125;// delete the specified value from myhtif (zend_hash_index_del(myht, idx) == FAILURE)&#123; php_printf(\"The value indexed by %ld failed to be deleted.\\n\", idx);&#125;else&#123; php_printf(\"The value indexed by %ld is deleted.\\n\", idx);&#125; 操作字符串鍵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// add an integer indexed by a string key, using zend_hash_update()zval *zv3;MAKE_STD_ZVAL(zv3);ZVAL_LONG(zv3, 1985);zend_hash_update(myht, \"year\", sizeof(\"year\"), &amp;zv3, sizeof(zval *), NULL);php_printf(\"An integer is updated to the hash-table indexed by a string key.\\n\");// add a string indexed by a string key, using zend_hash_add()zval *zv4;MAKE_STD_ZVAL(zv4);ZVAL_STRING(zv4, \"Great Donie !\", 1);if (zend_hash_add(myht, \"motto\", sizeof(\"motto\"), &amp;zv4, sizeof(zval *), NULL) == FAILURE)&#123; php_printf(\"Cannot add a string indexed by a string key to the hash-table, may be the index already exists.\\n\");&#125;else&#123; php_printf(\"A string is added to the hash-table indexed by a string key.\\n\");&#125;// get the next free keyphp_printf(\"The next free key will be %ld.\\n\", zend_hash_next_free_element(myht));// check if a string key existschar *key1 = \"year\";if (zend_hash_exists(myht, key1, strlen(key1)+1))&#123; php_printf(\"The key %s exists.\\n\", key1);&#125;else&#123; php_printf(\"The key %s does not exist.\\n\", key1);&#125;// get the value indexed by a string keyzval **zv_dest2;if (zend_hash_find(myht, key1, strlen(key1)+1, (void **) &amp;zv_dest2) == SUCCESS)&#123; php_printf(\"The value indexed by %s is %Z.\\n\", key1, *zv_dest2);&#125;else&#123; php_printf(\"Failed fetching the value indexed by %s.\\n\", key1);&#125;// delete the value indexed by a string keyif (zend_hash_del(myht, key1, strlen(key1)+1) == SUCCESS)&#123; php_printf(\"The value indexed by %s is deleted.\\n\", key1);&#125;else&#123; php_printf(\"The value indexed by %s failed to be deleted.\\n\", key1);&#125; 鍵的長度鍵長包括鍵字符串末尾的NUL字節。如果直接指定，應是sizeof(“key1”)；如果是char*類型變量，應是strlen(key1)+1。 快速操作適用於頻繁操作特定鍵的場景，只計算一次哈希值，加速操作。 對應的，有一組名帶“quick”的函數。 123456789// quick operations leveraging a one-time hashed valuezval *zv5;MAKE_STD_ZVAL(zv5);ZVAL_STRING(zv5, \"Great Donie Leigh !\", 1);ulong h;h = zend_get_hash_value(\"motto\", sizeof(\"motto\"));zend_hash_quick_update(myht, \"motto\", sizeof(\"motto\"), h, &amp;zv5, sizeof(zval *), NULL);php_printf(\"The value indexed by motto is updated with the quick operation.\\n\"); 遍歷123456789101112131415161718192021static int hashtable_traverse_callback(void *pDest TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key)&#123; zval **zv = (zval **) pDest; char *arg1 = va_arg(args, char*); php_printf(\"The first argument is %s.\\n\", arg1); if (hash_key-&gt;nKeyLength == 0) &#123; php_printf(\"K-V: %d=&gt;%Z\\n\", hash_key-&gt;h, *zv); &#125; else &#123; php_printf(\"K-V: %s=&gt;%Z\\n\", hash_key-&gt;arKey, *zv); &#125; return ZEND_HASH_APPLY_KEEP;&#125;// traverse the hash table.zend_hash_apply_with_arguments(myht, hashtable_traverse_callback, 1, \"nonsense\"); 三個函數遍歷哈希表的三個函數： 1234567void zend_hash_apply(HashTable *ht, apply_func_t apply_func TSRMLS_DC);void zend_hash_apply_with_argument( HashTable *ht, apply_func_arg_t apply_func, void *argument TSRMLS_DC);void zend_hash_apply_with_arguments( HashTable *ht TSRMLS_DC, apply_func_args_t apply_func, int num_args, ...); 三個函數接受的回調函數的類型： 12345typedef int (*apply_func_t)(void *pDest TSRMLS_DC);typedef int (*apply_func_arg_t)(void *pDest, void *argument TSRMLS_DC);typedef int (*apply_func_args_t)( void *pDest TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key); zend_hash_key的定義為： 12345typedef struct _zend_hash_key &#123; const char *arKey; uint nKeyLength; ulong h;&#125; zend_hash_key; nKeyLength為0表示索引是整數，值為h；否則是字符串，值為arKey。 回調函數的返回值： ZEND_HASH_APPLY_KEEP：繼續遍歷。 ZEND_HASH_APPLY_REMOVE：遍歷後刪除遍歷過的元素。 ZEND_HASH_APPLY_STOP：遍歷當前元素後停止。 ZEND_HASH_APPLY_REMOVE | ZEND_HASH_APPLY_STOP：遍歷當前元素後，刪除該元素並停止。 枚舉1234567891011121314151617181920// iterating the hash tablephp_printf(\"Begin iterating the hash table:\\n\");HashPosition pos;zval **data;char *str_idx;uint str_len;ulong num_idx;for (zend_hash_internal_pointer_reset_ex(myht, &amp;pos); zend_hash_get_current_data_ex(myht, (void **) &amp;data, &amp;pos) == SUCCESS; zend_hash_move_forward_ex(myht, &amp;pos)) &#123; switch (zend_hash_get_current_key_ex(myht, &amp;str_idx, &amp;str_len, &amp;num_idx, 0, &amp;pos)) &#123; case HASH_KEY_IS_LONG: php_printf(\"K-V: %d=&gt;%Z\\n\", num_idx, *data); break; case HASH_KEY_IS_STRING: php_printf(\"K-V: %s=&gt;%Z\\n\", str_idx, *data); break; &#125;&#125; 三個函數三個函數均帶“_ex”後綴，使用外部指針。不帶此後綴的函數使用哈希表內部指針，此時嵌套地遍歷哈希表可能導致指針修改錯誤。 取鍵的新方式PHP 5.5以上版本新增函數，直接取鍵值到zval： 123zval *key;MAKE_STD_ZVAL(key);zend_hash_get_current_key_zval_ex(myht, key, &amp;pos); 複製與合併1zend_hash_copy(ht_target, ht_source, (copy_ctor_func_t) zval_add_ref, NULL, sizeof(zval *)); zval_add_ref是適用於zval的回調函數，直接引用原數據。 當目標哈希表已存在對應鍵值的數據時，目標元素會被源元素覆蓋。使用zend_hash_merge()可通過最後一個參數指定是否用源數據覆蓋目標數據。 函數zend_hash_merge_ex()可指定一個回調函數，用於過濾要合併的元素： 1234zend_hash_merge_ex( Z_ARRVAL_P(return_value), Z_ARRVAL_P(array2), (copy_ctor_func_t) zval_add_ref, sizeof(zval *), (merge_checker_func_t) merge_greater, NULL); 回調函數的格式為： 123typedef zend_bool (*merge_checker_func_t)( HashTable *target_ht, void *source_data, zend_hash_key *hash_key, void *pParam); 比較、排序和極值比較函數： 123456int zend_hash_compare( HashTable *ht1, HashTable *ht2, compare_func_t compar, zend_bool ordered TSRMLS_DC);// 回調函數：typedef int (*compare_func_t)(const void *left, const void *right TSRMLS_DC); 排序函數： 1234567int zend_hash_sort(HashTable *ht, sort_func_t sort_func, compare_func_t compar, int renumber TSRMLS_DC);// 回調函數typedef void (*sort_func_t)( void *buckets, size_t num_of_buckets, register size_t size_of_bucket, compare_func_t compare_func TSRMLS_DC); 極值函數： 123int zend_hash_minmax( const HashTable *ht, compare_func_t compar, int flag, void **pData TSRMLS_DC); flag=0，極小值寫入pData；flag=1，極大值寫入pData。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"源碼","slug":"源碼","permalink":"http://0x3f.org/tags/源碼/"}]},{"title":"自動重映射鍵盤","slug":"auto-remap-keyboard","date":"2015-04-17T10:02:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/auto-remap-keyboard/","link":"","permalink":"http://0x3f.org/post/auto-remap-keyboard/","excerpt":"","text":"每次鍵盤拔出再插入時，鍵盤映射都會失效，要重新執行映射，而且要對不同的鍵盤應用不同的映射方案。試過直接添加udev規則，即使指定X Display和Xauthority也不成功。所以用pyudev寫個腳本（最新版本）： udev.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/env python2# encoding: utf-8\"\"\"File: udev.pyDescription: udev monitor script.Author: Donie LeighEmail: donie.leigh at gmail.com\"\"\"import glib, os, timefrom pyudev import Context, MonitorPID_FILE = \"/tmp/udev_monitor.pid\"def remap_pokerii(device): \"\"\" Do keyboard remapping when PokerII is plugged in. \"\"\" if device.get('ID_VENDOR_ID') == '0f39' \\ and device.action == 'add': time.sleep(1) os.system('setxkbmap') os.system('xmodmap ~/.Xmodmap')def remap_filco(device): \"\"\" Do keyboard remapping when Filco is plugged in. \"\"\" if device.get('ID_VENDOR_ID') == '04d9' \\ and device.action == 'add': time.sleep(1) os.system('setxkbmap') os.system('xmodmap ~/.Xmodmap')def is_pid_running(pid): \"\"\" Check if the given pid is running. :pid: int :returns: bool \"\"\" try: os.kill(pid, 0) except OSError: return False return Truedef write_pid_or_die(): \"\"\" Write the current pid into pid file or exists if there is already a instance running. :returns: void \"\"\" if os.path.isfile(PID_FILE): pid = int(open(PID_FILE).read()) if is_pid_running(pid): print(\"Process &#123;0&#125; is still running.\".format(pid)) raise SystemExit else: os.remove(PID_FILE) open(PID_FILE, 'w').write(str(os.getpid()))def main(): try: from pyudev.glib import MonitorObserver def device_event(observer, device): remap_pokerii(device) remap_filco(device) except: from pyudev.glib import GUDevMonitorObserver as MonitorObserver def device_event(observer, action, device): remap_pokerii(device) remap_filco(device) context = Context() monitor = Monitor.from_netlink(context) monitor.filter_by(subsystem='usb') observer = MonitorObserver(monitor) observer.connect('device-event', device_event) monitor.start() glib.MainLoop().run()if __name__ == '__main__': write_pid_or_die() try: main() except KeyboardInterrupt: print(\"Game over.\") 有個坑，監測到鍵盤插入事件後要等一秒再應用映射，否則不成功。 這裡只用了設備的Vendor ID，可以直接用lsusb看。看更多的設備屬性的命令如下： 12345678# 監視設備變動udevadm monitor --environment --udev# 查看設備屬性udevadm info -a -n [device name]# 查看文件所屬設備的屬性udevadm info -a -p [file name]","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"udev","slug":"udev","permalink":"http://0x3f.org/tags/udev/"},{"name":"鍵盤","slug":"鍵盤","permalink":"http://0x3f.org/tags/鍵盤/"}]},{"title":"用樹苺派做家庭監控","slug":"monitor-home-with-raspberry-pi","date":"2015-04-07T02:56:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/monitor-home-with-raspberry-pi/","link":"","permalink":"http://0x3f.org/post/monitor-home-with-raspberry-pi/","excerpt":"","text":"用樹苺派做視頻監控，當視野內有物體移動時，自動拍照、錄視頻、同步到遠程主機，並提醒到遠程電腦和手機。 用Motion做視頻監控安裝Motion，修改幾項必要的配置： /etc/motion/motion.conf1234567891011121314# 照片和視頻存儲路徑target_dir = /media/sda1/cam# 允許局域網內其它主機訪問視頻webcam_localhost off# 監測到移動物體時，創建作為標識的臨時文件on_event_start \"echo 1 &gt; /tmp/invasion_detected\"# 移動物體消失時，移除臨時文件on_event_end \"rm /tmp/invasion_detected\"# 監測到移動物體並在保存第一張照片時，發送提醒到電腦和手機on_picture_save [ -f /tmp/invasion_detected ] &amp;&amp; [ `cat /tmp/invasion_detected` -gt 0 ] &amp;&amp; echo 0 &gt; /tmp/invasion_detected &amp;&amp; proxychains /root/SmartHome/script/alert.py -f %f 用Lsyncd同步到VPS安裝lsyncd並配置： /etc/lsyncd.conf1234567891011121314151617181920settings&#123; pidfile = \"/var/log/lsyncd/lsyncd.pid\", logfile = \"/var/log/lsyncd/lsyncd.log\", statusFile = \"/var/log/lsyncd/lsyncd-status.log\", statusInterval = 1, maxDelays = 1, -- nodaemon = true,&#125;sync&#123; default.rsyncssh, source = \"/media/sda1/cam\", host = \"myvps.com\", targetdir = \"/opt/cam\", exclude=&#123; \".*\", \"*.tmp\" &#125;, rsync = &#123; compress = false, _extra = &#123;\"--bwlimit=50000\"&#125;, &#125;&#125; 用PushBullet通知電腦和手機Python有幾個封裝好PushBullet API的模塊，pushbullet.py在被Motion執行的時候報IOError，pushybullet的文件上傳有問題，所以程序裡用yapbl。 1git clone https://github.com/xbot/SmartHome.git 修改alert.py，填上自己的PushBullet API Key。 訪問PushBullet的API需要科學上網，在Motion的on_picture_save裡用proxychains執行PushBullet腳本。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"樹苺派","slug":"樹苺派","permalink":"http://0x3f.org/tags/樹苺派/"},{"name":"Geek","slug":"geek","permalink":"http://0x3f.org/tags/geek/"},{"name":"智能家居","slug":"智能家居","permalink":"http://0x3f.org/tags/智能家居/"}]},{"title":"用樹苺派搭NAS","slug":"make-nas-with-raspberry-pi","date":"2015-04-03T07:13:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/make-nas-with-raspberry-pi/","link":"","permalink":"http://0x3f.org/post/make-nas-with-raspberry-pi/","excerpt":"","text":"為了讓盒子能直接播放遠程下載的電影，繼續在樹苺派上搭NAS。 安裝samba，然後配置： /etc/samba/smb.conf1234567[nas]path = /media/sda1valid users = @usersforce group = userscreate mask = 0660directory mask = 0771read only = no 把Linux用戶添加到samba並設置密碼： 1smbpasswd -a pi 盒子上的Kodi硬解有問題，用ES+MX Player替代。電腦上用Kodi。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"樹苺派","slug":"樹苺派","permalink":"http://0x3f.org/tags/樹苺派/"},{"name":"Geek","slug":"geek","permalink":"http://0x3f.org/tags/geek/"},{"name":"智能家居","slug":"智能家居","permalink":"http://0x3f.org/tags/智能家居/"}]},{"title":"再次調整磁盤分區","slug":"adjust-disk-partitions-again","date":"2015-04-03T06:44:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/adjust-disk-partitions-again/","link":"","permalink":"http://0x3f.org/post/adjust-disk-partitions-again/","excerpt":"","text":"自從上次調整磁盤分區，一直把根目錄和主目錄分別掛在一個物理分區下，即使系統掛了或者換發行版也不影響主目錄。最近根分區很緊張，乾脆把兩個分區合併了。 先用UNetBootin安裝Puppy Linux到U盤，需要手工修改U盤裡的syslinux.cfg，把“pmedia=cd”改成“pmedia=usbflash”，然後用U盤啟動。 把主目錄的內容完整複製到移動硬盤： 12345678910111213# 掛載主目錄mkdir /mnt/oldhomemount -t ext4 /dev/sda2 /mnt/oldhome# 掛載移動硬盤mkdir /mnt/bakdiskmount -t ext4 /dev/sdc1 /mnt/bakdisk# 複製主目錄cp -a /mnt/oldhome /mnt/bakdisk/# 取消掛載主目錄umount /mnt/oldhome 用gparted刪除主目錄分區，合併到根分區。然後恢復主目錄： 12345678910111213# 掛載根分區mkdir /mnt/newrootmount -t ext4 /dev/sda1 /mnt/newroot# 恢復主目錄cp -a /mnt/bakdisk/* /mnt/newroot/# 修改fstab，取消主目錄的掛載vim /mnt/newroot/etc/fstab# 取消掛載umount /mnt/bakdiskumount /mnt/newroot","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"}]},{"title":"這段時間讀的幾本書","slug":"books-i-read-these-days","date":"2015-03-29T08:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/books-i-read-these-days/","link":"","permalink":"http://0x3f.org/post/books-i-read-these-days/","excerpt":"","text":"每個危樓聽雨的暮年都有過軟紅十丈的青春。文字凄豔，明清小品裏的上乘之作。後兩記文風模仿前文，意境遠遜，應是僞作，可以不讀。 上部是政治史，下部是文化史。文化史部分很好，漲知識，應該買本經常翻翻。 大部分是講稿，内容不系統，不适合入門。暢銷書不可信啊。 科普書，不知道豆瓣上那麼高的評分哪兒來的。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"}]},{"title":"用樹苺派實現遠程下載","slug":"remote-downloading-with-raspberry-pi","date":"2015-03-28T11:14:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/remote-downloading-with-raspberry-pi/","link":"","permalink":"http://0x3f.org/post/remote-downloading-with-raspberry-pi/","excerpt":"","text":"遠程用樹苺派利用空閒時間下載大文件，需要百度雲、aria2和VPS。因為網絡運營商給的IP不是真的公網IP，而且免費的動態域名服務不穩定，所以用VPS把樹苺派上的端口轉發到外網。 樹苺派在樹苺派上部署aria2下載服務，並發佈到VPS。 安裝aria2，創建以下配置文件，修改/media/sda1為實際下載目錄： /etc/aria2/aria2.conf123456789101112131415161718192021dir=/media/sda1file-allocation=prealloccontinue=truelog-level=info#log-level=debugmax-connection-per-server=10summary-interval=120daemon=trueenable-rpc=truerpc-listen-port=6800rpc-listen-all=truemax-concurrent-downloads=3save-session=/etc/aria2/save-session.listinput-file=/etc/aria2/save-session.listlog=/media/sda1/aria.logdisable-ipv6=truedisk-cache=25Mtimeout=600retry-wait=30max-tries=0user-agent=netdisk;4.4.0.6;PC;PC-Windows;6.2.9200;WindowsBaiduYunGuanJia 我的樹苺派用Archlinux，創建systemd的服務配置文件： /etc/systemd/system/aria2c.service12345678910111213[Unit]Description=aria2c -- file download managerAfter=network.target [Service]Type=forkingUser=%iWorkingDirectory=%hEnvironment=VAR=/var/%iExecStart=/usr/bin/aria2c --daemon --enable-rpc --rpc-listen-all --rpc-allow-origin-all -c -D --conf-path=/etc/aria2/aria2.conf [Install]WantedBy=multi-user.target 激活並啟動aria2服務。 在NGINX的WWW目錄下安裝aria2的Web界面： 1git clone https://github.com/binux/yaaw.git 發佈本地服務到VPS： 12345# 發佈NGINXautossh -M 5122 -R 80:localhost:80 myvps.com # 發佈aria2autossh -M 5124 -R 6800:localhost:6800 myvps.com autossh用於保持SSH連接，需要VPS上啟動TCP Echo服務。 VPS在VPS上啟用TCP Echo服務，安裝xinetd並修改配置文件： /etc/xinet.d/echo-stream12345678910111213service echo&#123; disable = no id = echo-stream type = INTERNAL wait = no socket_type = stream user = root server = /usr/bin/cat log_on_failure += USERID flags = REUSE only_from = 127.0.0.1&#125; 遠程主機在遠程主機上配置瀏覽器的代理規則，對http://localhost/yaaw和http://localhost:6800/jsonrpc兩個URL使用VPS上的VPN或Shadowsocks代理。 安裝Chrome擴展，然後到百度雲盤裡設置aria2的RPC地址為“http://localhost:6800/jsonrpc”即可。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"樹苺派","slug":"樹苺派","permalink":"http://0x3f.org/tags/樹苺派/"},{"name":"Geek","slug":"geek","permalink":"http://0x3f.org/tags/geek/"},{"name":"智能家居","slug":"智能家居","permalink":"http://0x3f.org/tags/智能家居/"}]},{"title":"運行時可裝卸的Mixin的PHP實現","slug":"php-implementation-of-runtime-mixin","date":"2014-12-04T03:52:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/php-implementation-of-runtime-mixin/","link":"","permalink":"http://0x3f.org/post/php-implementation-of-runtime-mixin/","excerpt":"","text":"PHP的Trait可以實現加載時（load time）的混入（mixin）。作爲元編程的一部分，運行時（run time）的混入擁有更大的靈活性。下面利用PHP的魔術方法實現運行時的混入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?php/** * 支持混入的類 */class Component&#123; // ... // 所有混入的實例 private $_behaviors = []; /** * 魔術方法 * @param string $name 方法名 * @param array $arguments 參數數組 * @return mixed * @throws MethodNotFoundException */ public function __call($name, $arguments) &#123; foreach ($this-&gt;_behaviors as $behavior) &#123; if (method_exists($behavior, $name)) &#123; return call_user_func_array([$behavior, $name], $arguments); &#125; &#125; throw new MethodNotFoundException(get_class($this), $name); &#125; /** * 魔術方法，從混入對象實例中取屬性值 * @param string $attrName 屬性名 * @return mixed * @throws AttrNotFoundException */ public function __get($attrName) &#123; foreach ($this-&gt;_behaviors as $behavior) &#123; if (property_exists($behavior, $attrName)) &#123; return $behavior-&gt;$attrName; &#125; &#125; throw new AttributeNotFoundException(get_class($this), $attrName); &#125; /** * 附加混入對象實例 * @param object $behavior 混入對象實例 * @param string $name 混入對象實例名稱 * @return void */ public function attachBehavior($behavior, $name='') &#123; if (empty($name)) $this-&gt;_behaviors[] = $behavior; else $this-&gt;_behaviors[$name] = $behavior; &#125; /** * 卸載混入對象實例 * @param string $name 混入對象實例名稱 * @return void */ public function detachBehavior($name) &#123; unset($this-&gt;_behaviors[$name]); &#125; // ...&#125; 123456789101112131415161718192021222324&lt;?php/** * 混入類 */class Behavior&#123; // ... /** * 将本實例混入指定對象 * @param object $object 支持混入的實例 * @param string $name 目标對象存儲本混入對象實例的鍵值 * @return void * @throws BehaviorNotAttachableException */ public function mixin($object, $name='') &#123; if (method_exists($object, 'attachBehavior')) &#123; return call_user_func_array([$object, 'attachBehavior'], [$this, $name]); &#125; throw new BehaviorNotAttachableException(get_class($object)); &#125; // ...&#125; 使用示例： 1234567891011121314151617181920212223242526272829&lt;?phpinclude_once 'component.php';include_once 'behavior.php';class TestBehavior extends Behavior&#123; public function test($what) &#123; echo \"say $what\"; &#125;&#125;$c = new Component();$b = new TestBehavior();$c-&gt;attachBehavior($b, 'test');echo '&lt;pre&gt;'; var_dump($c); echo '&lt;/pre&gt;';$c-&gt;detachBehavior('test');echo '&lt;pre&gt;'; var_dump($c); echo '&lt;/pre&gt;';$b-&gt;mixin($c, 'test');echo '&lt;pre&gt;'; var_dump($c); echo '&lt;/pre&gt;';$c-&gt;detachBehavior('test');$b-&gt;mixin($c);echo '&lt;pre&gt;'; var_dump($c); echo '&lt;/pre&gt;';$c-&gt;test('hello world');","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"}]},{"title":"讀完《湘行散記》","slug":"after-reading-sketches-of-the-travel-to-hunan","date":"2014-11-29T12:17:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-sketches-of-the-travel-to-hunan/","link":"","permalink":"http://0x3f.org/post/after-reading-sketches-of-the-travel-to-hunan/","excerpt":"","text":"能讓我這個不喜歡讀散文的人堅持讀完的，是枕著一葉扁舟、聽著潺潺流水、忖著多年後的自己——身在何方、心念何人、情系何物……","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"散文","slug":"散文","permalink":"http://0x3f.org/tags/散文/"}]},{"title":"Phalcon項目中PHPUnit的初始化","slug":"testing-with-phpunit-in-phalcon","date":"2014-11-29T01:58:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/testing-with-phpunit-in-phalcon/","link":"","permalink":"http://0x3f.org/post/testing-with-phpunit-in-phalcon/","excerpt":"","text":"參考官方文檔，稍作修改。 在項目下創建目錄unittests，進入目錄執行： 1composer require phpunit/phpunit 創建tests目錄并在其中創建文件Bootstrap.php： 12345678910111213141516171819202122232425262728293031&lt;?phpuse Phalcon\\DI, Phalcon\\DI\\FactoryDefault;ini_set('display_errors',1);error_reporting(E_ALL);define('ROOT_PATH', __DIR__);define('PROJECT_DIR', '/home/taoqi/workspace');set_include_path( ROOT_PATH . PATH_SEPARATOR . get_include_path());// required for phalcon/incubatorinclude __DIR__ . \"/../vendor/autoload.php\";// 加載項目文件$config = require_once PROJECT_DIR.'/web/config/config.php';require_once PROJECT_DIR.'/web/config/loader.php';$loader-&gt;registerDirs(array( ROOT_PATH), true);// $di = new FactoryDefault();DI::reset();// add any needed services to the DI hererequire_once PROJECT_DIR.'/web/config/services.php';DI::setDefault($di); 安裝phalcon的phpunit輔助庫： 1composer require phalcon/incubator 創建phpunit.xml： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;phpunit bootstrap=\"./Bootstrap.php\" backupGlobals=\"false\" backupStaticAttributes=\"false\" verbose=\"true\" colors=\"false\" convertErrorsToExceptions=\"true\" convertNoticesToExceptions=\"true\" convertWarningsToExceptions=\"true\" processIsolation=\"false\" stopOnFailure=\"false\" syntaxCheck=\"true\"&gt; &lt;testsuite name=\"Phalcon - Testsuite\"&gt; &lt;directory&gt;./&lt;/directory&gt; &lt;/testsuite&gt;&lt;/phpunit&gt; 創建單元測試基類UnitTestCase.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpuse Phalcon\\DI, \\Phalcon\\Test\\UnitTestCase as PhalconTestCase;abstract class UnitTestCase extends PhalconTestCase &#123; /** * @var \\Voice\\Cache */ protected $_cache; /** * @var \\Phalcon\\Config */ protected $_config; /** * @var bool */ private $_loaded = false; public function setUp(Phalcon\\DiInterface $di = NULL, Phalcon\\Config $config = NULL) &#123; // Load any additional services that might be required during testing $di = DI::getDefault(); // get any DI components here. If you have a config, be sure to pass it to the parent parent::setUp($di); $this-&gt;_loaded = true; &#125; /** * Check if the test case is setup properly * @throws \\PHPUnit_Framework_IncompleteTestError; */ public function __destruct() &#123; if(!$this-&gt;_loaded) &#123; throw new \\PHPUnit_Framework_IncompleteTestError('Please run parent::setUp().'); &#125; &#125;&#125; 創建單元測試類testsTestUnitTest.php： 123456789101112131415&lt;?phpnamespace Test;/** * Class UnitTest */class UnitTests extends \\UnitTestCase &#123; public function testTestCase() &#123; $post = \\Post::find(33); $this-&gt;assertObjectHasAttribute('title', $post, 'where is title ?'); &#125;&#125; 在tests目錄下建立phpunit的軟連接并執行測試： 12ln -sf ../vendor/bin/phpunit run./run 另：發現個詭異的問題，如果Model中不覆蓋getSource()方法，單元測試中會自動找用下劃線分隔的表名，即假如Model名爲FooBar，會去找foo_bar的表名，但正常執行程序時找的是foobar。在官方論壇問的問題還木有解決。phalcon坑挺多的。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"phalcon","slug":"phalcon","permalink":"http://0x3f.org/tags/phalcon/"},{"name":"phpunit","slug":"phpunit","permalink":"http://0x3f.org/tags/phpunit/"}]},{"title":"用好代碼時光機","slug":"leverage-code-time-machine","date":"2014-11-21T15:19:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/leverage-code-time-machine/","link":"","permalink":"http://0x3f.org/post/leverage-code-time-machine/","excerpt":"","text":"今天看了篇文章，講幾種常見的、糟糕的注釋用法。其中之一是把廢棄的代碼注釋起來，而不是直接删掉，原因是擔心以後可能會用。 這個其實就是版本控制系統（VCS）要解決的問題之一。包括對于團隊協作的項目，經常需要看某段代碼是誰改的、什麽時間、什麽原因。都是可以用VCS很方便地解決的問題。 我以前是用二分法在提交列表裏找的。其實有更好的解決方法，思路是列出源碼在曆次提交中修改的内容，然後在其中查找要找的東西就行了。 git的解決方法： 1git log -p abc.php svn的解決方法： 1svn log --diff --internal-diff abc.php vim的輔助函數： 1234567891011121314151617181920212223\" Show commit history of the current file under the given VCS in a new windowfunction! ShowCommitHistory(vcs) \" Check parameter if a:vcs != 'svn' &amp;&amp; a:vcs != 'git' echoerr 'Unknow VCS: '.a:vcs return endif \" Do the dirty work let fileName = expand('%') if !empty(fileName) exe 'new' if a:vcs == 'svn' exe 'r !svn log --diff --internal-diff '.fileName elseif a:vcs == 'git' exe 'r !git log -p '.fileName endif else echo 'File not found.' endifendfunctionnnoremap &lt;leader&gt;ssch :call ShowCommitHistory('svn')&lt;CR&gt;nnoremap &lt;leader&gt;gsch :call ShowCommitHistory('git')&lt;CR&gt;","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"git","slug":"git","permalink":"http://0x3f.org/tags/git/"},{"name":"svn","slug":"svn","permalink":"http://0x3f.org/tags/svn/"}]},{"title":"開始用在線Markdown編輯器記筆記","slug":"start-taking-note-in-online-markdown-editor","date":"2014-11-20T14:35:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/start-taking-note-in-online-markdown-editor/","link":"","permalink":"http://0x3f.org/post/start-taking-note-in-online-markdown-editor/","excerpt":"","text":"開始用支持VIM模式的在線Markdown編輯器記筆記。既非鼠輩（鼠标依賴症不治者），始終忍受不了其它WYSIWYG（所見即所得）的在線筆記。 大部分在線筆記最傻X的一點是，必須點一下編輯按鈕才能開始寫東西。支持VIM模式的筆記就不用說了，絲般順滑，不是我大Vimer就不會懂個中騷柔。 組織上一向後知後覺。智能手機剛開始的時候，組織上很不感冒，理由是屏幕易碎、電池難支、馮唐易老、李廣難封。而今現在眼目下，一日不搞機，如隔三秋。在線Markdown編輯器出現也有段時間了，一直覺得這貨無非就是給Markdown加了個可笑的準WYSIWYG，現在看來，真是做筆記的不二神器，罪過罪過。 說說組織上跟Markdown的故事。很久很久以前，博客剛開始流行的時候，組織上開始寫博客，和大部分人一樣，注冊個賬号寫公開日記，很快就忍受不了WYSIWYG編輯器失控的格式，于是開始手寫HTML代碼，很快就發現這貨真TM反人類，從此恨烏及烏至今最讨厭的數據交換格式還是XML，于是自定幾種格式或标記，用Java寫了個解析工具，把文章源碼翻譯成HTML。突然有天發現這個星球上居然有種叫輕量型标記語言的東西，幹的就是這麽個事，隻不過我的那些标記和解析工具又醜又爛而已。試了幾種之後，最終選了Markdown，從此舉案齊眉雲雲。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"markdown","slug":"markdown","permalink":"http://0x3f.org/tags/markdown/"},{"name":"編輯器","slug":"編輯器","permalink":"http://0x3f.org/tags/編輯器/"}]},{"title":"Vim強制在PHP中使用HTML註釋的方法","slug":"force-commenting-html-in-php-files-in-vim","date":"2014-11-13T13:45:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/force-commenting-html-in-php-files-in-vim/","link":"","permalink":"http://0x3f.org/post/force-commenting-html-in-php-files-in-vim/","excerpt":"","text":"對PHP頁面模板中的HTML做註釋，NERDCommenter是根據文件類型處理的，所以必須臨時轉換文件類型： 1234567891011121314151617181920\" 强制使用HTML的注释function! ForceHTMLComment(mode, type) range set ft=html if a:mode == \"x\" execute a:firstline.\",\".a:lastline.\"call NERDComment(\\\"x\\\", \\\"\".a:type.\"\\\")\" else if a:type == \"Sexy\" normal ,cs else normal ,cc endif endif set ft=phpendfunctionau FileType php nmap &lt;buffer&gt; &lt;leader&gt;fhcc :call ForceHTMLComment(\"n\", \"Comment\")&lt;CR&gt;au FileType php vmap &lt;buffer&gt; &lt;leader&gt;fhcc :call ForceHTMLComment(\"x\", \"Comment\")&lt;CR&gt;au FileType php nmap &lt;buffer&gt; &lt;leader&gt;fhcs :call ForceHTMLComment(\"n\", \"Sexy\")&lt;CR&gt;au FileType php vmap &lt;buffer&gt; &lt;leader&gt;fhcs :call ForceHTMLComment(\"x\", \"Sexy\")&lt;CR&gt;au FileType php nmap &lt;buffer&gt; &lt;leader&gt;fhcu :call ForceHTMLComment(\"n\", \"Uncomment\")&lt;CR&gt;au FileType php vmap &lt;buffer&gt; &lt;leader&gt;fhcu :call ForceHTMLComment(\"x\", \"Uncomment\")&lt;CR&gt; 有日子沒寫vimscript了，手都生了。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"html","slug":"html","permalink":"http://0x3f.org/tags/html/"}]},{"title":"ZSH下新安裝的程序無法自動補全的解決方法","slug":"how-to-auto-complete-newly-installed-command-in-zsh","date":"2014-11-12T14:15:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-auto-complete-newly-installed-command-in-zsh/","link":"","permalink":"http://0x3f.org/post/how-to-auto-complete-newly-installed-command-in-zsh/","excerpt":"","text":"Zsh默認開啟了對PATH變量的緩存，這是導致新安裝的程序無法立即使用自動補全的原因。 其實只要PATH變量不太複雜，安裝的程序不太多，完全沒必要開啟緩存，實際上我把緩存關掉後完全沒有感覺到補全的速度有什麼變化。 方法如下，在.zshrc中增加一行： 1zstyle ':completion:*' rehash true 也可以在必要的時間手工執行命令rehash，也是個臨時解決方法。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"zsh","slug":"zsh","permalink":"http://0x3f.org/tags/zsh/"},{"name":"linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"}]},{"title":"接管PHP致命錯誤的方法","slug":"how-to-take-over-php-fatal-error-handling","date":"2014-11-11T16:47:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-take-over-php-fatal-error-handling/","link":"","permalink":"http://0x3f.org/post/how-to-take-over-php-fatal-error-handling/","excerpt":"","text":"Yii 2.0引入了一項新特性，可以接管PHP的致命錯誤。在此之前，如果PHP源碼有語法錯誤，框架本身是不會處理的。 實現的思路如下： 禁止顯示錯誤 註冊自定義的shutdown回調函數 在回調函數中獲取最近的錯誤 若錯誤是致命錯誤，調用相應的處理邏輯 代碼如下： 1234567891011121314151617&lt;?php// ...ini_set('display_errors', false);register_shutdown_function(function()&#123; $error = error_get_last(); if (isset($error['type']) &amp;&amp; in_array($error['type'], [E_ERROR, E_PARSE, E_CORE_ERROR, E_CORE_WARNING, E_COMPILE_ERROR, E_COMPILE_WARNING])) &#123; ob_clean(); echo '&lt;pre&gt;'; var_dump($error); echo '&lt;/pre&gt;'; exit(1); &#125;&#125;);// ...?&gt;","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"}]},{"title":"讀完《黑客與畫家》","slug":"after-reading-hackers-and-painters","date":"2014-10-26T02:06:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-hackers-and-painters/","link":"","permalink":"http://0x3f.org/post/after-reading-hackers-and-painters/","excerpt":"","text":"身兼技術牛人和創業成功者兩個身份，自然有資格指點江山，有些觀點很自負，有些觀點對人有啟發。作者很推崇Lisp，很不屑Java。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"黑客","slug":"黑客","permalink":"http://0x3f.org/tags/黑客/"},{"name":"創業","slug":"創業","permalink":"http://0x3f.org/tags/創業/"}]},{"title":"讀完《MongoDB權威指南》第二版","slug":"after-reading-mongodb-the-definitive-guide","date":"2014-10-26T02:01:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-mongodb-the-definitive-guide/","link":"","permalink":"http://0x3f.org/post/after-reading-mongodb-the-definitive-guide/","excerpt":"","text":"第二版比第一版補充了很多內容，介紹得很詳細，是學習mongodb的好書。 但是翻譯版有很多印刷錯誤，個別譯句也有問題。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"數據庫","slug":"數據庫","permalink":"http://0x3f.org/tags/數據庫/"},{"name":"NoSQL","slug":"nosql","permalink":"http://0x3f.org/tags/nosql/"},{"name":"MongoDB","slug":"mongodb","permalink":"http://0x3f.org/tags/mongodb/"}]},{"title":"讀完《冰與火之歌》卷一","slug":"after-reading-a-song-of-ice-and-fire-v1","date":"2014-10-26T01:56:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-a-song-of-ice-and-fire-v1/","link":"","permalink":"http://0x3f.org/post/after-reading-a-song-of-ice-and-fire-v1/","excerpt":"","text":"讀了一部分，還是不怎麼喜歡西方中世紀文化，最後改看電視劇，拍得也很一般。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"小說","slug":"小說","permalink":"http://0x3f.org/tags/小說/"}]},{"title":"讀完《城南舊事》","slug":"after-reading-my-memories-of-old-beijing","date":"2014-10-26T01:40:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-my-memories-of-old-beijing/","link":"","permalink":"http://0x3f.org/post/after-reading-my-memories-of-old-beijing/","excerpt":"","text":"描写民国时北京南城市民生活很生动，但是以儿童的视角叙事显得揣着明白装糊涂。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"小說","slug":"小說","permalink":"http://0x3f.org/tags/小說/"}]},{"title":"讀完《邊城》","slug":"after-reading-border-town","date":"2014-10-26T01:32:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-border-town/","link":"","permalink":"http://0x3f.org/post/after-reading-border-town/","excerpt":"","text":"文章写得很美，本打算十一去茶峒，看看顺顺吊脚楼，坐坐白塔下的拉拉渡，临时改了行程，只能以后有空再去了。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"小說","slug":"小說","permalink":"http://0x3f.org/tags/小說/"}]},{"title":"放棄《一座城池》和《天才在左瘋子在右》","slug":"give-up-the-ideal-city-and-genius-and-madman","date":"2014-10-26T01:30:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/give-up-the-ideal-city-and-genius-and-madman/","link":"","permalink":"http://0x3f.org/post/give-up-the-ideal-city-and-genius-and-madman/","excerpt":"","text":"现在不喜欢这种书了。 內心不夠強大，再看下去我就疯了。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"小說","slug":"小說","permalink":"http://0x3f.org/tags/小說/"}]},{"title":"讀完《中國大歷史》","slug":"after-reading-big-history-of-china","date":"2014-09-12T15:07:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-big-history-of-china/","link":"","permalink":"http://0x3f.org/post/after-reading-big-history-of-china/","excerpt":"","text":"偏学术，比较抽象，不如《万历十五年》好看。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"}]},{"title":"讀完《中國歷代政治得失》","slug":"after-reading-political-gain-and-loss-of-china","date":"2014-08-31T15:19:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-political-gain-and-loss-of-china/","link":"","permalink":"http://0x3f.org/post/after-reading-political-gain-and-loss-of-china/","excerpt":"","text":"錢穆有文俠風，讀這本書，能看到這樣一個影子，上馬擊狂胡，下馬草軍書。他也是個民族主義者，提到元清，幾乎沒一句好話。所以要貫通國史，還得多讀讀別的書。總體來說，讀這本書時常感醍醐灌頂，為習國史者必讀。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"},{"name":"國史","slug":"國史","permalink":"http://0x3f.org/tags/國史/"}]},{"title":"讀完《中國史綱》","slug":"after-reading-brief-history-of-china","date":"2014-08-20T14:30:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-brief-history-of-china/","link":"","permalink":"http://0x3f.org/post/after-reading-brief-history-of-china/","excerpt":"","text":"自序中對治史的方法論讓我受益匪淺，本書語氣平和、娓娓道來，像講故事一樣講曆史，但又嚴謹、廣博、不膚淺，風格和其它史書大不一樣，我一直理想中的史書就是這樣，不要給曆史背太重的包袱，不要帶著一定要學點什麽的目的讀曆史。 本書的缺點是詳略失當。有些地方太簡略，比如匈奴的衰落，五單于爭立一筆帶過。有些地方太詳細，鴻門宴幾乎是史記的譯文。作爲一部通史，應該有大曆史觀，能站在較高的層面上把曆史的脈絡梳理清楚。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"},{"name":"國史","slug":"國史","permalink":"http://0x3f.org/tags/國史/"}]},{"title":"讀完《莊子今注今譯》","slug":"after-reading-zhuangzi-jin-zhu-jin-yi","date":"2014-08-17T10:36:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-zhuangzi-jin-zhu-jin-yi/","link":"","permalink":"http://0x3f.org/post/after-reading-zhuangzi-jin-zhu-jin-yi/","excerpt":"","text":"很好的注本，有些字句的翻譯有點兒晦澀。莊子的思想超越了老子，想把莊子的思想理解透徹很難。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"哲學","slug":"哲學","permalink":"http://0x3f.org/tags/哲學/"},{"name":"莊子","slug":"莊子","permalink":"http://0x3f.org/tags/莊子/"},{"name":"道家","slug":"道家","permalink":"http://0x3f.org/tags/道家/"},{"name":"諸子","slug":"諸子","permalink":"http://0x3f.org/tags/諸子/"}]},{"title":"Project Euler Problem 25 Solved","slug":"project-euler-25-solved","date":"2014-08-16T09:32:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-25-solved/","link":"","permalink":"http://0x3f.org/post/project-euler-25-solved/","excerpt":"","text":"1000-digit Fibonacci numberThe Fibonacci sequence is defined by the recurrence relation: Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1. Hence the first 12 terms will be: F1 = 1F2 = 1F3 = 2F4 = 3F5 = 5F6 = 8F7 = 13F8 = 21F9 = 34F10 = 55F11 = 89F12 = 144 The 12th term, F12, is the first term to contain three digits. What is the first term in the Fibonacci sequence to contain 1000 digits? SolutionTo be progmatic, take the brute-force approach. Furthermore, here gives a formula which solves this problem, but it’s too mathematical.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"euler","slug":"euler","permalink":"http://0x3f.org/tags/euler/"}]},{"title":"讀完《國史大綱》","slug":"after-reading-outline-history","date":"2014-07-16T13:27:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-outline-history/","link":"","permalink":"http://0x3f.org/post/after-reading-outline-history/","excerpt":"","text":"錢穆先生主張以誠敬心審視國史和傳統文化，一生為故國招魂。抗戰流亡，筆耕不輟，雖然這本書只是一本歷史教科書，但是高屋建瓴的大歷史觀讓我受益匪淺，很多東西是讀史料不能學到的。《國史大綱》所思所言，堪稱國史良心。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"}]},{"title":"使用lsyncd同步文件","slug":"live-syncing-daemon","date":"2014-06-18T06:03:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/live-syncing-daemon/","link":"","permalink":"http://0x3f.org/post/live-syncing-daemon/","excerpt":"","text":"lsyncd全稱“Live Syncing Daemon”，是Linux下的文件自动同步工具，同时支持SSH、rsync的实现方式。相对于rsync+inotify，它速度更快，也更穩定。 對於SSH的方式，需要目標機器中已啟動SSHD，並把源機器上的公鑰加到目標機器root用戶的authorized_keys中，私鑰應放在源機器上運行lsyncd的用戶的.ssh目錄中，密鑰放錯了用戶，會導致無法同步。 然後就是在源機器上創建配置文件，lsyncd的配置文件是個lua腳本： lsyncd.conf1234567891011121314151617181920settings&#123; pidfile = \"/var/log/lsyncd/lsyncd.pid\", logfile = \"/var/log/lsyncd/lsyncd.log\", statusFile = \"/var/log/lsyncd/lsyncd-status.log\", statusInterval = 1, maxDelays = 1, -- nodaemon = true,&#125;sync&#123; default.rsyncssh, source = \"/home/monk/workspace\", host = \"192.168.1.3\", targetdir = \"/var/www/workspace\", exclude=&#123; \".*\", \"*.tmp\" &#125;, rsync = &#123; compress = false, _extra = &#123;\"--bwlimit=50000\"&#125;, &#125;&#125; 然後啟動lsyncd： 1sudo lsyncd /etc/lsyncd.conf","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"應用","slug":"應用","permalink":"http://0x3f.org/tags/應用/"}]},{"title":"Project Euler Problem 24 Solved","slug":"project-euler-24","date":"2014-04-27T13:17:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-24/","link":"","permalink":"http://0x3f.org/post/project-euler-24/","excerpt":"","text":"Lexicographic permutationsA permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are: 012 021 102 120 201 210 What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9? Solutionp24.py123456789101112131415161718192021222324#!/usr/bin/python2# -*- coding: utf-8 -*-from math import factorialdef get_perm(digits, number): if len(digits) == 0: return '' (perm, counter) = ('', factorial(len(digits) - 1)) for digit in digits: if counter &gt;= number: digits.remove(digit) perm += str(digit) + get_perm(digits, number) break number -= counter return permif __name__ == '__main__': import time startTime = time.time() perm = get_perm([d for d in range(10)], 1000000) print perm, '%sms' % ((time.time() - startTime) * 1000) p24.php12345678910111213141516171819202122232425262728&lt;?phpfunction factorial($n) &#123; $result = 1; for ($i = 2;$i &lt;= $n;$i++) $result*= $i; return $result;&#125;function get_perm($digits, $number) &#123; $perm = \"\"; $length = count($digits); $counter = factorial($length - 1); for ($i = 0;$i &lt; $length;$i++) &#123; if ($counter &gt;= $number) &#123; $segment = array_splice($digits, $i, 1); $perm = $segment[0] . get_perm($digits, $number); break; &#125; $number-= $counter; &#125; return $perm;&#125;$startTime = microtime(true);$digits = array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);$perm = get_perm($digits, 1000000);$costs = (microtime(true) - $startTime) * 1000;echo \"$perm $&#123;costs&#125;ms\\n\";?&gt; p24.go12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"strconv\" \"time\")func factorial(n int) int &#123; result := 1 for i := 2; i &lt;= n; i++ &#123; result *= i &#125; return result&#125;func get_perm(digits []int, number int) string &#123; perm, length := \"\", len(digits) counter := factorial(length - 1) for i := 0; i &lt; length; i++ &#123; if counter &gt;= number &#123; digit := digits[i] digits = append(digits[:i], digits[i+1:]...) perm += strconv.Itoa(digit) + get_perm(digits, number) break &#125; number -= counter &#125; return perm&#125;func main() &#123; startTime := time.Now() digits := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125; perm := get_perm(digits, 1000000) fmt.Println(perm, time.Now().Sub(startTime))&#125; I’m the 57181st person to have solved this problem. I’ve just advanced to Level 1. 61264 members (15.9%) have made it this far. I have earned 1 new award: The Journey Begins: Progress to Level 1 by solving twenty-five problems","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"},{"name":"python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"}]},{"title":"Project Euler Problem 23 Solved","slug":"project-euler-23","date":"2014-04-25T15:56:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-23/","link":"","permalink":"http://0x3f.org/post/project-euler-23/","excerpt":"","text":"Non-abundant sumsA perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number. A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n. As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit. Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers. SolutionUsing sets instead of lists greatly improves performance in Python: p23.py1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python# -*- coding: utf-8 -*-def sum_proper_factors(n): (result, sqrt) = (1, n ** 0.5) (start, step) = n % 2 == 1 and (3, 2) or (2, 1) for i in range(start, int(sqrt) + 1, step): if n % i == 0: result += i + n / i if sqrt == int(sqrt): result -= sqrt return resultdef main(): (result, limit, abundants) = (0, 28124, set()) for n in range(1, limit): if sum_proper_factors(n) &gt; n: abundants.add(n) if not any(n - a in abundants for a in abundants): result += n print resultif __name__ == '__main__': import time startTime = time.time() main() print time.time() - startTime Simulate sets using maps in Go: p23.go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"fmt\" \"math\" \"time\")func sum_proper_factors(n int) int &#123; result, sqrt := 1, math.Sqrt(float64(n)) start, step := 2, 1 if n%2 == 1 &#123; start, step = 3, 2 &#125; for i := start; i &lt;= int(sqrt); i += step &#123; if n%i == 0 &#123; result += i + n/i &#125; &#125; if sqrt == float64(int(sqrt)) &#123; result -= int(sqrt) &#125; return result&#125;func main() &#123; result, limit, abundants, startTime := 0, 28124, make(map[int]bool), time.Now() for n := 1; n &lt; limit; n++ &#123; if sum_proper_factors(n) &gt; n &#123; abundants[n] = true &#125; isSumOfTwoAbundants := false for k := range abundants &#123; if abundants[n-k] == true &#123; isSumOfTwoAbundants = true break &#125; &#125; if !isSumOfTwoAbundants &#123; result += n &#125; &#125; fmt.Println(result, time.Now().Sub(startTime))&#125; I’m the 49489th person to have solved this problem.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"},{"name":"python","slug":"python","permalink":"http://0x3f.org/tags/python/"}]},{"title":"UltraBlog.vim v3.6.1: 文章分類自動補全","slug":"ultrablog-v361-released","date":"2014-04-20T14:50:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ultrablog-v361-released/","link":"","permalink":"http://0x3f.org/post/ultrablog-v361-released/","excerpt":"","text":"春節期間收到兩個issue，一直拖到今天才有時間完成。 增加了一個功能，在文章編輯視圖的元數據中分類那行，使用熱鍵\\\\自動完成文章的分類。在配置數組ub_blog中增加鍵值對“categories”，默認使用這一項的值實現自動完成，如下： 1234567let ub_blog = &#123;'login_name':'admin', \\'password':'pass2011', \\'url':'http://www.sample.com/', \\'xmlrpc_uri':'xmlrpc.php', \\'db':'$VIM/UltraBlog.db', \\'categories': 'News|Computer|Image' \\&#125; 如果這一項不存在，將從博客中拉取分類數據。 自從遷移到Octopress，有兩年不用Wordpress了，沒想到居然還有人在用UltraBlog.vim。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"UltraBlog.vim","slug":"ultrablog-vim","permalink":"http://0x3f.org/tags/ultrablog-vim/"}]},{"title":"Project Euler Problem 22 Solved","slug":"project-euler-22","date":"2014-04-20T00:03:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-22/","link":"","permalink":"http://0x3f.org/post/project-euler-22/","excerpt":"","text":"Names scoresUsing names.txt (right click and ‘Save Link/Target As…’), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score. For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 × 53 = 49714. What is the total of all the name scores in the file? SolutionPretty code snippets are easily to be implemented in Python as always: p22.py12345678910#!/usr/bin/python# -*- coding: utf-8 -*-if __name__ == '__main__': f = open('names.txt') names = sorted(f.readline().replace('\"', '').split(',')) f.close() print sum(map(lambda name: sum([ord(c) - 64 for c in name]) \\ * (names.index(name) + 1), names)) Easy as Python, ugly as shit, here is the PHP implementation: p22.php123456789&lt;?php$names = explode(',', str_replace('\"', '', file_get_contents('names.txt')));sort($names, SORT_STRING);$cal_alpha_value = function($name, $i) &#123; $cal_alpha_index = function($char)&#123;return ord($char) - 64;&#125;; return array_sum(array_map($cal_alpha_index, str_split($name, 1))) * $i;&#125;;echo array_sum(array_map($cal_alpha_value, $names, range(1, count($names))));?&gt; p22.go12345678910111213141516171819202122232425262728293031323334package mainimport ( \"bufio\" \"fmt\" \"os\" \"sort\" \"strings\")func main() &#123; f, err := os.Open(\"names.txt\") if err != nil &#123; fmt.Println(err) os.Exit(1) &#125; defer f.Close() reader := bufio.NewReader(f) line, _ := reader.ReadString('\\n') names := strings.Split(strings.Replace(line, \"\\\"\", \"\", -1), \",\") sort.Sort(sort.StringSlice(names)) val := 0 for i := 0; i &lt; len(names); i++ &#123; tmp := 0 for j := 0; j &lt; len(names[i]); j++ &#123; tmp += int(names[i][j]) - 64 &#125; val += tmp * (i + 1) &#125; fmt.Println(val)&#125; I’m the 65646th person to have solved this problem.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"},{"name":"python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"php","slug":"php","permalink":"http://0x3f.org/tags/php/"}]},{"title":"騎行的已知和未知","slug":"cycling-in-the-known-and-unknown","date":"2014-04-19T13:44:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/cycling-in-the-known-and-unknown/","link":"","permalink":"http://0x3f.org/post/cycling-in-the-known-and-unknown/","excerpt":"","text":"暫時沒有好路線，所以今天是保持性練習。上周發現順時針繞道G109從軍莊路放坡下來會很輕鬆，所以依舊從香岩寺出發，經黑山扈路、香山路、香山南路、八大處路、模式口大街、G109、軍莊路、北清路，最後回到出發點。 照例，先交作業： 走香山路是因為不想重複上周的老路，但是很快就體會到了不長記性的後果，這條路似乎從來沒有不堵過，天氣這麼差都擋不住這麼多人，植物園門口一坨一坨的，我一直覺得香山之難看、植物園之無聊可著北京城都是數一數二的，要不說文人可惡呢，忽悠了多少人！ 傳說中的模式口大街居然只是一條很窄的巷子，兩邊是很舊的居民區，時近中午，這麼窄的路上居然擠滿了一坨一坨的人。 軍莊路似乎一般是上午會有很多拉土方的卡車，上週我中午過後經過時車就不多，不幸今天中獎了，要不是貪圖放坡的快感，打死也不走這條路。 總之今天走的不是個好路線，不如上周盧溝橋那一圈，很大程度上是因為想到的路線都有坡，加上天氣不好、準備不充分，有點兒怵。以往的經歷，第一次走的路線，因為不知道前面會有什麼，懷著對未知的好奇和無畏，不管多困難，總是可以堅持下來，但下次就不敢了，因為有痛苦的經歷。所以騎行的樂趣在於對未知的好奇，或者是克服對已知的恐懼。前一種我還行，至於後者，無力吐槽，唯余呵呵。","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"騎行","slug":"騎行","permalink":"http://0x3f.org/tags/騎行/"}]},{"title":"Project Euler Problem 21 Solved","slug":"project-euler-21","date":"2014-04-17T14:18:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-21/","link":"","permalink":"http://0x3f.org/post/project-euler-21/","excerpt":"","text":"Amicable numbersLet d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers. For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220. Evaluate the sum of all the amicable numbers under 10000. Solutionp21.py123456789101112131415161718192021222324252627282930313233#!/usr/bin/python# -*- coding: utf-8 -*-def sum_proper_factors(n): (result, sqrt) = (1, n ** 0.5) (start, step) = n % 2 == 1 and (3, 2) or (2, 1) for i in range(start, int(sqrt) + 1, step): if n % i == 0: result += i + n / i if sqrt == int(sqrt): result -= sqrt return resultdef main(): result = 0 for i in range(1, 10000): sum1 = sum_proper_factors(i) if sum1 &gt; i: if i == sum_proper_factors(sum1): result += i + sum1 print resultif __name__ == '__main__': import time startTime = time.time() main() print time.time() - startTime p21.go123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"fmt\" \"math\" \"time\")func sum_proper_factors(n int) int &#123; sum, sqrt := 1, math.Sqrt(float64(n)) start, step := 2, 1 if n%2 == 1 &#123; start, step = 3, 2 &#125; for i := start; i &lt;= int(sqrt); i += step &#123; if n%i == 0 &#123; sum += i + n/i &#125; &#125; if sqrt == float64(int(sqrt)) &#123; sum -= int(sqrt) &#125; return sum&#125;func main() &#123; result, startTime := 0, time.Now() for i := 1; i &lt; 10000; i++ &#123; iSum := sum_proper_factors(i) if iSum &gt; i &#123; if i == sum_proper_factors(iSum) &#123; result += i + iSum &#125; &#125; &#125; fmt.Println(result, time.Now().Sub(startTime))&#125; I’m the 70186th person to have solved this problem.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"},{"name":"python","slug":"python","permalink":"http://0x3f.org/tags/python/"}]},{"title":"Project Euler Problem 20 Solved","slug":"project-euler-20","date":"2014-04-14T14:19:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-20/","link":"","permalink":"http://0x3f.org/post/project-euler-20/","excerpt":"","text":"Factorial digit sumn! means n × (n − 1) × … × 3 × 2 × 1 For example, 10! = 10 × 9 × … × 3 × 2 × 1 = 3628800,and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27. Find the sum of the digits in the number 100! Solutionp20.py12345678#!/usr/bin/python# -*- coding: utf-8 -*-if __name__ == '__main__': product = 1 for i in range(2, 101): product *= i print sum([int(x) for x in str(product)]) p20.go1234567891011121314151617181920package mainimport ( \"fmt\" \"math/big\" \"strconv\")func main() &#123; product := big.NewInt(1) for i := 1; i &lt; 101; i++ &#123; product.Mul(product, big.NewInt(int64(i))) &#125; sum := 0 for idx := range product.String() &#123; tmp, _ := strconv.Atoi(product.String()[idx : idx+1]) sum += tmp &#125; fmt.Println(sum)&#125; I’m the 100089th person to have solved this problem.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"},{"name":"python","slug":"python","permalink":"http://0x3f.org/tags/python/"}]},{"title":"騎行盧溝橋","slug":"a-ride-to-lugou-bridge","date":"2014-04-13T11:55:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/a-ride-to-lugou-bridge/","link":"","permalink":"http://0x3f.org/post/a-ride-to-lugou-bridge/","excerpt":"","text":"更始元年三月癸丑，孤親提鐵騎南下盧溝，為甲午一百二十年祭。 以前一直以為很遠，後來發現單程只有三十多公里，而且基本都是平地，自從去年推上妙峰山後，一般難度就不怕不怕啦。 先交作業： 不知道為什麼，記錄到了北安河就結束了，最後十公里木有了。 在網上見有人說從橋西進去不查門票，遂先過永定河，從西邊進去，路上撿了個迷路的小盆友，說剛剛用手機導航直接上了高速！聊 後得知是北科大的學生，曾國藩的老鄉，騎了輛不知道什麼牌子的舊車，怯生生的，不禁遙想老夫當年，去矽谷吃頓七塊錢的土豆牛肉飯都美得不行不行的。 騎到橋西入口，一個大媽模樣的頭從售票處小窗口裡伸出來：“二十！”，要不說我沒有大媽緣呢，走到哪都被攔，去年苦逼哈哈地推到七王墳，大媽說封山防火，片板不得入山。老老實實地買了票，才見著真神，愛個國容易麼。橋是金章宗的時候建的，乾隆五十多年重修。橋下就是永定河，左宗棠任直隸總督時在此治水，舊稱無定河，不過不是“可憐無定河邊骨，猶是春閨夢裡人”裡的那條。 請小盆友拍了張孤王的戎裝照： 果然每個獅子都不一樣，小學課本不余欺也： 盧溝曉月，所謂的燕京八景之一，我一般不尿這種虛無縹緲、濫竽充數的東西，魯迅在《再論雷峰塔的倒掉》裡說： 我们中国的许多人，——我在此特别正重声明：并不包括四万万同胞全部！——大抵患有一种“十景病”，至少是“八景病”，沉重起来的时候大概在清朝。凡看一部县志，这一县往往有十景或八景，如“远村明月”、“萧寺清钟”、“古池好水”之类。 我雖然不喜歡魯迅，因為此人文風過於惼狭和左倾，虽然老先生一再声明不针对所有国人，但还是随处可见断章取义、不懂装懂的人扯大旗作虎皮，动辄就中国人的劣根性怎么怎么样。但在这一点上我跟老先生意见一致，就某些小县城都有所谓“七台八景”，台好歹还有个土堆，景就開始胡扯了。 擺一堆仿明清的大炮幹什麼，跟七七世變不搭調，更容易聯想到兩甲子前的那場戰爭，此日漫揮天下淚，有公足莊海軍威。 小盆友的高中歷史是體育老師教的，居然不知道宛平城。這座長寬只有幾百米的小城是崇禎為抵禦闖賊建的橋頭堡。不要門票。 這麼小的一座城居然還有甕城： 城裡有個抗日紀念館，免費參觀，因為沒處存車，沒有進去，不過受黨國栽培多年，用腳趾頭也能想到裡面都是什麼，不去也罷。城裡沒啥可吃的，小盆友說要回校再吃飯，我心說您是直接奔學院路了，我還有幾十公里路要繞，不補充熱量怎麼行，請小盆友吃了頓熱干面。這兄弟明顯沒有方向感，好容易才讓他找著北，在手機上找好回學院路的路線，最後送出東門，然後告訴他怎麼走之後，老夫才起駕回宮。 之後的路基本比較輕鬆，大體沿永定河一直走，河邊的永定樓氣勢恢宏，懶得拍照了，再上G109，從軍莊路一路放坡下來，很爽。","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"騎行","slug":"騎行","permalink":"http://0x3f.org/tags/騎行/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"},{"name":"盧溝橋","slug":"盧溝橋","permalink":"http://0x3f.org/tags/盧溝橋/"}]},{"title":"Project Euler Problem 19 Solved","slug":"project-euler-19","date":"2014-04-12T13:21:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-19/","link":"","permalink":"http://0x3f.org/post/project-euler-19/","excerpt":"","text":"Counting SundaysYou are given the following information, but you may prefer to do some research for yourself. 1 Jan 1900 was a Monday. Thirty days has September,April, June and November.All the rest have thirty-one,Saving February alone,Which has twenty-eight, rain or shine.And on leap years, twenty-nine. A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400. How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)? Solutionp19.py1234567891011121314151617181920212223242526272829303132#!/usr/bin/python# -*- coding: utf-8 -*-def is_leap(year): return year % 400 == 0 or year % 100 != 0 and year % 4 == 0def count_days(year, month, day): days = 0 for y in range(1900, year): days += is_leap(y) and 366 or 365 thirties = [4, 6, 9, 11] for m in range(1, month): if m == 2: days += is_leap(year) and 29 or 28 else: days += m in thirties and 30 or 31 return days + daydef main(): count = 0 for year in range(1901, 2001): for month in range(1, 13): if count_days(year, month, 1) % 7 == 0: count += 1 print countif __name__ == '__main__': main() p19.go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"fmt\" \"math\")func is_leap(year int) bool &#123; return math.Mod(float64(year), 400) == 0 || math.Mod(float64(year), 100) != 0 &amp;&amp; math.Mod(float64(year), 4) == 0&#125;func count_days(year, month, day int) int &#123; days := 0 for y := 1900; y &lt; year; y++ &#123; if is_leap(y) &#123; days += 366 &#125; else &#123; days += 365 &#125; &#125; for m := 1; m &lt; month; m++ &#123; if m == 2 &#123; if is_leap(year) &#123; days += 29 &#125; else &#123; days += 28 &#125; &#125; else &#123; if m == 4 || m == 6 || m == 9 || m == 11 &#123; days += 30 &#125; else &#123; days += 31 &#125; &#125; &#125; return days + day&#125;func main() &#123; count := 0 for year := 1901; year &lt; 2001; year++ &#123; for month := 1; month &lt; 13; month++ &#123; if math.Mod(float64(count_days(year, month, 1)), 7) == 0 &#123; count++ &#125; &#125; &#125; fmt.Println(count)&#125; I’m the 65183rd person to have solved this problem.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"},{"name":"python","slug":"python","permalink":"http://0x3f.org/tags/python/"}]},{"title":"Project Euler Problem 18&67 Solved","slug":"project-euler-18-and-67","date":"2014-04-10T13:28:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-18-and-67/","link":"","permalink":"http://0x3f.org/post/project-euler-18-and-67/","excerpt":"","text":"Maximum path sum IBy starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23. 37 42 4 68 5 9 3 That is, 3 + 7 + 4 + 9 = 23. Find the maximum total from top to bottom of the triangle below: 7595 6417 47 8218 35 87 1020 04 82 47 6519 01 23 75 03 3488 02 77 73 07 63 6799 65 04 28 06 16 70 9241 41 26 56 83 40 80 70 3341 48 72 33 47 32 37 16 94 2953 71 44 65 25 43 91 52 97 51 1470 11 33 28 77 73 17 78 39 68 17 5791 71 52 38 17 14 91 43 58 50 27 29 4863 66 04 68 89 53 67 30 73 16 69 87 40 3104 62 98 27 23 09 70 98 73 93 38 53 60 04 23 NOTE: As there are only 16384 routes, it is possible to solve this problem by trying every route. However, Problem 67, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o) Solutionp18.py123456789101112131415161718192021222324252627#!/usr/bin/python# -*- coding: utf-8 -*-def main(): matrix = [] file = open('data_p18.txt') for line in file.readlines(): matrix.append(map(int, line.replace('\\n', '').split(' '))) (x, y) = (0, 0) for y in range(len(matrix)): for x in range(len(matrix[y])): if y &gt; 0: greaterParentPathValue = 0 if x &gt; 0: greaterParentPathValue = matrix[y - 1][x - 1] if x &lt; len(matrix[y - 1]) and matrix[y - 1][x] \\ &gt; greaterParentPathValue: greaterParentPathValue = matrix[y - 1][x] matrix[y][x] += greaterParentPathValue print max(matrix[-1])if __name__ == '__main__': main() I’m the 70471st person to have solved this problem. Maximum path sum IIBy starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23. 37 42 4 68 5 9 3 That is, 3 + 7 + 4 + 9 = 23. Find the maximum total from top to bottom in triangle.txt (right click and ‘Save Link/Target As…’), a 15K text file containing a triangle with one-hundred rows. NOTE: This is a much more difficult version of Problem 18. It is not possible to try every route to solve this problem, as there are 2^99 altogether! If you could check one trillion (10^12) routes every second it would take over twenty billion years to check them all. There is an efficient algorithm to solve it. ;o) Solutionp67.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( \"bufio\" \"fmt\" \"io\" \"os\" \"sort\" \"strconv\" \"strings\")func main() &#123; f, err := os.Open(\"data_p67.txt\") if nil != err &#123; fmt.Println(err) os.Exit(1) &#125; defer f.Close() matrix := make([][]int, 0) reader := bufio.NewReader(f) for &#123; line, err := reader.ReadString('\\n') if nil != err || io.EOF == err &#123; break &#125; row := make([]int, 0) numbers := strings.Split(strings.Replace(line, \"\\n\", \"\", -1), \" \") for i := range numbers &#123; number, _ := strconv.Atoi(numbers[i]) row = append(row, number) &#125; matrix = append(matrix, row) &#125; for y := 0; y &lt; len(matrix); y++ &#123; for x := 0; x &lt; len(matrix[y]); x++ &#123; if y &gt; 0 &#123; greaterParentPathValue := 0 if x &gt; 0 &#123; greaterParentPathValue = matrix[y-1][x-1] &#125; if x &lt; len(matrix[y-1]) &amp;&amp; matrix[y-1][x] &gt; greaterParentPathValue &#123; greaterParentPathValue = matrix[y-1][x] &#125; matrix[y][x] += greaterParentPathValue &#125; &#125; &#125; sort.Sort(sort.Reverse(sort.IntSlice(matrix[len(matrix)-1]))) fmt.Println(matrix[len(matrix)-1][0])&#125; I’m the 50650th person to have solved this problem.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"},{"name":"python","slug":"python","permalink":"http://0x3f.org/tags/python/"}]},{"title":"Project Euler Problem 17 Solved","slug":"project-euler-17","date":"2014-04-09T14:29:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-17/","link":"","permalink":"http://0x3f.org/post/project-euler-17/","excerpt":"","text":"Number letter countsIf the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total. If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used? NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of “and” when writing out numbers is in compliance with British usage. Solutionp17.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python# -*- coding: utf-8 -*-def translate_number(num): words = &#123; 0: '', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten', 11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen', 15: 'fifteen', 16: 'sixteen', 17: 'seventeen', 18: 'eighteen', 19: 'nineteen', 20: 'twenty', 30: 'thirty', 40: 'forty', 50: 'fifty', 60: 'sixty', 70: 'seventy', 80: 'eighty', 90: 'ninety', &#125; english = '' if num / 1000 &gt; 0: english += translate_number(num / 1000) + ' thousand' tmp = translate_number(num % 1000) english += ((tmp.strip() == '' or tmp.find('hundred') &gt; -1) and ' ' or ' and ') + tmp elif num / 100 &gt; 0: english += translate_number(num / 100) + ' hundred' tmp = translate_number(num % 100) if tmp.strip() != '': english += ' and ' + tmp else: if words.has_key(num): english += words[num] else: english += words[num / 10 * 10] + '-' + words[num % 10] return englishif __name__ == '__main__': count = 0 for i in range(1, 1001): count += len(translate_number(i).replace(' ', '').replace('-', '')) print count I’m the 71762nd person to have solved this problem.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"},{"name":"python","slug":"python","permalink":"http://0x3f.org/tags/python/"}]},{"title":"Project Euler Problem 16 Solved","slug":"project-euler-16","date":"2014-04-08T13:57:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-16/","link":"","permalink":"http://0x3f.org/post/project-euler-16/","excerpt":"","text":"Power digit sum2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26. What is the sum of the digits of the number 2^1000? Solutionp16.py1234567891011#!/usr/bin/python# -*- coding: utf-8 -*-import mathif __name__ == '__main__': str = format(math.pow(2, 1000), 'f') sum = 0 for c in str[:str.index('.')]: sum += int(c) print sum p16.go1234567891011121314151617181920package mainimport ( \"fmt\" \"math/big\" \"strconv\")func main() &#123; num, base := big.NewInt(1), big.NewInt(2) for power := 0; power &lt; 1000; power++ &#123; num.Mul(num, base) &#125; result := 0 for i := 0; i &lt; len(num.String()); i++ &#123; bit, _ := strconv.Atoi(num.String()[i : i+1]) result += bit &#125; fmt.Println(num.String(), result)&#125; I’m the 109044th person to have solved this problem.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"},{"name":"python","slug":"python","permalink":"http://0x3f.org/tags/python/"}]},{"title":"Project Euler Problem 15 Solved","slug":"project-euler-15","date":"2014-04-02T13:44:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-15/","link":"","permalink":"http://0x3f.org/post/project-euler-15/","excerpt":"","text":"Lattice pathsStarting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner. How many such routes are there through a 20×20 grid? Solutionp15.py123456789101112131415#!/usr/bin/python# -*- coding: utf-8 -*-if __name__ == '__main__': (steps, a, b) = (20, 1, 1) i = steps * 2 while i &gt; steps: a *= i i -= 1 while steps &gt; 1: b *= steps steps -= 1 print a / b I’m the 86747th person to have solved this problem.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"},{"name":"python","slug":"python","permalink":"http://0x3f.org/tags/python/"}]},{"title":"Project Euler Problem 14 Solved","slug":"project-euler-14","date":"2014-04-01T14:17:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-14/","link":"","permalink":"http://0x3f.org/post/project-euler-14/","excerpt":"","text":"Longest Collatz sequenceThe following iterative sequence is defined for the set of positive integers: n → n/2 (n is even)n → 3n + 1 (n is odd) Using the rule above and starting with 13, we generate the following sequence: 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1 It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1. Which starting number, under one million, produces the longest chain? NOTE: Once the chain starts the terms are allowed to go above one million. Solutionp14.go1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"fmt\" \"math\" \"time\")func collatz(n int) int &#123; if n == 1 &#123; return 1 &#125; if math.Mod(float64(n), 2) == 0 &#123; return collatz(n/2) + 1 &#125; else &#123; return collatz(n*3+1) + 1 &#125;&#125;func main() &#123; start := time.Now() i, iLen, count, max := 1000000, 0, 0, 0 for i &gt; 1 &#123; iLen = collatz(i) if iLen &gt; count &#123; count = iLen max = i &#125; i-- &#125; end := time.Now() fmt.Println(end.Sub(start), max, count)&#125; I’m the 104188th person to have solved this problem.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"}]},{"title":"PHP框架實戰（六）：依賴注入","slug":"flamework-dependency-injection","date":"2014-03-30T02:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/flamework-dependency-injection/","link":"","permalink":"http://0x3f.org/post/flamework-dependency-injection/","excerpt":"","text":"簡述依賴注入是個很好的解耦方法，也可以優雅的實現懶加載。 以數據庫連接為例，當一個組件用到數據庫時，最簡單粗暴的辦法是在使用前創建連接： 1234567891011&lt;?phpclass Component &#123; public function doSth() &#123; // ... $db = new DatabaseConnection($schema, $host, $port, $login, $password); // ... &#125;&#125;?&gt; 這樣做的缺點是代碼一旦執行，Component行為將不可更改，有時我們需要在程序執行的過程中決定其行為。很直接地，可以想到給Component添加一個Setter方法： 12345678910111213141516171819&lt;?phpclass Component &#123; private $__db; public function doSth() &#123; // ... if ($this-&gt;__db !== null) &#123; // do something ... &#125; // ... &#125; public function setConnection($db) &#123; $this-&gt;__db = $db; &#125;&#125;?&gt; 這樣就把Component和數據庫連接解耦了。這時又有一個問題，怎樣管理數據庫連接？最簡單粗暴的辦法是在每次使用前創建，如果在程序中多處需要改變數據庫連接，這就把代碼寫死了。 一種解決問題的方法是使用一個全局變量保存連接，對於簡單場景，這沒問題，但是這種做法會污染全局命名空間，尤其是在依賴較多的情況下，這種做法就不可取了。另一種方法就是用一個註冊表持有所有依賴，這就是依賴注入要做的事。 我曾經處理過一個問題，生產環境中即使在無請求的情況下也會在短時間內生成大量會話文件，直接原因是使用了keepalived檢查系統可用性。由於程序在一開始就打開了會話，並且keepalived不能保持會話，導致每次訪問都會生成一個新的會話文件。這就是沒有使用懶加載導致的錯誤。 懶加載可以讓每個組件只有在需要的情況下才被初始化，一方面簡化了代碼、提高了可讀性，另一方面也能提高程序效率、降低資源消耗。如果組件很多，而每次請求實際用到的很少，初始化所有組件產生的資源消耗將會很可觀。 實現用單例模式實現，以鍵值對的形式註冊依賴。同時支持以變量和callable的形式注入，前者用以註冊簡單類型或已實例化的依賴，後者可以用匿名函數的方式更靈活地管理依賴。同時，注入依賴時可以指定該依賴是否為單例模式，如果是，callable類型的依賴將會在第一次被調用後保持下來。此外，使用__call()魔術方法實現直接以getter方法的方式獲取依賴。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?phpnamespace org\\x3f\\flamework\\base;use org\\x3f\\flamework\\exceptions\\FlameException;/** * Dependency Injection Class * * @author Donie Leigh &lt;donie.leigh@gmail.com&gt; * @link http://0x3f.org * @copyright Copyright &amp;copy; 2013-2014 Donie Leigh * @license BSD (3-terms) * @since 1.0 */class DI&#123; /** * @var object Singleton instance * @since 1.0 */ public static $_instance; /** * @var array Services * @since 1.0 */ private $_services = array(); /** * Singleton constructor * @return void * @author Donie Leigh &lt;donie.leigh@gmail.com&gt; * @since 1.0 */ private function __construct() &#123; &#125; /** * Return the singleton instance * @return object Singleton instance * @since 1.0 **/ public static function getInstance() &#123; if (! self::$_instance instanceof self) &#123; self::$_instance = new self(); &#125; return self::$_instance; &#125; /** * Add a service to the register * @param string $key Service name * @param mixed $service Callable to create a service instance or exactly an instance * @param bool $isSingleton Set true to treat this service as singleton * @return void * @since 1.0 **/ public function set($key, $service, $isSingleton=false) &#123; $this-&gt;_services[strtolower($key)] = array( 'service' =&gt; $service, 'isSingleton' =&gt; $isSingleton, 'instance' =&gt; null ); &#125; /** * Get a service instance * @return mixed Service instance * @since 1.0 */ public function get($key) &#123; $key = strtolower($key); if (isset($this-&gt;_services[$key])) &#123; $info = &amp;$this-&gt;_services[$key]; if ($info['instance'] !== null) return $info['instance']; if (is_callable($info['service'])) &#123; $instance = call_user_func($info['service']); if ($info['isSingleton'] === true) $info['instance'] = $instance; return $instance; &#125; else &#123; return $info['service']; &#125; &#125; return null; &#125; /** * Get service with magic method * @param string $method get&#123;ServiceName&#125; * @param array $parameters Parameters, currently useless * @return mixed Service instance * @since 1.0 */ public function __call($method, $parameters) &#123; if (strpos(strtolower($method), 'get') === 0) &#123; $serviceName = substr($method, 3); return $this-&gt;get($serviceName); &#125; throw new FlameException('Call to undefined method: '.$method); &#125; &#125; // END class DI?&gt; 使用1234567891011121314151617181920212223242526272829303132&lt;?php$di = DI::getInstance();// 簡單類型$di-&gt;set('foo', 'bar');// 每次調用生成不同的依賴$di-&gt;set('newPassword', function()&#123; $pwd = ”; $pwdLen = 10; for ($i = 0; $i &lt; $pwdLen; $i++) &#123; $pwd .= chr(mt_rand(33, 126)); &#125; return $pwd;&#125;);// 注入對象實例$di-&gt;set('simpleSession', new SimpleSession());// 依賴在第一次被獲取時動態創建，然後保持為單例$di-&gt;set('complicatedSession', function()&#123; $session = new ComplicatedSession(); $session-&gt;setFirstVisitTime(time()); return $session;&#125;, true);// 獲取依賴echo $di-&gt;get('foo');// 以getter的形式獲取依賴echo $di-&gt;getFoo();?&gt; 總結之前的版本中，org\\x3f\\flamework\\base\\WebApplication中保存了數據庫連接和日誌級別，現在就可以把它們從這個類中解耦了。使用依賴注入，可以使框架核心保持盡可能的精簡，最大程度地保證任何一個組件都是可拆卸和更換的，也是防止過度設計的一個很好的機制。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"框架","slug":"框架","permalink":"http://0x3f.org/tags/框架/"},{"name":"Flamework","slug":"flamework","permalink":"http://0x3f.org/tags/flamework/"}]},{"title":"Project Euler Problem 13 Solved","slug":"project-euler-13","date":"2014-03-30T01:50:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-13/","link":"","permalink":"http://0x3f.org/post/project-euler-13/","excerpt":"","text":"Large sumWork out the first ten digits of the sum of the following one-hundred 50-digit numbers. 37107287533902102798797998220837590246510135740250463769376774900097126481248969700780504170182605387432498619952474105947423330951305812372661730962991942213363574161572522430563301811072406154908250230675882075393461711719803104210475137780632466768926167069662363382013637841838368417873436172675728112879812849979408065481931592621691275889832738442742289174325203219235894228767964876702721893184745144573600130643909116721685684458871160315327670386486105843025439939619828917593665686757934951621764571418565606295021572231965867550793241933316490635246274190492910143244581382266334794475817892575867718337217661963751590579239728245598838407582035653253593990084026335689488301894586282278288018119938482628201427819413994056758715117009439035398664372827112653829987240784473053190104293586865155060062958648615320752733719591914205172558297169388870771546649911559348760353292171497005693854370070576826684624621495650076471787294438377604532826541087568284431911906346940378552177792951453612327252500029607107508256381565671088525835072145876576172410976447339110607218265236877223636045174237069058518606604482076212098132878607339694128114266041808683061932846081119106155694051268969251934325451728388641918047049293215058642563049483624672216484350762017279180399446930047329563406911573244438690812579451408905770622942919710792820955037687525678773091862540744969844508330393682126183363848253301546861961243487676812975343759465158038628759287849020152168555482871720121925776695478182833757993103614740356856449095527097864797581167263201004368978425535399209318374414978068609844840309812907779179908821879532736447567559084803087086987551392711854517078544161852424320693150332599594068957565367821070749269665376763262354472106979395067965269474259770973916669376304263398708541052684708299085211399427365734116182760315001271653786073615010808570091499395125570281987460043753582903531743471732693212357815498262974255273730794953759765105305946966067683156574377167401875275889028025717332296191766687138199318110487701902712526768027607800301367868099252546340106163286652636270218540497705585629946580636237993140746255962240744869082311749777923654662572469233228109171419143028819710328859780666976089293863828502533340334413065578016127815921815005561868836468420090470230530811728164304876237919698424872550366387845831148769693215490281042402013833512446218144177347063783299490636259666498587618221225225512486764533677201869716985443124195724099139590089523100588229554825530026352078153229679624948164195386821877476085327132285723110424803456124867697064507995236377742425354112916842768655389262050249103265729672370191327572567528565324825826546309220705859652229798860272258331913126375147341994889534765745501184957014548792889848568277260777137214037988797153829820378303147352772158034814451349137322665138134829543829199918180278916522431027392251122869539409579530664052326325380441000596549391598795936352974615218550237130764225512118369380358038858490341698116222072977186158236678424689157993532961922624679571944012690438771072750481023908955235974572318970677254791506150550495392297953090112996751986188088225875314529584099251203829009407770775672113067397083047244838165338735023408456470580773088295917476714036319800818712901187549131054712658197623331044818386269515456334926366572897563400500428462801835170705278318394258821455212272512503275512160354698120058176216521282765275169129689778932238195734329339946437501907836945765883352399886755061649651847751807381688378610915273579297013376217784275219262340194239963916804498399317331273132924185707147349566916674687634660915035914677504995186714302352196288948901024233251169136196266227326746080059154747183079839286853520694694454072476841822524674417161514036427982273348055556214818971426179103425986472045168939894221798260880768528778364618279934631376775430780936333301898264209010848802521674670883215120185883543223812876952786713296124747824645386369930090493103636197638780396218407357239979422340623539380833965132740801111666627891981488087797941876876144230030984490851411606618262936828367647447792391803351109890697907148578694408955299065364044742557608365997664579509666024396409905389607120198219976047599490197230297649139826800329731560371200413779037855660850892521673093931987275027546890690370753941304265231501194809377245048795150954100921645863754710598436791786391670211874924319957006419179697775990283006991536871371193661495281130587638027841075444973307840789923115535562561142322423255033685442488917353448899115014406480203690680639606723221932041495354150312888033953605329934036800697771065056663195481234880673210146739058568557934581403627822703280826165707739483275922328459417065250945123252306082291880205877731971983945018088807242966198081119777158542502016545090413245809786882778948721859617721078384350691861554356628840622574736922845095162084960398013400172393067166682355524525280460972253503534226472524250874054075591789781264330331690 Solutionp13.go1234567891011121314151617181920212223242526272829package mainimport ( \"bufio\" \"fmt\" \"io\" \"math/big\" \"os\")func main() &#123; f, err := os.Open(\"data.txt\") if nil != err &#123; fmt.Println(err) os.Exit(1) &#125; defer f.Close() reader := bufio.NewReader(f) sum, tmp := big.NewInt(0), big.NewInt(0) for &#123; line, err := reader.ReadString('\\n') if nil != err || io.EOF == err &#123; break &#125; tmp.SetString(line, 10) sum = sum.Add(sum, tmp) &#125; fmt.Println(sum.String()[:10])&#125; I’m the 106168th person to have solved this problem.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"}]},{"title":"二騎白羊溝","slug":"2nd-ride-to-white-goat-valley","date":"2014-03-29T12:16:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/2nd-ride-to-white-goat-valley/","link":"","permalink":"http://0x3f.org/post/2nd-ride-to-white-goat-valley/","excerpt":"","text":"桃花、迎春花開得很好，但沒有秋天長滿路邊的花有氣氛。早上去得晚了，陽坊鎮的小籠包收攤了…… 交作業： 這次一口氣上了魔鬼六連彎，彎口溪水別樣清啊： 小藍月湖，命名權是我的：","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"騎行","slug":"騎行","permalink":"http://0x3f.org/tags/騎行/"}]},{"title":"Project Euler Problem 12 Solved","slug":"project-euler-12","date":"2014-03-28T14:51:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-12/","link":"","permalink":"http://0x3f.org/post/project-euler-12/","excerpt":"","text":"Highly divisible triangular numberThe sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, … Let us list the factors of the first seven triangle numbers: 1: 1 3: 1,3 6: 1,2,3,610: 1,2,5,1015: 1,3,5,1521: 1,3,7,2128: 1,2,4,7,14,28 We can see that 28 is the first triangle number to have over five divisors. What is the value of the first triangle number to have over five hundred divisors? Solutionp12.go123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"fmt\" \"math\")func count_divisor(num int64) int64 &#123; var count, factor, lastFactor, exponent int64 = 1, 2, 0, 1 for factor &lt;= num &#123; if math.Mod(float64(num), float64(factor)) == 0 &#123; if factor == lastFactor &#123; exponent++ &#125; else &#123; count *= (exponent + 1) exponent = 1 lastFactor = factor &#125; num /= factor &#125; else &#123; factor++ &#125; &#125; return count&#125;func main() &#123; var count, n int64 = 0, 1 for count &lt; 500 &#123; n++ count = count_divisor(n * (n + 1) / 2) &#125; fmt.Println(n*(n+1)/2, count)&#125; I’m the 99509th person to have solved this problem.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"}]},{"title":"使用存取控制表在Linux用戶間共享文件","slug":"share-file-using-access-control-lists","date":"2014-03-19T14:38:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/share-file-using-access-control-lists/","link":"","permalink":"http://0x3f.org/post/share-file-using-access-control-lists/","excerpt":"","text":"我用Dropbox在兩台電腦間同步個人維基數據，將數據目錄從Web Server下軟連接到Dropbox裡，而對Dropbox目錄的備份實際上只包含那個軟連接，沒有內容，結果當把備份拷貝到另一台電腦上並打開Dropbox後，維基數據被清空了！我積累多年的筆記差一點兒完蛋，幸虧單獨備份過維基。然後改將維基數據放到Dropbox裡，然後軟連接到Web Server下，新問題出現了，Web Server是以http身份運行的，對用戶主目錄沒有權限，當然也不能訪問主目錄下的Dropbox目錄。 最簡單的辦法是將主目錄、Dropbox、維基目錄的權限全部設成777，顯然，這樣做太不安全。另一種方法是把Dropbox用NFS輸出，然後掛載到Web Server下，這麼做太蛋疼。最合適的解決方案是Access Control List（存取控制表），它可以為文件和目錄設置具體到單個用戶或用戶組的存取權限，實現像Windows下的文件（目錄）共享權限設置那樣的效果，而且比後者更強大、靈活。 使用ACL首先需要目錄的掛載選項中包含acl，不過一般缺省都包含這一項。 ACL包含兩個命令：getfacl和setfacl，前者用來查看目錄或文件的存取控制表，後者用來操作它。 首先，把維基目錄的所有者改成http，並設置目錄權限為770： 12chown -R http:http ~/Dropbox/wikichmod -R 770 ~/Dropbox/wiki 這時Web Server還是不能訪問維基目錄，使用getfacl查看用戶主目錄的ACL： 1getfacl ~ 顯示結果如下： getfacl: Removing leading ‘/‘ from absolute path names# file: home/taoqi# owner: taoqi# group: usersuser::rwxuser:root:–xgroup::—mask::–xother::— 顯然，要給http用戶訪問該目錄的權限： 1setfacl -m u:http:x ~ 再查看ACL，發現增加了一條： user:http:–x 同理，給Dropbox目錄也加上這一條規則之後，Web Server就可以訪問維基數據目錄了。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"CLI","slug":"cli","permalink":"http://0x3f.org/tags/cli/"}]},{"title":"西山徒步——大覺寺至鳳凰嶺南線","slug":"a-walk-through-the-west-mountain","date":"2014-03-15T11:56:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/a-walk-through-the-west-mountain/","link":"","permalink":"http://0x3f.org/post/a-walk-through-the-west-mountain/","excerpt":"","text":"從大覺寺上，至鳳凰嶺南線下，全程十六公里，最高海拔一千多米，上升一千米，用時七個多小時，難度適中。全程用行者騎行軟件記錄，挺好用，GPS定位准，耗電不大，魅族MX3大概用了60%的電。 記錄數據： 山上的公路很好，在這裡騎行挺好的，只是不知道從哪上來： 在山上接了壺泉水，陸羽《茶經·煮》裡說：“其水，用山水上，江水中，井水下”，上水烹茶，不言其中：","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"徒步","slug":"徒步","permalink":"http://0x3f.org/tags/徒步/"},{"name":"山","slug":"山","permalink":"http://0x3f.org/tags/山/"},{"name":"茶","slug":"茶","permalink":"http://0x3f.org/tags/茶/"}]},{"title":"讀完《The C Programming Language》","slug":"after-reading-the-c-programming-language","date":"2014-03-09T14:47:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-the-c-programming-language/","link":"","permalink":"http://0x3f.org/post/after-reading-the-c-programming-language/","excerpt":"","text":"譚書可能因為面向學生而顯得囉嗦，這本書比譚書精煉。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"Kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"},{"name":"電子書","slug":"電子書","permalink":"http://0x3f.org/tags/電子書/"},{"name":"C","slug":"c","permalink":"http://0x3f.org/tags/c/"}]},{"title":"探訪納蘭家廟","slug":"a-visit-to-the-family-temple-of-nalans","date":"2014-03-07T10:25:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/a-visit-to-the-family-temple-of-nalans/","link":"","permalink":"http://0x3f.org/post/a-visit-to-the-family-temple-of-nalans/","excerpt":"","text":"客居多年，不久前才知道附近有如此底蘊的一個去處，於是趕在開始一段新行程前探訪了這裡。 永泰莊東岳廟，始建於明代，經清代納蘭明珠遺言修繕，供奉明珠牌位，所以又叫納蘭家廟，據說納蘭性德也葬在附近，不過已經難覓詞蹤。 前殿已經殘破不堪，橫生淒涼： 鐘鼓樓已經只剩下西面一座： 雖然沒有重簷，正殿仍然顯得很有氣勢： 宋以後中國知識界思想僵化，明清兩代能拿得出手的只有小品和小說，納蘭詞是一個異數，有清一代的詩詞裡，一定少不了那句“人生若只如初見”。","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"騎行","slug":"騎行","permalink":"http://0x3f.org/tags/騎行/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"}]},{"title":"讀完《你一定愛讀的極簡歐洲史》","slug":"after-reading-the-shortest-history-of-europe","date":"2014-02-23T12:57:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-the-shortest-history-of-europe/","link":"","permalink":"http://0x3f.org/post/after-reading-the-shortest-history-of-europe/","excerpt":"","text":"中国的历史教育培养了一群读了二十年书还分不清五胡十六国和五代十国的人，看看人家是怎么教历史的，提纲挈领比死记签了哪些条约有用多了。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"Kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"},{"name":"電子書","slug":"電子書","permalink":"http://0x3f.org/tags/電子書/"},{"name":"歷史","slug":"歷史","permalink":"http://0x3f.org/tags/歷史/"}]},{"title":"讀完《大數據時代》","slug":"after-reading-big-data-era","date":"2014-02-08T02:11:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-big-data-era/","link":"","permalink":"http://0x3f.org/post/after-reading-big-data-era/","excerpt":"","text":"讀完，我首先感到的不是大數據有多可愛，而是有多可怕。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"Kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"},{"name":"電子書","slug":"電子書","permalink":"http://0x3f.org/tags/電子書/"},{"name":"互聯網","slug":"互聯網","permalink":"http://0x3f.org/tags/互聯網/"},{"name":"大數據","slug":"大數據","permalink":"http://0x3f.org/tags/大數據/"}]},{"title":"讀完《萬歷十五年》","slug":"after-reading-a-year-of-no-significance","date":"2014-02-03T05:17:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-a-year-of-no-significance/","link":"","permalink":"http://0x3f.org/post/after-reading-a-year-of-no-significance/","excerpt":"","text":"國史奇書，一本書讀懂三百年大明。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"Kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"},{"name":"電子書","slug":"電子書","permalink":"http://0x3f.org/tags/電子書/"}]},{"title":"讀完《Go Web編程》","slug":"after-reading-build-web-application-with-golang","date":"2014-02-02T07:52:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-build-web-application-with-golang/","link":"","permalink":"http://0x3f.org/post/after-reading-build-web-application-with-golang/","excerpt":"","text":"用較少的篇幅介紹了golang的語法，然後從實現的角度講了一些Web應用的概念，最後介紹了beego框架。程序員思維，很實用，講Web應用基礎概念的實現的部分很有用，這方面的書不多。語言表達和示例代碼有提升的空間。是Go語言很好的入門教材。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"Kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"},{"name":"電子書","slug":"電子書","permalink":"http://0x3f.org/tags/電子書/"},{"name":"golang","slug":"golang","permalink":"http://0x3f.org/tags/golang/"}]},{"title":"讀完《明朝那些事兒》","slug":"after-reading-ming-chao-na-xie-shi","date":"2014-01-29T04:14:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-ming-chao-na-xie-shi/","link":"","permalink":"http://0x3f.org/post/after-reading-ming-chao-na-xie-shi/","excerpt":"","text":"還舊賬，多年前讀的時候這本書還沒有寫完，趁讀完《通鑑》把最後兩本解決了。下面計劃讀的是《萬歷十五年》，今年是我的明矾年麼？","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"Kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"},{"name":"電子書","slug":"電子書","permalink":"http://0x3f.org/tags/電子書/"}]},{"title":"讀完《資治通鑑》","slug":"after-reading-tong-jian","date":"2014-01-28T12:53:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-tong-jian/","link":"","permalink":"http://0x3f.org/post/after-reading-tong-jian/","excerpt":"","text":"一部書，二百九十四卷，三百萬字，一千三百六十二年，從中華書局20冊胡三省注本，到Kindle DXG，再到Kindle Paperwhite，讀了四年。 讀史應該先讀通史，再讀斷代史，然後是野史。因為讀懂歷史必須站在大時代背景上，比如不瞭解兩周封建拓殖史，就不懂什麼是“南夷與北狄交，中國不絕若線。”，更不會明白“尊王攘夷”區區四個字有多大的份量。所以十年前我《世說新語》剛讀了個開頭就讀不下去了。 《通鑑》關注的是興衰更替，所以很多有意思的歷史故事沒有記錄，尤其是先秦時期，我最喜歡的傳奇時代，結果看得索然無味。漢紀部分又包含了太多的上書和詔書。我一度覺得選擇讀《通鑑》是個錯誤。 所幸堅持了下來，鑑於自小說作家司馬遷開始，我國歷代史家保持著添油加醋的優良傳統，越生動的歷史往往越不可信，去葉存枝方見國史之骨。如果說兩司馬有什麼區別，前者是用故事講歷史，後者是用歷史講歷史，單就史學而言，誰更牛X，一目瞭然。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"Kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"},{"name":"電子書","slug":"電子書","permalink":"http://0x3f.org/tags/電子書/"}]},{"title":"PHP框架實戰（∝）：烈焰之終章","slug":"flamework-summary","date":"2014-01-02T07:15:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/flamework-summary/","link":"","permalink":"http://0x3f.org/post/flamework-summary/","excerpt":"","text":"寫“烈焰”（Flame）用了一周的業餘時間，主要是對平時一些想法的總結和驗證。實現了比較完整的控制器層和視圖層，對模型層的ActiveRecord實現思路做了一下梳理。 當然，一個可實用的框架需要包含的東西遠不止這些。比如框架中用到代碼動態調用的地方，一定要做好語言安全子集的過濾，否則就是很大的安全漏洞。再比如需要支持依賴反轉的緩存機制，實現對多種緩存方式的平滑支持。此外，像URI路由、可擴展、多模板方案支持也都是現代框架的標配。這些留待以後有時間再討論。然而在這次練習的過程中，我突然想到一個問題——PHP是不是適合實現一個完備的框架。 曾見過一句話，說PHP本身就是一個框架，後來明白，這才是微言大義。PHP有很多高級選項、高級函數和擴展，用得好事半功倍，用不好就是魔鬼。 PHP本身有很多問題，協議不統一、函數命名混亂、命名空間語法怪異而且雞肋等等都是老生常談。在運行模式上，無論是Apache+PHP模塊，還是NGINX+FastCGI，都只能實現在縱向層面上對一次請求的處理，由於缺乏在內存中持續運行程序的機制，凡是對程序全局共享並持續佔有的東西都不能實現，比如數據庫連接池等，以至於很多初始化的工作對於每次請求都要重新執行一次，這意味著面向對象越徹底、封裝越多，系統資源的重複消耗越厲害，所以PHP的程序在性能和內存佔用上與Java相比有一定缺陷。因此PHP更適合短平快的應用場景，不適合實現複雜的業務邏輯。 基於這個觀點，我認同混合編程。沒有哪種語言是完美的，用對的工具做對的事是最理想的。用PHP實現一個完備的框架也許不是個明智的選擇，從短平快的角度出發，它更適合用來實現微框架。 現在微框架是個比較熱門的話題，我最早接觸的是Python的Bottle和Flask，短小精悍，非常容易上手。微框架主要實現控制器層和視圖層，一般不包括模型層。為了以最快的速度將請求路由到處理邏輯，一般以最直接的方式建立URI模板和回調物件之間的映射，控制器層可以以極簡的方式實現，例如只做一個像本文後面例子中那樣簡單的約定。微框架應該盡可能少地包含配置，大部分時候並不需要像Java的S.S.H那樣濫用配置，CoC原則就持這樣的觀點，約定可以解決的問題就不要用配置去做。 下面只使用兩個函數和五條約定實現一個微框架： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php/** * 路由定義與應用 * @param string $route 用作定義路由規則時，此參數為模板字符串， * 使用冒號加參數名作為參數佔位符，例如： * on('/post/edit/:id', function($id)&#123;&#125;); * 用做應用路由規則時，此參數為URI，例如： * on($_SERVER['REQUEST_URI']); * @param callable $callback 路由規則的回調邏輯，如果路由規則中 * 含有參數佔位符，回調中需存在同名的參數；當函數作為應用路 * 由規則使用時，此參數不指定 * @return void * @since 1.0 */function on($route, $callback) &#123; static $routes = array(); $regex = '#'.preg_replace('#:[^\\/]+#', '.*', $route).'#'; $routes[$route] = array($regex, $callback); if (is_null($callback)) &#123; foreach ($routes as $r=&gt;$cfg)&#123; if (preg_match($cfg[0], $route)) &#123; $params = array(); $idx = strpos($r, ':'); if (is_int($idx)) &#123; $keys = explode('/', substr($r, $idx)); $keys = array_map(function($v)&#123; return trim($v, ':'); &#125;, $keys); $values = explode('/', substr($route, $idx)); $params = array_combine($keys, $values); &#125; call_user_func_array($callback, $params); break; &#125; &#125; echo '404'; &#125; &#125;/** * 視圖渲染函數 * @param string $view 視圖名稱 * @param array $params 關聯數組，包含需要填到視圖模板中的參數鍵值對 * @return void * @since 1.0 */function render($view, $params=array()) &#123; extract($data, EXTR_PREFIX_SAME, 'tpl_'); $viewFile = dirname(realpath(__FILE__)).DIRECTORY_SEPARATOR.'view' .DIRECTORY_SEPARATOR.$view.'.php'; if (is_readable($viewFile)) &#123; require($viewFile); &#125; else &#123; throw new Exception(\"View template $view does not exist or cannot be readable.\"); &#125;&#125;?&gt; on()身兼兩用，一是定義路由規則和對應的響應邏輯，一是對指定URI應用路由規則。render()的作用是渲染視圖模板。用法如下： 12345678910111213&lt;?phpinclude 'micro.php';on('/post/save', function()&#123; echo \"Post saved.\\n\";&#125;);on('/mail/send/:address/:title', function($address, $title)&#123; echo \"write letter to $address with title $title\\n\";&#125;);on($_SERVER['REQUEST_URI']);?&gt; 約定如下： 每個Controller作為一個文件放在項目根目錄下的controller目錄中，名稱即文件名，後綴是“.php”；Action對應於Controller中的各個函數（注意過濾語言安全子集）； 使用php.ini的配置項“auto_prepend_file”和“auto_append_file”實現過濾器； 使用“set_error_handler()”和“set_exception_handler()”自動處理異常和錯誤； 使用PDO實現數據庫抽象層； 視圖模板用PHP腳本實現，模板文件放在當前目錄下的view目錄裡，模板文件名即模板名，後綴為“.php”； 當然這離實際可用還差得遠，這裡只是說明一下微框架的基本理念：第一，打狗不需要金箍棒；第二，大部分項目都是在打狗。結合混合編程，這一點會更明顯。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"框架","slug":"框架","permalink":"http://0x3f.org/tags/框架/"},{"name":"Flamework","slug":"flamework","permalink":"http://0x3f.org/tags/flamework/"}]},{"title":"PHP框架實戰（五）：ORM與ActiveRecord","slug":"flamework-active-record","date":"2014-01-01T12:45:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/flamework-active-record/","link":"","permalink":"http://0x3f.org/post/flamework-active-record/","excerpt":"","text":"簡述Model是MVC框架中最複雜的部分，它要提供與業務邏輯相關的數據及數據處理方法的封裝，一般要提供數據對象、數據庫連接、事務管理、SQL語句構造、數據CRUD、高級通用業務邏輯等一系列功能。由於Model與Controller和View是解耦的，並且本身具備很高的通用性和複雜性，所以有很多獨立的實現。本文希望能通過開發一個簡單的ActiveRecord，驗證這種Model實現方案的原理和過程。 ORM：對象關係映射ORM的全稱是Object Relational Mapping，即對象關係映射。它是為了解決關係數據庫的數學模型和編程語言的對象模型之間的阻抗不匹配問題而提出的解決方案。 阻抗不匹配是個逼格很高的詞。 阻抗是指電路中的電容、電感、電阻對交流電的障礙作用，就像電阻對直流電的障礙作用。兩個系統傳遞信號可以形象地看成電壓的傳遞，公式為： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;U(out) * Z(in)U(in) = ————————–&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z(in) + Z(out) 即輸入電壓等於輸出電壓與輸入阻抗的積除以輸入阻抗與輸出阻抗的和。 理想情況肯定是輸入電壓等於輸出電壓，這時信號是沒有失真的，也就是要求Z(in)與Z(in)+Z(out)之商無限逼近1，這個過程就叫阻抗匹配。關係型數據庫是建立在數學模型的基礎上，而編程語言中的對象是建立在人對客觀世界認知的具象模型上。說白了，阻抗不匹配問題就是說因這兩種模型不一致而導致的問題。 ORM通過建立表與對象、列與屬性（这只是一般情况）之間的映射關係而解決問題，這可以實現像操作對象一樣對數據庫中的數據進行增刪改查，簡化了開發過程。不過ORM的缺點是不能很好地處理複雜數據關係，會出現效率低下的問題，因此必要時仍然需要直接使用SQL。 ActiveRecordActiveRecord是Ruby on Rails提出的一個概念，其實就是ORM的一種實現，它是對象類型、數據、CRUD方法的合體，使對數據的操作以更具象化的方式實現。下面介紹在Flamework中實現一個簡單的ActiveRecord的過程。 首先實現數據庫的接口，提供數據庫連接、查詢、執行SQL語句、事務管理等基本功能。這裡使用PDO實現： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;?phpnamespace org\\x3f\\flamework\\base;/** * Database connection above PDO * * @author Donie Leigh &lt;donie.leigh@gmail.com&gt; * @link http://0x3f.org * @copyright Copyright &amp;copy; 2013-2014 Donie Leigh * @license BSD (3-terms) * @since 1.0 */class DBConnection&#123; /** * @var PDO Database connection * @since 1.0 */ private $_c; /** * @var array PDO options * @since 1.0 */ private $_options = array( 'connection_string' =&gt; 'sqlite::memory:', 'username' =&gt; null, 'password' =&gt; null, 'pdo_options' =&gt; null, ); /** * @var PDOStatement Last PDO statement * @since 1.0 */ private $_lastStmt; public function __construct($options) &#123; $this-&gt;_options = array_merge($this-&gt;_options, $options); &#125; /** * Init DB connection * @param string $dsn DB connection string * @param string $user DB user name * @param string $password DB password * @param array $options PDO options * @return void * @since 1.0 */ private function _connectDB($dsn, $user='', $password='', $options=array()) &#123; if ($this-&gt;_c == null) &#123; $this-&gt;_c = new \\PDO($dsn, $user, $password, $options); &#125; &#125; /** * Execute sql statement * @param mixed $sql SQL statement or template * @param array $params Parameters for SQL template * @return bool * @since 1.0 */ public function execute($sql, $params=array()) &#123; $this-&gt;_connectDB( $this-&gt;_options['connection_string'], $this-&gt;_options['username'], $this-&gt;_options['password'], $this-&gt;_options['driver_options'] ); $stmt = $this-&gt;_c-&gt;prepare($sql); $this-&gt;_lastStmt = $stmt; return $stmt-&gt;execute($params); &#125; /** * Fetch rows * @return array Associative array holding data rows * @since 1.0 */ public function rows($sql, $params=array()) &#123; $this-&gt;execute($sql, $params); $stmt = $this-&gt;getLastStmt(); $rows = array(); while ($row = $stmt-&gt;fetch(\\PDO::FETCH_ASSOC)) &#123; $rows[] = $row; &#125; return $rows; &#125; /** * Return the last PDO statement * @return PDOStatement * @since 1.0 */ public function getLastStmt() &#123; return $this-&gt;_lastStmt; &#125; /** * Begin transaction * @return void * @since 1.0 */ public function beginTransaction() &#123; $this-&gt;_c-&gt;beginTransaction(); &#125; /** * Commit the current transaction * @return void * @since 1.0 */ public function commit() &#123; $this-&gt;_c-&gt;commit(); &#125; /** * Rollback the current transaction * @return void * @since 1.0 */ public function rollback() &#123; $this-&gt;_c-&gt;rollBack(); &#125; &#125;?&gt; 然後實現ActiveRecord類： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232&lt;?phpnamespace org\\x3f\\flamework\\base;use org\\x3f\\flamework\\Flame;/** * Ancestor class for active records * * @abstract * @author Donie Leigh &lt;donie.leigh@gmail.com&gt; * @link http://0x3f.org * @copyright Copyright &amp;copy; 2013-2014 Donie Leigh * @license BSD (3-terms) * @since 1.0 */abstract class ActiveRecord&#123; /** * @var array Models * @since 1.0 */ private static $_models = array(); /** * @var array Attributes and values * @since 1.0 */ private $_data = array(); /** * @var array Attributes and values which are changed * @since 1.0 */ private $_dirtyData = array(); /** * @var bool Whether this record is a new one * @since 1.0 */ private $_isNew = true; /** * Get model instance * @param string $className * @return ActiveRecord * @since 1.0 */ public static function getModel($className = __CLASS__) &#123; if (isset(self::$_models[$className])) &#123; return self::$_models[$className]; &#125; else &#123; $model = self::$_models[$className] = new $className; return $model; &#125; &#125; /** * Get table name of this ActiveRecord * @return string Table name * @since 1.0 */ abstract public function getTableName(); /** * Get the name of the primary key column * @return string Column name * @since 1.0 */ abstract public function getPrimaryKey(); /** * Magic method for accessing model attributes * @param string $attr Attribute name * @return mixed Attribute value * @since 1.0 */ public function __get($attr) &#123; if (isset($this-&gt;_data[$attr])) &#123; return $this-&gt;_data[$attr]; &#125; return null; &#125; /** * Magic method for setting attribute value * @param string $attr Attribute name * @param mixed $val Attribute value * @return void * @since 1.0 */ public function __set($attr, $val) &#123; $this-&gt;_data[$attr] = $val; if (!$this-&gt;getIsNew()) &#123; $this-&gt;_dirtyData[$attr] = $val; &#125; &#125; /** * Magic method for checking if an attribute is set * @param string $attr Attribute name * @return bool * @since 1.0 */ public function __isset($attr) &#123; return isset($this-&gt;_data[$attr]); &#125; /** * Magic method for unsetting an attribute * @param string $attr Attribute name * @return void * @since 1.0 */ public function __unset($attr) &#123; unset($this-&gt;_data[$attr]); &#125; /** * Set this record to be $isNew * @param bool $isNew * @return void * @since 1.0 */ public function setIsNew($isNew) &#123; $this-&gt;_isNew = $isNew; &#125; /** * Whether this record is new * @return bool * @since 1.0 */ public function getIsNew() &#123; return $this-&gt;_isNew; &#125; /** * Find a record by primary key * @param mixed $val Primary key value * @return ActiveRecord * @since 1.0 */ public function findByPk($val) &#123; $sql = \"select * from \".$this-&gt;getTableName().\" where \".$this-&gt;getPrimaryKey().\"=?\"; $rows = Flame::app()-&gt;getDBConnection()-&gt;rows($sql, array($val)); if (count($rows) &gt; 0) &#123; return $this-&gt;createInstance($rows[0]); &#125; return null; &#125; /** * Create an instance with given data * @param array $row Associative array * @return ActiveRecord * @since 1.0 */ public function createInstance($row) &#123; $className = get_class($this); $instance = new $className; foreach ($row as $col=&gt;$val)&#123; $instance-&gt;$col = $val; &#125; $instance-&gt;setIsNew(false); return $instance; &#125; /** * Save this record * @return void * @since 1.0 */ public function save() &#123; if ($this-&gt;getIsNew()) &#123; $this-&gt;_insert(); &#125; else &#123; $this-&gt;_update(); &#125; &#125; /** * Save this record into the database as a new row * @return void * @since 1.0 */ private function _insert() &#123; if (count($this-&gt;_data) &gt; 0) &#123; $cols = implode(', ', array_keys($this-&gt;_data)); $placeHolders = implode(', ', array_fill(0, count($this-&gt;_data), '?')); $sql = \"insert into \".$this-&gt;getTableName(). \" ($cols) values ($placeHolders)\"; Flame::app()-&gt;getDBConnection()-&gt;execute($sql, array_values($this-&gt;_data)); &#125; &#125; /** * Save this record * @return void * @since 1.0 */ private function _update() &#123; if (count($this-&gt;_dirtyData) &gt; 0) &#123; $pairs = implode('=?, ', array_keys($this-&gt;_dirtyData)).'=?'; $sql = 'update '.$this-&gt;getTableName().\" set $pairs where \".$this-&gt;getPrimaryKey().'=?'; $pk = $this-&gt;getPrimaryKey(); Flame::app()-&gt;getDBConnection()-&gt;execute($sql, array_merge(array_values($this-&gt;_dirtyData), array($this-&gt;$pk))); &#125; &#125; /** * Delete this record * @return void * @since 1.0 */ public function delete() &#123; if (!$this-&gt;getIsNew()) &#123; $pk = $this-&gt;getPrimaryKey(); $sql = 'delete from '.$this-&gt;getTableName().\" where $pk=?\"; Flame::app()-&gt;getDBConnection()-&gt;execute($sql, array($this-&gt;$pk)); &#125; &#125; &#125;?&gt; 約定，所有子類都必須覆蓋和實現getModel()、getTableName()、getPrimaryKey()這三個方法。getModel()返回不包含具體數據的ActiveRecord實例，用於執行對象類型範疇的操作，例如查詢符合特定條件的對象。在包含具體數據的ActiveRecord實例中執行針對該具體對象的操作，例如保存和刪除。 為了更好地區分ActiveRecord的屬性和對象數據，這裡將對象數據存放在關聯數組ActiveRecord::$_data裡，然後使用__get()、__set()等魔術方法實現像使用ActiveRecord自身屬性一樣使用對象數據。 在更新對象時，出於性能考慮，應該只更新被修改過的列。這裡借助魔術方法__set()，實現向對象屬性賦值時將被修改的屬性和值添加到關聯數組ActiveRecord::$_dirtyData中。最後構造update語句時，從該數組中取值即可。 ActiveRecord的使用在Demo項目中實現一個對象，繼承ActiveRecord： 1234567891011121314151617181920212223&lt;?phpnamespace org\\x3f\\flamedemo\\model;use org\\x3f\\flamework\\base\\ActiveRecord;class Post extends ActiveRecord&#123; public static function getModel($className=__CLASS__) &#123; return parent::getModel($className); &#125; public function getTableName() &#123; return 'post'; &#125; public function getPrimaryKey() &#123; return 'id'; &#125; &#125;?&gt; 用法如下： 123456789101112131415161718&lt;?php// 根據ID查詢對象$p = Post::getModel()-&gt;findByPk(1);var_dump($p);// 更新對象$p = new Post();$p-&gt;setIsNew(false);$p-&gt;id = 3;$p-&gt;title = 'bad name 2';$p-&gt;save();// 刪除對象$p = new Post();$p-&gt;setIsNew(false);$p-&gt;id = 3;$p-&gt;delete();?&gt; 總結ORM的根本任務是解決關係模型與對象模型的阻抗不匹配問題。而ActiveRecord是時下很流行的一種ORM的實現方式。在對ActiveRecord的實現中使用了PDO，這是PHP 5.1開始引入的一個輕量的數據訪問抽象層，相比以前針對每種數據庫使用不同的函數集的方式，它使PHP的數據庫操作變得更簡單。此外，魔術方法的使用簡化了代碼，使數據操作變得更靈活。 本文只實現了一個最基本的ActiveRecord，實際使用時，還要包含SQL語句構造等複雜的邏輯，不過只要弄清楚了核心原理和實現方式，其它也就水到渠成了。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"框架","slug":"框架","permalink":"http://0x3f.org/tags/框架/"},{"name":"Flamework","slug":"flamework","permalink":"http://0x3f.org/tags/flamework/"}]},{"title":"PHP框架實戰（四）：View的模板與渲染","slug":"flamework-view-rendering","date":"2013-12-30T13:05:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/flamework-view-rendering/","link":"","permalink":"http://0x3f.org/post/flamework-view-rendering/","excerpt":"","text":"目標實現MVC模型的View層，Controller的Action中應可以將從Model層獲取的數據填充到View模板中，並將渲染結果返回給訪問者。本文並不志在實現一個完備的模板框架，相應的需求可借助Smarty這樣現有的實現。 獲取代碼1git checkout v0.4 設計與實現View的模板是最好實現的，因為PHP本身就是一個模板語言，所以這裡實現的模板主要是指幾條約定： 模板文件本身是一個普通PHP文件，文件名後綴是“.php”； 模板文件應存儲在項目指定的模板基礎目錄中； 模板名稱指模板文件相對於項目的模板基礎目錄的路徑，並且去掉文件後綴； 模板本身的實際效果等同於在Controller的Action中執行的代碼，故可以調用Controller的所有方法以及Flame對象的方法等內容； 所有要填充到模板中的數據以鍵值對的形式存儲在一個關聯數組中，並傳遞給渲染模板的方法，在模板中使用與鍵名相同的變量調用數據； View的渲染方法 添加Controller::render()方法： 1234567891011121314151617181920212223242526&lt;?php // ... /** * Render the view template with data * @param string $view View template relative path to base path of the templates * For example, 'post/list' point to file /srv/http/mysite/protected/view/post/list.php * @param array $data Associative array in which data is stored as key-value pairs * @return void * @since 1.0 */ public function render($view, $data) &#123; extract($data, EXTR_PREFIX_SAME, 'tpl_'); $viewFile = Flame::app()-&gt;getViewPath().DIRECTORY_SEPARATOR.$view.'.php'; if (is_readable($viewFile)) &#123; require($viewFile); &#125; else &#123; throw new FlameException(\"View template $view does not exist or cannot be readable.\"); &#125; &#125; // ...?&gt; $view是模板名稱，$data是要填充到模板中的數據。 驗證Demo在Demo項目的protected下新增文件“view/post/list.php”，並創建不存在的這兩個上級目錄“view”和“post”。內容如下： 12345678910&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;Post&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;?php echo $name; ?&gt;&lt;/h1&gt; &lt;p&gt;&lt;?php echo $age; ?&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 將DefaultController::index()方法修改為： 123456789101112131415&lt;?php // ... public function index() &#123; $this-&gt;render('post/list', array( 'name' =&gt; 'leigh', 'age' =&gt; 23, )); &#125; // ...?&gt; 訪問Demo項目，頁面將顯示預期的內容和樣式。 總結PHP本身的特點使得View這一層很容易實現。不過，隨著富客戶端的流行，MVC模型的View這一層正在被逐漸弱化，現在主流的開發方式是前端通過AJAX與服務器端交換數據，而不是把數據填充到模板中再返回給客戶端。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"框架","slug":"框架","permalink":"http://0x3f.org/tags/框架/"},{"name":"Flamework","slug":"flamework","permalink":"http://0x3f.org/tags/flamework/"}]},{"title":"PHP框架實戰（三）：實現Controller和Filter","slug":"flamework-controller-and-filter","date":"2013-12-29T12:40:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/flamework-controller-and-filter/","link":"","permalink":"http://0x3f.org/post/flamework-controller-and-filter/","excerpt":"","text":"目標實現Controller和Filter，程序可以從HTTP請求中解析Controller和Action，並在這兩個切面級別實現Filter鏈。此外，在Controller中，可以使用Action的參數直接訪問HTTP請求中的同名參數。 獲取代碼項目目錄結構做了調整，framework目錄存放Flamework框架源碼，demo目錄存放示例項目。 1git checkout v0.3 設計與實現Controller的實現 要求請求URL的格式如下： http://www.mydomain.com/index.php?r=post/save r表示Route，斜杠前面的post表示Controller的名稱，後面的save表示Action的名稱。對HTTP請求的各種處理邏輯封裝在新對象HttpRequest中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?phpnamespace org\\x3f\\flamework\\base;use org\\x3f\\flamework\\Flame as Flame;/** * HTTP request wrapper * * @author Donie Leigh &lt;donie.leigh@gmail.com&gt; * @link http://0x3f.org * @copyright Copyright &amp;copy; 2013-2014 Donie Leigh * @license BSD (3-terms) * @since 1.0 */class HttpRequest&#123; /** * @var HttpRequest Singleton instance * @since 1.0 */ private static $_instance; /** * @var string Controller name, null if no one is given * @since 1.0 */ private $_controller; /** * @var string Action name, null if no one is given * @since 1.0 */ private $_action; /** * Singleton constructor * @return void * @since 1.0 */ private function __construct() &#123; $this-&gt;parseRoute(); &#125; /** * Disable the cloning * @return void * @since 1.0 */ public function __clone() &#123; trigger_error('Clone is not allow!', E_USER_ERROR); &#125; /** * Get the singleton instance * @return HttpRequest * @since 1.0 */ public static function getInstance() &#123; if (!(self::$_instance instanceof self)) self::$_instance = new self; return self::$_instance; &#125; /** * Parse request route, set controller and action names * * @return void * @since 1.0 */ public function parseRoute() &#123; if (isset($_GET['r'])) &#123; $arr = explode('/', $_GET['r']); $this-&gt;_controller = $arr[0]; if (count($arr)&gt;1) $this-&gt;_action = $arr[1]; &#125; else &#123; $this-&gt;_controller = Flame::app()-&gt;getDefaultController(); &#125; &#125; /** * Get controller name * * @return string null if no controller is present * @since 1.0 */ public function getController() &#123; return $this-&gt;_controller; &#125; /** * Get action name * * @return string null if no action is found * @since 1.0 */ public function getAction() &#123; return $this-&gt;_action; &#125; /** * Get parameter value * * @param string $param Parameter name * @return mixed Parameter value * @since 1.0 */ public function getParam($param) &#123; if (isset($_REQUEST[$param])) return $_REQUEST[$param]; return null; &#125;&#125;?&gt; 考慮到HttpRequest可能在多個地方被調用，所以用單例模式實現。 WebApplication中添加如下內容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpclass WebApplication &#123; // ... /** * @var string The default controller name * @since 1.0 */ public $defaultController = 'default'; // ... /** * Get the default controller name * @return string Controller name * @since 1.0 */ public function getDefaultController() &#123; return $this-&gt;defaultController; &#125; /** * Get controller path * @return string The controller path * @since 1.0 */ public function getControllerPath() &#123; return $this-&gt;getProtectedPath().DIRECTORY_SEPARATOR.'controller'; &#125; /** * Create an instance of the controller * @param string $controllerName * @return Controller Controller instance * @since 1.0 */ public function createController($controllerName) &#123; $className = ucfirst($controllerName).'Controller'; $classFile = $this-&gt;getControllerPath().DIRECTORY_SEPARATOR.\"$className.php\"; if (file_exists($classFile)) &#123; $ns = include_once($classFile); $fullClassName = \"$ns\\\\$className\"; if (class_exists($fullClassName)) &#123; return new $fullClassName(); &#125; else &#123; throw new HttpException(404, \"Request to $controllerName is unresolvable.\"); &#125; &#125; else &#123; throw new HttpException(404, \"Request to $controllerName is unresolvable.\"); &#125; &#125;&#125;?&gt; 程序應指定一個缺省的Controller，覆蓋$defaultController屬性即可，默認為“default”。Controller的類名應在名稱後面加“Controller”字樣的後綴。由於需要包含命名空間的完整類名來動態實例化Controller，故Controller的源碼中都應在最後返回其命名空間（return \\_NAMESPACE__;_）。 增加Controller類，作為所有Controller的父類： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?phpnamespace org\\x3f\\flamework\\base;use org\\x3f\\flamework\\exceptions\\HttpException;/** * Ancestor class for all controllers * * @author Donie Leigh &lt;donie.leigh@gmail.com&gt; * @link http://0x3f.org * @copyright Copyright &amp;copy; 2013-2014 Donie Leigh * @license BSD (3-terms) * @since 1.0 */class Controller &#123; /** * @var string The default action * @since 1.0 */ protected $defaultAction = 'index'; /** * @var array Filter classnames and rules. * This is an associative array, in which keys are classnames of filters, * and values are regular expressions. * For example: * array( * 'org\\\\x3f\\\\flamedemo\\filter\\\\PerformanceFilter' =&gt; '/^(save|update|delete)$/', * ); * @since 1.0 */ protected $filters = array(); /** * Process http request * @param HttpRequest $request * @return void * @since 1.0 */ public function process(HttpRequest $request) &#123; $action = $request-&gt;getAction() === null ? $this-&gt;defaultAction : $request-&gt;getAction(); if (method_exists($this, $action)) &#123; // do parameter bindings $method = new \\ReflectionMethod(get_class($this), $action); $params = array(); foreach ($method-&gt;getParameters() as $param)&#123; if (isset($_REQUEST[$param-&gt;getName()])) &#123; $params[] = $_REQUEST[$param-&gt;getName()]; &#125; else if ($param-&gt;isDefaultValueAvailable()) &#123; $params[] = $param-&gt;getDefaultValue(); &#125; else &#123; throw new HttpException(400, \"Parameter \".$param-&gt;getName().\" is missing.\"); &#125; &#125; // create filter chain and run it $filters = $this-&gt;getActionFilters($action); $chain = new FilterChain($this, $action, $params, $filters); $chain-&gt;run(); &#125; else &#123; $msg = 'Request to '.$request-&gt;getController().'/'.$action.' cannot be resolved, action does not exist.'; throw new HttpException(404, $msg); &#125; &#125; /** * Get filters for the given action * @param string $action * @return array Filter names * @since 1.0 */ public function getActionFilters($action) &#123; $filters = array(); foreach ($this-&gt;filters as $filterClass=&gt;$regex)&#123; if (preg_match($regex, $action)) $filters[] = $filterClass; &#125; return $filters; &#125; &#125;?&gt; Controller::process()是入口方法，它會通過反射機制實現HTTP參數與Action參數的綁定，並指定Action。 Filter與Filter鏈的實現 Filter中實現before()和after()方法，Filter鏈通過對Filter按順序遞歸調用，實現所有Filter::before()方法在切面之前順序執行，並且所有Filter::after()方法在切面之後逆序執行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpnamespace org\\x3f\\flamework\\base;/** * Ancestor class for all filters * * @author Donie Leigh &lt;donie.leigh@gmail.com&gt; * @link http://0x3f.org * @copyright Copyright &amp;copy; 2013-2014 Donie Leigh * @license BSD (3-terms) * @since 1.0 */class Filter&#123; /** * Run this filter and the filter chain * @param FilterChain $chain * @return void * @since 1.0 */ public function filter(FilterChain $chain) &#123; if ($this-&gt;before($chain)) &#123; $chain-&gt;run(); $this-&gt;after($chain); &#125; &#125; /** * The logic to be executed before the aspect point * @param FilterChain $chain * @return boolean Return true to continue the filter chain, return false to break the chain * @since 1.0 */ protected function before(FilterChain $chain) &#123; return true; &#125; /** * The logic to be executed after the aspect point * @param FilterChain $chain * @return void * @since 1.0 */ protected function after(FilterChain $chain) &#123; &#125;&#125;?&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpnamespace org\\x3f\\flamework\\base;/** * Filter chain * * @author Donie Leigh &lt;donie.leigh@gmail.com&gt; * @link http://0x3f.org * @copyright Copyright &amp;copy; 2013-2014 Donie Leigh * @license BSD (3-terms) * @since 1.0 */class FilterChain&#123; /** * @var object Object to be filtered * @since 1.0 */ public $obj; /** * @var string Method of the object to be filtered * @since 1.0 */ public $method; /** * @var array Parameters to be passed to the method * @since 1.0 */ public $params; /** * @var array Filters * @since 1.0 */ public $filters; /** * @var int The offset of filters array * @since 1.0 */ private $_offset = 0; public function __construct($obj, $method, $params, $filters) &#123; $this-&gt;obj = $obj; $this-&gt;method = $method; $this-&gt;params = $params; $this-&gt;filters = $filters; &#125; /** * Run this filter and the filter chain * @return void * @since 1.0 */ public function run() &#123; $filter = $this-&gt;nextFilter(); if ($filter instanceof Filter) &#123; $filter-&gt;filter($this); &#125; else &#123; call_user_func_array(array($this-&gt;obj, $this-&gt;method), $this-&gt;params); &#125; &#125; /** * Get next filter * @return Filter Filter instance * @since 1.0 */ private function nextFilter() &#123; if ($this-&gt;_offset &lt; count($this-&gt;filters)) &#123; $filter = $this-&gt;filters[$this-&gt;_offset]; $this-&gt;_offset++; return new $filter; &#125; &#125; &#125;?&gt; 對FilterChain和Filter的使用方法在前面的WebApplication::run()和Controller::process()中均有包含。Controller級的Filter在配置文件中設置，內容如下： 1234567891011121314&lt;?phpreturn array( // ... // app namespace and its path 'namespaces' =&gt; array('org\\\\x3f\\\\flamedemo' =&gt; '/srv/http/flamework/demo/protected'), // filter classes 'filters' =&gt; array( 'org\\\\x3f\\\\flamedemo\\\\filter\\\\GlobalFilterA', 'org\\\\x3f\\\\flamedemo\\\\filter\\\\GlobalFilterB', ),);?&gt; Action級的Filter在Controller裡覆蓋$filters屬性： 123456789&lt;?php // ... protected $filters = array( 'org\\\\x3f\\\\flamedemo\\\\filter\\\\ActionFilterC' =&gt; '/^(index|noindex)$/', ); // ...?&gt; Action級別的Filter通過$filters數組中的正則表達式選擇適用的Action。 Demo驗證Demo中實現了兩個Controller級別的Filter（GlobalFilterA和GlobalFilterB），一個Action級別的Filter（ActionFilterC），訪問demo項目，頁面打印如下結果： org\\x3f\\flamedemo\\filter\\GlobalFilterA::beforeorg\\x3f\\flamedemo\\filter\\GlobalFilterB::beforeorg\\x3f\\flamedemo\\filter\\ActionFilterC::beforeorg\\x3f\\flamedemo\\controller\\Defaultcontroller::indexorg\\x3f\\flamedemo\\filter\\ActionFilterC::afterorg\\x3f\\flamedemo\\filter\\GlobalFilterB::afterorg\\x3f\\flamedemo\\filter\\GlobalFilterA::after 總結WebApplication作為程序的統一入口，通過對HTTP請求的解析動態創建Controller，並借此實現了Controller級別的Filter鏈。Controller通過反射機制實現了HTTP參數與Action參數的綁定，以及Action級別的Filter鏈。而通過對Filter的遞歸執行，Filter鏈實現了面向切面編程。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"框架","slug":"框架","permalink":"http://0x3f.org/tags/框架/"},{"name":"Flamework","slug":"flamework","permalink":"http://0x3f.org/tags/flamework/"}]},{"title":"PHP框架實戰（二）：錯誤和異常的自動處理","slug":"flamework-error-auto-handling","date":"2013-12-28T05:40:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/flamework-error-auto-handling/","link":"","permalink":"http://0x3f.org/post/flamework-error-auto-handling/","excerpt":"","text":"目標實現錯誤和異常的自動捕獲和處理。 獲取代碼1git checkout v0.2 設計與實現使用set_error_handler()和set_exception_handler()兩個函數註冊錯誤和異常的處理方法，並在兩個處理方法中先調用用戶自定義的錯誤和異常處理邏輯，如果自定義邏輯不存在或者返回false，繼續調用框架缺省的處理邏輯，輸出錯誤信息到頁面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;?phpclass WebApplication &#123; // ... /** * @var boolean Whether to enable error auto-handling, default to true * @since 1.0 */ public $enableErrorHandling = true; /** * @var boolean Whether to enable exception auto-handling, default to true * @since 1.0 */ public $enableExceptionHandling = true; /** * @var callable Error handler * @since 1.0 */ public $errorHandler; /** * @var callable Exception handler * @since 1.0 */ public $exceptionHandler; /** * @var boolean Whether to enable debug mode, default to false * @since 1.0 */ public $debug = false; /** * @param string $config */ public function __construct($config) &#123; // ... $this-&gt;initErrorHandlers(); &#125; /** * Initialize auto-handling for errors and exceptions * @return void * @since 1.0 */ public function initErrorHandlers() &#123; if ($this-&gt;enableErrorHandling == true) set_error_handler(array($this, 'handleError'), error_reporting()); if ($this-&gt;enableExceptionHandling == true) set_exception_handler(array($this, 'handleException')); &#125; /** * Handle errors * @param int $code * @param string $message * @param string $file * @param int $line * @return void * @since 1.0 */ public function handleError($code, $message, $file, $line) &#123; // prevent recursive errors restore_error_handler(); restore_exception_handler(); $msg = \"Error $code: $message ($file:$line)\"; Flame::error($msg); // let errorHandler() return true to prevent displayError() if (is_callable($this-&gt;errorHandler) &amp;&amp; call_user_func($this-&gt;errorHandler, $code, $message, $file, $line) !== true) $this-&gt;displayError($code, $message, $file, $line); exit(1); &#125; /** * Handle exceptions * @param Exception $exception * @return void * @since 1.0 */ public function handleException($exception) &#123; // prevent recursive errors restore_error_handler(); restore_exception_handler(); $msg = get_class($exception).': '.$exception-&gt;getMessage().' ('.$exception-&gt;getFile().':'.$exception-&gt;getLine().\"\\n\".$exception-&gt;getTraceAsString(); Flame::error($msg); // let exceptionHandler() return true to prevent displayException() if (is_callable($this-&gt;exceptionHandler) &amp;&amp; call_user_func($this-&gt;exceptionHandler, $exception) !== true) $this-&gt;displayException($exception); exit(1); &#125; /** * Display error information * @param int $code * @param string $message * @param string $file * @param int $line * @return void * @since 1.0 */ public function displayError($code, $message, $file, $line) &#123; if ($this-&gt;debug == true) &#123; echo \"&lt;h1&gt;Error $code&lt;/h1&gt;\"; echo \"&lt;p&gt;$message in ($file:$line)&lt;/p&gt;\"; echo '&lt;pre&gt;'; debug_print_backtrace(); echo '&lt;/pre&gt;'; &#125; else &#123; echo \"&lt;h1&gt;Error $code&lt;/h1&gt;\"; echo \"&lt;p&gt;$message&lt;/p&gt;\"; &#125; &#125; /** * Display exception information * @param Exception $exception * @return void * @since 1.0 */ public function displayException($exception) &#123; if ($this-&gt;debug == true) &#123; echo '&lt;h1&gt;'.get_class($exception).'&lt;/h1&gt;'; echo '&lt;p&gt;'.$exception-&gt;getMessage().' ('.$exception-&gt;getFile().':'.$exception-&gt;getLine().')&lt;/p&gt;'; echo '&lt;pre&gt;'.$exception-&gt;getTraceAsString().'&lt;/pre&gt;'; &#125; else &#123; echo '&lt;h1&gt;'.get_class($exception).'&lt;/h1&gt;'; echo '&lt;p&gt;'.$exception-&gt;getMessage().'&lt;/p&gt;'; &#125; &#125; // ...&#125;?&gt; “handleError()”和“handleException()”中先調用了“restore_error_handler()”和“restore_exception_handler()”，用於防止遞歸處理。 開發者可以在配置數組中指定自定義的錯誤和異常處理邏輯： 12345678910&lt;?phpreturn array( // ... 'exceptionHandler' =&gt; function($exception) &#123; var_dump($exception); return true; &#125;, 'errorHandler' =&gt; array('MyClass', 'handleError'),);?&gt; “errorHandler”和“exceptionHandler”的值必須是一個callable類型，在這個callable結束時，如果不希望後續邏輯（例如框架自己的錯誤、異常處理邏輯）繼續處理，就返回true，此時程序將會終止執行並退出。 Demo驗證在WebApplication::run()中拋出一個異常或使用trigger_error()觸發一個錯誤，可以看到均被攔截和處理。 總結引入錯誤和異常的自動處理可以極大地簡化代碼。我們經常需要在AJAX請求出錯時返回一個JSON字符串，並由客戶端決定如何處理，這時就可以使用自定義的處理邏輯處理錯誤和異常，而Controller裡只實現正常的邏輯即可，無需再有大量難看的try…catch塊。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"框架","slug":"框架","permalink":"http://0x3f.org/tags/框架/"},{"name":"Flamework","slug":"flamework","permalink":"http://0x3f.org/tags/flamework/"}]},{"title":"PHP框架實戰（一）：框架入口與類的自動加載","slug":"flamework-entry","date":"2013-12-27T17:56:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/flamework-entry/","link":"","permalink":"http://0x3f.org/post/flamework-entry/","excerpt":"","text":"目標實現框架入口和類的自動加載。 獲取代碼1git checkout v0.1 設計與實現通過兩個類實現本次目標。 靜態類Flame作為整個框架的入口，實現一系列框架級公用靜態方法（例如創建應用實例和自動加載類）。 WebApplication是應用的抽象層，實現應用的入口和其它應用級（即運行時）公用方法（例如讀取配置文件）。 程序入口 1234&lt;?php// ...Flame::createApplication($config)-&gt;run();?&gt; 此處傳入的$config是應用配置文件的路徑，該配置文件內容格式如下： 123456&lt;?phpreturn array( 'opt1' =&gt; 'val1', // ...);?&gt; 在文件中直接return一個關聯數組的好處是，加載該文件時，include()函數的返回值就是該數組，代碼更簡潔，效率比解析其它格式配置文件高。 類的自動加載 1234567891011121314151617181920212223242526&lt;?php// ...class Flame &#123; // ... public static function autoload($className) &#123; if (!isset(self::$_namespaces[__NAMESPACE__])) self::$_namespaces[__NAMESPACE__] = dirname(__FILE__); foreach (self::$_namespaces as $ns=&gt;$path)&#123; if (strpos($className, $ns) === 0) &#123; $classFile = $path.str_replace('\\\\', DIRECTORY_SEPARATOR, substr($className, strlen($ns))).'.php'; include($classFile); return class_exists($className); &#125; &#125; return false; &#125; // ...&#125;spl_autoload_register(__NAMESPACE__.'\\\\Flame::autoload');?&gt; 通過函數spl_autoload_register()註冊Flame::autoload()方法。當用到一個類時，PHP會先檢查該類是否已加載，如果沒有，就把包括命名空間在內的完整的類名傳遞給autoload()，最終完成類的加載。 當不填參數調用spl_autoload_register()時，PHP使用默認的spl_autoload()函數加載類文件，如果命名空間與目錄結構完全對應，也可以實現自動加載，而且效率比指定的自定義加載方法更高。但是spl_autoload()有個歷久彌新的Bug，它總是試圖加載文件名是小寫字母的文件，例如，假如類名是MyClass，spl_autoload()就去找文件名為myclass.php的文件，然而一般情況是文件名與類名相同，即MyClass.php，這在大小寫敏感的系統中就找不到了。這個函數的開發者得有多恨Linux啊。 驗證Demo整個Demo程序的index.php只需包含以下代碼即可： 12345678&lt;?phprequire_once '../flamework/Flame.php';use org\\x3f\\flamework\\Flame as Flame;$_config = 'protected/config.php';Flame::createApplication($_config)-&gt;run();?&gt; 總結這樣一個最簡單的框架就實現了。 通過這兩個類，將框架級靜態邏輯與運行時的動態邏輯分開。對應用高度的抽象和OOP封裝使框架和應用的代碼更易讀。單一的應用入口也方便實現一些橫向邏輯（例如過濾器）。 此外，利用include()會將它所加載的腳本中return的值作為自身返回值的特性實現配置文件的讀取，簡化了代碼，提高了效率。類的自動加載使開發者不必再關心類文件的引入和移除，避免因多餘的include或require而導致效率下降和資源浪費。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"框架","slug":"框架","permalink":"http://0x3f.org/tags/框架/"},{"name":"Flamework","slug":"flamework","permalink":"http://0x3f.org/tags/flamework/"}]},{"title":"PHP框架實戰（零）：代碼規範","slug":"flamework-code-spec","date":"2013-12-26T14:07:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/flamework-code-spec/","link":"","permalink":"http://0x3f.org/post/flamework-code-spec/","excerpt":"","text":"類C語言語法風格最大的問題就是用花括號區分代碼塊，這導致源碼排版容易混亂，對於我這種有代碼潔癖的人來說非常痛苦，所以我最喜歡的語法風格是Python的，用縮進區分代碼塊，排版不規範直接判處語法錯誤。 命名規範所有命名使用駝峰風格。 源碼開頭定義命名空間，Flamework框架入口類的命名空間為“org\\x3f\\flamework”，其餘類的命名空間應在此基礎上追加與所在目錄路徑匹配的內容。例如，框架源碼目錄下一級子目錄“base”中的類文件的命名空間均為“org\\x3f\\flamework\\base”。 類名必須是名詞，不允許添加任何無意義的前綴或後綴，只允許使用大小寫英文字母且首字母大寫。 方法名必須是“動詞+名詞”的形式（如果動詞意義明確且不需要賓語，可省略後者），只允許使用大小寫英文字母及阿拉伯數字和下劃線，首字母小寫。 屬性名分两种情况，对于存储普通数据的属性，名称必須是名詞；对于布尔型属性，名称必须是“動詞+名詞”的形式。只允許使用大小寫英文字母及阿拉伯數字和下劃線，首字母小寫。 源碼文件名必須與類名相同，後綴統一使用“.php”。 註釋規範統一使用phpDocumenter的註釋規範。 類註釋必須註明@author、@since。 屬性和方法的作者如果和類的創建者不同，必須註明@author，此外必須註明@since。 文件格式所有文本文件統一使用UNIX格式和UTF-8編碼。 嚴禁使用製表符縮進代碼，必須使用4個空格替代製表符。 類、屬性、方法、方法內部代碼塊都必須嚴格按照層級縮進。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"框架","slug":"框架","permalink":"http://0x3f.org/tags/框架/"},{"name":"Flamework","slug":"flamework","permalink":"http://0x3f.org/tags/flamework/"}]},{"title":"PHP框架實戰：Flamework","slug":"flamework","date":"2013-12-26T12:24:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/flamework/","link":"","permalink":"http://0x3f.org/post/flamework/","excerpt":"","text":"從今天開始，逐步實現一個PHP的MVC框架，以踐行平時對這方面的一些想法。 項目信息 名稱：Flamework (Flame Framework) 源碼：https://github.com/xbot/flamework 框架特性激進 用PHP高版本引入的新特性，不考慮向前兼容問題，沒有歷史包袱。 命名空間 PHP 5.3引入的命名空間可以有效避免類命名衝突，這樣可以使類名看起來更自然，不用再在類名前面加難看的前綴了。 類的自動加載 手動include會增加維護的難度，因為經常會出現一個類被從源碼中移除而它的include行還在的問題，這會拖慢程序執行速度、增加內存佔用。 實現類的自動加載可以在類被引用時自動include相應的源碼。 異常的自動處理 在設計程序時，一般應該把用戶級的錯誤返回給頁面顯示，或者對一些HTTP錯誤顯示個性化的頁面（例如人民群眾喜聞樂見的404頁面），所以在業務邏輯、數據操作這些層一般應該逐級向上拋異常，然後在Controller裡捕獲並加工成頁面可識別的格式（例如JSON）。這樣做的缺點是Controller裡每個Action都包含重複的try…catch塊。 異常的自動處理允許開發者指定自定義的異常處理邏輯，將異常處理與普通邏輯解耦，這樣每個Action只需實現它所關注的功能即可。 過濾器 過濾器允許面向切面編程，是將橫向邏輯與縱向邏輯解耦的重要工具。Flamework要實現針對Controller和Action兩個級別的過濾器鏈，過濾器可在該級別邏輯前後執行，並能停止該級別邏輯及後續過濾器的執行。 懶加載 對盡可能多的資源實現懶加載，例如數據庫連接、類、組件等，目的是提高效率、節約資源。 參數綁定 自動將請求中的參數與Action方法的參數綁定，從而避免在Action裡出現通過$_POST、$_GET這些數組取參數的髒代碼，也可以自動實現參數的校驗和錯誤處理。 ActiveRecord ORM是對關係模型和對象模型的阻抗不匹配問題的解決方案，ActiveRecord是目前最流行的一種ORM的實現方式。通過AR，可以以更對象化的方式操作關係數據庫的數據。 依賴注入 依賴注入是個很好的解耦方法，也可以很優雅地實現懶加載。 目錄 零：代碼規範 一：框架入口與類的自動加載 二：錯誤和異常的自動處理 三：實現Controller和Filter 四：視圖的模板與渲染 五：ORM與ActiveRecord 六：依賴注入 ∝：烈焰之終章","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"框架","slug":"框架","permalink":"http://0x3f.org/tags/框架/"},{"name":"Flamework","slug":"flamework","permalink":"http://0x3f.org/tags/flamework/"}]},{"title":"這半年讀過的幾本書","slug":"books-read-in-the-second-half-of-2013","date":"2013-12-25T15:10:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/books-read-in-the-second-half-of-2013/","link":"","permalink":"http://0x3f.org/post/books-read-in-the-second-half-of-2013/","excerpt":"","text":"微博一度使我更新博客的頻率一降再降，現在我決定回歸。已經寫了七年，依然樂此不疲。 這半年去過一些地方，讀過一些書，頓悟了一些東西，我是個有一身毛病的動物，但我享受debug的過程。 現在讀書的動力很大程度上來自於使用PaperWhite的愉悅感，雖然最初買電子書閱讀器的目的是讀盜版，不過現在寧願為了更好的排版而買正版，而且覺得更過癮。現在我在買一本書前都要先看有沒有電子版，沒有的話就去找盜版，連盜版都沒有才去買印刷版。 小通鑑 雖然《通鑑》讀了三年還沒有讀完，這本小書卻很快就過了一遍。它從通鑑裡抽出了幾個故事，展開評論了一下。读了原史再看别人的解读，经常会会心一笑，或心有戚戚，或醍醐灌顶。读史最大的好处有两个，一是学做事，一是学做人，我注六经，六经注我。 誅仙 純粹是為了了結舊賬，這書在我還在學校的時候還沒寫完，隔了多年，畫一個圈圈，終結它。書本身的故事不錯，本來可以再深挖一些，可惜被文筆糟蹋了，整本書縮寫為原來的一百分之一波形不會有失真。 我所認識的蔣介石 這本書只讀了開頭就讀不下去了，对于历史和历史人物，全面肯定和全面否定都是不可信的。 大漠蒼狼：絕密飛行 懸疑設定得不錯。不過現在越來越不喜歡有恐怖色彩的東西，所以這可能是我最後看的一本這種題材的書。 Javascript權威指南 傳說中的犀牛書，Javascript最權威的資料之一。第一部分“语言核心”是要细读的，第二部分“客户端的JS”对有几年经验的人，从13到18章浏览一遍，之后的用康圣人读书法。讀完這本書就知道什麼叫生命不息挖坑不止。 精通CSS 本想查漏補缺，所以沒選《CSS禪意花園》，結果這書還是偏設計。難道這個星球上就沒有一本給非前端開發看的CSS書麼？ Spring in Action 重新尋找丟掉的青春，撂下五年再拾起來容易麼。這書是本不錯的Spring初級教材。 板橋雜記 明末清初大才子余懷的招嫖回憶錄，從對江南名妓的記述中映射物是人非之慨，文筆絕佳。秋风团扇，一觉扬州，于字字雕琢中见山河离碎、愁绪盈怀。每個危樓聽雨的暮年都有著軟紅十丈的青春。 NoSQL精粹 NoSQL絕佳的一本入門教材，對NoSQL的概念、應用場景、各類實現的優缺點等等都有適度的介紹。對於一直使用傳統技術的人而言，這本書有醍醐灌頂使人捶胸頓足怒相見恨晚嘆青春易逝之副作用。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"}]},{"title":"用Dojo實現拖放操作的最佳實踐","slug":"practical-drag-and-drop-implementation-with-dojo","date":"2013-11-05T08:58:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/practical-drag-and-drop-implementation-with-dojo/","link":"","permalink":"http://0x3f.org/post/practical-drag-and-drop-implementation-with-dojo/","excerpt":"","text":"網上關於Dojo實現拖放操作的資料都講得很淺，所以我在研究這個東西的時候在一些細節上費了不少功夫，例如創建自定義樣式的拖拽物件、將光標置於拖拽開始時的位置等等。這些細節一般在實現個性化的拖放操作時都要涉及，但幾乎找不到任何直接的資料，所以本文斗膽宣稱是當前Dojo拖放的最佳實踐。 創建自定義樣式的拖拽物件Dojo缺省的拖拽物件樣式很醜，通過覆蓋官方文檔裡列出的幾個CSS的class可以有限地調整部分樣式，如果需要更多個性化，就需要使用自定義的物件模板。 通過重載Source對象的creator方法可以實現這一點。這個方法會在創建拖拽物件的時候被調用，如果hint參數的值為“avatar”就表示將被創建的是被拖拽物件，此時可以使用預先定義好的模板avatarTmpl創建物件的node。 1234567891011this.dndSrc = new Source(this.itemList.domNode, &#123; copyOnly:true, selfAccept:true, creator: function(item, hint) &#123; var n; if (hint == 'avatar') &#123; n = domConstruct.toDom(lang.replace(avatarTmpl, item)); &#125; return &#123;node:n, data:item, type:['text']&#125;; &#125;&#125;); 置光標位置於拖拽起始處在拖拽開始後，Dojo默認將光標置於被拖拽物件的左上角，而一般把光標置於拖拽開始時相對於物件的位置處顯得比較自然。 實現方式是先記錄拖拽開始時光標的位置，然後設置dojo.dnd.Manager的兩個位移屬性。 12345678910on(this.domNode, 'mousedown', lang.hitch(this, this._setDndOffset))_setDndOffset: function(evt)&#123; // summary: 鼠标按下时将光标相对于组件的位移设置为dojo.dnd.Manager的位移 // 即使光标在拖动开始后位于拖动开始时的位置 var cPos = Functions.getCursorPosition(evt); var nPos = domGeometry.position(this.domNode); Manager.manager().OFFSET_X = nPos.x - cPos.x; Manager.manager().OFFSET_Y = nPos.y - cPos.y;&#125;, 使鼠標事件穿透被拖拽物件將光標置於物件開始被拖拽時的位置後，物件本身會擋住mouseover事件，導致Target不能獲知物件被拖拽到自己上方，以致能拖不能放。 解決方法是通過CSS使鼠標事件穿透被拖拽物件。 1234.dojoDndAvatar &#123; pointer-events: none; /*Chrome, FF下使鼠标事件穿透*/ background:transparent; /*IE下使鼠标事件穿透*/&#125;","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Javascript","slug":"javascript","permalink":"http://0x3f.org/tags/javascript/"},{"name":"Dojo","slug":"dojo","permalink":"http://0x3f.org/tags/dojo/"}]},{"title":"IE中使用IFrame上傳文件報錯——TypeError:拒絕訪問","slug":"typeerror-access-denied","date":"2013-08-02T17:03:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/typeerror-access-denied/","link":"","permalink":"http://0x3f.org/post/typeerror-access-denied/","excerpt":"","text":"場景為： 點擊一個圖標，打開文件選擇對話框，選擇好文件後即時上傳。 之前的實現方式是在一個隱藏表單中放一個file類型的input元素，通過調用input.click()打開對話框，同時監聽input.onchange，最後通過dojo/request/iframe上傳文件。 這個實現方式在Chrome和Firefox裡都沒問題，但是在IE裡報錯：“TypeError:拒絕訪問”。原因是IE要求必須通過點擊file類型的input的按鈕打開選擇對話框，否則就報這個錯誤。 解決辦法是修改input元素的樣式，或者直接用dojox.form.Uploader替代。 因為這個破問題又血戰到半夜，只支持IE9+的世界你們好嗎，還支持IE7+的屌絲傷不起……不起……起……啊。IE不死，吾難未已！！！","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Javascript","slug":"javascript","permalink":"http://0x3f.org/tags/javascript/"},{"name":"Dojo","slug":"dojo","permalink":"http://0x3f.org/tags/dojo/"},{"name":"IE","slug":"ie","permalink":"http://0x3f.org/tags/ie/"}]},{"title":"Dojo DnD: Cannot read property 'type' of undefined","slug":"dojo-dnd-cannot-read-property-type-of-undefined","date":"2013-07-11T14:44:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/dojo-dnd-cannot-read-property-type-of-undefined/","link":"","permalink":"http://0x3f.org/post/dojo-dnd-cannot-read-property-type-of-undefined/","excerpt":"","text":"場景如下： 假設有兩個Widget：ItemListWidget和ItemWidget，後者要被創建多份並追加到前者內部，同時ItemListWidget要作為dojo/dnd/Source，每個ItemWidget作為一個單元可被拖拽到另外一個dojo/dnd/Target容器中。 問題是，當Source被創建後，再添加到ItemListWidget的ItemWidget實例在被拖拽時會報如下錯誤： Uncaught TypeError: Cannot read property ‘type’ of undefined 在Chrome開發工具中點開這個錯誤，顯示以下內容： 從方法的註釋或API中可以看到，checkAcceptance()是用來判斷當前拖拽對象是否在這個target接受的範圍之內，接受規則用Source和Target的構造參數中的“accept”定義。在這個方法裡通過Source.getItem()方法拿到的對象是null，上述錯誤就是從這兒報出來的。 接合API和Reference Guide發現，每個Source中的可拖拽項目在Source中都要有一個對應的對象，這個對象至少包括兩個屬性：“data”和“type”。在Reference Guide中，對這兩個屬性有詳細說明，簡言之，data是向Target傳遞的數據，type是被Target用來判斷拖拽個體是否屬於接受範圍的依據。 當Source實例被創建時，已經存在於ItemListWidget中的ItemWidget實例會被自動創建對應的上述對象，但之後加入的不會。解決的辦法是調用Source.setItem()方法為每一個新加入的ItemWidget關聯相應的對象，或在ItemWidget中添加一個構造參數，用於指定Source，並在postCreate()方法中為當前ItemWidget實例關聯相應的對象: 1234567891011121314151617define([ \"dojo/_base/declare\", \"dijit/_WidgetBase\",], function(declare, _WidgetBase)&#123; return declare(\"ItemWidget\", [_WidgetBase], &#123; // 本Widget實例所屬的Source實例 dndSrc: null, postCreate: function() &#123; this.inherited(arguments); // 不需要傳遞數據時，可忽略data參數 if (this.dndSrc !== null) this.dndSrc.setItem(this.id, &#123;type:[\"text\"]&#125;); &#125; &#125;);&#125;);","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Javascript","slug":"javascript","permalink":"http://0x3f.org/tags/javascript/"},{"name":"Dojo","slug":"dojo","permalink":"http://0x3f.org/tags/dojo/"}]},{"title":"Take Sakura as My Primary Terminal","slug":"take-sakura-as-my-primary-terminal","date":"2013-07-07T04:07:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/take-sakura-as-my-primary-terminal/","link":"","permalink":"http://0x3f.org/post/take-sakura-as-my-primary-terminal/","excerpt":"","text":"It’s a long time since I came across rxvt-unicode. About seven years ago, when I switched from Windows XP to Ubuntu mainly for performance issues, I never be bored with searching for everything with a higher speed. To me, gnome-terminal is too much slow as a terminal being frequently opened and closed. Then, rxvt-unicode came through. At first glance, rxvt-unicode was so ugly that I put it behind without the slightest bit of hesitation. Not until I once saw a screenshot did I realize this ugly thing can actually be pretty like that. So I started to take it as my primary terminal since then, for it was the fastest terminal I can find at that time. Time flies, rxvt-unicode has proved to be a very good friend within these years, only until yesterday. I descided to change my Zsh theme to agnoster, which is a very pretty and git-friendly theme. Although I did everything according to the official manual, the right and left arrow signs were still displayed as boxes, then I tried almost all the methods I could find from Google, it still didn’t work. So I reluctantly descided to part from rxvt-unicode. A number of terminals came out through these years, some of them also show a good performance, like sakura, terminator, etc. Now I take sakura as my primary terminal, it runs as fast as rxvt-unicode while working normally with agnoster or powerline. Here is the final effect: Update (2013-07-07 23:34:53): Thanks to Star Brilliant, he mentioned LilyTerm in his comment. I discovered that it is even faster than Sakura while supplying plenty of functions, so now I descide to switch to LilyTerm.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"rxvt","slug":"rxvt","permalink":"http://0x3f.org/tags/rxvt/"},{"name":"終端","slug":"終端","permalink":"http://0x3f.org/tags/終端/"},{"name":"sakura","slug":"sakura","permalink":"http://0x3f.org/tags/sakura/"},{"name":"powerline","slug":"powerline","permalink":"http://0x3f.org/tags/powerline/"},{"name":"zsh","slug":"zsh","permalink":"http://0x3f.org/tags/zsh/"}]},{"title":"讀完《悟空傳》","slug":"after-reading-wukongs-biography","date":"2013-07-05T15:12:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-wukongs-biography/","link":"","permalink":"http://0x3f.org/post/after-reading-wukongs-biography/","excerpt":"","text":"我要這天，再遮不住我眼；要這地，再埋不了我心；要這眾生，都明白我意；要那諸佛，都煙消雲散！ 這是本適合少年讀、青年悟、中年回味的書，很遺憾沒有在我最好的幾年裡讀過它。到了沒有激情和理想的年齡，已經不能耐著性子讀這種需要花時間和動腦子的書，這次在Kindle PaperWhite上匆匆翻完，我知道可能需要很多年去慢慢的品。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"Kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"},{"name":"電子書","slug":"電子書","permalink":"http://0x3f.org/tags/電子書/"}]},{"title":"PySide: How to Get the Position of a Widget-Value-Changed Cell in QTableWidget","slug":"get-position-in-qtablewidget-for-changed-cellwidgets","date":"2013-06-30T16:57:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/get-position-in-qtablewidget-for-changed-cellwidgets/","link":"","permalink":"http://0x3f.org/post/get-position-in-qtablewidget-for-changed-cellwidgets/","excerpt":"","text":"Assume we have created an instance of QTableWidget, in which cells are filled with widgets like QComboBox, QCheckBox, etc. When values are changed, we need to get the row and column indexes of the cells. But the QTableWidget.cellChanged() and QTableWidget.itemChanged() signals are only effective for cells containing QTableWidgetItem instances, for those in which widgets are filled in with QTableWidget.setCellWidget(), this doesn’t work. This problem nearly made me crazy last weekend. So how can I make it ? Here is the solution, by leveraging QSignalMapper, we can send other data to the slots instead of the default value. As the following code snippet shows, I put the row and column indexes into a string, then mapped it with the QComboBox.currentIndexChanged() slot. Notice that this slot has two generics, one accept an int type as the parameter and the other accept a string, so a QString key should be used to select the second generic. 1234signalMapper = QtCore.QSignalMapper(self.ui)signalMapper.setMapping(comboWidget, '%d,%d' % (rowIdx, colIdx))comboWidget.currentIndexChanged['QString'].connect(signalMapper.map)signalMapper.mapped['QString'].connect(self.__onCellWidgetChanged) The only downside of this solution is, we should call QTableWidget.cellWidget() seperately to get the new value. Which I think it’s not to much trouble.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PySide","slug":"pyside","permalink":"http://0x3f.org/tags/pyside/"}]},{"title":"那些年我用過的鼠標","slug":"my-mouses-of-all-those-years","date":"2013-06-29T11:53:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/my-mouses-of-all-those-years/","link":"","permalink":"http://0x3f.org/post/my-mouses-of-all-those-years/","excerpt":"","text":"第四款，羅技M185，卖相不错，无光，一节五号电池驱动，据说很省电，握感不错，正在用。 第三款，惠普百靈，卖相不错，大小适中，左侧两个快捷按键在浏览网页时前进后退很方便。两节七号电池驱动，不太省电。先后买过两个，都是滚轮失灵，似乎这款的滚轮有问题，傷心了。 第二款，雷柏7100，形状较大，握感还可以，用一节五号电池，省电。最后按键失灵，壮烈牺牲。 第一款，Thinkpad 31P7410，先后买过两三个，比较小巧，按键易坏，不推薦。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"數碼","slug":"數碼","permalink":"http://0x3f.org/tags/數碼/"}]},{"title":"讀完《背包十年》","slug":"after-reading-ten-years-of-traveling","date":"2013-06-06T14:12:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-ten-years-of-traveling/","link":"","permalink":"http://0x3f.org/post/after-reading-ten-years-of-traveling/","excerpt":"","text":"年齡越大，越有種對失去自由的恐懼。“老牛自知夕陽晚，不用揚鞭自奮蹄”，於是越來越想走得遠點兒，然後就看到了這本書。這是我第一次正經買電子書，花了3￥，用了五天的時間。 這是本遊記，主要講的是作者十年旅行的見聞和心路歷程，從自然平實的詞句中可以看出作者心態很平和，能體會這種心態，已經很好。 PS: 有点淡淡的忧桑，今天，我高考十年……","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"旅行","slug":"旅行","permalink":"http://0x3f.org/tags/旅行/"}]},{"title":"How to Make YouCompleteMe Compatible with UltiSnips","slug":"make-youcompleteme-ultisnips-compatible","date":"2013-05-23T03:26:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/make-youcompleteme-ultisnips-compatible/","link":"","permalink":"http://0x3f.org/post/make-youcompleteme-ultisnips-compatible/","excerpt":"","text":"I replaced NeoComplCache with YouCompleteMe today. The main reason is for the auto-complete feature and the fast speed. Besides, it seems that YCM provides more features than NCC. Although NCC can also do auto-completions, it was so slow that I had to turn it off. For a long time, I have been doing completions by triggering the TAB key manually. YCM is much faster in most conditions, but I found it is also slow for C source files. Moreover, with the power of jedi, YCM makes completions of python sources much wiser, which is very convenient. Then a problem raised again. It’s the confiliction of mappings for Tab key between YCM and UltiSnips. Many people changed the default mapping of either YCM or UltiSnips, but I cannot tolerate that. I insist that the most convenient way is UltiSnips having a higher priority above YCM, which means, when Tab is triggered, UltiSnips expands the snippet, if there is not a valid snippet, YCM will take over the job. Fortunately, there is a solution. The idea is the same with my former post about NCC. I made it by the help of SuperTab. I have to say that UltiSnips is a well-written script, it passes Tab key through if there is not a snippet. Then SuperTab will be triggered. Since the default action of SuperTab is customizable, so I can set it to the key-binding of YCM. That is the whole trick. First, change the default key-binding of YCM to \\ and \\: let g:ycm_key_list_select_completion = [‘\\‘, ‘\\‘]let g:ycm_key_list_previous_completion = [‘\\‘, ‘\\‘] Then set the default action of SuperTab to triggering \\: let g:SuperTabDefaultCompletionType = ‘\\‘ OK, job done. 相關閱讀： 用neocomplete換掉了YouCompleteMe Vim的終極自動補全插件：NeoComplCache","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"插件","slug":"插件","permalink":"http://0x3f.org/tags/插件/"}]},{"title":"Vundle vs Pathogen","slug":"vundle-vs-pathogen","date":"2013-05-22T13:33:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/vundle-vs-pathogen/","link":"","permalink":"http://0x3f.org/post/vundle-vs-pathogen/","excerpt":"","text":"I have been using Pathogen for a long time and I am happy with it. But it seems that more and more Vim scripts are recommending to use Vundle in their install references. So I made a study today, the conclusion is, although almost all the articles I found from Google have a positive attitude on Vundle, I still prefer Pathogen. Most supporters of Vundle praise it for one reason, that is, it can install and update scripts automatically, which is lacked by Pathogen. Yes, since Vundle leverages the vim-scripts repository on GitHub, it is really easier to do so than Pathogen. But the disadvantage is as good as the advantage. I found that the vim-scripts repo is not updated in time, the latest activity was carried out a month ago ! As an OCD patient of updating, I cannot tolerate old versions of vim scripts. Although that Vundle supports using scripts’ git repos of their own (either on GitHub or other places), there is still a problem, what if authors commit broken code to the master brunch ? Moreover, not all scripts are deposited in public git repos. How can I organize those scripts in ~/.vim/bundle/ and prevent :BundleClean from deleting them at the same time ? Pathogen only handles the organization job that puts scripts in individual folders under ~/.vim/bundle/, so there is without the above problem. For updating issues, GetLatestVimScripts.vim is a good choice, it fetches the latest stable updates from vim.org, so I don’t have to worry about careless commits. The only problem is, when GetLatestVimScripts.vim downloads all packages, I should install them manually. But since most scripts rarely update, I think this is not a hard work to do. KISS things are always good.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"插件","slug":"插件","permalink":"http://0x3f.org/tags/插件/"}]},{"title":"騎行京西古道","slug":"riding-to-ancient-west-peking-path","date":"2013-05-18T14:09:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/riding-to-ancient-west-peking-path/","link":"","permalink":"http://0x3f.org/post/riding-to-ancient-west-peking-path/","excerpt":"","text":"13年5月，騎行京西古道。 從水峪嘴下去，進京西古道風景區，通過牛角嶺關城，到落坡馬志遠故居，然後經韭園橋沿永定河谷至擔禮大橋進入G109。 京西古道風景區收20￥，裡面有博物館、軍事酒吧、古道和牛角嶺關城。博物館其實就是個村史展館，很小，沒什麼內容，就一間屋子，一覽無餘。古道是亂石砌成的，非常不平，推車上去很累，好在只有一千米長： 牛角嶺關城，看著像個磚窯，地上的石頭溝溝坎坎： 馬志遠故居，看著像重建的，刻意營造成“小橋流水人家”的樣子，裡面就一四合院，收費10￥，沒進去。附近有一山泉，想老馬也算過了一把農婦山泉有點兒田的癮，夫復何求。 永定河谷一線的景色非常好，可惜沒有拍照。","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"騎行","slug":"騎行","permalink":"http://0x3f.org/tags/騎行/"},{"name":"京西古道","slug":"京西古道","permalink":"http://0x3f.org/tags/京西古道/"}]},{"title":"解決ROX-Filer文件類型識別問題","slug":"fix-ms-office-mime-types-in-rox-filer","date":"2013-05-17T04:52:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/fix-ms-office-mime-types-in-rox-filer/","link":"","permalink":"http://0x3f.org/post/fix-ms-office-mime-types-in-rox-filer/","excerpt":"","text":"默認情況下，ROX-Filer會將“*.docx”、“*.xlsx”、“*.pptx”文檔識別為zip壓縮包。由於ROX中與文件關聯的行為實際上都是和文檔類型掛鉤的，所以對這些文檔的操作會遇到很大麻煩，而且沒有變通方法。 實際上，Linux對文件類型的識別比Windows靈活。Windows只能通過文件名的後綴判斷文件類型，隨便創建一個文本文件，然後將後綴“.txt”改成“.exe”，Win就會傻乎乎地認為這是個二進制的可執行程序。這種做法很傻，而且很不安全，試想，如果將一個病毒程序的後綴改成“.jpg”，就可以騙過大多數用戶，然後通過某種手段執行它，後果會怎樣？更傻的是，XP以上版本默認是隱藏後綴的，那攻擊者連改後綴都可以省了。顫抖吧，神一樣的Win！ Linux不但可以通過後綴識別文件類型，更重要的，還可以通過文件開頭的幾個字節實現這一點，這就比前一種方式精確、安全很多。當然，Linux還支持更多的文件類型識別方法。 前面說過，在ROX-Filer下，所有行為都綁定到文件類型上，也就是MIME Types，ROX通過這種方式實現了將可靈活自由定製的文件操作與自身解耦，從而在確保自身穩定的同時實現對高度靈活的自由定製的支持，這是一個很值得學習的實現方式。因此，既然文件的後綴沒有問題，ROX仍將它們識別為ZIP格式，原因是什麼？顯然，最大的嫌疑集中在第二種識別方式上。 一個公開的秘密是，Office文檔本身其實就是一個ZIP壓縮包，裡面包含了描述文檔的XML、多媒體文件等成分，只不過MS賤賤地把壓縮包的後綴改成了docx之類的東東，加上Windows只能通過後綴識別文件類型，所以很多人不知道這一點。瞭解了這個，問題的原因就躍然紙上了，既然都是ZIP壓縮包，那第二種文件類型識別方式也就區分不出Office文件類型與ZIP壓縮包了。 能號出病因，就有方子治病。 既然ROX使用多種文件類型識別方式，那必然有一個優先級的關係，否則就會亂套。打開ROX的MIME Editor： 找到MIME類型“application/zip”： 打開zip的屬性對話框： 可以看到“Contents matching”這一塊裡，通過檢查文件頭部的幾個字節是否為“PK\\003\\004”來判斷，並且此項判斷標準的優先級是40。下面所要做的，就是找到相應文件類型，添加一項條件相同的“Contents matching”，並把優先級設得大於40。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"ROX-Filer","slug":"rox-filer","permalink":"http://0x3f.org/tags/rox-filer/"},{"name":"Office","slug":"office","permalink":"http://0x3f.org/tags/office/"},{"name":"MIME","slug":"mime","permalink":"http://0x3f.org/tags/mime/"}]},{"title":"樂山大佛與十面普賢","slug":"tour-to-leshan-and-emei","date":"2013-05-16T14:04:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/tour-to-leshan-and-emei/","link":"","permalink":"http://0x3f.org/post/tour-to-leshan-and-emei/","excerpt":"","text":"12年8月，去樂山、峨嵋玩兒了兩天。 樂山大佛真的很大： 據說佛爺頭上的便便越多，表示智慧越大、級別越高： 峨嵋金頂的十面普賢菩薩，美輪美奐，從沒有見過這樣一尊佛像，能讓人在看第一眼的時候就感受到震撼： 雲開日出時的十面普賢，那一瞬間，場面無以言表，極為震撼人心： 剛到樂山時看到路邊的條幅，才恍然想起這是祖師爺的老家，沒時間拜謁，罪過罪過。這次旅行最大的收穫就是看到了雲開日出時的十面普賢，是我迄今見過的最攝人心魄的景觀。","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://0x3f.org/tags/旅行/"},{"name":"山","slug":"山","permalink":"http://0x3f.org/tags/山/"},{"name":"佛","slug":"佛","permalink":"http://0x3f.org/tags/佛/"}]},{"title":"夜爬百望山","slug":"nightly-climbing-baiwang-mountain","date":"2013-05-15T14:51:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/nightly-climbing-baiwang-mountain/","link":"","permalink":"http://0x3f.org/post/nightly-climbing-baiwang-mountain/","excerpt":"","text":"今晚參加了綠野夜爬百望山的活動。主要為了認一下路，以前逃票都是從公路旁柵欄的缺口鑽進去的，後來封了就沒再去。 站在望京樓上俯瞰夜色中的帝都： 活動強度很低，適合下班後鍛鍊一下。百望山很矮，但是叉路很多，有的爬了。","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://0x3f.org/tags/旅行/"},{"name":"山","slug":"山","permalink":"http://0x3f.org/tags/山/"}]},{"title":"五一徒步恆山、雲岡石窟","slug":"tour-to-hengshan-and-yungang","date":"2013-05-13T14:48:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/tour-to-hengshan-and-yungang/","link":"","permalink":"http://0x3f.org/post/tour-to-hengshan-and-yungang/","excerpt":"","text":"綠野的活動。 頭天晚上的汽車，第二天早上三四點到恆山後山，五點出發。很冷，除了T恤，就穿了一件冲锋衣，冻得直哆嗦，不过一开始爬就好多了。上山的地方不知名，不是传说中的后山山门附近。爬上第一个山顶，转过去就是修好的登山道，放眼可见莽原与群山： 底下就是我们当晚要宿营的恒山湖： 朕與江山： 再往上没多远就是山顶，恒山海拔虽高，实际爬起来难度很低。 都说前山景色一般、精华在后山，没感觉，也许跟我们走的路线有关，倒觉得前山附崖而建的寺庙耐看： 逢山必看摩崖石刻： 前山處處隱沒在山林中的寺廟，很有意境： 邊下邊逛，中午就下了山，不明白這麼一座平平無奇的山怎麼稱得上北岳恆宗： 然後坐車去懸空寺，寺小、人多、票貴，沒上去，遠遠地拍上幾張交作業： 不宿營的人坐車去渾源縣城住宿，我們徒步走回恆山湖扎營。湖並不好看，水也不怎麼乾淨，有人釣魚，空手而歸，好在湖邊有小飯館，好吃就別想了，聊勝於無。扎營地是山腳一個凹口，是片干了的湖底，沒草，所以帳蓬容易進灰而且硌得慌，遠不像想像中青山綠水草地上伴著明月篝火清風入睡那樣享受。 雖然沒有魚，篝火還是要有的： 除了被凍醒一次，一夜無話。第二天早上坐車去渾源縣城吃傳說中的小媳婦涼粉，這個地方的涼粉配料有特色，主要有三樣東西：不辣的辣椒油、豆干和炸蠶豆，而作為主料的涼粉本身卻並不比其它地方的特別，我想像中好的涼粉應該是入口即化的。不管怎樣，有這樣的經歷也是好的： 然後坐車去雲岡石窟，首先進去是靈嚴寺： 靈嚴寺的塔和佛像都很有特色，不著重彩，呈乳白色或米黃色，觀感素雅： 雙層建築在我到過的寺廟裡是第一次見到： 大雄寶殿門口的黃金樹很耀眼： 寺後就是雲岡石窟，風化的石壁很有滄桑感，與前面金碧輝煌的靈嚴寺對比鮮明。最近越來越不喜歡破敗的事物，所以在前面寺廟的興致至此稍挫： 大窟中的巨佛，依稀可見鮮卑帝國時代的盛況： 石窟的外部原本都是有附崖建築的： 下午四點，坐車返京，晚上九點左右抵西直門散夥。 活動貼在這裡：http://bbs.lvye.cn/thread-780144-1-1.html 最後是恆頂合影：","categories":[{"name":"行見","slug":"行見","permalink":"http://0x3f.org/categories/行見/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://0x3f.org/tags/旅行/"},{"name":"徒步","slug":"徒步","permalink":"http://0x3f.org/tags/徒步/"},{"name":"山","slug":"山","permalink":"http://0x3f.org/tags/山/"},{"name":"佛","slug":"佛","permalink":"http://0x3f.org/tags/佛/"}]},{"title":"讀過Hello Android","slug":"after-reading-hello-android","date":"2013-02-21T13:01:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-hello-android/","link":"","permalink":"http://0x3f.org/post/after-reading-hello-android/","excerpt":"","text":"春節前花了一周時間讀完了這本書。 是本不錯的Android入門教材，能讓人快速地搭出開發環境，瞭解Android應用的運作機制，對於移動應用開發的初學者尤其有用。當然，這種書一般不會講得很全面，更深的東西還是要看官方文檔，只是Android的官方指南寫得比較散，並且過於簡單，不適合初學者。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[]},{"title":"DualHead Watchdog v1.0 Released","slug":"dualhead-watchdog-v1-released","date":"2013-02-16T00:56:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/dualhead-watchdog-v1-released/","link":"","permalink":"http://0x3f.org/post/dualhead-watchdog-v1-released/","excerpt":"","text":"DualHead Watchdog is a Linux desktop app which runs commands or scripts after display settings are changed. It is especially usefull for users who prefer window managers to those huge desktop environments. For these people, wallpapers often cannot be ajusted automatically when the screen size is changed or dual-head display is started. With this app, people can run custom commands to reset the background image when the display settings are changed. For example, I use i3wm in my daily life and I use dual-head display, my laptop has a screen resolution as 1366x768 and my outer display is 1920x1080. So when I start the dual-head display, the background image in the outer display is tiled with 1366x768 images. So I put the following commandline into this app: feh --bg-scale ~/.wallpaper “~/.wallpaper” is a soft link to my wallpaper. So when dual-head display is started, this command will be called and my wallpaper will be reset to fit the new screen size. More than that, users can make this app do everything when display settings are changed. At the moment, there will be a ‘monitors-changed’ and a ‘size-changed’ event, users can specify which event to listen to for each command. Features A KISSy app which does custom jobs on display changes. Event-driven, which is resource-saving. Can support as many commands as you can set. Each command can be enabled or disabled alone. Each command can listen to either the monitors-changed event or the size-changed event, or both. Links Project: https://github.com/xbot/DualHead-Watchdog FAQ How to modify settings ? Right click the tray icon and select ‘Settings’. How to add an entry to the command list ? Right click the command list and select ‘Add new entry’. How to delete an entry in the command list ? Right click the entry and select ‘Delete’. Why doesn’t the command take effect ? Make sure that you have selected the right event to listen and the command is enabled. Change Logversion 1.0.0 (2013-02-06 Wednesday 15:14:24) Initial release.","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[]},{"title":"遷移到octopress","slug":"migrate-blog-to-octopress","date":"2012-06-23T15:13:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/migrate-blog-to-octopress/","link":"","permalink":"http://0x3f.org/post/migrate-blog-to-octopress/","excerpt":"","text":"##關於遷移 前段時間，用了五年的虛擬主機突然限制了PHP內存上限，導致Wordpress只能啟用有限的幾個插件，根本不能滿足需要。 所以毅然決定遷移到JeckyII+GitHub，在摸索的過程中發現octopress比JeckyII易用，於是導出所有文章，開始遷移。因為我這幾年博客寫得比較亂，無論是內容上，還是發表方式上，結果用了幾個導出腳本，效果都不甚理想，還是有很多地方需要手工修改。六百篇文章，正好趁這個機會挑揀一下，較早的文章質量低的比較多。斷斷續續地遷移了一些，剩下的工作量還是很大的，留著以後慢慢來吧。另外這次把URL也改成永久格式了，這一來真的傷筋動骨了，連永久重定向都沒的做。 至於Feed輸出，以前訂閱Feedburner燒錄的兩個地址的讀者不受影響，直接訂閱Wordpress輸出的地址的就丟了，這裡再公佈一下： 本博客聚合輸出：http://feeds.feedburner.com/sinolog 我的全部資訊聚合：http://feeds.feedburner.com/leninlee ##遷移那點事 ###Python版本的問題 Archlinux很激進，早已把Python的缺省版本進化到了3.x，octopress會用到2.x，結果在生成全站的時候，會報如下錯誤： 1234 File &quot;&lt;string&gt;&quot;, line 1 import sys; print sys.executable ^SyntaxError: invalid syntax 在這裡找到解決方法。在octopress的plugins目錄裡創建文件： 12345require 'pygments'if !!RUBY_PLATFORM['linux'] RubyPython.configure :python_exe =&gt; '/usr/bin/python2'end ###不足 用了這段時間octopress，感覺缺點也不小，每次修改後都要重新生成全站，佔用系統資源不小，而且理論上以後會越來越慢。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"牧碼志","slug":"牧碼志","permalink":"http://0x3f.org/tags/牧碼志/"},{"name":"wordpress","slug":"wordpress","permalink":"http://0x3f.org/tags/wordpress/"},{"name":"octopress","slug":"octopress","permalink":"http://0x3f.org/tags/octopress/"},{"name":"github","slug":"github","permalink":"http://0x3f.org/tags/github/"},{"name":"git","slug":"git","permalink":"http://0x3f.org/tags/git/"}]},{"title":"讀過\"ZK: AJAX without the JavaScript Framework\"","slug":"after-reading-zk-ajax-without-the-javascript-framework","date":"2012-06-19T13:47:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-zk-ajax-without-the-javascript-framework/","link":"","permalink":"http://0x3f.org/post/after-reading-zk-ajax-without-the-javascript-framework/","excerpt":"","text":"前段時間，某天凌晨無故醒來，讀完了這本書。 雖然是ZK框架的開發者寫的書，不過實在不敢恭維。開發環境搭建的一章已經過時，其餘內容也顯得蜻蜓點水，加上全書結構顯得不是很合理，總之看完對ZK的感覺仍是朦朦朧朧的，更別說上手做東西了。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"框架","slug":"框架","permalink":"http://0x3f.org/tags/框架/"},{"name":"Javascript","slug":"javascript","permalink":"http://0x3f.org/tags/javascript/"},{"name":"AJAX","slug":"ajax","permalink":"http://0x3f.org/tags/ajax/"}]},{"title":"怎樣為紅帽系Linux發行版寫系統服務腳本","slug":"how-to-write-service-scripts-for-redhat-distros","date":"2012-06-18T16:14:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-write-service-scripts-for-redhat-distros/","link":"","permalink":"http://0x3f.org/post/how-to-write-service-scripts-for-redhat-distros/","excerpt":"","text":"##閱讀說明 閱讀本文要求有基本的Linux系統使用經驗和Bash腳本編程能力。 本文所述的內容適用於RHEL、CentOS等紅帽系Linux發行版。 ##系統服務簡介 ###常用命令 1234567891011121314151617181920# 啟動MySQLservice mysqld start# 關閉MySQLservice mysqld stop# 重啟MySQLservice mysqld restart# 查看MySQL服務運行狀態service mysqld status# 查看MySQL服務是否開機自動運行chkconfig --list mysqld# 設置MySQL服務開機自動運行chkconfig --level 345 mysqld on# 取消MySQL服務開機自動運行chkconfig --level 345 mysqld off ###運行級別 泛UNIX派系操作系統使用運行級別標識使用何種模式初始化。理論上，不同的發行版各級別代表的意義不同。紅帽系發行版使用以下七個運行級別： 0：關機 1：單用戶模式 2：多用戶模式，無網絡服務 3：多用戶模式，有網絡服務 4：未使用/用戶自定義 5：帶圖形界面的多用戶模式 6：重啟 最常用的是0、3、5、6四種模式。其中，0和6表示關閉和重啟操作系統，所以，執行命令init 0和shutdown是一個效果，同樣，執行命令init 6和reboot是一個效果。模式3即普通的命令行用戶界面，模式5即普通的圖形界面用戶界面。 模式1在個別情景下會用到，例如忘記root用戶的密碼時，需要進入模式1修改密碼。 ##系統服務腳本格式 ###示例 1234567891011121314151617181920212223242526#!/bin/bash# chkconfig: 345 99 12# description: This is a sample service scriptcase \"$1\" in start) # Start something. touch /var/lock/subsys/sample ;; stop) # Stop something. /bin/rm -f /var/lock/subsys/sample ;; restart|reload) # Restart something. ;; status) # Report the running status of something. ;; *) # Invalid command, complain an error. ;;esacexit 0 ###解釋 假設本服務腳本文件的文件名為sample。 整個服務腳本是一個普通的Bash腳本。主體是一個case語句，定義了四個命令start、stop、restart或reload、status，顧名思義，四個命令分別用來啟動、停止、重啟該服務，以及獲取服務的運行狀態。 紅帽系發行版使用chkconfig命令設置服務自動在哪個運行級別被自動執行。要使服務腳本支持chkconfig命令，需要加入註釋行： 1# chkconfig: 345 99 12 其中，345表示缺省的運行級別，使用如下命令添加服務時： 1chkconfig --add sample 將和使用如下命令一個效果： 1chkconfig --level 345 sample on 99表示啟動序號，例如若希望服務B在服務A啟動後啟動，且服務A的啟動序號是98，則服務B的啟動序號應設為大於98的一個整數。 12表示停止序號，作用與啟動序號相同。 此外，若希望在操作系統關閉前先自動執行服務的關閉命令，需要在/var/lock/subsys/目錄中存在與服務名同名的空文件，因此，應在start命令中創建一個這樣的文件，並在stop命令中刪除之。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Redhat","slug":"redhat","permalink":"http://0x3f.org/tags/redhat/"},{"name":"CentOS","slug":"centos","permalink":"http://0x3f.org/tags/centos/"},{"name":"Bash","slug":"bash","permalink":"http://0x3f.org/tags/bash/"}]},{"title":"讀完《三體——死神永生》","slug":"after-reading-three-body-long-live-the-king-of-terrors","date":"2012-06-14T14:20:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-three-body-long-live-the-king-of-terrors/","link":"","permalink":"http://0x3f.org/post/after-reading-three-body-long-live-the-king-of-terrors/","excerpt":"","text":"前天夜裡讀完了《三體》的第三部。 這三部一部比一部成熟。第一部只能算是整個故事的開端；第二部的亮點在最後揭示黑暗森林，前面的部分廢話太多；第三部開始出現情節的跌宕，是三部中最像小說的一部。 誠如所聞，劉慈欣真的把地球寫毀滅了。但是站在宇宙眾生的角度冷眼旁觀要好過以人類自我為中心的意淫，邊泡妞邊救地球的好萊塢套路也就是過過眼癮而已。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"小說","slug":"小說","permalink":"http://0x3f.org/tags/小說/"},{"name":"科幻","slug":"科幻","permalink":"http://0x3f.org/tags/科幻/"}]},{"title":"讀完《三體——黑暗森林》","slug":"after-reading-three-body-the-dark-forests","date":"2012-04-30T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-three-body-the-dark-forests/","link":"","permalink":"http://0x3f.org/post/after-reading-three-body-the-dark-forests/","excerpt":"","text":"凌晨三點，讀完了《三體》的第二部。 咒語，這個東西的確很有意思。第二部比第一部好看，故事情節上完全展開，成功地製造了懸念。如果一部小說，刪掉很多文字仍不影響故事情節，那這部分就是多餘的，可惜在這部書裡這是個很大的問題，所以直到最後三分之一才真正出彩。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"小說","slug":"小說","permalink":"http://0x3f.org/tags/小說/"},{"name":"科幻","slug":"科幻","permalink":"http://0x3f.org/tags/科幻/"}]},{"title":"UltraBlog.vim v3.5.0: 內建瀏覽器","slug":"ultrablog-v350-released","date":"2012-04-29T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ultrablog-v350-released/","link":"","permalink":"http://0x3f.org/post/ultrablog-v350-released/","excerpt":"","text":"此前預覽文章是通過調用系統默認的網絡瀏覽器實現的，缺點是這些功能完備的瀏覽器啟動速度不甚理想，尤其是火狐，誰用誰知道。 前兩天看了TuxRadar的一個Podcast，幾分鐘內就可以用pywebkitgtk拼裝出一個五臟俱全的網絡瀏覽器，pywebkitgtk這個東西實在是非常的好用。不過我實測後發現這東西加載頁面的速度比較慢，而且貌似是單線程的，因為圖片都是放在最後才加載，不知道是這個綁定本身的問題，還是有API可以實現的。於是突然想到拿這個東西實現一個簡單的瀏覽器，很適合在UB裡預覽文章。 增加了一個選項“ub_use_ubviewer”，默認值是1，即默認使用這個內建的瀏覽器預覽文章。當這個選項的值被設為0時，仍然使用系統的默認瀏覽器，並且在Vim啟動時不會加載內建的瀏覽器。這樣做一是為了多一種選擇，再一個也可以避開煩人的GTK警告： ** (gvim:13629): WARNING **: Trying to register gtype 'GMountMountFlags' as enum when in fact it is of type 'GFlags' ** (gvim:13629): WARNING **: Trying to register gtype 'GDriveStartFlags' as enum when in fact it is of type 'GFlags' ** (gvim:13629): WARNING **: Trying to register gtype 'GSocketMsgFlags' as enum when in fact it is of type 'GFlags' 這些警告是GTK或其它一些程序庫的Bug造成的，雖然只在虛擬終端中啟動Vim時會顯示並且不影響使用，但總會有警告恐懼症患者會覺得這種東西很鬧心。如果這樣，就把這個選項的值設成0，用回巨型瀏覽器好了。 本次更新的全部內容如下： Feature: Add a tiny web browser to do previewing, which starts much faster than full-functional browsers like firefox and chromium. The later ones are still supported. The matter that whether or not to use the new previewer is controlled by a new option ub_use_ubviewer. Bugfix: Issue 7: Keywords highlighting is disabled in item lists, even if searches are made manually. 關於UB的詳細信息在這裡。 這是那個Podcast： Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"UltraBlog.vim","slug":"ultrablog-vim","permalink":"http://0x3f.org/tags/ultrablog-vim/"}]},{"title":"UltraBlog.vim v3.4.0: 正則表達式、批量替換和調試模式","slug":"ultrablog-v340-released","date":"2012-04-28T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ultrablog-v340-released/","link":"","permalink":"http://0x3f.org/post/ultrablog-v340-released/","excerpt":"","text":"這次的更新主要引入了支持正則表達式的全文檢索、批量替換和調試模式。 正則表達式 我一直覺得原來的全文檢索有一個遺憾，雖然可以通過多個關鍵詞實現較為精確的查詢，但還是不如正則表達式靈活和精確。 這是個蓄謀已久的需求，但直到真正做起來，才發現很多有意思的東西。雖然SQLite3提供支持正則表達式查詢的“REGEX”關鍵詞，但並沒有實際實現這個功能，而是需要寫程序實現並在數據庫接口中註冊這個函數： 123456789101112131415161718import sqlite3conn = sqlite3.connect('/tmp/your-database-file.db')# 使用正則表達式匹配給定內容的函數，返回布爾類型def regexp_search(expr, item): \"\"\"Check if the item has a sub-string which matches the expr\"\"\" reg = re.compile(expr) return reg.search(item) is not None# 在數據庫中註冊這個函數conn.create_function('REGEXP', 2, regexp_search)cur = conn.execute('select id,title from post where content REGEXP ?', '\\babc\\b')row = cur.fetchone()print rowconn.close() 在SQLAlchemy中具體的實現方式是： 123456789# 註冊函數dbe = sqlalchemy.create_engine(\"sqlite:///tmp/your-database-file.db\")conn = dbe.connect()conn.connection.create_function('REGEXP', 2, regexp_search)# 在SQL Expression Language中創建查詢條件tbl = Post.__table__cond_1 = tbl.c.title.op('regexp')(r'\\babc\\b')cond_2 = tbl.c.content.op('regexp')(r'\\babc\\b') 和普通的全文檢索一樣，正則表達式的全文檢索也支持使用多個表達式作為查詢條件，多個條件之間是與的關係。現在可以這樣查詢所有包含“UltraBlog.vim”但不把推廣代碼算在內的文章了： 1:UBRegexSearch [^\\[]UltraBlog\\.vim[^\\]] 批量替換 在我換過新域名後，我就覺得這個功能很有必要了： 1:UBReplace https://sinolog.it https://0x3f.org 包含第一個參數內容並被替換的文章數目會顯示在Vim的命令輸出緩衝區中。 有了前面實現全文檢索支持正則表達式的嘗試，再實現支持正則表達式的批量替換就容易多了： 123456789101112131415161718192021# 轉換字符串成raw格式的函數def raw(text): \"\"\"Returns a raw string representation of text\"\"\" escape_dict=&#123;'\\a':r'\\a', '\\b':r'\\b', '\\c':r'\\c', '\\f':r'\\f', '\\n':r'\\n', '\\r':r'\\r', '\\t':r'\\t', '\\v':r'\\v', '\\'':r'\\'', '\\\"':r'\\\"', '\\0':r'\\0', '\\1':r'\\1', '\\2':r'\\2', '\\3':r'\\3', '\\4':r'\\4', '\\5':r'\\5', '\\6':r'\\6', '\\7':r'\\7', '\\8':r'\\8', '\\9':r'\\9'&#125; return \"\".join([escape_dict.get(char,char) for char in text])# 使用正則表達式替換字符串的函數def regex_replace(string, expr, repl): \"\"\"Do substitutions on the string for repls matching the expr\"\"\" r = re.compile(raw(expr)) return r.sub(repl, string)# 在數據庫中註冊這個函數conn.connection.create_function('regex_replace', 3, regex_replace)# 在SQL語句中使用這個函數sql_replace = \"update post set title=regex_replace(title,:needle,:replacement),content=regex_replace(content,:needle,:replacement)\"conn.execute(sql_replace, &#123;'needle':r'\\babc\\b', 'replacement':'xyz'&#125;) 最終，這個命令是這樣的： 1:UBRegexReplace \\babc\\b xyz 實現批量替換容易，但要解決由此引出的一個問題就費周折了，就是批量替換過文章內容後怎樣和博客同步的問題，現在我還沒有好的想法，留作以後實現。 調試模式 開啟調試模式可以將所有被執行的SQL語句顯示在Vim的命令輸出緩衝區中，在有異常拋出時，也可以顯示堆棧信息。由於開啟調試模式既不需要修改代碼，也不需要重啟Vim，這可以極大地方便開發時對UltraBlog.vim的調試，也能使用戶提交問題時能反饋更多更詳細的信息。 以下三個命令用於控制調試模式的開啟狀態： :UBEnableDebug :UBDisableDebug :UBToggleDebug 其它內容 本次更新的內容如下： Feature: Add the command :UBRegexSearch, doing full-text searches with regular expressions ! Feature: Add the command :UBReplace, doing full-text substitutions. Feature: Add the command :UBRegexReplace, doing full-text substitutions with regular expressions. Feature: Add commands :UBEnableDebug, :UBDisableDebug, :UBToggleDebug and an option ub_debug. In debug mode, SQL statements and stack traces of exceptions will be displayed. Change: Undo keywords highlighting after executing :UBList. Bugfix: Exceptions raised when opening the current item under cursor in item lists if the option ub_hotkey_save_current_item has not been set. Now this options comes with a default value. 關於UB的詳細信息在這裡。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"UltraBlog.vim","slug":"ultrablog-vim","permalink":"http://0x3f.org/tags/ultrablog-vim/"}]},{"title":"慎用PHP的fsockopen()連接localhost","slug":"fsockopen-fails-connecting-localhost","date":"2012-04-23T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/fsockopen-fails-connecting-localhost/","link":"","permalink":"http://0x3f.org/post/fsockopen-fails-connecting-localhost/","excerpt":"","text":"使用xdebug跟蹤程序性能時發現fsockopen()函數耗時一秒，單步調試發現實際在這裡超時了，而超時時間設置的就是一秒。 如果把目標地址由原來的“localhost”換成“127.0.0.1”，馬上就可以連上。在PHP的Bug跟蹤系統中找到這個問題： https://bugs.php.net/bug.php?id=50953 看起來像是在5.2.12以後已修改，但我發現在5.2.17中仍存在這個問題。另有說法在5.3中不存在這個問題，我沒有測試。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"性能","slug":"性能","permalink":"http://0x3f.org/tags/性能/"}]},{"title":"PHP大量常量應集中使用APC定義","slug":"define-massive-constants-using-apc","date":"2012-04-23T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/define-massive-constants-using-apc/","link":"","permalink":"http://0x3f.org/post/define-massive-constants-using-apc/","excerpt":"","text":"用xdebug跟蹤程序性能時，發現一個定義了約七百個常量的文件，include_once()時消耗約六十毫秒的時間。事實上define()的效率比較低，如果需要定義大量常量，使用APC擴展提供的apc_define_constants()效果會好得多。 下面是對這個文件改造前後效率跟蹤結果的對比： define()方案（ms） apc_define_constants()方案（ms） 啟動Web服務和PHP，第一次運行 58 4 不重啟Web服務和PHP，第二次運行 65 1 不重啟Web服務和PHP，第三次運行 66 1 由此可見，apc_define_constants()不但在初次調用時效能就超過define()，而且由於APC自身的緩存功能，在後續調用時效率會有進一步的提高，而define()基本沒有變化。 以下是apc_define_constants()的代碼示例： 12345678910&lt;?phpif(!apc_load_constants('my_constants')) &#123; $constants = array( 'ONE' =&gt; 1, 'TWO' =&gt; 2, 'THREE' =&gt; 3, ); apc_define_constants('my_constants', $constants);&#125;?&gt; Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"性能","slug":"性能","permalink":"http://0x3f.org/tags/性能/"}]},{"title":"UltraBlog.vim v3.3.0：I18N、超時時間和其它","slug":"ultrablog-v330-released","date":"2012-04-14T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ultrablog-v330-released/","link":"","permalink":"http://0x3f.org/post/ultrablog-v330-released/","excerpt":"","text":"UB一歲了，這算是個週年紀念版吧。 在這一年裡，因為各種原因，博客寫得沒有以前多了，但每篇都是用這個插件寫的，我覺得很好用。斷斷續續地做了一些修改，因為一切都是一個人在做，所以大的變化不多。這次這個版本裡有些改動還是要感謝荒野無燈童鞋，他的建議很大程度上催生了這個新版本：比如加入保存命令的熱鍵映射選項，這樣可以使用保存普通文件的熱鍵保存UB中的內容，我自己以前也經常習慣性地用錯熱鍵；還有socket超時時間的選項，最近我這裡也經常性地在UB操作博客時報超時的異常，荒童鞋關於自定義socket超時時間的建議一語驚醒了夢中人。 此外，似乎與近期Vim的一次升級有關，在Vim中調用Python接口打印任何內容到標準IO都會導致Vim崩潰，所以這次把所有的輸出都改成了調用Vim的輸出命令來做。 本次修改的內容中，還有一項比較重要的內容就是實現了國際化，目前只提供英文和簡體中文兩種語言，由於Vimball不能處理二進制文件，所以從此以後UB改用zip格式壓縮包打包。 以下是本次更新的詳細內容： Feature: Add i18n support ! Feature: Add a new option ub_hotkey_save_current_item, users can define their own hotkey for :UBSave. Feature: Add a new option ub_socket_timeout, users can customize the timeout period in seconds, useful for slow networks. Bugfix: Exception raised when one event is processed by more than one event handlers. Change: Echoing messages now uses the command :echoerr instead of python's sys.stderr, because Vim crashes on this due to an upgrade recently. Change: Change commands :UBSave, :UBSend, :UBUpload, :UBConv, :UBPreview to be available only in their effective views. Change: Lists are set nowrapped. Bugfix: Stop complaining '_pop from empty list_' while doing almost everything. 關於UB的詳細信息在這裡。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"UltraBlog.vim","slug":"ultrablog-vim","permalink":"http://0x3f.org/tags/ultrablog-vim/"}]},{"title":"在Archlinux下使用thinkfan控制Thinkpad x220的風扇轉速","slug":"how-to-control-fan-speed-with-thinkfan","date":"2012-04-13T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-control-fan-speed-with-thinkfan/","link":"","permalink":"http://0x3f.org/post/how-to-control-fan-speed-with-thinkfan/","excerpt":"","text":"Archlinux目前對Thinkpad風扇的自動控制效果並不好，氣溫上升後很容易出現一直在三千多轉一直跑的問題。thinkfan是目前用的比較多的自動控制風扇轉速的程序，但Google到的配置thinkfan的文章大多語焉不詳，可能是跟具體的發行版有關，因為貌似有些發行版中安裝了thinkfan後會自動生成缺省的配置文件，但在目前的AUR中的包被安裝後卻沒有生成任何配置文件。 下面是我在Archlinux下配置的步驟，實際效果很好，現在只要不看視頻、不編譯程序、不啟動Chromium，一般是兩千九百轉的速度，安靜多了。 lm_sensors 安裝lm_sensors並執行命令初始化： 12# 一路回車sudo sensors-detect 將sensors加入rc.conf中DAEMONS中，開機啟動。 启动sensors服务： 1sudo rc.d start sensors thinkpad_acpi 修改文件“/etc/modprobe.d/thinkpad_acpi.conf”： 1options thinkpad_acpi fan_control=1 我這裡雖沒有把thinkpad_acpi加到rc.conf的MODULES中，但lsmod也是可以看到它的，說明還是自動啟用了。要使上面這項配置生效，必須重啟電腦，我這裡重啟thinkpad_acpi模塊時報錯說該模塊正在被使用。 thinkfan 安裝thinkfan並修改文件“/etc/default/thinkfan”： 1START=yes 修改文件“/etc/thinkfan.conf”： 123456789sensor /sys/class/hwmon/hwmon0/temp1_input(0, 0, 55)(1, 48, 60)(2, 50, 61)(3, 52, 63)(4, 56, 65)(5, 59, 66)(7, 63, 32767) 將thinkfan加入rc.conf的DAEMONS中，開機自動啟動。 啟動thinkfan： 1sudo thinkfan 查看狀態 12345# 看CPU温度和风扇转速sensors# 看風扇詳細信息cat /proc/acpi/ibm/fan Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"},{"name":"ThinkPad","slug":"thinkpad","permalink":"http://0x3f.org/tags/thinkpad/"}]},{"title":"TurboCRM Cluster Express v1.0 釋出","slug":"turbocrm-cluster-express-v1-released","date":"2012-04-07T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/turbocrm-cluster-express-v1-released/","link":"","permalink":"http://0x3f.org/post/turbocrm-cluster-express-v1-released/","excerpt":"","text":"TurboCRM Cluster Express是TurboCRM的集群實施工具。 去年我曾經寫過一個配置集群的Bash腳本“cluster.sh”，TCE是對這個腳本的圖形界面封裝，通過可視化的操作簡化集群的實施工作。 TCE的最新版本和使用說明可以在這裡找到。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"BASH","slug":"bash","permalink":"http://0x3f.org/tags/bash/"},{"name":"PyGTK","slug":"pygtk","permalink":"http://0x3f.org/tags/pygtk/"},{"name":"CRM","slug":"crm","permalink":"http://0x3f.org/tags/crm/"},{"name":"雲計算","slug":"雲計算","permalink":"http://0x3f.org/tags/雲計算/"}]},{"title":"禁止屏幕在播放視頻時自動關閉","slug":"how-to-keep-monitor-active-while-watching-flv","date":"2012-04-03T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-keep-monitor-active-while-watching-flv/","link":"","permalink":"http://0x3f.org/post/how-to-keep-monitor-active-while-watching-flv/","excerpt":"","text":"貌似Lose系統下看在線視頻的時候不會超時自動關閉屏幕，但是我在Arch下就一直晃鼠標、按鍵盤來著，這嚴重違反了DRY原則。於是昨天終於寫了這個腳本，當全屏播放視頻的時候，關閉屏保和顯示器的節能特性，否則則激活它們。由於是在X的級別實現，理論上應當適合所有桌面環境。 123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bash# Baby-sitter of the monitor's DPMSidle_period=60ss_switch_off=0ss_is_off=0while true; do # Read DPMS state xset -q|grep \"DPMS is Disabled\" &gt; /dev/null &amp;&amp; ss_is_off=1 || ss_is_off=0 # Get pid of the current window active_window_id=`xprop -root | grep \"_NET_ACTIVE_WINDOW(WINDOW)\" | cut -d\" \" -f5` decimal_id=`xprop -id $active_window_id | grep PID | cut -d\" \" -f3` # Traverse all libflashplayer.so for pid in `ps -ef|grep -v grep|grep libflashplayer.so|awk '&#123;print $2&#125;'`; do # If the current window is libflashplayer.so if [ \"$pid\" -eq \"$decimal_id\" ]; then ss_switch_off=1 break else ss_switch_off=0 fi done if [ $ss_switch_off -eq 1 ]; then # Turn off DPMS echo Turn off DPMS if [ $ss_is_off -eq 0 ]; then echo Action xset s off xset -dpms fi else # Turn on DPMS echo Turn on DPMS if [ $ss_is_off -eq 1 ]; then echo Action xset +dpms xset s on fi fi sleep $idle_perioddone 似乎對非全屏播放的情況沒有什麼好方法。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"BASH","slug":"bash","permalink":"http://0x3f.org/tags/bash/"},{"name":"腳本","slug":"腳本","permalink":"http://0x3f.org/tags/腳本/"}]},{"title":"關於PyGTK.CellRenderer的回調方法中聚焦異常的問題","slug":"the-focus-issue-of-pygtk-cellrenderer","date":"2012-03-24T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-focus-issue-of-pygtk-cellrenderer/","link":"","permalink":"http://0x3f.org/post/the-focus-issue-of-pygtk-cellrenderer/","excerpt":"","text":"遇到這樣一個問題： 在pygtk.TreeView中，需要在一個Cell的值被修改後做一個校驗，如果不合法，則重新聚焦該Cell並選中其中的內容。 示意代碼如下： 12345678910111213141516# pygtk.CellRenderer的edited事件的回調方法def onCellEdited(self, cell, path, newText, userData): store,colNum = userData # 使用事件驅動的設計理念，創建一個自定義的事件 evt = ServerTypeChangedEvent(self, cell, usrData) # 事件入隊列 EventQueue.fireEvent(evt) # 處理事件隊列，如果截獲異常，提示並重新聚焦Cell try: EventQueue.processEvents() except Exception,e: self.alert(e.message) col = self.treeView.get_column(colNum-1) # 聚焦Cell，並選中Cell中的內容 self.treeView.set_cursor_on_cell(path, col, cell, True) 關鍵的代碼在最後一行，通過調用TreeView的set_cursor_on_cell方法聚焦Cell並選中其內容。但就是這一步出了問題，報如下警告： GtkWarning: _gtk_tree_view_column_start_editing: assertion `tree_column->editable_widget == NULL' failed 此後整個TreeView的行為表現不正常，表現為可直接修改其它Cell的內容，且原Cell一直處於聚焦狀態。 此問題的原因是：edited事件在Cell的輸入控件被銷毀前就發出了，這時在事件的回調方法中重新聚焦該Cell就導致了這個問題（詳見這裡）。 解決方法是借助glib.idle_add函數，在PyGTK空閒的時候再調用set_cursor_on_cell方法，由於此時原控件已被銷毀，所以不會有問題。 修改後的代碼如下： 12345678910111213def onCellEdited(self, cell, path, newText, userData): store,colNum = userData evt = ServerTypeChangedEvent(self, cell, usrData) EventQueue.fireEvent(evt) try: EventQueue.processEvents() except Exception,e: self.alert(e.message) col = self.treeView.get_column(colNum-1) #self.treeView.set_cursor_on_cell(path, col, cell, True) import glib glib.idle_add(self.treeView.set_cursor_on_cell, path, col, cell, True) Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PyGTK","slug":"pygtk","permalink":"http://0x3f.org/tags/pygtk/"}]},{"title":"Mac，江湖再見！","slug":"bye-mac","date":"2012-03-11T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/bye-mac/","link":"","permalink":"http://0x3f.org/post/bye-mac/","excerpt":"","text":"零八年底，我用半年的差補收了當時Thinkpad X200頂配的FN3。三年的時間，幾乎每天都要用很久，竟然從沒掉過鏈子。雖說是這樣，但畢竟用的強度大、時間長，屏幕已經遠不如當初清晰，亮度也差了，即使調到最高亮度都覺著暗。 於是打算趁著還能發揮餘熱，趁早處理掉，省得將來砸手裡。 既然要換，不如玩兒得折騰一點兒，於是小手一抖，Mac到手。 我對Mac的OS只是有點小好奇，主要是奔著Mac的外觀和做工去的，還是打算回頭裝Arch。玩兒了四個月，平心而論，Mac OS X確實是個不錯的OS，美觀程度無與倫比，結合Mac硬件的外觀和做工，真是天作之合；易用性之高，確實讓我有點小驚訝，多點觸摸得心應手，軟件安裝一拖而就，相比之下，Windows顯得拙劣不堪。 如果只是作為辦公和娛樂的工具，Mac可挑剔的地方確實不多。但是易用性往往和靈活性成反比，靈活性高意味著你可以隨心所欲地制定自己的遊戲規則，而易用性高則往往意味著你只能接受它的方式、認可它的價值觀，易用並不代表順手。 除此之外就是軟件資源的問題，Mac的免費軟件相對很少，而且和Windows一樣，需要先下載，再安裝。雖然也有MacPorts、Homebrew，和Linux的軟件倉庫比起來還是差得太遠。 做慣了Archer，是可忍，孰不可忍。 還是要裝Arch。但是在製作安裝介質這一步就遇著麻煩了，USB啟動安裝盤死活都不認，試了幾種方法，無果。此外還有不少未知的問題，比如驅動等等。 如果在幾年前，在學校，有大把的時間可以糟蹋，我就跟丫死掐了。現在不行了，傷不起了。果斷入手Thinkpad X220 A45，上周六把Mac出手了。 小黑和Arch不愧是天作之合，比起當初在X200上裝的時候還容易。只是小黑的多點觸摸板啊，東施效顰，我想不到更貼切的詞形容了，太TMD坑爹了！ 鑑於X200上4G內存被Chromium吃光光的苦逼經歷，這次果斷入手兩根4G的三星金條，都是黨的政策好啊，最近內存白菜價，兩根金條才300糧票。 從宣和八年秋十月到宣和九年春王三月，我的短暫的小白史告一段落，MacBook Pro MC700CH/A，江湖再見！ Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"ThinkPad","slug":"thinkpad","permalink":"http://0x3f.org/tags/thinkpad/"},{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"Mac","slug":"mac","permalink":"http://0x3f.org/tags/mac/"},{"name":"筆記本","slug":"筆記本","permalink":"http://0x3f.org/tags/筆記本/"}]},{"title":"NGINX: 405 Not Allowed","slug":"nginx-405-not-allowed","date":"2012-02-18T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/nginx-405-not-allowed/","link":"","permalink":"http://0x3f.org/post/nginx-405-not-allowed/","excerpt":"","text":"NGINX不允许向静态文件提交POST方式的请求，否则报405错误。测试方法为，使用curl向服务器上的静态文件提交POST请求： 1curl -d 1=1 http://localhost/version.txt 得到以下结果： 1234567&lt;html&gt;&lt;head&gt;&lt;title&gt;405 Not Allowed&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=\"white\"&gt;&lt;center&gt;&lt;h1&gt;405 Not Allowed&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.0.11&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 网上传抄的添加以下配置的解决办法不可用： 12345error_page 405 =200 @405;location @405&#123; root /srv/http;&#125; 一种不完美但可用的方法为： 12345678910111213141516upstream static_backend &#123; server localhost:80;&#125;server &#123; listen 80; # ... error_page 405 =200 @405; location @405 &#123; root /srv/http; proxy_method GET; proxy_pass http://static_backend; &#125;&#125; 即转换静态文件接收的POST请求到GET方式。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"Nginx","slug":"nginx","permalink":"http://0x3f.org/tags/nginx/"},{"name":"HTTP","slug":"http","permalink":"http://0x3f.org/tags/http/"}]},{"title":"登入XFCE後自動關閉藍牙的方法","slug":"how-to-disable-bluetooth-after-login-to-xfce","date":"2012-02-17T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-disable-bluetooth-after-login-to-xfce/","link":"","permalink":"http://0x3f.org/post/how-to-disable-bluetooth-after-login-to-xfce/","excerpt":"","text":"Blueman不能記憶藍牙的關閉狀態，每次登入桌面都會自動打開藍牙，既費電又不安全。 一種方法是禁止bluetooth服務自動啟動，缺點是使用藍牙時不方便，還要手工啟動bluetooth服務。 另一種方法是登入桌面後自動關閉藍牙，即使用如下命令： 1sudo rfkill block bluetooth 但XFCE不能定製自動啟動程序的順序，所以可以寫下面這麼個腳本，然後添加到自動啟動程序列表中： 12345#!/bin/bashblueman-applet &amp;sleep 5sudo rfkill block bluetooth 當然，還要取消自動啟動程序列表中原來的Blueman。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"XFCE","slug":"xfce","permalink":"http://0x3f.org/tags/xfce/"},{"name":"藍牙","slug":"藍牙","permalink":"http://0x3f.org/tags/藍牙/"}]},{"title":"啟用新域名0x3f.org","slug":"enable-the-new-domain-name-0x3f-org","date":"2012-01-08T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/enable-the-new-domain-name-0x3f-org/","link":"","permalink":"http://0x3f.org/post/enable-the-new-domain-name-0x3f-org/","excerpt":"","text":"元旦假期第三天，還是把域名給換了。 原因主要是.it太貴，年費十幾刀，而.org只有它的一半。另外，原來的sinolog.it有點兒長，也顯老氣，想換個更個性、更短的。 可惜中意的0xff有主了，只好退而求0x3f。0x3f在ASCII裡面代表問號，象徵“保持好奇心”。 按照上次的經驗，對著數據庫一通改，加上這兩年四處沾花惹草，很多網站上的相關信息都得跟著改，長此以往，以後連域名都換不起了。 好在RSS訂閱早已經換成了FeedBurner燒錄，只是對於直接用原域名訂閱的需要改一下訂閱地址了。 用了幾年國家域名，現在也用上國際域名了…… Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"牧碼志","slug":"牧碼志","permalink":"http://0x3f.org/tags/牧碼志/"},{"name":"域名","slug":"域名","permalink":"http://0x3f.org/tags/域名/"}]},{"title":"讀完《三體》","slug":"after-reading-three-body","date":"2011-12-17T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-three-body/","link":"","permalink":"http://0x3f.org/post/after-reading-three-body/","excerpt":"","text":"幾年沒讀過小說了，上次讀劉慈欣的《球狀閃電》還是在學校的時候，多年後再次讀小說的感覺怪怪的，有點陌生，也沒有激情。雖然早就知道這部書，一直沒看，現在終於利用零散時間在Kindle上讀完了它。 我不是個科幻迷，但也覺得這部書寫得挺好。有懸念，立意新穎，尤其是據說在後兩部裡乾脆把地球給寫毀滅了！我要接著往下看。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"小說","slug":"小說","permalink":"http://0x3f.org/tags/小說/"},{"name":"科幻","slug":"科幻","permalink":"http://0x3f.org/tags/科幻/"}]},{"title":"讀完《Hacking Vim7.2》","slug":"after-reading-hacking-vim72","date":"2011-11-27T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-hacking-vim72/","link":"","permalink":"http://0x3f.org/post/after-reading-hacking-vim72/","excerpt":"","text":"作者對Vim很有心得，分享了很多好的經驗。這本書於新手可以用來入門，於老手也多有可取之處，是本學習Vim很不錯的參考書。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"}]},{"title":"MatchTag.vim: 高亮配對的HTML標籤","slug":"highlighting-paired-html-tags-using-matchtag-vim","date":"2011-11-22T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/highlighting-paired-html-tags-using-matchtag-vim/","link":"","permalink":"http://0x3f.org/post/highlighting-paired-html-tags-using-matchtag-vim/","excerpt":"","text":"兩年前我曾在Vim郵件列表裡問怎樣高亮配對的HTML標籤，但沒能解決。今天意外收到一封郵件，Linqq童鞋在StackOverflow上問了同樣的問題，有人就寫了這個插件。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"HTML","slug":"html","permalink":"http://0x3f.org/tags/html/"},{"name":"插件","slug":"插件","permalink":"http://0x3f.org/tags/插件/"}]},{"title":"YYeTs.py：人人影視BT種子下載輔助腳本","slug":"yyets-torrents-download-script","date":"2011-11-13T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/yyets-torrents-download-script/","link":"","permalink":"http://0x3f.org/post/yyets-torrents-download-script/","excerpt":"","text":"这是最好的時代，这是最壞的時代。現在還有像人人影視的BT種子FTP这樣的站點，實在不容易。但是所有種子列在一塊，想看看最近幾天都更新了甚麼都很困難，於是早想寫個腳本省時省力。这週末終於實現了这個想法。 主要功能 按關鍵詞查詢種子 限制查詢範圍為最近幾天新增的 下載符合查詢條件的種子，允許下載前編輯任務列表 使用說明 環境 Python 2.7，不支持Python3 Mac OS X Lion，Archlinux測試通過，理論上支持Windows 配置 如果需要編輯下載任務列表（即使用-s選項），應事先配置環境變量YYETS_EDITOR，將值設定為一個文本編輯器的路徑，或者修改腳本的私有屬性__editor__也一樣。如果这兩個位置都沒有設置，則使用環境變量EDITOR。否則，將報“Command not found”的錯誤。 有一點提示，如果使用GVim或MacVim，需要加上選項-f，以阻塞的方式啓動它，否則會導致下載結果不能達到預期。例如對於MacVim，可配置YYETS_EDITOR為： mvim -f 使用舉例 123456789101112131415161718192021# 列出所有種子./yyets.py# 搜索關鍵詞./yyets.py 猩球崛起 1080p# 搜索最近三天新增的種子./yyets.py --past=3# 搜索最近七天內新增的、滿足關鍵詞條件的種子./yyets.py --past=7 蓝精灵# 下載滿足查詢條件的種子./yyets.py -d --past=30 1080p# 下載滿足查詢條件的種子，下載前編輯任務列表./yyets.py -d -p --past=30 1080p# 更多詳細信息，參閱幫助./yyets.py -h./yyets.py --help 下載 移步GitHub獲取最新版本： https://github.com/xbot/shell Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"下載","slug":"下載","permalink":"http://0x3f.org/tags/下載/"},{"name":"腳本","slug":"腳本","permalink":"http://0x3f.org/tags/腳本/"},{"name":"BT","slug":"bt","permalink":"http://0x3f.org/tags/bt/"}]},{"title":"讀完《Pro Git》","slug":"after-reading-pro-git","date":"2011-11-13T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-pro-git/","link":"","permalink":"http://0x3f.org/post/after-reading-pro-git/","excerpt":"","text":"花了大約一周的時間，周日晚上讀完《Pro Git》的最後幾頁。 高效、安全的分布式和強大的分枝合併是Git的殺手級特性，这本書在語言上淺顯易懂、簡明扼要，在章節安排上循序漸進，在內容講解上有較深入的挖掘，當屬眼下Git方面最好的教材。此外，这本書的中譯水平也很高，必要的地方還有譯注，能看出譯者不是外行。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"Git","slug":"git","permalink":"http://0x3f.org/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://0x3f.org/tags/版本控制/"}]},{"title":"UltraBlog.vim v3.1釋出：代碼重構與MacVim支持","slug":"ultrablog-v310-released","date":"2011-11-04T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ultrablog-v310-released/","link":"","permalink":"http://0x3f.org/post/ultrablog-v310-released/","excerpt":"","text":"距離上一個版本的釋出已經有三個月了，这次新版並沒有增加多少功能性的內容，主要是代碼的重構和對在MacVim下穩定性的改進。 對依賴關係檢查的不細緻導致了一些麻煩，拋出的錯誤信息有時與實際原因相距甚遠。由於開始時是以實現功能為主，所以都是直接用函數實現的，之後修修補補，代碼冗余而且維護麻煩。於是著手重構主要功能的源碼，面向對象，把所有檢查邏輯放到父類中去實現，子類只關注自身邏輯，最後新版減少了二百多行的代碼量。 在重構的過程中偶然發現，在MacVim中，程序拋出任何異常，即便是有捕獲邏輯，也會導致編輯器崩潰。在这裡簡略地提到： the failure was actual a crash, through some strange combination of threading, matplotlib pyplot backend, and ssh X11 forwarding, sys.stderr had somehow been assigned to something which python complained wasn't a file-like object 於是將所有標準輸出與標準錯誤輸出語句換成另一種形式： 1234567# 原形式sys.stdout.write('xxx')sys.stderr.write('xxx')# 新形式print &gt;&gt; sys.stdout, 'xxx'print &gt;&gt; sys.stderr, 'xxx' 以上是新版主要變更的內容，此外，也順便解決了開發過程中發現的個別Bug和做了其它一些改動： Change: The key \"xmlrpc\" of the settings list is dropped, a new one with the name \"url\" is added, you should set its value to the blog url. Change: Source code refactorings. Change: Solve the crash problem existing in MacVim only. Change: :UBConv can be used in any buffer. Change: :UBThis now has a third parameter, which enables convertions between syntaxes. Bugfix: The second parameter of :UBThis cannot take effect. 这也是將源碼從Google Code遷移到GitHub後發佈的第一個新版本，更詳細的信息請移步插件主頁或GitHub上的代碼倉庫。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"UltraBlog.vim","slug":"ultrablog-vim","permalink":"http://0x3f.org/tags/ultrablog-vim/"}]},{"title":"Double Commander: 免費、跨平台的Total Commander","slug":"double-commander","date":"2011-08-30T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/double-commander/","link":"","permalink":"http://0x3f.org/post/double-commander/","excerpt":"","text":"由於Total Commander很貴，在Windows下又是必不可少的，我一直希望能找到一個TC的免費替代品。試用過很多免費的文件管理器，但都不理想。偶然看到Double Commander，才發現這幾乎完全就是我想要的。 特性 幾乎完全模仿TC，甚至連插件的API都一致 界面佈局、樣式高度可定製 熱鍵高度可定製 開源、免費、跨平台 侷限 功能相對TC少很多 穩定性不是非常高 運行速度稍嫌慢 開發進度慢 小技巧 熱鍵設置 每個內置命令可以設置多個熱鍵，每個熱鍵可以指定參數，參數中可以使用環境變量，如下圖所示： 針對命令cm_ChangeDir設置了兩個熱鍵，其中，給Ctrl+Home指定的參數是$HOME，給Ctrl+Shift+Home指定的參數是$HOME/Desktop，即分別切換到當前用戶的主目錄和桌面目錄。 自定義文件類型命令 可以為每種文件類型定義多個命令，這些自定義命令將顯示為上下文菜單的“動作”菜單的子菜單項。如下圖所示： 定義了名稱為“Archive”的文件類型，關聯了一系列的文件後綴名。然後添加了一個名為“解壓縮到當前目錄”的動作，並指定所執行的命令為urxvt -e aunpack %f。其中，%f是一個佔位符，代表當前文件的全名。DC預置了幾個佔位符，可以點擊命令輸入框右側圖標是加號的按鈕選擇。 最終的效果如下： 解決日期時間亂碼的問題 截至版本0.5.0 beta，如果設置了使用日期時間字符串的格式為“yyyy-mm-dd hh:mm:ss”，在zh_CN.UTF-8的區域設置下，字符串中將出現亂碼： 臨時解決辦法是以英文區域設置啟動doublecmd： 1234#!/bin/bashexport LC_ALL=en_US.UTF-8doublecmd &amp; Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"Windows","slug":"windows","permalink":"http://0x3f.org/tags/windows/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"軟體","slug":"軟體","permalink":"http://0x3f.org/tags/軟體/"},{"name":"開源","slug":"開源","permalink":"http://0x3f.org/tags/開源/"},{"name":"免費","slug":"免費","permalink":"http://0x3f.org/tags/免費/"},{"name":"跨平台","slug":"跨平台","permalink":"http://0x3f.org/tags/跨平台/"}]},{"title":"Enable Code Snippet Highlighting For UltraBlog.vim Templates","slug":"enable-code-snippet-highlighting-for-ultrablog-vim-templates","date":"2011-08-26T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/enable-code-snippet-highlighting-for-ultrablog-vim-templates/","link":"","permalink":"http://0x3f.org/post/enable-code-snippet-highlighting-for-ultrablog-vim-templates/","excerpt":"","text":"Templates make it possible for users previewing posts in custom formats in UltraBlog.vim. However, there is more you can do with our highly customizable templates. This article discusses how to highlight code snippets in posts by the use of some third-party open-source tools. Before setting out to work, let me introduce the tools we are about to use: highlight.js: A javascript library which highlights code blocks in web pages automatically. jquery: The famous RIA development javascript library. Download the upper two libraries and put them under any folder accessible to your webbrowser, in my case, it is /home/lenin/.vim/bundle/ultrablog/vendor/. Then open UltraBlog.vim and edit the template you are using, put the following lines in the &lt;head&gt;...&lt;/head&gt; area: 123456789101112&lt;link rel=\"stylesheet\" href=\"/home/lenin/.vim/bundle/ultrablog/vendor/highlight/styles/default.css\"&gt;&lt;script src=\"/home/lenin/.vim/bundle/ultrablog/vendor/highlight/highlight.pack.js\"&gt;&lt;/script&gt;&lt;script src=\"/home/lenin/.vim/bundle/ultrablog/vendor/jquery.js\"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; $('pre').each(function(i, e)&#123; if(typeof e.lang != 'undefined') e.className = e.lang; hljs.highlightBlock(e, ' '); &#125;);&#125;);&lt;/script&gt; If you are using the default template UltraBlog.vim supplies, change .title to .postTitle in the pre-defined &lt;style&gt;...&lt;/style&gt; area, and change the class name of the div element in the &lt;body&gt;...&lt;/body&gt; area from title to postTitle, that is because this class name is also used by highlight.js. An important point, the jquery selector I used in the code snippet above selects every &lt;pre&gt;...&lt;/pre&gt; element and copies the value of its attribute lang to class. This is specified for the wordpress plugin wp-syntax I use. If you use another syntax highlighting tool which uses different markup for code blocks, you should modify the code above to make highlight.js find code blocks correctly. Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"UltraBlog.vim","slug":"ultrablog-vim","permalink":"http://0x3f.org/tags/ultrablog-vim/"}]},{"title":"Linux下雙屏顯示的設置","slug":"dualhead-display-on-linux","date":"2011-08-03T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/dualhead-display-on-linux/","link":"","permalink":"http://0x3f.org/post/dualhead-display-on-linux/","excerpt":"","text":"RandR是對X11的一個擴展協議，允許在不重啟X的情況下修改輸出的一些參數並使之生效，xrandr是該協議的命令行界面，它的功能之一就是用來設置雙屏顯示。 缺省情況下，外接顯示器後啟用的是屏幕複製模式，即兩個屏幕顯示完全相同的內容。使用命令xrandr -q查看當前的輸出狀態： Screen 0: minimum 320 x 200, current 1920 x 1080, maximum 8192 x 8192 LVDS1 connected 1280x800+0+0 (normal left inverted right x axis y axis) 261mm x 163mm 1280x800 60.0+ 60.0 50.0 1024x768 75.1 70.1 60.0 800x600 72.2 75.0 60.3 56.2 768x576 75.0 72.0 60.0 640x480 72.8 75.0 60.0 59.9 VGA1 connected 1920x1080+0+0 (normal left inverted right x axis y axis) 509mm x 286mm 1920x1080 60.0+ 1680x1050 60.0 1280x1024 75.0 60.0 1440x900 59.9 1280x960 60.0 1024x768 75.1 70.1 60.0 832x624 74.6 800x600 72.2 75.0 60.3 56.2 640x480 72.8 75.0 66.7 60.0 720x400 70.1 HDMI1 disconnected (normal left inverted right x axis y axis) DP1 disconnected (normal left inverted right x axis y axis) HDMI2 disconnected (normal left inverted right x axis y axis) DP2 disconnected (normal left inverted right x axis y axis) DP3 disconnected (normal left inverted right x axis y axis) 可見，筆記本電腦的屏幕輸出（LVDS1）的顯示分辨率是1280x800，外接顯示器的輸出（VGA1）的分辨率是1920x1080。兩個輸出在整個虛擬屏幕（名稱：Screen 0；當前大小：1920x1080；最大：8192x8192）上的坐標都是+0+0。所以在外接顯示器中可以看到屏幕左上角有一個1280x800分辨率的小屏幕。 屏幕複製模式最常用於外接投影儀，現在我需要兩個屏幕分別顯示在各自的顯示器中，並在兩個屏幕中顯示不同的內容（也就是Windows下設置雙屏顯示時選擇的擴展模式）。 由於我將筆記本電腦放在外接顯示器的左邊，所以為了操作的自然，使用命令xrandr --output VGA1 --right-of LVDS1將外接顯示器的輸出在虛擬屏幕上的位置設置在筆記本電腦的輸出的右邊，示意圖如下： 這樣，兩個顯示器中就可以顯示不同的內容了。由於屬於同一個虛擬屏幕，當然也可以將一個窗口跨過邊界從一個顯示器拖到另一個顯示器中。再使用命令xrandr -q查看現在的輸出狀態： Screen 0: minimum 320 x 200, current 3200 x 1080, maximum 8192 x 8192 LVDS1 connected 1280x800+0+0 (normal left inverted right x axis y axis) 261mm x 163mm 1280x800 60.0+ 60.0 50.0 1024x768 75.1 70.1 60.0 800x600 72.2 75.0 60.3 56.2 768x576 75.0 72.0 60.0 640x480 72.8 75.0 60.0 59.9 VGA1 connected 1920x1080+1280+0 (normal left inverted right x axis y axis) 509mm x 286mm 1920x1080 60.0+ 1680x1050 60.0 1280x1024 75.0 60.0 1440x900 59.9 1280x960 60.0 1024x768 75.1 70.1 60.0 832x624 74.6 800x600 72.2 75.0 60.3 56.2 640x480 72.8 75.0 66.7 60.0 720x400 70.1 HDMI1 disconnected (normal left inverted right x axis y axis) DP1 disconnected (normal left inverted right x axis y axis) HDMI2 disconnected (normal left inverted right x axis y axis) DP2 disconnected (normal left inverted right x axis y axis) DP3 disconnected (normal left inverted right x axis y axis) 使用xrandr做的設置只對當前的X會話有效，重啟後恢復原樣。使設置持久化的方法為修改xorg.conf或設置自動執行命令。據說有一些圖形界面封裝的xrandr的前端，完善的桌面環境如GNOME和KDE應該也是可以在圖形界面中設置的，不過我所使用的XFCE目前似乎只能啟用/禁用複製模式，而不支持在圖形界面中設置擴展模式。 下面的腳本用來簡化雙屏顯示的設置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/bash# Restart trayer and cairo-dock which I use on my desktoprestart_widget()&#123; killall trayer killall cairo-dock # Another script which starts trayer and set some options mytrayer cairo-dock &amp;&#125;set_dualhead()&#123; xrandr --output LVDS1 --auto xrandr --output VGA1 --auto xrandr --output VGA1 --right-of LVDS1 restart_widget&#125;set_lvds()&#123; xrandr --output VGA1 --off xrandr --output LVDS1 --auto restart_widget&#125;set_vga()&#123; xrandr --output LVDS1 --off xrandr --output VGA1 --auto restart_widget&#125;if [ $# -eq 0 ]; then set_dualhead exitficase \"$1x\" in \"lvdsx\") set_lvds;; \"vgax\") set_vga;; *) echo 'Unknown parameter !';;esac Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"}]},{"title":"UltraBlog.vim v3.0釋出：全文檢索與事件驅動","slug":"ultrablog-v300-released","date":"2011-07-24T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ultrablog-v300-released/","link":"","permalink":"http://0x3f.org/post/ultrablog-v300-released/","excerpt":"","text":"用了一周的業餘時間，昨天我釋出了UltraBlog.vim的3.0版。新版本主要加入了全文檢索的功能，並引入事件驅動的模式。 全文檢索是我蓄謀已久的功能，一個不能搜索的博客客戶端的管理功能是大打折扣的。得益於SQLite數據庫和SQLAlchemy框架，全文檢索的實現是很簡單的，新增加的:UBFind命令將在所有文章和頁面的標題與內容中查詢，並將搜索結果顯示在一個可分頁的列表中。這個命令支持任意多個關鍵詞，各關鍵詞之間遵循與的關係。此外，檢索結果中，所有的關鍵詞將被自動標記為高亮。 事件驅動模式的引入是我悍然將版本號跳躍到3.x的主要原因。 在前幾個版本中，我實現了對多窗口的支持，它使得用戶可以在新窗口中打開列表中的文章。但UltraBlog.vim最初開發的時候並沒有考慮到多窗口的問題，所有命令都只針對當前窗口進行操作。這就有了緩衝區內容同步的問題，假如在一個新的緩衝區中打開了和另一個緩衝區相同的文章，則一個緩衝區內容的改變不會同步到另外一個中，這多少是有些隱患的。 最直接的做法是在所有可能改變緩衝區內容的功能中加入對其它緩衝區的處理，但這樣做有不少問題： 代碼耦合度太高，違反K.I.S.S原則，不利於今後的開發和維護 函數體過長，我討厭難看的代碼 代碼冗餘，重複勞動 事件驅動模式可以很好的解決以上問題，一個函數只干一件事，做完後一個事件拋出去，至於連帶著要做什麼，誰監聽這個事件誰去處理，代碼的耦合度很低，復用度很高，易於維護和閱讀。 UltraBlog.vim引入事件驅動模式處理緩衝區同步的問題。不同的操作拋出不同的事件，所有的事件繼承自父類UBEvent： 1234567891011class UBEvent: def __init__(self, srcObj): self.srcObj = srcObjclass UBDebugEvent(UBEvent): passclass UBTmplDelEvent(UBEvent): passclass UBTmplSaveEvent(UBEvent): passclass UBLocalPostDelEvent(UBEvent): passclass UBRemotePostDelEvent(UBEvent): passclass UBPostSendEvent(UBEvent): passclass UBPostSaveEvent(UBEvent): pass 一個可能改變緩衝區內容的操作執行完後，創建一個特定的事件並將其加入到事件隊列中。事件隊列類中存放兩個列表，一是事件隊列，二是事件監聽器列表；提供三個方法，分別用來註冊事件監聽器、對事件執行入隊列操作和處理隊列中所有事件： 12345678910111213141516171819class UBEventQueue: queue = [] listeners = [] @classmethod def fireEvent(cls, evt): cls.queue.append(evt) @classmethod def processEvents(cls): for evt in cls.queue: for listener in cls.listeners: if listener.isTarget(evt): cls.queue.remove(evt) listener.processEvent(evt) @classmethod def registerListener(cls, lsnr): cls.listeners.append(lsnr) 事件隊列對事件的處理是通過事件監聽器進行的，每個事件監聽器要實現兩個功能：識別監聽對象和處理監聽對象。所有具體事件的監聽類都是UBListener的子類： 123456789101112131415161718192021222324252627282930313233class UBListener(): ''' Parent class of all listeners ''' eventType = None @classmethod def isTarget(cls, evt): return isinstance(evt, cls.eventType) @staticmethod def processEvent(evt): passclass UBPostSaveListener(UBListener): ''' Listener for saving posts/pages 1. Refresh the current view if it is an edit/list view of this post 2. Mark all edit/list views of posts/pages outdated ''' eventType = UBPostSaveEvent @staticmethod def processEvent(evt): for nr in ub_get_buffers(['post_edit','page_edit']): if evt.srcObj==ub_get_meta('id', nr): if nr==ub_get_bufnr('%'): ub_refresh_current_view() else: ub_set_view_outdated(nr) for nr in ub_get_buffers(['post_list','page_list','search_result_list']): if nr == ub_get_bufnr('%'): ub_refresh_current_view() else: ub_set_view_outdated(nr) 事件監聽器遍歷所有滿足處理條件的緩衝區，對當前緩衝區，立即刷新，其餘的標記為已過期。同時利用Vim自身的事件驅動特性，在進入已過期的緩衝區時，再更新之，也就是傳說中的懶加載模式： 1au BufEnter * py __ub_on_buffer_enter() 1234567@__ub_exception_handlerdef __ub_on_buffer_enter(): ''' Triggered by BufEnter event, check if the buffer is outdated ''' if ub_is_view_outdated('%'): ub_refresh_current_view() ub_set_view_outdated('%', False) 此外，隨著代碼量的增加，原來把全部代碼都放在一個文件中的做法不再適用，尤其是以Here Document形式存放在vim腳本文件中的Python代碼不能被ctags識別，所以按類別分別存放到$VIMRUNTIME/plugin/ultrablog/下的幾個Python源文件中。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"UltraBlog.vim","slug":"ultrablog-vim","permalink":"http://0x3f.org/tags/ultrablog-vim/"}]},{"title":"收入AOC E2343F","slug":"got-aoc-e2343f","date":"2011-07-23T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/got-aoc-e2343f/","link":"","permalink":"http://0x3f.org/post/got-aoc-e2343f/","excerpt":"","text":"當初在深圳被公司的Dell Inspiron 1300嚇怕了，所以不惜重金收入了高配的Thinkpad X200 FN3。最近越來越覺得12寸的屏幕看代碼實在是太侷促了。 今天中午收到AOC E2343F，979￥，23寸屏裡算是價位很低的了，不算是很好的屏，不過看看代碼、電影足夠了。外接到X200上，人品不錯，完美屏，沒壞點，桌面環境下可以使用最大1920x1080x32分辨率，但是不知道為什麼，hwinfo --framebuffer列出的結果中沒有這個最佳分辨率，KMS自動選用了1280x1024x32，可惜不能在fbterm下撒野了。 下午複習了一下AVATAR，720P，有點兒衝動，Intel GMA X4500還是很堅挺的。打開Vim，分割窗口，豁然開朗，對於這個根本目的，結果相當衝動。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"ThinkPad","slug":"thinkpad","permalink":"http://0x3f.org/tags/thinkpad/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"桌面環境","slug":"桌面環境","permalink":"http://0x3f.org/tags/桌面環境/"},{"name":"framebuffer","slug":"framebuffer","permalink":"http://0x3f.org/tags/framebuffer/"},{"name":"裝備","slug":"裝備","permalink":"http://0x3f.org/tags/裝備/"}]},{"title":"使用PAC Manager管理SSH連接","slug":"manage-ssh-connections-using-pac-manager","date":"2011-07-13T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/manage-ssh-connections-using-pac-manager/","link":"","permalink":"http://0x3f.org/post/manage-ssh-connections-using-pac-manager/","excerpt":"","text":"本文發表在今年一月份的『Linuxpilot』上，已經過了半年，可以放到博客上了。本文基於PAC 2.x版，最近PAC發佈了3.0版，界面和功能都有一定的變化。 簡介 PAC Manager（以下簡稱PAC）是一個使用Perl編程語言和GTK圖形界面開發套件實現的SSH/Telnet/Serial連接管理工具，是同類的PuTTY、SecureCRT、SSHMenu的一個開源、免費的替代品。 具備哪些特性 可創建本地端口轉發、遠程端口轉發和動態端口轉發，并支持X圖形界面轉發 對連接分組，方便管理較多連接 將指定的、已打開的連接加入集群，同一集群的所有終端共享鍵盤輸入 虛擬終端窗口支持多標簽 虛擬終端窗口的樣式可定制，支持半透明 支持通過代理服務器建立連接 支持通過Expect表達式進行自動交互 支持使用本地和遠程宏管理數量眾多且復雜的常用指令 支持定制連接前和斷開後自動執行的指令 為每個連接保存截圖 針對重要特性的細解 創建SSH隧道 假如當我們在進行諸如收發電郵、使用即時通訊工具聊天或者使用網絡銀行等網絡通訊行為時，也許有些重要的數據我們不希望被明文傳遞；亦或某些資源受限于網絡結構和防火牆等因素而不能被我們直接訪問，這時我們往往就可以通過SSH的端口轉發功能來實現。 所謂端口轉發，即是指將原本使用其它TCP端口訪問的數據經由SSH連接占用的端口發送，加之這一過程也伴隨有數據的加密和解密，因此也往往被稱作“隧道”。根據連接方向的不同，SSH的隧道一般分為三種，即正向隧道、反向隧道和動態隧道；同時，根據端口轉發方式的不同，這三種隧道又分別被稱為本地端口轉發、遠程端口轉發與動態端口轉發。 那麽這三種端口轉發方式彼此之間有什麽异同，分別又都有什麽用途呢？這裏舉個例子來說明一下。 假設我的公司有一個較大的內部網絡，而只有一台服務器作為網關對公網提供服務。如果我需要在家裏的個人電腦上訪問公司的辦公系統，而這套系統又部署在內部網絡中的一台服務器上、不能被公網訪問，該怎麽辦呢？ 第一種情況，假設網關服務器對外提供了SSH服務，那麽我就可以在家庭電腦上使用如下指令建立一個隧道： ssh -L 9999:192.168.1.128:80 111.111.111.111 這條指令中，192.168.1.128是公司辦公系統服務器在內網中的IP地址，111.111.111.111是公司網關服務器的公網IP地址。整條指令的意思是：我在家庭電腦中訪問本機的9999端口，就如同我在IP地址為111.111.111.111的公司網關服務器上訪問IP地址為192.168.1.128的主機的80端口一樣。因此，當這條指令執行成功後，我就可以在家庭電腦中通過訪問9999端口來打開公司內部辦公系統了。 第二種情況，假設網關服務器不對外提供SSH服務但安裝了SSH客戶端，而我的家庭電腦卻安裝了SSH服務，那麽我就可以在公司網關服務器上執行如下指令建立一個隧道： ssh -R 9999:192.168.1.128:80 222.222.222.222 這條指令中，222.222.222.222是家庭電腦的公網IP地址。整條指令的意思是：我在公網IP地址為222.222.222.222的電腦上訪問9999端口，就如同在本機（公司網關服務器）上訪問IP地址為192.168.1.128的主機的80端口一樣。當我回到家中，就可以和前面一樣通過訪問9999端口來打開辦公系統了。 事實上，第一種情況是將本地端口映射為遠程主機所能訪問的資源，故稱為本地端口轉發；而第二種情況是將遠程主機的端口映射為本機所能訪問的資源，故稱為遠程端口轉發。 但無論是本地端口轉發還是遠程端口轉發，都只能將一個資源轉發到一個端口上，假若我要訪問很多資源，豈非要建立很多SSH隧道，不但操作麻煩，而且浪費本機資源。這時，我們就可以使用第三種端口轉發方式--動態端口轉發： ssh -D 9999 111.111.111.111 這條指令的意思是：我在本機訪問9999端口，就像在IP地址為111.111.111.111的主機上訪問它所能訪問的某些資源一樣。這個所謂的“某些資源”，需要由我在發起訪問請求時通過SSH隧道告訴遠程主機，事實上，SSH的動態端口轉發就是創建了一個SOCKS代理服務器。 在PAC Manager中，我們可以在每個SSH連接的配置界面創建隧道。對于上面的例子，創建本地端口轉發時，應點擊“Local Port Forwarding”區域的“Add”按鈕，并將本地端口、遠程資源IP地址和端口分別填寫到“Local Port”、“Remote Address”和“Remote Port”中： 截至當前最新的版本（2.4.1.3），PAC Manager尚未為遠程端口轉發提供像本地端口轉發功能一樣單獨的配置界面，但可以使用高級選項功能實現。在“Advanced Options”輸入框中填寫如下內容： 如果需要建立多個遠程端口轉發，可以在“Advanced Options”中填寫多個類似上面內容的選項，彼此之間使用空格分隔即可。 創建動態端口轉發時，應選中“Dynamic Port Forwarding”區域前面的復選框，然後填寫“Forwarded SOCKS Port”即可： 連接前及斷開後的自動指令 通過在PAC Manager中定義連接前和斷開後的自動指令，我們可以指定一些在相應的SSH連接建立之前及斷開之後通常要在本機執行的指令。 例如假設我使用的是計時收費的網絡服務，為了節省資費，我希望只在每次建立SSH連接時才激活網絡服務，并且在完成工作後斷開SSH連接時自動斷開網絡服務。那麽就可以在“Pre Exec”中定義激活網絡服務的指令，如下圖所示： 在“Post Exec”中定義斷開網絡服務的指令，如下圖所示： PAC Manager會在每次建立SSH連接前和斷開SSH連接後彈出對話框請求用戶選擇要在本機執行的指令。 Expect正則表達式 Expect是一個用以實現終端中自動交互功能的軟件套件，它允許用戶通過編寫腳本實現自動響應終端中的指令對用戶輸入的請求，從而將用戶從日常重復的勞動中解脫出來。利用Expect，我們可以實現自動輸入日常使用的指令中密碼的輸入；可以在安裝程式要求確認時自動確認；甚至實現一個IRC聊天機器人，在你不在時自動回復你的朋友！ 那麽在PAC Manager中，Expect是怎樣使用的呢？我們用一個示例來說明。 假設我是公司內部郵件系統的管理員，每天下班後回到家都要時常查看一下系統的日志記錄，而郵件系統服務器位于公司內部網絡，我只有公司網關的SSH訪問權限。這樣我每次查看日志都要做至少三件事： 通過SSH登錄到公司網關主機 使用SCP指令從內網郵件服務器上下載日志文件到公司網關主機（需要輸入密碼） 使用vi編輯器打開日志文件 如果經常這樣做，會是件很煩瑣的事。那麽在PAC Manager中可以這樣實現： 首先創建一個到公司網關的SSH連接，然後添加Expect配置如下： 第一個Expect配置項的意思是在到公司網關的SSH連接建立成功後馬上從郵件服務器（IP是192.168.1.3）上下載日志文件（mail.log），然後使用vi編輯器打開該日志文件。由于SCP指令需要輸入密碼，故第二個Expect配置項會在SCP請求密碼時自動輸入。這樣，在PAC Manager中每次連接到公司網關時就會自動下載并打開日志文件了。 宏 對于經常要做遠程管理的用戶，通常會有一些常用的指令，有時指令太多或太長，記憶和輸入都不方便，這時就可以使用PAC Manager的宏管理功能來管理這些常用指令。 例如在下面的圖中，我們定義了兩個指令： 然後在建立SSH連接後就可以在需要的時候通過右鍵菜單選擇要執行的指令： 如果在編輯宏時選中了輸入框前面的“Confirm”，則表示在使用此指令前會彈出一個對話框要求用戶確認，對于一些危險的指令，這會是防止自己犯下不可饒恕的錯誤的最後一道屏障。 集群 如果您有多台遠程主機需要管理，并且經常會對所有主機都執行一些相同的操作，那麽PAC Manager的集群功能就可以免去在每台主機上都執行一遍相同指令的麻煩。 首先我們打開三個SSH連接，假設現在需要在其中的兩台主機中輸入同樣的指令，那麽可以點擊PAC Manager主窗口上的“Clusters”按鈕，在彈出的對話框中的集群列表中新建或選擇一個集群。 在對話框左邊的列表中列出的是當前所有打開的連接中沒有被加入集群的連接，選中其中的兩個，并點擊“Add to Cluster”，這兩個連接即被加入指定的集群中。如下圖所示： 同一集群中的所有終端窗口將共享用戶的輸入，例如在集群中的任一終端中輸入“hostname”并點擊Enter鍵，則集群中所有終端都會顯示該連接對應主機的主機名。 環境變量及用戶自定義變量 PAC Manager允許用戶在定義宏、Expect腳本和其它指令時使用系統環境變量和自定義的變量。對于某些需要用到會經常變化的特定值的指令，這個功能免去了每當這些值變化後都必須逐個修改相關指令的麻煩。 以前面在“Expect正則表達式”節舉的例子來說，假設我不但定義了連接後自動下載日志文件的Expect表達式，還定義了幾個使用lftp指令下載遠程主機其它文件的宏，那麽每當遠程主機的FTP賬號密碼發生變化，我都必須逐個修改所有使用了這個密碼的宏，設想如果這種情況很多，那將會是怎樣的噩夢！ 此時我就可以使用自定義變量的功能定義一個變量，以存儲這個密碼，如下圖所示： 然後在所有使用這個密碼的位置使用這個變量作為替代值。查找已定義變量的方法是在指令輸入框中點擊右鍵，所有的用戶自定義變量都顯示在“User variables”菜單中： 如果需要在指令中引入系統環境變量，則可以在與“User variables”平級的“Environment variables”菜單中選擇。 靈活的可定制性 PAC Manager提供一個簡潔直觀的全局定制界面，用戶可在其中定義程式本身行為的參數、建立連接後的虛擬終端窗口的樣式、連接的超時時間及建立連接時使用的代理服務器信息。 它甚至為每個連接都提供了定制功能，用戶可以針對個別連接進行個性化定制，單個連接中的配置信息將會覆蓋全局配置中對應的信息。 管理Telnet/Serial連接 PAC Manager不但支持SSH協議，也可以作為Telnet和Serial協議的連接管理工具，在此不作贅述。 結束語 PAC Manager是一個年輕的項目，在用戶體驗和功能上還有很大的發展空間。但憑借出色的用戶界面設計和實用細致的功能，即使與那些老牌的同類工具相比也不遑多讓，從它華麗的現身我們高興地看到在SSH/Telnet管理工具中又多出一個易用、強大、美觀和免費的選擇。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"SSH","slug":"ssh","permalink":"http://0x3f.org/tags/ssh/"},{"name":"遠程控制","slug":"遠程控制","permalink":"http://0x3f.org/tags/遠程控制/"}]},{"title":"APC、文件和Memcached效率對比","slug":"comparison-of-efficiency-for-apc-file-memcached","date":"2011-07-12T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/comparison-of-efficiency-for-apc-file-memcached/","link":"","permalink":"http://0x3f.org/post/comparison-of-efficiency-for-apc-file-memcached/","excerpt":"","text":"對一個保存了100個對象實例的數組進行300次讀寫，該數組序列化後大小為232KB。 測試環境 網絡服務器 PHP版本 操作系統 硬件配置 NGINX v1.0.4 PHP-FPM v5.3.6APC啟用 Archlinux 32bit Intel(R) Core(TM)2 Duo CPU T9400 @ 2.53GHzMem: 3G DDR3Disk: 5400r/s 測試腳本 測試數據： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220&lt;?php/* * @file data.php */class XTest&#123; var $x0; var $x1; var $x2; var $x3; var $x4; var $x5; var $x6; var $x7; var $x8; var $x9; var $x10; var $x11; var $x12; var $x13; var $x14; var $x15; var $x16; var $x17; var $x18; var $x19; var $x20; var $x21; var $x22; var $x23; var $x24; var $x25; var $x26; var $x27; var $x28; var $x29; var $x30; var $x31; var $x32; var $x33; var $x34; var $x35; var $x36; var $x37; var $x38; var $x39; var $x40; var $x41; var $x42; var $x43; var $x44; var $x45; var $x46; var $x47; var $x48; var $x49; var $x50; var $x51; var $x52; var $x53; var $x54; var $x55; var $x56; var $x57; var $x58; var $x59; var $x60; var $x61; var $x62; var $x63; var $x64; var $x65; var $x66; var $x67; var $x68; var $x69; var $x70; var $x71; var $x72; var $x73; var $x74; var $x75; var $x76; var $x77; var $x78; var $x79; var $x80; var $x81; var $x82; var $x83; var $x84; var $x85; var $x86; var $x87; var $x88; var $x89; var $x90; var $x91; var $x92; var $x93; var $x94; var $x95; var $x96; var $x97; var $x98; var $x99; function __construct() &#123; $this-&gt;x0 = 1234567890; $this-&gt;x1 = 1234567890; $this-&gt;x2 = 1234567890; $this-&gt;x3 = 1234567890; $this-&gt;x4 = 1234567890; $this-&gt;x5 = 1234567890; $this-&gt;x6 = 1234567890; $this-&gt;x7 = 1234567890; $this-&gt;x8 = 1234567890; $this-&gt;x9 = 1234567890; $this-&gt;x10 = 1234567890; $this-&gt;x11 = 1234567890; $this-&gt;x12 = 1234567890; $this-&gt;x13 = 1234567890; $this-&gt;x14 = 1234567890; $this-&gt;x15 = 1234567890; $this-&gt;x16 = 1234567890; $this-&gt;x17 = 1234567890; $this-&gt;x18 = 1234567890; $this-&gt;x19 = 1234567890; $this-&gt;x20 = 1234567890; $this-&gt;x21 = 1234567890; $this-&gt;x22 = 1234567890; $this-&gt;x23 = 1234567890; $this-&gt;x24 = 1234567890; $this-&gt;x25 = 1234567890; $this-&gt;x26 = 1234567890; $this-&gt;x27 = 1234567890; $this-&gt;x28 = 1234567890; $this-&gt;x29 = 1234567890; $this-&gt;x30 = 1234567890; $this-&gt;x31 = 1234567890; $this-&gt;x32 = 1234567890; $this-&gt;x33 = 1234567890; $this-&gt;x34 = 1234567890; $this-&gt;x35 = 1234567890; $this-&gt;x36 = 1234567890; $this-&gt;x37 = 1234567890; $this-&gt;x38 = 1234567890; $this-&gt;x39 = 1234567890; $this-&gt;x40 = 1234567890; $this-&gt;x41 = 1234567890; $this-&gt;x42 = 1234567890; $this-&gt;x43 = 1234567890; $this-&gt;x44 = 1234567890; $this-&gt;x45 = 1234567890; $this-&gt;x46 = 1234567890; $this-&gt;x47 = 1234567890; $this-&gt;x48 = 1234567890; $this-&gt;x49 = 1234567890; $this-&gt;x50 = 1234567890; $this-&gt;x51 = 1234567890; $this-&gt;x52 = 1234567890; $this-&gt;x53 = 1234567890; $this-&gt;x54 = 1234567890; $this-&gt;x55 = 1234567890; $this-&gt;x56 = 1234567890; $this-&gt;x57 = 1234567890; $this-&gt;x58 = 1234567890; $this-&gt;x59 = 1234567890; $this-&gt;x60 = 1234567890; $this-&gt;x61 = 1234567890; $this-&gt;x62 = 1234567890; $this-&gt;x63 = 1234567890; $this-&gt;x64 = 1234567890; $this-&gt;x65 = 1234567890; $this-&gt;x66 = 1234567890; $this-&gt;x67 = 1234567890; $this-&gt;x68 = 1234567890; $this-&gt;x69 = 1234567890; $this-&gt;x70 = 1234567890; $this-&gt;x71 = 1234567890; $this-&gt;x72 = 1234567890; $this-&gt;x73 = 1234567890; $this-&gt;x74 = 1234567890; $this-&gt;x75 = 1234567890; $this-&gt;x76 = 1234567890; $this-&gt;x77 = 1234567890; $this-&gt;x78 = 1234567890; $this-&gt;x79 = 1234567890; $this-&gt;x80 = 1234567890; $this-&gt;x81 = 1234567890; $this-&gt;x82 = 1234567890; $this-&gt;x83 = 1234567890; $this-&gt;x84 = 1234567890; $this-&gt;x85 = 1234567890; $this-&gt;x86 = 1234567890; $this-&gt;x87 = 1234567890; $this-&gt;x88 = 1234567890; $this-&gt;x89 = 1234567890; $this-&gt;x90 = 1234567890; $this-&gt;x91 = 1234567890; $this-&gt;x92 = 1234567890; $this-&gt;x93 = 1234567890; $this-&gt;x94 = 1234567890; $this-&gt;x95 = 1234567890; $this-&gt;x96 = 1234567890; $this-&gt;x97 = 1234567890; $this-&gt;x98 = 1234567890; $this-&gt;x99 = 1234567890; &#125;&#125;$repeat = 300;$arr = array();for ($i = 0; $i &lt; 100; $i++) &#123; $arr[] = new XTest;&#125;?&gt; APC: 1234567891011121314151617&lt;?php/* * @file t1.php */include_once 'data.php';$stime = microtime(true);for ($i = 0; $i &lt; $repeat; $i++) &#123; apc_store('key'.$i, $arr); apc_fetch('key'.$i);&#125;$etime = microtime(true);echo $etime-$stime;?&gt; 文件： 1234567891011121314151617&lt;?php/* * @file t2.php */include_once 'data.php';$stime = microtime(true);for ($i = 0; $i &lt; $repeat; $i++) &#123; file_put_contents('/tmp/xtest_key'.$i.'.srl', serialize($arr)); unserialize(file_get_contents('/tmp/xtest_key'.$i.'.srl'));&#125;$etime = microtime(true);echo $etime-$stime;?&gt; Memcached: 1234567891011121314151617181920&lt;?php/* * @file t3.php */include_once 'data.php';$mem = new Memcached;$mem-&gt;addServer(\"127.0.0.1\", 11211);$stime = microtime(true);for ($i = 0; $i &lt; $repeat; $i++) &#123; $mem-&gt;set('key'.$i, $arr); $mem-&gt;get('key'.$i);&#125;$etime = microtime(true);echo $etime-$stime;?&gt; 測試結果 APC 文件 Memcached 3.4926421642303 3.6572530269623 4.6224999427795 總結 APC效率最高，Memcached效率最低 APC和Memcached的測試結果很穩定，文件方式的耗時從開始時的4秒逐步降低並穩定在3.6秒 猜想： 在IO量較小的情況下，文件讀寫可能確實比通過TCP操作Memcached效率高，但是在IO量較大的情況下，文件方式會出現瓶頸，Memcached的優勢會得到體現 對於集群應用，通過NFS共享文件緩存的效率會低於Memcached Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"Memcached","slug":"memcached","permalink":"http://0x3f.org/tags/memcached/"},{"name":"緩存","slug":"緩存","permalink":"http://0x3f.org/tags/緩存/"},{"name":"評測","slug":"評測","permalink":"http://0x3f.org/tags/評測/"}]},{"title":"隱藏InstallShield對話框控件的方法","slug":"how-to-hide-dialog-in-installshield","date":"2011-06-21T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-hide-dialog-in-installshield/","link":"","permalink":"http://0x3f.org/post/how-to-hide-dialog-in-installshield/","excerpt":"","text":"SQLServerSelectLogin對話框中如果選擇Windows身份驗證，在附加數據庫時會因權限不夠而失敗，所以應該隱藏這個選項，從而要求用戶只執行SQL身份驗證。 但是如果在定製對話框佈局時直接刪除兩個單選框，會導致用戶輸入的用戶名和密碼不能被安裝程序獲取，並且InstallShield也沒有提供隱藏這些控件的屬性。解決方法是修改控件的定位屬性，將其定位到對話框的大小範圍之外： 要達到的目標： 修改Top屬性，將指定的控件定位在對話框之外： 最終效果： Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"InstallShield","slug":"installshield","permalink":"http://0x3f.org/tags/installshield/"}]},{"title":"讀完『Ext JS IN Action』","slug":"after-reading-extjs-in-action","date":"2011-06-20T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-extjs-in-action/","link":"","permalink":"http://0x3f.org/post/after-reading-extjs-in-action/","excerpt":"","text":"這是本需要仔細讀的書，對ExtJS的主要控件有比較詳細的解說，有一定的原理性解釋，并且對擴展ExtJS和ExtJS項目開發的模式有一些介紹。但不涉及底層特性，例如DOM、AJAX等。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"JavaScript","slug":"javascript","permalink":"http://0x3f.org/tags/javascript/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"ExtJS","slug":"extjs","permalink":"http://0x3f.org/tags/extjs/"}]},{"title":"UltraBlog.vim v2.3.0 Released With Templates","slug":"ultrablog-v230-released","date":"2011-06-12T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ultrablog-v230-released/","link":"","permalink":"http://0x3f.org/post/ultrablog-v230-released/","excerpt":"","text":"I released the new version 2.3.0 of UltraBlog.vim last week. The main improvement in this version is that templates are introduced in. Templates are simply HTML strings, they are used to preview posts/pages in the browser locally. This feature is a reparation for the remote previewing, due to the limit of the API, users cannot send a post to Wordpress as draft and preview it without affecting the post status if the post has been published. With templates, they do not have to send drafts to blogs to preview the final effect, but preview drafts directly in the browser in a pre-defined style. Templates can be created as many as users like and their looks can be customized with CSS, HTML and Javascript. The following illustrations show the content and final effect of the default template: Templates should be formatted as valid Python template strings, that is, use the following avaliable placeholders and escape any literal '%' with another '%': %(title)s The title of the current post/page. %(content)s The content of the current post/page. %% A literal '%'. Users can take the default template whose name is 'default' as an example for writing their own templates. The default template can be changed to another one by setting the name of that template to the option ub_default_template. Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"UltraBlog.vim","slug":"ultrablog-vim","permalink":"http://0x3f.org/tags/ultrablog-vim/"}]},{"title":"Vim自定義命令的參數自動補全","slug":"how-to-define-auto-completion-for-vim-commands","date":"2011-06-10T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/how-to-define-auto-completion-for-vim-commands/","link":"","permalink":"http://0x3f.org/post/how-to-define-auto-completion-for-vim-commands/","excerpt":"","text":"UltraBlog.vim起初的幾個版本采用增加命令個數的方式減少每個命令的參數個數，目的是降低命令格式記憶的難度。從2.3.0版本起，開始采用Vim自定義命令的一些高級特性，精簡命令個數，雖然參數個數增加了，但由于實現了參數補全，反而更加直觀。 Vim對自定義命令提供了多種補全參數的方式，詳見:h command-complete。其中，最常用的當屬custom： 1command! -nargs=? -complete=custom,StatusCmpl UBSend exec('py ub_send_item(&lt;f-args&gt;)') 以上代碼定義了一個自定義命令UBSend，它可以獲得一個或零個參數（-nargs=?），如果指定參數，則補全方式采用custom，該方式調用一個名為StatusCmpl的函數并以其返回值作為補全的值域： 123function! StatusCmpl(ArgLead, CmdLine, CursorPos) return \"draft\\npublish\\nprivate\\npending\\n\"endfunction 從以上代碼可以看出，該函數需要接受三個參數，返回值應該是一個用換行符“\\n”分割的字符串，在執行補全時，Vim自動使用正則表達式匹配備選項。對于只有一個參數的情況，這種實現方式簡單高效。 對于參數較多的情況，customlist補全方式最為適用： 1command! -nargs=* -complete=customlist,UBNewCmpl UBNew exec('py ub_new_item(&lt;f-args&gt;)') 以上代碼定義了命令UBNew，customlist補全方式調用函數UBNewCmpl獲取補全的值域： 123456789101112131415161718192021222324252627function! UBNewCmpl(ArgLead, CmdLine, CursorPos) let lst = split(a:CmdLine) if len(a:ArgLead)&gt;0 let lst = lst[0:-2] endif let results = [] \" For the first argument, complete the object type if len(lst)==1 let objects = ['post','page','tmpl'] for obj in objects if stridx(obj,a:ArgLead)==0 call add(results,obj) endif endfor \" For the second argument, complete the syntax for :UBNew post or :UBNew \" page elseif len(lst)==2 &amp;&amp; count(['post', 'page'], lst[1])==1 let syntaxes = ['markdown','html','rst','textile','latex'] for synx in syntaxes if stridx(synx,a:ArgLead)==0 call add(results,synx) endif endfor endif return resultsendfunction 這時侯，前面提到的三個參數就派上用場了。ArgLead是進行補全時，已輸入的參數部分，例如輸入:UBNew p，然後按Tab鍵，則ArgLead的值就是“p”；CmdLine是已經輸入的命令的全部，按上例，這個參數的值就是“UBNew p”；CursorPost是當前光標距離命令行開頭的字符數。利用這三個參數，就可以判斷正在補全命令的第幾個參數，進而利用ArgLead篩選該參數的值域。 與custom調用的函數不同，customlist調用的函數的返回值應該是一個list類型的值。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"聚合個人資訊","slug":"burn-personal-info-into-one-feed-using-yahoo-pipes","date":"2011-06-07T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/burn-personal-info-into-one-feed-using-yahoo-pipes/","link":"","permalink":"http://0x3f.org/post/burn-personal-info-into-one-feed-using-yahoo-pipes/","excerpt":"","text":"前段時間我把Twitter整合進博客之後，忽然覺得，既然微博已經很重要了，就應該加強它的地位，使其與博客分庭抗禮。于是開始用blueprint做CSS框架，對兩三年沒變過的iterse做一些調整。 我對前端不太熟悉，這時候CSS框架的優越性就充分體現出來了，它讓頁面的布局變得相當容易，尤其是對前端設計最煩人的對多浏覽器的兼容問題。現在的主題采用流行的950px寬度，比以前800px要寬裕了不少。其中，三分之一的寬度分給側邊欄，剩餘部分留給博客文章列表，仍然采用兩欄結構。 我在頁面頂部加了頂欄，将原來側邊欄中的分類、歸檔、頁面、搜索框、RSS訂閱全部扔到裏面。同時提升Twitter和最新評論列表的位置，增加它們顯示條目的數量，以加強這兩個時效性和互動性比較強的欄目。 然後我覺得資訊訂閱中的内容也不應該再僅僅局限于博客文章了，應該把我在用的Twitter、豆瓣、Google Reader分享、PicasaWeb等服務中我的資訊也聚合進來。開始的時候打算用Yahoo! Pipes，後來突然發現FriendFeed就可以做這個事，而且更好用，于是将原來燒錄的http://feeds.feedburner.com/leninlee指向FriendFeed。 所以對于訂閱原來的FeedBurner燒錄的feed的讀者，如果希望仍然隻訂閱博客文章，可以訂閱http://feeds.feedburner.com/sinolog。這兩個feed都放到了頂欄中，請以各種姿態翻牆訂閱。 2011-06-08 更新 時隔一天，我認識到一個錯誤，FriendFeed畢竟還是一個微博，用它聚合個人資訊是不合適的，比如不能全文輸出博客文章。最終還是使用Yahoo! Pipes，這貨很強大、很好用。 另外，twitter2rss是支持OAuth的Twitter燒錄服務，非常好用。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"日志","slug":"日志","permalink":"http://0x3f.org/tags/日志/"},{"name":"牧碼志","slug":"牧碼志","permalink":"http://0x3f.org/tags/牧碼志/"}]},{"title":"人性化Vim的預覽窗口","slug":"humanize-preview-window-in-vim","date":"2011-05-28T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/humanize-preview-window-in-vim/","link":"","permalink":"http://0x3f.org/post/humanize-preview-window-in-vim/","excerpt":"","text":"Vim的預覽窗口由:ptag等命令觸發，可用于預覽函數定義。但在缺省情況下，預覽窗口的高度是固定的，對于注釋信息較多的函數，往往不能完全顯示注釋，而對于注釋較少的函數，又會有多餘的行浪費屏幕空間。 下面的函數用于解決這個問題： 123456789101112131415161718192021222324252627282930313233343536373839\" 調用:ptag命令預覽光標所在&lt;word&gt;的定義\" 對類C語言風格的函數/方法定義和注釋有效，對其餘情況仍沿用:ptag的原有效果function! PTagIt() exec \"ptag \".expand(\"&lt;cword&gt;\") let cwin = winnr() silent! wincmd P let lnr = line('.') if lnr &lt; 3 return endif if foldlevel('.')&gt;0 normal zo endif let chead = 0 let linestr = getline(lnr-1) if linestr =~ '^\\s*\\*/' let ptr = lnr-2 while ptr&gt;0 let linestr = getline(ptr) if linestr =~ '^\\s*/\\*' let chead = ptr break endif let ptr = ptr-1 endwhile endif if chead&gt;0 exec 'resize '.(lnr-chead+1) exec 'normal '.chead.\"z\\&lt;CR&gt;\" exec 'normal '.lnr.'G' endif exec cwin.'wincmd w' endfunctionnmap &lt;leader&gt;pp :call PTagIt()&lt;CR&gt;nmap &lt;leader&gt;pc :pclose&lt;CR&gt; 例如對于如下的函數定義： 1234567/* * 我是一個測試函數 * @param int 我是整型形參 * @param string 我是字符串形參 * @param array 我是返回值 */function foo($bar1, $bar2) &#123;...&#125; 實際效果為打開的預覽窗口將完全顯示并只顯示以上內容。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"ack: grep的同类替代品","slug":"use-ack-as-an-alternative-to-grep","date":"2011-05-08T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/use-ack-as-an-alternative-to-grep/","link":"","permalink":"http://0x3f.org/post/use-ack-as-an-alternative-to-grep/","excerpt":"","text":"ack是一個perl腳本，是grep的一個可選替換。 有以下優勢： 為程序員設計，使用方便，輸入較少 默認遞歸搜索 缺省提供多種文件類型供選，文件類型對應的後綴名可修改 使用perl的正則表達式，而grep只支持其一個子集 搜索結果高亮輸出 很多人以訛傳訛，使人容易對ack的搜索速度產生誤解。ack的官方宣傳中說比grep快，其前提是ack可方便地針對部分後綴的文件進行搜索，而grep默認對所有文件搜索。ack的官方文檔中明確指出，在對大量文件進行搜索時，grep的速度還是最快的。 ~/.ackrc 使用此配置文件存儲ack的常用選項。 -i --type-add php=.lib 如上所示，該文件中每一行應該是ack命令行參數中用空格分隔的一個部分。 例子 如果搜索的關鍵詞是正則表達式，在Linux下必須將其用雙引號包圍起來。 如： 1ack \"gbldb\\s*=\" Windows下的安裝 安裝strawberryperl 保存ack.pl到C:\\bin 創建批處理文件C:\\bin\\ack.bat：12@echo offperl.exe c:/bin/ack.pl %* 將C:\\bin加入環境變量%PATH% 資源 ack.vim: Vim使用ack的輔助擴展 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"grep","slug":"grep","permalink":"http://0x3f.org/tags/grep/"},{"name":"搜索","slug":"搜索","permalink":"http://0x3f.org/tags/搜索/"}]},{"title":"讀完《Nginx HTTP Server》","slug":"after-reading-nginx-http-server","date":"2011-04-28T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-nginx-http-server/","link":"","permalink":"http://0x3f.org/post/after-reading-nginx-http-server/","excerpt":"","text":"昨天晚上在杭州飛北京的飛機上讀完了這本書，用Kindle DXG。 作者是江蘇科技大學的一位外籍老師，所以這本書也很有教科書的風格，先用一章的篇幅介紹Linux的相關概念和日常操作，而後通過和Apache的對比講述了Nginx的主要特性，并使用Wordpress、MediaWiki等作了實例講解。面面俱到，簡單易懂，但并不深入。 目前介紹Nginx的書還不多，這本算得上是其中很好的一本。但是前六十頁都是介紹Linux的基本概念，和後面的內容關系不大，顯得很突兀，且很不KISS，對于一本只有三百多頁的小書來說，這個篇幅很令人遐想。拋開這一點，這本書當屬眼下入門Nginx的優秀指南。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"服務器","slug":"服務器","permalink":"http://0x3f.org/tags/服務器/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"},{"name":"Web","slug":"web","permalink":"http://0x3f.org/tags/web/"},{"name":"Apache","slug":"apache","permalink":"http://0x3f.org/tags/apache/"},{"name":"Nginx","slug":"nginx","permalink":"http://0x3f.org/tags/nginx/"}]},{"title":"PHP序列化方案效率比較","slug":"comparison-of-serialization-methods-of-php","date":"2011-04-16T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/comparison-of-serialization-methods-of-php/","link":"","permalink":"http://0x3f.org/post/comparison-of-serialization-methods-of-php/","excerpt":"","text":"同時對以下幾種PHP的序列化方案進行了測試： serialize() and unserialize() json_encode() and json_decode() msgpack_serialize() and msgpack_unserialize() igbinary_serialize() and igbinary_unserialize() 測試環境： OS: Archlinux 32-bit CPU: CORE 2 DUO T9400, 2.53GHz Mem: DDR3, 3G Server: nginx v1.0.0 PHP: php v5.3.6 + php-fpm Profiler: xhprof v0.9.2 測試代碼塊： 123456789101112131415161718192021222324252627282930313233&lt;?phpclass Test&#123; function __construct()&#123; $this-&gt;value = str_repeat('a', 1000); &#125;&#125;function produce($num)&#123; $arr = array(); for ($i = 0; $i &lt; $num; $i++) &#123; $arr[] = new Test(); &#125; $data = serialize($arr); $arr = unserialize($data); $data = json_encode($arr); $arr = json_decode($data); $data = msgpack_serialize($arr); $arr = msgpack_unserialize($data); $data = igbinary_serialize($arr); $arr = igbinary_unserialize($data);&#125;produce(10000);?&gt; 測試結果： 序列化性能：serialize() 24.611ms &gt; msgpack_serialize() 32.687ms &gt; igbinary_serialize() 36.012ms &gt; json_encode() 132.142ms 反序列化性能：igbinary_unserialize() 12.141ms &gt; msgpack_unserialize() 17.185ms &gt; unserialize() 28.723ms &gt; json_decode() 183.141ms 綜合性能：igbinary 48.153ms &gt; msgpack 49.872ms &gt; serialize 53.334ms &gt; json 315.283ms 測試結果并沒有像傳說中的那樣，官方的序列化和反序列化函數性能與msgpack和igbinary兩個第三方的擴展相差不大，而JSON性能非常差。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"}]},{"title":"UltraBlog.vim開發手記","slug":"ultrablog-development-note","date":"2011-04-10T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ultrablog-development-note/","link":"","permalink":"http://0x3f.org/post/ultrablog-development-note/","excerpt":"","text":"對于博客已死的說法，我一點都不感到奇怪。早在幾年前博客還比較火的時候我就表達過對博客泡沫的看法。 經歷了短暫的tumblog的風頭，微博成為現在最火的媒介。說博客已死，無非就是說微博將成為個人信息傳播的主流。好吧，現在我知道那時候我所說的不懂什麽是博客的人都去幹什麽了。 但是博客還是會繼續發展，微博的興起只會減少濫竽充數。因為微博突出的是時效性，最缺乏的是系統性和可重復更新的能力。微博的短處，正是博客的長處。這讓我對博客有了一個新的、遲到了很久的認識──一個好的博客，它的文章不應該是寫掉就忘的，而應該是不斷地更新著的。 UltraBlog.vim就是出于這個需要而寫的。 我對博客客戶端的使用大概可以追溯到四五年前，那時候博客正火，在比較了幾個BSP後選擇了中國博客網，就是因為他們提供桌面客戶端。後來獨博之後也試用過幾個通用的客戶端，但都沒堅持多久，最根本的原因是它們幾乎無一例外地都是WYSIWYG。而WYSIWYG的編輯器生成的HTML源碼幾乎都使用inline的樣式，這就導致文章的排版布局很難控制，我對WYSIWYG其實是很抵觸的，至今都不怎麽用Office這類東西。 後來我意識到，我所需要的是樣式與內容分離，于是準備自己寫一個客戶端，後來由于工作的原因不了了之。與此同時，我自定義了一套文章格式并用Java寫了一個轉換文章到HTML的工具，直到後來發現Markdown，我才知道我其實是需要一個輕量标記語言。 使用Markdown之後，寫博客開始變得輕松愉快。我一度用過一段時間SciTE，還用Lua寫了個輔助腳本。但是我需要一個完整的客戶端來管理文章，而這是一個編輯器所不能勝任的，所以就著手實現一個支持Markdown的客戶端。這一次走得比較遠，ForeverFantasy最終達到了可用的程度，我一度用它寫過一段時間的博客。但是作為一個Vim重症患者，wxPython的編輯器部件是遠遠達不到我需要的水平的。雖然後來還實現了調用外部程序處理文章內容（當然也可以調用Vim），但總歸覺得不舒服，至今已經一年沒更新了。 直到前段時間試用了一下VimRepress，在修改這個插件的時候突然受到啟發，我這幾年的需求原來是可以這麽簡單地解決的。 其實在幾年前vimpress剛剛發布的時候我就了解過這個東西，包括此後接連發布的幾個Vim寫博客的插件，它們和我原來寫的SciTE的那個輔助腳本沒有本質的區別，都是博客編輯器。與完整的客戶端相比，編輯器缺少對本地文章源碼的管理，而且它們不記錄文章源碼和發布的文章的關聯關系，簡單地說是無狀態的。這不符合博客文章持續更新的觀點。 UltraBlog.vim使用SQLAlchemy做數據庫抽象層，將所有文章的源碼及其狀態保存在本地的一個SQLite數據庫中，并且以此為基礎，通過XMLRPC接口實現對博客文章、頁面的CRUD操作。同時利用Vim分模式的特點實現了可分頁的文章列表和文章編輯視圖。 UltraBlog.vim目前支持Markdown和HTML兩種格式的文章，它最大的特點是在Markdown格式的源碼和發布到博客中的文章之間建立聯系，你可以隨時修改本地數據庫中的Markdown源碼并更新博客中對應的文章。 新的功能還會不斷地加入。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"SQLAlchemy","slug":"sqlalchemy","permalink":"http://0x3f.org/tags/sqlalchemy/"},{"name":"Markdown","slug":"markdown","permalink":"http://0x3f.org/tags/markdown/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"SQLite","slug":"sqlite","permalink":"http://0x3f.org/tags/sqlite/"},{"name":"UltraBlog.vim","slug":"ultrablog-vim","permalink":"http://0x3f.org/tags/ultrablog-vim/"}]},{"title":"GNOME 3 Launch Party","slug":"gnome3-launch-party","date":"2011-04-08T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/gnome3-launch-party/","link":"","permalink":"http://0x3f.org/post/gnome3-launch-party/","excerpt":"","text":"在保福寺橋南下了車我就迷失了，作為一個G7er，問路太跌份，于是自信滿滿地祭出G7，結果Google導航很淡定地告訴我──您所在的區域不支持導航！有木有搞錯，有木有，有木有，有木有啊！最後在3G、GPS、電子指南針全開的情況下，跟著Google地圖上的小箭頭在中關村南街、中關村三街流竄了半個小時，後來我才知道，我規則地繞中科院研究生院做了一次順時針圓周運動。 好吧，我最後還是人肉到目的地的，感謝給我指路的朋友，他讓我終于找到了那條隱藏地很深的小路，你敢隱藏得再深一點嗎？！ 有時侯這個世界真的很給力，當我比原定時間晚半個多鐘頭到達會場的時候，他們居然還沒有開始！ 愛美麗宣布開會： 程大龍介紹GNOME 3： 這小哥兒原來是北航的，後生可畏啊，當初我開始玩兒Linux的時候他剛脫離李雷和韓梅梅吧。 來一張火爆的： 今天最意外的亮點就是這個什麽××××協會的西班牙舞了，開始、中間和結束的時候各來了一段，俺們紅小兵也看不懂，就是感覺很勁爆，反正只要是不規則的事物我都喜歡。 其它的，兩岸三地的視頻會議很失敗，搞個高速VPN不行嗎？瞻仰了傳說中的Vincent，小哥兒比我還胖，我很欣慰。在Twitter上看到了林健桑拍的熱舞照片，感覺他坐得離我不遠，把坐我前面的都遍歷了一遍卻沒找到，誰知道居然在我後面。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"GNOME","slug":"gnome","permalink":"http://0x3f.org/tags/gnome/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"日志","slug":"日志","permalink":"http://0x3f.org/tags/日志/"},{"name":"桌面環境","slug":"桌面環境","permalink":"http://0x3f.org/tags/桌面環境/"}]},{"title":"Navicat: 輕量的多數據庫客戶端","slug":"navicat-a-light-weight-database-client","date":"2011-04-05T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/navicat-a-light-weight-database-client/","link":"","permalink":"http://0x3f.org/post/navicat-a-light-weight-database-client/","excerpt":"","text":"Navicat是一套商業軟件，但是它的免費版Navicat Lite已足夠好用。作為一套數據庫客戶端，它具有以下特性： 支持Microsoft SQL Server、Oracle、MySQL、PostgreSQL、SQLite五個最常見的關系數據庫。 占用系統資源少，輕便快捷 功能較為全面，使用方便 跨平台 我使用Navicat完成一般的數據庫操作，這樣可以無須在多種數據庫的官方客戶端之間來回切換，而且對于速度不快的機器來說，Navicat輕量的優勢是很明顯的。 Navicat另外一個為人所忽略的優點是對SQLite的支持，我曾花不少時間找一個好的SQLite的客戶端，大部分搜索結果都介紹的是另外一個Sqliteman，但是我始終不能習慣它，感覺這個東西功能少而且不好用。直到發現Navicat，才算找到一個完善的SQLite客戶端。 對于跨平台的特性，Navicat對Linux平台的支持其實是通過wine實現的，好在其安裝包對wine已做過定制，運行狀況良好。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"數據庫","slug":"數據庫","permalink":"http://0x3f.org/tags/數據庫/"}]},{"title":"從iG:Syntax Hiliter轉換到WP-Syntax","slug":"migrate-from-igsyntax-hiliter-to-wp-syntax","date":"2011-04-05T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/migrate-from-igsyntax-hiliter-to-wp-syntax/","link":"","permalink":"http://0x3f.org/post/migrate-from-igsyntax-hiliter-to-wp-syntax/","excerpt":"","text":"終于決定放棄使用了三年多的iG:Syntax Hiliter，將代碼語法高亮插件換成WP-Syntax。 原因是Vim的Markdown語法高亮插件有問題，會把iG的標簽[LANG]當作Markdown的超鏈接處理，結果導致插入代碼後，後面的內容被錯誤地著色，很難看。而Syntax使用&lt;pre lang=\"LANG\"&gt;格式的標簽，不會有這個問題。 其實很早就想過要換了，只是受累于使用iG進行高亮的文章太多，替換起來不方便。加上後來解決了由于iG停止更新導致的不支持更多的語法的問題，所以就一致拖到現在。今天晚上花了一個小時就完成了替換，比想象中的要容易地多。 根據我使用過的語法的情況，使用以下語句在數據庫中替換iG的標簽到Syntax的標簽： 123456789101112131415161718192021222324252627282930313233343536update wp_posts set post_content=replace(post_content,'[bash]','&amp;lt;pre lang=\"bash\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/bash]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[python]','&amp;lt;pre lang=\"python\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/python]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[vim]','&amp;lt;pre lang=\"vim\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/vim]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[java]','&amp;lt;pre lang=\"java\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/java]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[lua]','&amp;lt;pre lang=\"lua\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/lua]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[sql]','&amp;lt;pre lang=\"sql\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/sql]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[plsql]','&amp;lt;pre lang=\"plsql\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/plsql]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[php]','&amp;lt;pre lang=\"php\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/php]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[cpp]','&amp;lt;pre lang=\"cpp\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/cpp]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[inno]','&amp;lt;pre lang=\"inno\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/inno]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[xml]','&amp;lt;pre lang=\"xml\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/xml]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[html]','&amp;lt;pre lang=\"html4strict\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/html]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[ini]','&amp;lt;pre lang=\"ini\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/ini]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[pascal]','&amp;lt;pre lang=\"pascal\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/pascal]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[javascript]','&amp;lt;pre lang=\"javascript\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/javascript]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[reg]','&amp;lt;pre lang=\"reg\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/reg]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'[css]','&amp;lt;pre lang=\"css\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'[/css]','&amp;lt;/pre&amp;gt;');update wp_posts set post_content=replace(post_content,'&amp;lt;coolcode LANG=\"php\"&amp;gt;','&amp;lt;pre lang=\"php\" line=\"1\"&amp;gt;');update wp_posts set post_content=replace(post_content,'&amp;lt;/coolcode&amp;gt;','&amp;lt;/pre&amp;gt;'); 即便轉換到Syntax，也不能避免Vim中Markdown語法高亮的問題，只要文字中出現成對的方括號，仍然會出問題，正確的做法是對HTML標簽中的內容不進行Markdown語法的著色。 在轉換和寫這篇文章的過程中，發現WP-Syntax還存在一些問題，例如啟用行號後部分表格不能充滿頁面寬度的問題，還有上面這些SQL語句，必須將其中的尖括號替換成HTML實體才能正常顯示。看來雖然歷經兩三年的發展，WP-Syntax還是不很成熟。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"WordPress","slug":"wordpress","permalink":"http://0x3f.org/tags/wordpress/"},{"name":"日志","slug":"日志","permalink":"http://0x3f.org/tags/日志/"},{"name":"牧碼志","slug":"牧碼志","permalink":"http://0x3f.org/tags/牧碼志/"}]},{"title":"在非GNOME環境中使用TweetDeck","slug":"howto-use-tweetdeck-out-of-gnome","date":"2011-04-04T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-use-tweetdeck-out-of-gnome/","link":"","permalink":"http://0x3f.org/post/howto-use-tweetdeck-out-of-gnome/","excerpt":"","text":"在非GNOME桌面環境中，運行TweetDeck會報如下錯誤： Ooops, TweetDeck can't find your data TweetDeck is having trouble using some of your passwords that are stored securely on your machine. Clicking submit will clear this data so that you continue to use TweetDeck. 原因是Adobe Air將密碼保存在GNOME的Keyring裏，而此時Air找不到GNOME的相關守護進程gnome-keyring-daemon。 使用如下腳本啟動之： 123#!/bin/bashGNOME_KEYRING=`pidof gnome-keyring-daemon`GNOME_DESKTOP_SESSION_ID=$GNOME_KEYRING /usr/bin/tweetdeck &amp; Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"GNOME","slug":"gnome","permalink":"http://0x3f.org/tags/gnome/"},{"name":"XFCE","slug":"xfce","permalink":"http://0x3f.org/tags/xfce/"},{"name":"桌面環境","slug":"桌面環境","permalink":"http://0x3f.org/tags/桌面環境/"},{"name":"Twitter","slug":"twitter","permalink":"http://0x3f.org/tags/twitter/"}]},{"title":"Orta: 凸凹有致的GTK主題","slug":"orta-a-pretty-gtk-theme","date":"2011-04-04T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/orta-a-pretty-gtk-theme/","link":"","permalink":"http://0x3f.org/post/orta-a-pretty-gtk-theme/","excerpt":"","text":"如果說Orta最大的特點，就是凸凹有致。它的主要組件都突出了這個特點，加上對細節的表現很細致，整個主題給人以很舒服的感覺。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"美化","slug":"美化","permalink":"http://0x3f.org/tags/美化/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"GTK+","slug":"gtk","permalink":"http://0x3f.org/tags/gtk/"},{"name":"主題","slug":"主題","permalink":"http://0x3f.org/tags/主題/"}]},{"title":"UltraBlog.vim: Ultimate Vim Blogging Plugin","slug":"ultrablog-as-an-ultimate-vim-blogging-plugin","date":"2011-04-01T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ultrablog-as-an-ultimate-vim-blogging-plugin/","link":"","permalink":"http://0x3f.org/post/ultrablog-as-an-ultimate-vim-blogging-plugin/","excerpt":"","text":"Introduction UltraBlog.vim is yet another Vim blogging script for Wordpress. The biggest difference between UB and other similar scripts is that UB is an ultimate client, which stores posts locally in an SQLite database, while others just operate remotely. In this way, many things can be done easily by the advantage of local storage and many other utilities, for example, you can search for posts stored in the database with a few keywords by typing a simple command, also you can preview drafts with any of your favorite templates as soon as you want to. For those who just needs a lightweight blog editor similar as other Vim blogging scripts, UB also comes with an Editor Mode, which doesn’t create a database and store data in it. In addition, UB is tending to make life easier for writing posts with many kinds of lightweight markup languages, currently the following kinds are supported: Markdown, reStructuredText, LaTeX, Textile and of cause HTML. Enjoy Vim blogging ! Here is a post written in Chinese describing the motion for which I wrote UltraBlog.vim. Features Multiple syntax support: Markdown, HTML, reStructuredText, LaTeX, Textile. Editor mode and client mode. Data is stored in a local SQLite database in client mode. Full-text search with keywords highlighted. Full-text search by using regular expressions. Full-text substitutions. Full-text substitutions using regular expressions. Templates for previewing posts. Built-in web browser, much faster to preview items. Event-driven system. I18N. Tutorial Requirement UltraBlog.vim takes advantages from the following techs: Vim with python support SQLAlchemy v0.7 or newer python-markdown or python-markdown2 pandoc You must have these prerequisites met before using UltraBlog.vim. For more information, refer to UltraBlog_Prerequisites in the help file. Installation Download UltraBlog.vim from Vim.org or retrieve the latest source from Github: https://github.com/xbot/UltraBlog.vim Install UltraBlog.vim to your plugin folder and put the following lines in your vimrc file: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465let ub_blog = &#123;'login_name':'admin', \\'password':'pass2011', \\'url':'http://www.sample.com', \\'xmlrpc_uri':'xmlrpc.php', \\'db':'~/.vim/UltraBlog.db', \\'categories':'News|Computer|Image' \\&#125;\" Set this option to 1 if you want to enable debug mode, see :help ub_debug for more informationlet ub_debug = 0\" Set this option to 0 if you prefer using firefox or chromium to preview items.let ub_use_ubviewer = 1\" Default timeout period of xmlrpc operations, see :help ub_socket_timeout for more informationlet ub_socket_timeout = 10\" Default page size of local post list, see :help ub_local_pagesize for more informationlet ub_local_pagesize = 30\" Default page size of remote post list, see :help ub_remote_pagesize for more informationlet ub_remote_pagesize = 15\" Default page size of search result list, see :help ub_search_pagesize for more informationlet ub_search_pagesize = 30\" Proudly show your visitors that you are blogging with the world's most powerful editorlet ub_append_promotion_link = 1\" Set width of the local id column in post or page listslet ub_list_col1_width = 7\" Set width of the remote id column in post or page listslet ub_list_col2_width = 8\" Set width of the status column in post or page listslet ub_list_col3_width = 11\" Set this value to 1 if you want to use editor mode.let ub_editor_mode = 0\" Set this value to 1 if you want to save posts/pages immediately after they are fetched from the blog.let ub_save_after_opened = 0\" Set this value to 0 if you do not want to save posts/pages immediately after they are sent to the blog.let ub_save_after_sent = 1\" Set the following options to use a custom extenal command as the converter.let ub_converter_command = 'pandoc'let ub_converter_options = ['--reference-links']let ub_converter_option_from = '--from=%s'let ub_converter_option_to = '--to=%s'\" Customize hotkeyslet ub_hotkey_open_item_in_current_view='&lt;enter&gt;'let ub_hotkey_open_item_in_splitted_view='&lt;s-enter&gt;'let ub_hotkey_open_item_in_tabbed_view='&lt;c-enter&gt;'let ub_hotkey_delete_item='&lt;del&gt;'let ub_hotkey_save_current_item='&lt;C-S&gt;'\" Set the link template string for images uploaded by :UBUploadlet ub_tmpl_img_url=\"markdown###![$(file)s][]\\n[$(file)s]:%(url)s\"\" Set the default template to use when previewing posts/pages locallylet ub_default_template=\"default\" Change values of the upper options to yours. Restart Vim and a database file will be created in the path you specified above. Concepts It is important to understand some basic concepts of UltraBlog.vim. Modes UltraBlog.vim makes life easier while writing or updating blogs. It stores posts/pages in a local SQLite database. You can also set it to editor mode, in which UltraBlog.vim does not store data locally, just like other Vim blogging scripts. By default, UltraBlog.vim is in client mode. You can set it to use editor mode by adding the fallowing line to the vimrc file: 1let ub_editor_mode = 1 Items Currently, UltraBlog.vim manages three items: post, page and tmpl. “tmpl” is the shorthand of “template”. Templates are used to preview the current post/page in the browser locally. This feature is a reparation for the remote previewing, due to the limit of the API, users cannot send a post to Wordpress as draft and preview it without affecting the post status if the post has been published. With templates, users can preview posts/pages directly in the browser in a pre-defined style. They can create as many templates as they like and customize the look with CSS and HTML, or even Javascript. Templates should be formatted as a valid python template string, that is, use the following avaliable placeholders and escape any literal ‘%’ with another ‘%’: %(title)s The title of the current post/page.%(content)s The content of the current post/page.%% A literal ‘%’. There is a default template in the database, whose name is ‘default’, which can be used as an example of template. Users can specify the default template to use with the option ub_default_template. Syntaxes The syntaxes supported by UltraBlog.vim currently are: markdown, html, rst, textile, latex. Statuses The available statuses are: publish, private, draft, pending. Scopes Scopes tells UltraBlog.vim to operate on items in which place, “local” stands for items stored in the database, and “remote” stands for the blog. Usage Create a new item :UBNew [item [syntax/template_name]] Create a new item. For the first parameter, refer to UltraBlog_Items. The default value is “post”. If “item” is either “post” or “page”, the second parameter must be a syntax name, refer to UltraBlog_Syntaxes. The default value is “markdown”. If “item” is “tmpl”, the second parameter should be the name of the new template. When the cursor is focused in the metadata line of categories, press to do auto-completion. This will use the data set by option ub_blog[‘categories’], if it is not set, categories will be fetched from your blog. Save a modified post :UBSave After executing this command, the current buffer is saved into database. Send a post to blog :UBSend [status] Post an item. If no parameter is given, UltraBlog.vim will send the item to blog and set it to be the value stored in the meta information area. Refer to UltraBlog_Statuses. List posts :UBList [item [scope [page_size [page_no]]]] List items. Refer to UltraBlog_Items for the first parameter. The default value of this parameter is “post”. The second parameter “scope” is only available when “item” is either “post” or “page”. Refer to UltraBlog_Scopes. “page_size” and “page_no” are both for the situation when “item” is “post” and “scope” is “local”. The former stands for how many item will be listed a page. The latter stands for the page number. For example: :UBList This command lists the first page of local posts, by default, posts which have not been posted to blog are listed before the posted ones, and there are ub_local_pagesize posts a page. :UBList post local 20 3 This command lists the third page of local posts, 20 posts a page. As you see, you can use this command to scroll forward or back between pages. As a matter of fact, there are two key mappings within local post list: CTRL+PageDown CTRL+PageUp :UBList post remote 50 This command lists the latest 50 posts in the blog. Pressing the ENTER key in a remote post list will open the post under cursor and save it to the local database if it is not in it, otherwise, the local copy will be opened instead of the remote one. This enables users to modify markdown source and update the remote post. The remote post list doesn’t support paging. Open a single post :UBOpen {item} {post_id/template_name} [scope] Open an item. For the first parameter, refer to UltraBlog_Items. If “item” is either “post” or “page”, the second parameter should be value of its id. If it’s “tmpl”, the name. For “scope”, refer to UltraBlog_Scopes. The default value is “local”. Upload a media :UBUpload {file_path} This command can only be executed in a post edit view, and the URL of the uploaed file will be appended in that buffer. Preview the changes :UBPreview [status/template name] Preview the content of the current buffer. If any of the UltraBlog_Statuses is given, the current buffer will be sent to the blog and then opened in the browser with a parameter “preview” appended to the URL. If the given parameter is not a post status, a pre-defined template whose name is the same with the parameter will be used to preview the buffer locally. If none is given, the default template is used. You do not have to care for which syntax you use, markdown source will be translated into html automatically before a browser window is opened to display it. The matter that whether to use the built-in web browser or the system default ones is controlled by the option ub_use_ubviewer. Delete a post/page :UBDel {item} {post_id/template_name} [scope] Delete an item. Refer to UBOpen for the usage of these options. You can also delete items in the list by pressing the DELETE button on the target. In a local post list, if the post to be deleted has been posted to the blog, a confirmation will be prompted for you to decide whether to delete the remote copy cascadly. Create a post/page using content of the current buffer :UBThis [item [to_syntax [from_syntax]]] Create a new post or page which is filled with content in the current buffer. If no parameter is specified, the first parameter will be default to “post”; for the second and the third one, the syntax of the current buffer is used. Content of the current buffer will be automatically converted from the from_syntax to the to_syntax. Convert a post/page buffer between the available syntaxes :UBConv {to_syntax} [from_syntax] Convert the current buffer from ‘from_syntax’ to ‘to_syntax’. Refer to UltraBlog_Syntaxes. If you only need to convert from Markdown to HTML, only python-markdown or python-markdown2 module is required. For other conversion scenarios, you must install pacdoc or use the options: ub_converter_command, ub_converter_options, ub_converter_option_from, ub_converter_option_to to specify a valid external command. Refresh the current buffer :UBRefresh Full-text search :UBFind keyword1 [keyword2 …] Doing full-text searches for both posts and pages by keywords, all keywords will be highlighted. Page size of the search result list is controlled by option ub_search_pagesize. :UBRegexSearch regexp1 [regexp2 …] Doing full-text searches for both posts and pages by regular expressions, all strings that match the regular expressions will be highlighted. Page size of the search result list is controlled by ub_search_pagesize. Full-text substitutions Attention: Full-text substitutions will change contents of all matched posts/pages immediately when executed. You may need to backup your database file first. :UBReplace needle replacement Do full-text substitutions. :UBRegexReplace regexp replacement Do full-text substitutions using regular expressions. Debug In debug mode, SQL statements being executed will be displayed and so are all stack traces of exceptions raised. :UBEnableDebug Enable debugging. :UBDisableDebug Disable debugging. :UBToggleDebug Toggle debugging status. Options For more detail information on tweaking UltraBlog.vim, refer to the documentation. Tips Install syntax files for any light weight markup language you use to highlight the posts/pages. Enable Code Snippet Highlighting For UltraBlog.vim Templates News 2014-04-20 v3.6.1 released. Changes 2012-04-30 v3.5.0 released. Changes 2012-04-29 v3.4.0 released. Changes 2012-04-15 v3.3.0 released. Changes 2012-01-05 v3.2.0 released. Changes 2011-11-01 v3.1.0 released. Changes 2011-07-24 v3.0.0 released. Changes 2011-06-15 v2.3.1 released. Changes 2011-06-10 v2.3.0 released. Changes 2011-05-30 v2.2.0 released. Changes 2011-05-28 v2.1.0 released. Changes 2011-05-12 v2.0.1 released. Changes 2011-04-14 v2.0.0 released. Changes 2011-04-12 v1.4.0 released. Changes 2011-04-09 v1.3.0 released. Changes 2011-04-07 v1.2.0 released. Changes 2011-04-05 v1.1.0 released. Changes 2011-04-04 v1.0.5 released. Changes 2011-04-02 v1.0.4 released. Changes 2011-04-02 v1.0.3 released. Changes 2011-04-02 v1.0.2 released. Changes 2011-04-01 v1.0.1 released. Changes 2011-04-01 v1.0.0 released. Changes Posted via UltraBlog.vim.","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"SQLAlchemy","slug":"sqlalchemy","permalink":"http://0x3f.org/tags/sqlalchemy/"},{"name":"Markdown","slug":"markdown","permalink":"http://0x3f.org/tags/markdown/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"SQLite","slug":"sqlite","permalink":"http://0x3f.org/tags/sqlite/"},{"name":"UltraBlog.vim","slug":"ultrablog-vim","permalink":"http://0x3f.org/tags/ultrablog-vim/"}]},{"title":"Soothe: 柔和細致的GTK主題","slug":"gtk-theme-soothe","date":"2011-04-01T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/gtk-theme-soothe/","link":"","permalink":"http://0x3f.org/post/gtk-theme-soothe/","excerpt":"","text":"Soothe給人的感覺是細致而且柔和，不易于產生視覺疲勞，這正對我的胃口。更完美的是，它支持虛線焦點框，對于喜歡使用鍵盤的Rox-filer重症患者來說很重要。 Posted via UltraBlog.vim.","categories":[],"tags":[{"name":"美化","slug":"美化","permalink":"http://0x3f.org/tags/美化/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"GTK+","slug":"gtk","permalink":"http://0x3f.org/tags/gtk/"},{"name":"主題","slug":"主題","permalink":"http://0x3f.org/tags/主題/"}]},{"title":"解決gVim白邊問題的偽方法","slug":"the-fake-way-to-fix-white-gap-of-gvim","date":"2011-03-20T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/the-fake-way-to-fix-white-gap-of-gvim/","link":"","permalink":"http://0x3f.org/post/the-fake-way-to-fix-white-gap-of-gvim/","excerpt":"","text":"gVim的窗口大小與行數、列數、字體寬度等都有關系，并不像一般的圖形界面一樣可以完全地最大化或全屏，如果幾個因素組合後與屏幕分辨率不符合，就會在屏幕的左邊和底部出現灰色的白邊。 這是gVim非常著名的一個問題，它使最大化的gVim窗口顯得非常難看。目前僅有一種變通的解決方法，就是把白邊部分的顏色設置成和gVim主題背景色一致的顏色： 12345# 修改~/.gtkrc-2.0，加入如下內容：style \"vimfix\" &#123; bg[NORMAL] = \"#DBDBD2\" # this matches my gvim theme 'Normal' bg color.&#125;widget \"vim-main-window.*GtkForm\" style \"vimfix\" 由于并非真正地去掉白邊，所以只能算是個偽方法。 Windows下的方法見這裡。","categories":[],"tags":[{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"}]},{"title":"Batch Cat v0.3 Released","slug":"batchcat-v03-released","date":"2011-03-19T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/batchcat-v03-released/","link":"","permalink":"http://0x3f.org/post/batchcat-v03-released/","excerpt":"","text":"Change Log 2011-03-20 Sunday Solve the compatibility problem under Wordpress 3.1, thanks to wongkediri. Check the plugin’s page for more information.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"WordPress","slug":"wordpress","permalink":"http://0x3f.org/tags/wordpress/"}]},{"title":"修改Vimball默認安裝路徑","slug":"howto-set-the-default-vimball-install-path","date":"2011-03-18T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-set-the-default-vimball-install-path/","link":"","permalink":"http://0x3f.org/post/howto-set-the-default-vimball-install-path/","excerpt":"","text":"在Windows下，我希望把vba文件安裝到$VIM/vimfiles目錄下，而不是用戶主目錄中。 Vim在安裝vba文件時默認從$VIMRUNTIME中取出第一個路徑作為安裝路徑，使用如下命令查看當前設置： 1:echo &amp;rtp 在Windows下，Vim默認將用戶主目錄放在了$VIMRUNTIME的第一個，因此才會將vba安裝到用戶主目錄。 修改方法為在vimrc中加入如下設置： 1set rtp-=$HOME/vimfiles","categories":[],"tags":[{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"}]},{"title":"使用Vim寫博客","slug":"blogging-with-vim","date":"2011-03-18T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/blogging-with-vim/","link":"","permalink":"http://0x3f.org/post/blogging-with-vim/","excerpt":"","text":"VimRepress是Vim寫博客的插件中較新的一個，是久未更新的Vimpress的一個衍生版。 雖然不是所有此類插件中功能最多的一個，但VimRepress非常實用，除包含最常用的幾個功能外，還支持Markdown。但是當前版本的VimRepress在轉換Markdown格式的字符串到HTML時，是通過直接調用外部命令markdown來實現的，這顯然只是針對Linux（及其它類UNIX）系統設計的。 為了使VimRepress支持在Windows下使用Markdown寫文章，可以對它做一些改進。 修改VimRepress的源文件blog.vim，在if __name__ == \"__main__\":這一行的上方加入如下兩個函數： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def markdown_preview2(): import sys reload(sys) sys.setdefaultencoding('utf-8') import markdown2 as mkd global vimpress_temp_dir if vimpress_temp_dir == '': vimpress_temp_dir = tempfile.mkdtemp(suffix=\"vimpress\") temp_htm = os.path.join(vimpress_temp_dir, \"vimpress_temp.htm\") html_heads = \\\"\"\"&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;/head&gt;&lt;body&gt;\"\"\" tmp_file = open(temp_htm, 'w') tmp_file.write(html_heads) txt = \"\\n\".join(vim.current.buffer[:]) #txt = unicode(txt,'cp936') tmp_file.write(mkd.markdown(txt)) #tmp_file.write(mkd.markdown(\"\\n\".join(vim.current.buffer[:]))) tmp_file.close() webbrowser.open(\"file://%s\" % temp_htm)def markdown_newpost2(): import sys reload(sys) sys.setdefaultencoding('utf-8') import markdown2 as mkd global vimpress_temp_dir if vimpress_temp_dir == '': vimpress_temp_dir = tempfile.mkdtemp(suffix=\"vimpress\") temp_htm = os.path.join(vimpress_temp_dir, \"vimpress_post.htm\") title = \"\" title_s = 0 try: while title_s &lt; 10: if vim.current.buffer[title_s].startswith(\"#\"): title = vim.current.buffer[title_s].strip('#') break title_s += 1 except IndexError: pass cur_file = vim.eval('expand(\"%:p\")') if cur_file is None: cur_file = os.path.join(vimpress_temp_dir, \"tmp_vimpress.mkd\") sys.stdout.write(\"\\n\\nCurrent buffer saved to %s\\n\\n\" % cur_file) vim.command(\":w! %s\" % cur_file) tmp_file = open(temp_htm, 'w') tmp_file.write(mkd.markdown(\"\\n\".join(vim.current.buffer[:]))) tmp_file.close() sys.stdout.write(\"Press ENTER to continue.\") vim.command(\":bdelete\") vim.command(\":r %s\" % temp_htm) blog_new_post(title = title) 這兩個函數修改自原有的markdownpreview()和markdownnewpost()，由調用外部的markdown命令改為調用Python的markdown2模塊來實現格式轉換。 然後，修改blog.vim中的命令映射，使VimRepress的:MarkDownPreview和:MarkDownNewPost命令在Windows下自動調用上述兩個函數： 1234567if has(\"win32\") command! -nargs=0 MarkDownPreview exec('py markdown_preview2()') command! -nargs=0 MarkDownNewPost exec('py markdown_newpost2()')else command! -nargs=0 MarkDownPreview exec('py markdown_preview()') command! -nargs=0 MarkDownNewPost exec('py markdown_newpost()')endif 最後，只須安裝Python的markdown2模塊就可以用了。 2011-03-23更新： pentie已合并這些功能到新版本的VimRepress。 2011-04-04更新： 作為Markdown寫博的重度患者，我覺得Vim的其它相關插件都缺乏對Markdown源碼的有效管理，所以我幹脆寫了個新的插件UltraBlog。","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"}]},{"title":"Dumperor v1.0.0 Released","slug":"dumperor-v100-released","date":"2011-03-14T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/dumperor-v100-released/","link":"","permalink":"http://0x3f.org/post/dumperor-v100-released/","excerpt":"","text":"Changelog 2011-03-14 Now Dumperor is stable enough. Add the abillity to export table structures or data to a human readable format, which is suit for comparing. Add the abillity to manage multiple configurations. Add a desktop application to sort the human readable output file of table structures, written in python and tk. Check the main page for more information.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"SQL","slug":"sql","permalink":"http://0x3f.org/tags/sql/"},{"name":"Database","slug":"database","permalink":"http://0x3f.org/tags/database/"},{"name":"Dumperor","slug":"dumperor","permalink":"http://0x3f.org/tags/dumperor/"}]},{"title":"刷了Oxygen v2.0.1","slug":"flashed-oxygen-v201","date":"2011-03-05T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/flashed-oxygen-v201/","link":"","permalink":"http://0x3f.org/post/flashed-oxygen-v201/","excerpt":"","text":"上周Oxygen v2.0發布之後，感覺還不穩定，忍住了。前兩天終于刷上了剛發布的Oxygen v2.0.1。 事先直接做了一次完整的wipe，刷完後沒發現XDA上亂七八糟的問題。用了兩天，除了UI的變化，沒看出來跟以前版本有什麽不同，只是仍未實現軌跡球喚醒這點很遺憾。","categories":[],"tags":[{"name":"桌面日记","slug":"桌面日记","permalink":"http://0x3f.org/tags/桌面日记/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"Google","slug":"google","permalink":"http://0x3f.org/tags/google/"},{"name":"Android","slug":"android","permalink":"http://0x3f.org/tags/android/"},{"name":"Desire","slug":"desire","permalink":"http://0x3f.org/tags/desire/"},{"name":"Oxygen","slug":"oxygen","permalink":"http://0x3f.org/tags/oxygen/"}]},{"title":"好貴的套啊","slug":"expensive-kindle-cover","date":"2011-02-27T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/expensive-kindle-cover/","link":"","permalink":"http://0x3f.org/post/expensive-kindle-cover/","excerpt":"","text":"把淘寶上價格比較靠譜的幾家問了個遍，都沒有貨，估計都是因為價格高，只代購，不存貨。最後還是在買Kindle的店等了好幾天才搞到了原裝黑色皮套，雖然相對已經算是低價，還是十分地肉疼。 無圖無真相：","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"日志","slug":"日志","permalink":"http://0x3f.org/tags/日志/"},{"name":"Kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"}]},{"title":"Anti Artificial Spam v0.2 Released","slug":"anti-artificial-spam-v02-released","date":"2011-02-23T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/anti-artificial-spam-v02-released/","link":"","permalink":"http://0x3f.org/post/anti-artificial-spam-v02-released/","excerpt":"","text":"Change Log 2011-02-23 Wednesday 22:24:12 Rename anti-manpower-spam to anti-artificial-spam. Don’t just test if the URL is in the banned ones, but also test if it is a substring of one of them. Optimize the speed of matching. Check the plugin’s page for more information.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"WordPress","slug":"wordpress","permalink":"http://0x3f.org/tags/wordpress/"},{"name":"spam","slug":"spam","permalink":"http://0x3f.org/tags/spam/"}]},{"title":"初入Kindle DX Graphite","slug":"got-kindle-dxg","date":"2011-02-19T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/got-kindle-dxg/","link":"","permalink":"http://0x3f.org/post/got-kindle-dxg/","excerpt":"","text":"垂涎已久，昨天終於出手，今天上午就收到了。 把玩了一下自帶的系統，用免費的3G網絡看Wikipedia，體驗不錯。中文文件名不能顯示，嵌入了中文字體的PDF可以正常顯示。買DXG的目的就是為了看計算機類的英文PDF和繁體豎排的掃描版的古籍PDF，所以不折騰，直接裝多看系統。 多看果然給力，全中文界面，中文輸入法，中文TTS語音朗讀，而且支持MP3播放、圖片瀏覽和包括chm、epub在內的多種電子書格式。因為暫時用不上，所以先不深究。連到Arch傳PDF，直接自動掛載並彈出Nautilus，沒想到對Linux如此友好！ 貼了膜，所以有反光，但是只要沒有燈光直射，大角度效果依然良好： 來個微距： 以上圖片出自G7+Camera360，光線不好，馬馬虎虎。 缺點。一是不支持觸摸操控，加上官方系統古板、笨拙，做一些高級操作是很費力的，好在多看系統在這一點上做得很好。二是PDF翻頁的時候速度確實比較慢，還要閃一下屏，不過還可以接受。多看系統也不完美，最要命的是不支持3G網絡，要使用3G網絡還得切換到官方系統中；另外就是不支持重力感應，文檔方向需要手工設置。 齊活了，從此不用再擔心長時間在電腦上看OReilly累眼了，也不用發愁中華書局的掃描版史書沒法看了。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"kindle","slug":"kindle","permalink":"http://0x3f.org/tags/kindle/"},{"name":"玩物","slug":"玩物","permalink":"http://0x3f.org/tags/玩物/"},{"name":"數碼","slug":"數碼","permalink":"http://0x3f.org/tags/數碼/"}]},{"title":"精美的圖標主題：Faenza","slug":"icon-theme-faenza","date":"2011-02-18T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/icon-theme-faenza/","link":"","permalink":"http://0x3f.org/post/icon-theme-faenza/","excerpt":"","text":"Faenza Icons Theme是適用于GTK+環境的一套圖標主題，風格很漂亮，而且齊全。","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"GTK+","slug":"gtk","permalink":"http://0x3f.org/tags/gtk/"},{"name":"主題","slug":"主題","permalink":"http://0x3f.org/tags/主題/"},{"name":"圖標","slug":"圖標","permalink":"http://0x3f.org/tags/圖標/"}]},{"title":"MySQL升級後執行mysql_upgrade","slug":"execute-mysql-upgrade-after-upgrading","date":"2011-02-10T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/execute-mysql-upgrade-after-upgrading/","link":"","permalink":"http://0x3f.org/post/execute-mysql-upgrade-after-upgrading/","excerpt":"","text":"最近把MySQL從5.1升級到5.5，之後創建存儲過程時報如下錯誤：ERROR 1548 (HY000) at line 5: Cannot load from mysql.proc. The table is probably corrupted解決辦法是執行如下命令： 1mysql_upgrade -p mysql_upgrade是MySQL提供的一個指令，作用是檢查MySQL中的各個表與當前版本的數據庫是否匹配并嘗試修復所有發現的問題。MySQL官方文檔中推薦在每次升級後執行一下這個指令。","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"MySQL","slug":"mysql","permalink":"http://0x3f.org/tags/mysql/"},{"name":"Database","slug":"database","permalink":"http://0x3f.org/tags/database/"}]},{"title":"部分無線路由導致Wordpress無法登錄","slug":"wordpress-fails-logging-in-with-some-wifi-routers","date":"2011-01-30T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/wordpress-fails-logging-in-with-some-wifi-routers/","link":"","permalink":"http://0x3f.org/post/wordpress-fails-logging-in-with-some-wifi-routers/","excerpt":"","text":"問題表現為在登錄頁面輸入用戶名和密碼并點擊登錄按鈕後，Wordpress跳轉到登錄頁面。 解決方法是修改wp-includes/plugable.php中的wp_set_auth_cookie()函數，將下面這行： 1setcookie($auth_cookie_name, $auth_cookie, $expire, ADMIN_COOKIE_PATH, COOKIE_DOMAIN, $secure, true); 改成： 1setcookie($auth_cookie_name, $auth_cookie, $expire, SITECOOKIEPATH, COOKIE_DOMAIN, $secure, true); 這一行在這個函數中有兩處，是根據php的版本決定執行哪一塊，所以應該根據自己的情況修改，或者幹脆兩處都修改。 在我的tp-link tl-wr841n中發現這個問題，而中興無線貓中沒有這個問題。","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"WordPress","slug":"wordpress","permalink":"http://0x3f.org/tags/wordpress/"},{"name":"路由器","slug":"路由器","permalink":"http://0x3f.org/tags/路由器/"}]},{"title":"讀完Agile Web Application Development with Yii1.1 and PHP5","slug":"after-reading-agile-web-application-development-with-yii11-and-php5","date":"2011-01-23T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-agile-web-application-development-with-yii11-and-php5/","link":"","permalink":"http://0x3f.org/post/after-reading-agile-web-application-development-with-yii11-and-php5/","excerpt":"","text":"花了兩個周末，讀完了Agile Web Application Development with Yii1.1 and PHP5，邊讀邊做，受益匪淺。 這本書從零開始細致地講解了用Yii開發一個項目管理系統TrackStar的全過程，涉及到Yii的大部分主要特性。全書風格簡潔凝練，沒有過多的占用篇幅的截圖，但講解淺顯易懂，可操作性很強，是我看過的Tutorial類的書裏面最好的一本。 從這段時間學習Yii的體會中，我覺得在目前的條件下，對于有PHP程序開發基礎的人，學習路線應該是： Yii權威指南→The Yii Blog Tutorial→Agile Web Application Development with Yii1.1 and PHP5","categories":[],"tags":[{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"Web","slug":"web","permalink":"http://0x3f.org/tags/web/"},{"name":"框架","slug":"框架","permalink":"http://0x3f.org/tags/框架/"},{"name":"Yii","slug":"yii","permalink":"http://0x3f.org/tags/yii/"}]},{"title":"Console2：取代cmd.exe的Windows虛擬終端","slug":"console2-as-an-alternative-of-cmd-exe","date":"2011-01-21T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/console2-as-an-alternative-of-cmd-exe/","link":"","permalink":"http://0x3f.org/post/console2-as-an-alternative-of-cmd-exe/","excerpt":"","text":"相對于雞肋cmd.exe，Console2有以下優點： 窗口大小可調整 字體樣式可選擇 支持多標簽 有很方便的選擇、復制、粘貼等基本編輯功能 支持自定義快捷鍵 對經常不得不使用Windows虛擬終端的人來說，以上幾個特性足以使人忘掉cmd.exe。其實，Console2本身只是Shell的圖形前端，只是在默認情況下它會調用cmd.exe處理用戶輸入，因此，也可以通過設置使Console2成為Cygwin的前端，只是從這一點上講，Console2和Mintty相比完全沒有優勢。","categories":[],"tags":[{"name":"終端","slug":"終端","permalink":"http://0x3f.org/tags/終端/"},{"name":"Windows","slug":"windows","permalink":"http://0x3f.org/tags/windows/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"cygwin","slug":"cygwin","permalink":"http://0x3f.org/tags/cygwin/"},{"name":"Shell","slug":"shell","permalink":"http://0x3f.org/tags/shell/"},{"name":"軟體","slug":"軟體","permalink":"http://0x3f.org/tags/軟體/"}]},{"title":"Dokan SSHFS：Windows下通過SSH挂載Linux主機為本地分區","slug":"mount-linux-dirs-as-windows-local-partitions","date":"2011-01-19T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/mount-linux-dirs-as-windows-local-partitions/","link":"","permalink":"http://0x3f.org/post/mount-linux-dirs-as-windows-local-partitions/","excerpt":"","text":"Linux一般使用Samba向Windows共享資源。另一個辦法就是使用SSH。 Dokan是一個為Windows提供實現新文件系統的開發庫，而Dokan SSHFS是在此基礎上實現的挂載SSH通道為本地分區的文件系統。必須先安裝Dokan，然後再安裝Dokan SSHFS。 如果從安裝SSH服務做起，步驟是： 在Linux主機上安裝openssh 修改Linux主機的/etc/hosts.allow，加入sshd: ALL，以允許外部訪問 啟動sshd守護進程 在Windows主機上安裝Dokan和Dokan SSHFS 通過SSHFS的圖形配置工具挂載SSH通道 這種方式的好處是簡單，但是存在安全隱患，不管怎樣，公布SSH連接絕非好事，這意味著接入用戶可以遠程控制Linux主機，尤其是當SSH賬戶的權限較高時。因此，這種方式只適用于虛擬機或家庭網絡，例如對Host-Guests共享支持不佳的KVM虛擬機來說就是個好的選擇。即便如此，也要注意相應的Windows主機的安全防範，否則，入侵者可以通過Windows主機做跳板來進入Linux主機。","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"},{"name":"Windows","slug":"windows","permalink":"http://0x3f.org/tags/windows/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"軟體","slug":"軟體","permalink":"http://0x3f.org/tags/軟體/"},{"name":"kvm","slug":"kvm","permalink":"http://0x3f.org/tags/kvm/"},{"name":"SSH","slug":"ssh","permalink":"http://0x3f.org/tags/ssh/"}]},{"title":"讀完《程序員修煉之道》","slug":"after-reading-pragmatic-programmers","date":"2011-01-10T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-pragmatic-programmers/","link":"","permalink":"http://0x3f.org/post/after-reading-pragmatic-programmers/","excerpt":"","text":"上周日讀完了這本The Pragmatic Programmer的中譯本，都是經驗之談，有些東西讀後受益匪淺，更多的需要時間去體會。 很糾結讀的是中譯本，但實在買不到原版，非常好奇他們是怎樣地殫精竭慮才能想出如此爛俗的譯名。","categories":[],"tags":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"日志","slug":"日志","permalink":"http://0x3f.org/tags/日志/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"}]},{"title":"Oracle中對LOB字段的操作方法","slug":"oracle-lob-operations","date":"2011-01-06T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/oracle-lob-operations/","link":"","permalink":"http://0x3f.org/post/oracle-lob-operations/","excerpt":"","text":"在Oracle中插入或更新LOB字段時，可以將字符串以如下方式寫入SQL語句： 1insert tbl_lob (fld_lob) values (utl_raw.cast_to_raw('hello world')); 這樣做的限制是： Oracle中單條SQL語句有長度限制 cast_to_raw()對字符串有長度限制 因此如果要插入或更新的字符串過長，會導致執行失敗。此時應該使用dbms_lob處理LOB相關字段。下面是利用dbms_lob更新一個BLOB字段的存儲過程，對CLOB的操作同理： 123456789101112131415161718192021222324252627282930313233create or replace procedure updateblob( ctbl in varchar2, cfld in varchar2, cstr in varchar2, ccond in varchar2)is vqry varchar2(1000); vblob blob; vbatch varchar2(2000); vstrlen number; voffset number :=1; vamt number :=2000;begin vstrlen := length(cstr); vqry := 'update '||ctbl||' set '||cfld||'=empty_blob() where '||ccond; execute immediate vqry; vqry := 'select '||cfld||' from '||ctbl||' where '||ccond||' for update'; execute immediate vqry into vblob; if vstrlen&gt;vamt then while vstrlen&gt;voffset loop vbatch := substr(cstr, voffset, vamt); voffset := voffset+vamt; dbms_lob.writeappend(vblob, length(vbatch), utl_raw.cast_to_raw(vbatch)); end loop; else dbms_lob.writeappend(vblob, length(cstr), utl_raw.cast_to_raw(cstr)); end if; commit;end; 示例： 12345678910-- 將tbl_lob表的fld_lob字段的值改為“hello lob !”，要求被更改的行滿足條件：-- 1. fld_code字段的值以“2011”開頭-- 2. fld_name字段的值等於“Hell”declare vcond varchar2(1000);begin vcond := 'fld_code like ''2011%'' and fld_name=''Hell'''; updateblob('tbl_lob', 'fld_lob', 'hello lob !', vcond);end;","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"SQL","slug":"sql","permalink":"http://0x3f.org/tags/sql/"},{"name":"oracle","slug":"oracle","permalink":"http://0x3f.org/tags/oracle/"}]},{"title":"darkstat: 網絡流量監測工具","slug":"darkstat-as-a-network-discharge-meter","date":"2010-12-25T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/darkstat-as-a-network-discharge-meter/","link":"","permalink":"http://0x3f.org/post/darkstat-as-a-network-discharge-meter/","excerpt":"","text":"darkstat是一個跨平台的網絡流量監測工具，可顯示最大一個月內操作系統的各項網絡流量指標。 具有以下特性： 以守護進程方式運行，提供Web用戶界面，零配置，易于使用 可顯示較為詳細的網絡流量指標 性能表現好，占用資源少 跨平台，支持多個UNIX、類UNIX操作系統，并有非官方的Windows移植版 具有以下不足： 功能較為簡單，以易用性換靈活性 日志記錄功能比較單薄，需要編寫輔助腳本并設置定時任務 darkstat啟動時需要手工指定監視的網絡接口，因此需要用根權限啟動： 1sudo darkstat -i eth0 darkstat默認使用667端口提供Web訪問，可以用-p參數指定端口： 1sudo darkstat -i eth0 -p 8080 darkstat的Web用戶界面分為Graph、Hosts和Host三部分。Graph是缺省主頁，用于顯示最近一分鐘、一小時、一天和一個月的流量統計直方圖，將光標置于任何一個直方條上可查看對應時刻的流量指標： Hosts界面按主機顯示各自的流量統計指標的值： 單擊Hosts界面上的IP進入對應主機的Host界面，此界面按TCP/UDP類型顯示對應的主機的各端口的網絡流量指標的值： 可通過如下命令查看占用指定端口的進程： [lenin@archer ~]$ lsof -i tcp:58062 -nCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmlnet 18660 lenin 74u IPv4 251788 0t0 TCP 192.168.1.3:58062-&gt;122.116.212.89:http (ESTABLISHED) darkstat區別于其它流量監測工具的最大的優點就是簡單易用，非常適合對流量監測應用不復雜的場景。前段時間公司的一台RHEL服務器因為流量過大多次被網管拔線，後來用darkstat監測到大部分流量被幾個UDP端口占去，進而發現原來是服務器被入侵并被安裝了一個掃描器SIPVicious。","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"},{"name":"Windows","slug":"windows","permalink":"http://0x3f.org/tags/windows/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://0x3f.org/tags/计算机网络/"},{"name":"安全","slug":"安全","permalink":"http://0x3f.org/tags/安全/"},{"name":"Unix","slug":"unix","permalink":"http://0x3f.org/tags/unix/"}]},{"title":"Linux的內存使用機制","slug":"linux-memory-usage","date":"2010-12-23T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/linux-memory-usage/","link":"","permalink":"http://0x3f.org/post/linux-memory-usage/","excerpt":"","text":"在top中，內存使用情況顯示為如下格式： Mem: 3056828k total, 2624472k used, 432356k free, 185196k buffersSwap: 2096476k total, 0k used, 2096476k free, 1613592k cached 根據內存的使用情況，將內存空間劃分為四種類型：已使用（used），未使用（free），緩沖區（buffers）和已緩存（cached）。 “已使用”是指目前正被使用的活躍的內存區域。“未使用”是指當前空閑的內存區域。“緩沖區”是用于存放即將寫入存儲介質的數據的區域。“已緩存”是指曾因需要而被讀入內存、但目前已不被使用的數據。Linux通常會在資源使用完畢後保留一部分數據在內存中而不全部釋放，這就是“已緩存”區域，這樣當這些數據再次被使用時，系統就可以直接從內存中讀取。而“緩沖區”用于將對存儲介質的寫操作集中進行。因此，“緩沖區”和“已緩存”特性對減少存儲介質IO和加速系統運行都具有非常重要的作用。 所以，Linux運行一段時間後，通常看起來空閑內存都很小，其實是因為很大一部分被用作“已緩存”區域，這部分內存會在內存資源緊張時被自動釋放，也可以通過如下命令手工釋放： 1echo 1 &gt; /proc/sys/vm/drop_caches","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"BASH","slug":"bash","permalink":"http://0x3f.org/tags/bash/"}]},{"title":"Vim中設置關鍵詞識別規則的方法","slug":"howto-set-keyword-identification-in-vim","date":"2010-12-21T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-set-keyword-identification-in-vim/","link":"","permalink":"http://0x3f.org/post/howto-set-keyword-identification-in-vim/","excerpt":"","text":"在Vim中，關鍵詞是一個至關重要的概念。合理地利用關鍵詞，可以快速地對光標下有特殊含義的字符串進行一系列的操作，例如通過快捷鍵復制關鍵詞、查詢函數定義或文檔、在項目中查詢所有引用當前函數的地方等等。這對工作效率的提升有極大的幫助。 但我的Vim對PHP文件的關鍵詞識別有問題，在選擇函數名的時候總是將函數名後的小括弧一起選入。 Vim使用選項iskeyword設定關鍵詞的匹配規則，使用如下命令查看當前文件類型的關鍵詞規則： 1set iskeyword 我這裏查看PHP文件的規則結果如下： iskeyword=@,48-57,_,192-255,$,( 不明白為什麽缺省設置中會有左括弧，在vimrc中加入如下配置取消之： 1au FileType php set iskeyword-=(","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"}]},{"title":"Root了Desire并刷了Oxygen","slug":"rooted-desire-and-flashed-oxygen","date":"2010-12-18T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/rooted-desire-and-flashed-oxygen/","link":"","permalink":"http://0x3f.org/post/rooted-desire-and-flashed-oxygen/","excerpt":"","text":"五月末入手Desire後一直沒有折騰，一是因為時間和精力不夠，二也沒有迫切的需要。 這次Google Map的更新給了我足夠的理由，加上Froyo原生的“移動到SD”功能已被榨幹最後一點油水，于是用unrEVOked3很傻瓜地root了Desire，用Move2SD Enabler開啟了完全的App2SD，用Market Enabler化妝潛入米國菜市場安裝了Google Map 5.0，最後還啟用了SetCPU。 後來還是沒有把持住，一不做二不休，對原裝的Sense做了一個nandroid備份，刷上了Oxygen。Oxygen的主題十分的簡潔美觀，我覺得比Sense漂亮： Oxygen基于AOSP，是改動較少、較接近于官方Android的一個ROM，最大的優點是速度快和穩定性高。這兩天使用的感受証明了這兩點，尤其是速度，一騎絕塵啊，與之相比 ，神馬Sense之類的都是浮雲。當然，因為精簡，理論上在耗電量上較Sense要小，不過我實際感覺如果持續使用的話也好不到哪去，但是待機的話效果還是比較明顯，可能跟啟用了SetCPU也有一定的關系。 開始差點刷了MIUI，但是隨即發現很多人反映耗電和穩定性的問題，雖然是個好東西，還是等穩定了再說。","categories":[],"tags":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"Google","slug":"google","permalink":"http://0x3f.org/tags/google/"},{"name":"主題","slug":"主題","permalink":"http://0x3f.org/tags/主題/"},{"name":"Android","slug":"android","permalink":"http://0x3f.org/tags/android/"},{"name":"Desire","slug":"desire","permalink":"http://0x3f.org/tags/desire/"},{"name":"Oxygen","slug":"oxygen","permalink":"http://0x3f.org/tags/oxygen/"},{"name":"ROM","slug":"rom","permalink":"http://0x3f.org/tags/rom/"}]},{"title":"Batch Cat v0.2 Released","slug":"batchcat-v02-released","date":"2010-12-11T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/batchcat-v02-released/","link":"","permalink":"http://0x3f.org/post/batchcat-v02-released/","excerpt":"","text":"Change Log 2010-12-12 Sunday Add the ability to append the selected categories to posts Add the ability to delete the selected categories from posts Check the plugin’s page for more information.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"WordPress","slug":"wordpress","permalink":"http://0x3f.org/tags/wordpress/"}]},{"title":"Vim保存文件時移除尾行換行符的方法","slug":"howto-remove-eof-in-vim","date":"2010-12-04T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-remove-eof-in-vim/","link":"","permalink":"http://0x3f.org/post/howto-remove-eof-in-vim/","excerpt":"","text":"Vim認為一個文本文件的每一行都應該由一換行符結束，即使文件的最後一行也不例外。這就使得Vim保存過的文本文件在其它文本編輯器中查看時可能會在文件末尾多出一個空行。一般來說，這不是個問題，但對于程序員來說，有時候一些不規範的運行環境或其它組件就要求文件的最後一行不能有換行符，否則就會出莫名其妙的問題，尤其是在Windows環境下最常見。 要在保存文件時不在最後一行添加換行符，最常見、最簡單的方法就是： 12:set binary:set noendofline 但是這樣做有一個問題，就是會把DOS格式的文件自動轉換成UNIX格式，WinSlave們肯定不希望這麽做。 因此，可在vimrc中加入如下內容： 12345678910111213141516\" Save the current buffer as a file with no EOF sign.function! SaveAsNOEOF(filename) let a=getline(1,line('$')-1) let b=map(a, 'iconv(v:val,\"'.&amp;enc.'\",\"'.&amp;fenc.'\") . nr2char(13)') call extend(b, getline('$', '$')) call writefile(b,a:filename, 'b') if a:filename == bufname('%') set nomodified endifendfunction\" Save the current buffer and get rid of the EOF sign.function! SaveNOEOF() call SaveAsNOEOF(bufname('%'))endfunctioncommand! -complete=file -nargs=0 SaveNOEOF :call SaveNOEOF()command! -complete=file -nargs=1 SaveAsNOEOF :call SaveAsNOEOF(&lt;q-args&gt;) 然後就可以使用SaveNOEOF和SaveAsNOEOF兩條命令去保存沒有EOF的文件了。 說明：本文的目的在于保存文件時移除最後一行的換行符，而并非移除EOF，上述配置中使用EOF只為記憶更容易起見。 更新： 2010-12-15 修正SaveNOEOF命令報缺少參數的錯誤的問題 修正保存當前buffer後沒有變更文檔修改狀態的問題 修正保存文件後總是將編碼轉換成encoding選項的值的問題","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"Windows","slug":"windows","permalink":"http://0x3f.org/tags/windows/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"}]},{"title":"黃粱一夢","slug":"a-fools-paradise","date":"2010-12-04T09:51:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/a-fools-paradise/","link":"","permalink":"http://0x3f.org/post/a-fools-paradise/","excerpt":"","text":"昨天晚上放棄了年終聚餐，去看了《黃粱夢》。 一個很老套的故事，耳熟能詳，但是經過精心的演繹，加上聲、光、電的完美運用，真就給人以耳目一新的感覺。我一直不怎麽觀注地方戲曲，以往覺得能湊合聽聽的也就是河南的越調、安徽的黃梅戲等，河北的地方戲也就聽說過一個河北梆子，像邯鄲的平調落子這樣的聞所未聞。《黃粱夢》徹底改變了我對地方戲曲的看法，京劇、昆曲固然高雅，但假如也加入魔術、雜技、俚語甚至RAP，肯定會讓人覺得不倫不類，地方戲曲的長處就在于靈活多變，不拘泥形式，能夠很快地針對時代變化作出改進，如果分寸拿捏得好，就能不斷推陳出新。 整場戲用兩個小時的時間表現了盧生一夢中的一生，故事情節十分緊湊，每折都用不同的場景、不同的唱腔、不同的表現形式，讓人眼花繚亂，一改傳統戲劇連篇累牘的大段說詞，整場看下來從未覺得枯燥乏味，很適應時下流行的快餐文化。在故事情節上，《黃粱夢》并沒有跳出懲惡揚善、因果報應的老套，當然，一味地追求突破未見得是好事。 雖然時間不長，但是整場戲有很多地方讓人印象深刻，比如有句意味深長的戲詞“邯鄲道長，人生路短”，還有那句雷倒了無數人的“現在哪裏還有什麽純真美女啊”。當然，最讓人意猶未盡的還是這段高潮的“貪官舞”：","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"日志","slug":"日志","permalink":"http://0x3f.org/tags/日志/"},{"name":"戲曲","slug":"戲曲","permalink":"http://0x3f.org/tags/戲曲/"},{"name":"文化","slug":"文化","permalink":"http://0x3f.org/tags/文化/"}]},{"title":"virtio可能導致windows藍屏","slug":"virto-may-breakdown-windows","date":"2010-12-03T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/virto-may-breakdown-windows/","link":"","permalink":"http://0x3f.org/post/virto-may-breakdown-windows/","excerpt":"","text":"前段時間突然發現kvm中的windows在啟動時藍屏，開始以為是kvm新版本的bug，後來發現如果不啟用虛擬機硬盤的virtio就不會出現藍屏。 于是下載了最新版的virtio，然而更新後，藍屏的問題并沒有解決，所以目前只能暫時不使用virtio。不過網卡的virtio是沒有問題的。","categories":[],"tags":[{"name":"Windows","slug":"windows","permalink":"http://0x3f.org/tags/windows/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"kvm","slug":"kvm","permalink":"http://0x3f.org/tags/kvm/"},{"name":"虛擬技術","slug":"虛擬技術","permalink":"http://0x3f.org/tags/虛擬技術/"}]},{"title":"開啟自定義GTK程序菜單快捷鍵的方法","slug":"howto-enable-hotkey-for-gtk-menus","date":"2010-12-03T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-enable-hotkey-for-gtk-menus/","link":"","permalink":"http://0x3f.org/post/howto-enable-hotkey-for-gtk-menus/","excerpt":"","text":"基于GTK的程序菜單本身支持通過在焦點所在的菜單項上按下組合鍵來定義該菜單項的快捷鍵，但默認并不開啟。 一般來說，對于支持X的會話管理的桌面環境，可以通過修改相應的設置來開啟這個功能： GNOME中該設置項所在的路徑是：主選單 &gt; 桌面 &gt; 偏好設定 &gt; 選單及功具列 &gt; 可編輯選單捷徑鍵 XFCE中該設置項所在的路徑是：主選單 &gt; 設置 &gt; 外觀 &gt; 設置 &gt; 開啟可編輯快捷鍵 對于不支持會話管理的桌面環境，可在~/.gtkrc-2.0中添加如下配置內容： gtk-can-change-accels = 1","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"GNOME","slug":"gnome","permalink":"http://0x3f.org/tags/gnome/"},{"name":"XFCE","slug":"xfce","permalink":"http://0x3f.org/tags/xfce/"},{"name":"快捷键","slug":"快捷键","permalink":"http://0x3f.org/tags/快捷键/"}]},{"title":"Hope GTK：平靜、柔和、細膩的主題","slug":"gtk-theme-hope","date":"2010-12-03T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/gtk-theme-hope/","link":"","permalink":"http://0x3f.org/post/gtk-theme-hope/","excerpt":"","text":"Hope GTK是套漂亮的冷色調的GTK主題，色調過渡柔和，細節表現得也很好，整體給人以平靜的感覺。","categories":[],"tags":[{"name":"美化","slug":"美化","permalink":"http://0x3f.org/tags/美化/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"GTK+","slug":"gtk","permalink":"http://0x3f.org/tags/gtk/"},{"name":"主題","slug":"主題","permalink":"http://0x3f.org/tags/主題/"}]},{"title":"screen曰：$TERM too long - sorry.","slug":"screen-is-sorry-for-term-being-too-long","date":"2010-11-30T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/screen-is-sorry-for-term-being-too-long/","link":"","permalink":"http://0x3f.org/post/screen-is-sorry-for-term-being-too-long/","excerpt":"","text":"最近rxvt-unicode-256color的一次更新觸發了screen的一個缺陷。新的版本將默認的環境變量$TERM由rxvt-256color改成了rxvt-unicode-256color，這導致在rxvt中啟動screen時報這樣的錯誤： $TERM too long - sorry. 雖然可以在.Xdefaults中指定$TERM的值，但是據說這樣會導致rxvt加載錯誤的terminfo，并導致終端的顏色由256色降低到88色。另外雖然按照同樣的說法，可以在screenrc中設置$TERM的值，但是不知道是我寫的格式不對還是什麽原因，無效。 最終還是設了個別名： 123# vi ~/.bashrcalias screenx='export TERM=screen-256color &amp;&amp; screen'","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"rxvt","slug":"rxvt","permalink":"http://0x3f.org/tags/rxvt/"},{"name":"終端","slug":"終端","permalink":"http://0x3f.org/tags/終端/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"BASH","slug":"bash","permalink":"http://0x3f.org/tags/bash/"},{"name":"screen","slug":"screen","permalink":"http://0x3f.org/tags/screen/"}]},{"title":"WinMerge：開源的差异比較工具","slug":"winmerge-as-a-free-diff-tool","date":"2010-11-28T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/winmerge-as-a-free-diff-tool/","link":"","permalink":"http://0x3f.org/post/winmerge-as-a-free-diff-tool/","excerpt":"","text":"WinMerge是開源的差异比較工具，只運行于Windows平台。 具有以下實用特性： 支持文件內容和文件、文件夾差异比較 文件內容比較采用左右雙欄顯示，支持語法高亮 提供Windows資源管理器右鍵菜單，以選擇文件或文件夾進行比較 具有以下不足： 文件夾比較結果以單欄顯示，不直觀 僅支持兩方比較，不支持多方比較 使用時的注意事項： 使用樹狀的列表顯示文件夾比較結果可以稍微緩解單欄顯示導致的不直觀的問題 Windows資源管理器的右鍵菜單需要在設置界面手工設置才能加入選取不同目標進行比較的菜單項 相較于商業的Beyong Compare等工具，WinMerge在操作的直觀度和功能細節上存在不足，但是在差异比較的主要功能上，WinMerge完全可以勝任日常工作。同時，由于免費，WinMerge可以作為這些商業軟件很好的替代工具。 後記：這些天越來越對使用未授權的商業軟件感到不安，于是開始尋找這些工具的開源、免費替代品。","categories":[],"tags":[{"name":"Windows","slug":"windows","permalink":"http://0x3f.org/tags/windows/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"軟體","slug":"軟體","permalink":"http://0x3f.org/tags/軟體/"},{"name":"開源","slug":"開源","permalink":"http://0x3f.org/tags/開源/"}]},{"title":"Oxygen Refit：適用于xfce的Oxygen圖標集","slug":"oxygen-iconset-fit-for-xfce","date":"2010-11-28T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/oxygen-iconset-fit-for-xfce/","link":"","permalink":"http://0x3f.org/post/oxygen-iconset-fit-for-xfce/","excerpt":"","text":"Oxygen是KDE桌面環境中的一套著名的圖標集，但是據說基于GTK的桌面環境如GNOME、XFCE等對其支持得不好，我這裏在GNOME下倒沒發現問題，不過在XFCE下文件夾的圖標顯示的是缺省的圖標，不好看。 Oxygen Refit是針對GTK的桌面環境修改的Oxygen圖標集，在XFCE下可以正常顯示，但是缺點是最大分辨率只有48×48，不能顯示較大的高清圖標。Archlinux下可以安裝AUR中的oxygenrefit2-icon-theme。","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"美化","slug":"美化","permalink":"http://0x3f.org/tags/美化/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"},{"name":"GNOME","slug":"gnome","permalink":"http://0x3f.org/tags/gnome/"},{"name":"XFCE","slug":"xfce","permalink":"http://0x3f.org/tags/xfce/"},{"name":"桌面環境","slug":"桌面環境","permalink":"http://0x3f.org/tags/桌面環境/"},{"name":"KDE","slug":"kde","permalink":"http://0x3f.org/tags/kde/"}]},{"title":"升級fcitx到4.0","slug":"upgraded-to-fcitx4","date":"2010-11-19T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/upgraded-to-fcitx4/","link":"","permalink":"http://0x3f.org/post/upgraded-to-fcitx4/","excerpt":"","text":"雖然是個大版本，但4.0在實際功能上并沒有太大的進步。新版本相對于3.x增加的主要特性是： 支持皮膚 圖形界面的配置工具 增加系統托盤圖標 托盤圖標和輸入條提供右鍵菜單，如皮膚切換、選擇輸入法等 放棄GBK編碼，改用UTF-8編碼 拼音支持多詞庫 一系列細節功能及Bug修復 最主要的特性只有前兩個，可見fcitx 4.0只是這個項目涅槃後的一個新的起點，象征意義大于實際意義，尤其對于碼表輸入法用戶來說是這樣。三年前我就說過，fcitx在用戶造詞上有個致命缺陷，就是對于多音字它總是使用字母表中聲母靠前的編碼，對于音碼或者音形碼輸入法來說，這樣造出來的詞的編碼經常會是錯的，更糟糕的是用戶還不容易自行修改詞組編碼。三年後的今天，新版本并沒有解決這個問題。 此外，需要注意的是，新版本對界面和易用性的改進也帶來一些負面的影響，fcitx不再是當年以輕巧著稱的那只小企鵝了，在我這裏，它的內存占用達到了26M，所幸反應速度仍然很快。 三年前，由于眾所周知的原因，fcitx的路線圖顯得非常混亂，幾個新版本都非常不穩定，所以我不再使用源中的版本，轉而編譯安裝了新版本中相對穩定的黑色星期五版，不知不覺中三年過去了，想到一直用著這個版本就這麽過來了，很感慨。要卸載編譯安裝的程序就得用源碼重新configure一下再make uninstall，所幸還能在這裏找到這個版本。 Archlinux下安裝AUR中的fcitx-config時報如下錯誤： ERROR: certificate common name “*.github.com” doesn’t match requested host name “github.com”. 需要修改/etc/makepkg.conf，使wget在下載源碼時不做安全驗証： # 增加–no-check-certificate參數DLAGENTS=(‘ftp::/usr/bin/wget -c –passive-ftp -t 3 –waitretry=3’ ‘http::/usr/bin/wget -c -t 3 –waitretry=3 –no-check-certificate’ ‘https::/usr/bin/wget -c -t 3 –waitretry=3 –no-check-certificate’ ‘rsync::/usr/bin/rsync -z’ ‘scp::/usr/bin/scp -C’) 新版本的穩定性不如黑色星期五版，如果把簡繁轉換熱鍵修改為ALT+J，使用時會導致fcitx崩潰。加之實際功能的改進不大，所以是否升級就無可無不可了。","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"},{"name":"fcitx","slug":"fcitx","permalink":"http://0x3f.org/tags/fcitx/"},{"name":"拼音","slug":"拼音","permalink":"http://0x3f.org/tags/拼音/"},{"name":"輸入法","slug":"輸入法","permalink":"http://0x3f.org/tags/輸入法/"}]},{"title":"調整Arch的磁盤分區","slug":"adjust-disk-partitions-in-archlinux","date":"2010-11-12T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/adjust-disk-partitions-in-archlinux/","link":"","permalink":"http://0x3f.org/post/adjust-disk-partitions-in-archlinux/","excerpt":"","text":"簡述 目標：移除Windows 7，整塊硬盤完全分配給Archlinux。 原分區結構： 分區類型掛載文件系統容量 /dev/sda1主分區，啟動分區Windows 7的安裝分區ntfs30G /dev/sda2擴展分區--- /dev/sda5邏輯分區Windows的D盤ntfs40G /dev/sda3主分區/ext378G /dev/sda4交換分區swap-2G 調整後分區結構： 分區類型掛載文件系統容量 /dev/sda1主分區，啟動分區/ext330G /dev/sda2主分區/homeext3120G /dev/sda3交換分區swap-2G 步驟 Archlinux中重裝GRUB，覆蓋Windows 7的BCD：1sudo grub-install /dev/sda 在GRUB啟動菜單中加入將要復制到sda1分區中的Archlinux的啟動項：1sudo vi /boot/grub/menu.lst # (2) Arch Linux title Arch Linux root (hd0,0) kernel /boot/vmlinuz26 root=/dev/sda1 resume=/dev/sda4 ro acpi_osi=\"Linux\" initrd /boot/kernel26.img 安裝U盤啟動的Puppy Linux Puppy中格式化sda1分區：1mkfs.ext3 /dev/sda1 復制sda3上的Archlinux所有的文件到sda1：1234# 先點擊桌面上sda1和sda3的盤符，使之被掛載到/mnt下cd /mnt/sda3cp -a * /mnt/sda1 修改sda1上的fstab：1vi /mnt/sda1/etc/fstab # 修改必要的挂載點，如將根目錄的挂載點由sda3改為sda1： /dev/sda1 / ext3 defaults,noatime 0 1 重啟系統，并引導到新分區上的系統中 重新安裝GRUB，使之引導sda1分區中的系統：1sudo grub-install /dev/sda 重啟并進入Puppy，使用gparted刪除除sda1以外的所有分區，然後在空閑的空間上創建ext3格式的主分區sda2和交換分區sda3 移動sda1上home目錄下的所有東西到sda2：12cp -a /mnt/sda1/home/* /mnt/sda2rm -rf /mnt/sda1/home/* 修改sda1上的fstab和menu.lst：1vi /mnt/sda1/etc/fstab # 將fstab中磁盤分區的挂載點配置為如下內容 /dev/sda1 / ext3 defaults,noatime 0 1 /dev/sda2 /home ext3 defaults,noatime 1 2 /dev/sda3 swap swap defaults 0 0 1vi /mnt/boot/grub/menu.lst # 將原來啟動項中的sda3修改為sda1，由于配置過休眠，也將resume參數中的sda4改為sda3，即交換分區 重啟系統 後記 從Arch誕生時只裝XP，到裝上Archlinux後雙系統并存，再到嘗試Win7，兩年的時間裏，一直有很多原因讓Windows像只寄生蟲一樣頑強地活著。最近硬盤空間越來越緊張，早前裝的Win7也很長時間不用了，于是時隔三年之後，我又成了個純粹的Archer。","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"Windows","slug":"windows","permalink":"http://0x3f.org/tags/windows/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"}]},{"title":"制作Puppy Linux的啟動U盤","slug":"howto-create-bootable-udisk-for-puppylinux","date":"2010-11-10T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-create-bootable-udisk-for-puppylinux/","link":"","permalink":"http://0x3f.org/post/howto-create-bootable-udisk-for-puppylinux/","excerpt":"","text":"Puppy Linux的體積只有一百多兆字節，但圖形界面實現得很完備，也包含了很多短小精悍的工具，安裝和使用都很方便，非常適合用來做日常維護工具盤。 Puppy自帶了傻瓜式的啟動U盤制作工具，但官方只提供整個發行版的ISO鏡像下載，通常需要刻錄成光盤并引導系統啟動後才可以繼續將Puppy安裝到U盤。其實也可以不刻錄光盤，而是把Puppy安裝到硬盤上。 Puppy本身封裝得很好，對軟硬件環境的要求不高，完全可以安裝到一個獨立的目錄中而不影響其它操作系統。本文基于Linux環境下通過GRUB引導的前提，Windows下應該可以通過GRUB4DOS引導。 挂載Puppy的ISO鏡像到一個目錄： 1sudo mount -o loop puppy.iso /media/puppy 復制鏡像中的所有文件到根目錄下的puppy目錄： 12sudo mkdir /puppysudo cp -a /media/puppy/* /puppy 修改GRUB的引導文件，加入Puppy的引導項： 1sudo vi /boot/grub/menu.lst # (2) Puppytitle Puppyroot (hd0,2)kernel /puppy/vmlinuz root=/dev/ram0initrd /puppy/initrd.gz 重啟系統并啟動到Puppy 使用桌面上的Setup中的Puppy Universal Installer制作啟動U盤。不過雖然這是官方推薦的制作工具，但我的雜牌U盤無論如何也不能引導系統，最後使用另一個備選的工具“BootFlash USB Installer”的USB-HDD模式制作成功。","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"}]},{"title":"目錄與文件的存儲空間占用分析工具","slug":"storage-space-analysing-tools","date":"2010-09-30T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/storage-space-analysing-tools/","link":"","permalink":"http://0x3f.org/post/storage-space-analysing-tools/","excerpt":"","text":"du du是命令行中用于查看目錄和文件的空間占用情況的指令。 常用示例： 1du -h /tmp/logs ncdu ncdu為du提供了一個基于NCurses的命令行用戶界面，并能夠按照多種條件對分析結果進行排序，它大大簡化了du指令的使用。 baobab baobab使用基于GTK的圖形用戶界面，突出特點是可以分析遠程目錄。 參考 磁盘目录占用空间计算排序工具 - ncdu","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"軟體","slug":"軟體","permalink":"http://0x3f.org/tags/軟體/"}]},{"title":"搭建自己的Twitter API","slug":"howto-setup-twitter-api-of-your-own","date":"2010-09-30T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-setup-twitter-api-of-your-own/","link":"","permalink":"http://0x3f.org/post/howto-setup-twitter-api-of-your-own/","excerpt":"","text":"創建Twitter應用程序 從2010年9月起，twitter只支持第三方應用程序使用oauth方式登錄。要使用第三方API程序，就必須先在twitter中創建應用程序。 申請地址如下： https://twitter.com/apps/ 填寫信息時，Application Type應該選Browser，Default Access type應選Read &amp; Write，User Twitter for login不選，其它隨便。 創建成功後，該應用程序的Consumer key和Consumer secret在部署API時一般都要用到。 第三方API程序 gtap gtap使用python開發，可部署在appspot上。 部署前，先修改app.yaml，填寫在appspot上創建的應用程序的ID，并使用符號#注釋掉secure: always，因為GFW屏蔽了appspot的https。 然後修改main.py，填寫Consumer key和Consumer secret。 最後安裝App Engine SDK，使用其中的appcfg.py上傳gtap文件夾： 1appcfg.py update gtap 在瀏覽器中（此時應使用可以翻牆的代理）訪問在appspot上創建的應用程序的URL地址（如：http://xxx.appspot.com ），在打開的頁面中點擊Sign in with Twitter，然後在跳轉到的頁面中點擊Allow按鈕。在跳轉到的頁面上修改API的密碼（據說有些客戶端要求API的密碼與Twitter的密碼一致）。 在客戶端中使用API的地址如下： http://xxx.appspot.com/ 其中，xxx是appspot應用程序的ID，末尾的斜杠必不可少。 twip twip使用php開發，應部署在支持PHP的服務器上。 首先將config-example.php改名為config.php，然後修改其中的OAUTH_KEY/OAUTH_SECRET/BASE_URL三項內容，前兩項分別是Consumer key和Consumer secret，base_url應該是twip部署到服務器上後的URL地址（如http://myblog.com/twip/ ，最後的斜杠必不可少）。 然後在瀏覽器中訪問上面的base_url，選擇使用o模式，API地址會在最後的頁面中輸出。 補充說明 當前版本的Google App Engine SDK要求使用python 2.5，但如果只是用來上傳應用程序到appspot，2.5以上版本的python也可以用，只是在上傳時會報某些模塊已不推薦使用。如果使用appcfg.py時報找不到2.5版本的python，可以強制使用已安裝的新版本的python執行之，即：python appcfg.py update gtap","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"Google","slug":"google","permalink":"http://0x3f.org/tags/google/"},{"name":"GFW","slug":"gfw","permalink":"http://0x3f.org/tags/gfw/"},{"name":"Twitter","slug":"twitter","permalink":"http://0x3f.org/tags/twitter/"}]},{"title":"中秋後記","slug":"note-after-the-mid-autumn-day","date":"2010-09-25T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/note-after-the-mid-autumn-day/","link":"","permalink":"http://0x3f.org/post/note-after-the-mid-autumn-day/","excerpt":"","text":"可以讓回憶放肆一些。 中秋的晚上公司餐廳放電影，《鄰家特工》和《越光寶盒》，本來打算看完《越光》就走，結果先放的是《特工》。也好，復習一下，好在這片子不錯，再看也挺有意思。《越光》純屬爛片，但是如今看看這種不費腦子的東西也變得無可無不可。免費的零食很烘托氣氛，唯一的驚喜是居然還有罐裝啤酒。 回到住處的當夜就發布了Dumperor。其實這個東西很早就開始做了，起初的目的是為了判斷數據庫腳本從SQL Server遷移到Oracle和MySQL是否成功。單純的遷移只能保証修改後的腳本在這兩個數據庫中執行不會報錯，但究竟是不是該執行的東西都成功執行了，一般很難判斷，尤其是那幫家夥總是在發版前一兩天才告訴我要遷移腳本，那麽多不規範的語句，能保証不報錯就已經不錯了，遑論沒有遺漏。所以就著手做一個數據庫表結構和數據的導出工具，這樣只需用diff工具比較標准數據庫和測試數據庫導出的腳本就可以了。 從一開始我就決定不使用公司產品的一行代碼。其實做這個東西最大的麻煩不是來自來自于如何查詢不同的數據庫的表結構，而是數據庫抽象層。如果要白手起家搞個抽象層的話，我想可能代碼量比Dumperor本身都大，于是選擇了Yii框架。後來在Dumperor基本成型時又覺得為了僅僅使用最基本的數據庫查詢功能就捆綁這麽大一個框架，有點搞笑，謝天謝地，我終于花時間學了PDO。 中秋節放假的第二天，開始讀Google Code上關于Chrome擴展開發的官方文檔。這事源于本尊被另一個Chrome擴展作者無視了。 一直強迫自己喜歡上Firefox，但都敗了。本來對Opera充滿希望，但是從10.0起它帶給我的除了失望就是更多的失望，這個東西的發展就像它的國家的位置一樣怪异，你永遠不能以常人的思維去臆測Opera的開發者，他們就像一群母系氏族社會的娘們兒一樣整天跟著感覺走。 于是不知道什麽時候我就開始經常用Chrome了，前段時間開始用一個擴展輔助MLDonkey下載。這個東西會在工具欄裏添加一個圖標，唯一的作用就是打開選項設置頁面設置那個也許這輩子都只需要設置一次的MLDonkey的URL地址。于是我給那個擴展的作者寫了封郵件，那家夥居然到現在都沒有回復。 所以本尊決定無視他了。太祖武皇帝的那句豐衣足食的聖諭真是至理名言，讀完文檔我就發現這個擴展完全應該用Chrome的Page Action取代Browser Action，簡單地說就是當且僅當本頁面中包含有可下載的資源時才在地址欄中顯示一個圖標，而不應該總是在工具欄占用一個圖標的位置。 隨後要做的就是用AJAX請求取代彈出新窗口的方式添加下載任務，我嫌每次添加一個下載任務後都要關閉一個彈出窗口太麻煩。我的目標是用AJAX請求將要下載的任務在後台傳遞給MLDonkey，并用Chrome的Desktop Notification功能彈出桌面提示對話框顯示結果狀態。這樣很優雅。 但是實際去做的時候問題來了，雖然Chrome本身允許擴展使用跨域的AJAX，但是至少在和MLDonkey進行通訊時，無論成功與否，得到的返回信息都是空的，狀態碼也都是0。這個問題浪費了我幾乎一整天的時間，最終我決定用AJAX的請求響應時間來判斷失敗或成功，因為一次AJAX請求響應過程在MLDonkey沒啟動的時候耗費的時間一般會比正在運行時要長。這就要求每個用戶都要根據自己的情況設定合適的超時時間。為了避免麻煩，最後還是實現了通過彈窗添加下載任務的模式，畢竟這個東西總是可靠的。 要發布的時候發現如今在Chrome Extension Gallery中發布擴展居然要收費了，雖然只是一次性的。最後花了八兩銀子注冊了Google Checkout賬戶，又付了五刀美帝幣，才把DonkeyBuddy傳上去。發布個免費擴展還得倒貼，本尊也太背了吧。 節後收到了Dell sk8115鍵盤、HP百靈無線鼠標和Nokia BH-105藍牙耳機，sk8115是用來讓我的纖纖玉手撒野的，百靈鼠是用來接替即將退役的雷柏7100的，而BH-105和我的小七搭配得天衣無縫。 很久沒有安靜地整理一下頭緒了，感謝我那價值四十兩銀子的Dell sk8115，它讓我顯得如此的語無倫次。","categories":[],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"SQL","slug":"sql","permalink":"http://0x3f.org/tags/sql/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"MySQL","slug":"mysql","permalink":"http://0x3f.org/tags/mysql/"},{"name":"oracle","slug":"oracle","permalink":"http://0x3f.org/tags/oracle/"},{"name":"腳本","slug":"腳本","permalink":"http://0x3f.org/tags/腳本/"},{"name":"firefox","slug":"firefox","permalink":"http://0x3f.org/tags/firefox/"},{"name":"Dumperor","slug":"dumperor","permalink":"http://0x3f.org/tags/dumperor/"},{"name":"Chrome","slug":"chrome","permalink":"http://0x3f.org/tags/chrome/"},{"name":"DonkeyBuddy","slug":"donkeybuddy","permalink":"http://0x3f.org/tags/donkeybuddy/"},{"name":"Google","slug":"google","permalink":"http://0x3f.org/tags/google/"},{"name":"Opera","slug":"opera","permalink":"http://0x3f.org/tags/opera/"},{"name":"框架","slug":"框架","permalink":"http://0x3f.org/tags/框架/"}]},{"title":"DonkeyBuddy: A Chrome Extension for MLDonkey","slug":"donkeybuddy-a-chrome-extension-for-mldonkey","date":"2010-09-23T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/donkeybuddy-a-chrome-extension-for-mldonkey/","link":"","permalink":"http://0x3f.org/post/donkeybuddy-a-chrome-extension-for-mldonkey/","excerpt":"","text":"DonkeyBuddy is an extension for Google Chrome Browser. It's intended to make life easier when you add downloading tasks to MLDonkey. Features Users can choose how to interact with MLDonkey, either by AJAX or popup windows. The AJAX mode interacts with MLDonkey by AJAX requests and uses desktop notifications to show the results, so it won't bother you by popping up windows and forcing you to close them. The popup-window mode interacts with MLDonkey by popping up a window and displays results in it, this is always a reliable way to add downloads but annoying. An icon will be displayed in the location bar only when downloadable resources are found in the current tab, so it saves you the space in both toolbar and location bar. Batch downloading. Screenshots Location bar icon: Desktop notification: Popup window: Settings page: Install https://chrome.google.com/webstore/detail/hbajjpcakkngealbehjippmdbfapodnn FAQ Why a success notification pops up when I haven't even started MLDonkey ? Since the responses of the cross-domain AJAX requests have an empty message and a status which has the value 0, so I can't identify that whether they are successful or not. But when MLDonkey is not running, AJAX requests always take more time to receive responses, so if a request has not received its reponse within a reasonable time, DonkeyBuddy will take it as a failure. So you should set the *AJAX timeout* option to a suitable value on your condition. If you are still in trouble, use the popup-windows mode instead. Why a failure notification pops up when the downloading task has acturally been added ? Take a look at the upper question. How can I send the selected links to MLDonkey in one click ? Click on this extension's icon in the address bar. Change log version 1.1.0 (2011-05-15 Sunday) Enable batch downloading for VeryCD.com. version 1.0.1 (2010-09-25 Saturday) 1. Fix the problem that the image in the option page doesn't display as is expected. 2. Set the default value of the option *AJAX timeout* to 1000. version 1.0 (2010-09-24 Friday) Initial release.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"Chrome","slug":"chrome","permalink":"http://0x3f.org/tags/chrome/"},{"name":"DonkeyBuddy","slug":"donkeybuddy","permalink":"http://0x3f.org/tags/donkeybuddy/"},{"name":"Google","slug":"google","permalink":"http://0x3f.org/tags/google/"},{"name":"Web","slug":"web","permalink":"http://0x3f.org/tags/web/"}]},{"title":"Dumperor: Multi-Database Dumping Toolkit","slug":"dumperor-as-a-multidb-dumping-tool","date":"2010-09-22T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/dumperor-as-a-multidb-dumping-tool/","link":"","permalink":"http://0x3f.org/post/dumperor-as-a-multidb-dumping-tool/","excerpt":"","text":"Dumperor is a multi-database dumping toolkit. It dumps table structures and data from databases, and generates CREATE-TABLE SQL statements for table structures or INSERT SQL statements for data. Part of the original intention for developing Dumperor is to check whether a migration of SQL scripts from one database to another is successful, you know, by comparing the differences between two files, one dumped before executing scripts and the other after. The second part is to ensure that upgrades to table structures or data not miss anything, similarly. The last part is to take samples of databases and put up development or testing environments with them, or even replace sensitive information with fake data. Dumperor is written in PHP 5 and hosted on GitHub with the New BSD License: https://github.com/xbot/Dumperor For the shortage of time, there must be some limitations and bugs in Dumperor. So reports from users are welcome, emails prefered. I will be very grateful if someone send their suggestions on Dumpeor to me. Features Currently support Microsoft SQL Server, Oracle and MySQL. Dump table structures and generate CREATE-TABLE SQL statements. Dump data and generate INSERT SQL statements. Dump table structures or data and output them in a human readable format. Save dumped information to user-specified files. Display table structures with web page tables in the web browser. Options controlling which information should be displayed in the web browser. Options controlling which information should be and should not be dumped from the database. A limit number can be set to take sample of a huge database. Needless tables or columns can be prevented from appearing in dumped results. Only the needed tables are to be exported if you like. Sensitive columns can be dumped with fake data. Conditions can be added to data querying statements. With PDO support by default but extensive to many kinds of database toolkits. More in the future … Requirements A web server configured with PHP5 support. PDO feature of PHP. PHP 5.x, notice that some versions in 5.3.x series have a bug in function parse_ini_file(), which may cause trouble. Limitations (Known Issues) Conditions for data querying only support numeric columns and equation relation. Support for auto increment columns has not been implemented. Sensitive columns must be prefixed with table names. Needless columns must be specified only with column names, nothing more. Data types which have not been tested may fail dumping. Installation Instructions Download a stable release from GitHub or clone a git repo: git clone git://github.com/xbot/Dumperor.git Copy files to a folder which can be visited by the web server, e.g. www/dumperor. Rename dumperor.ini.sample to dumperor.ini and change the settings to meet your needs. Visit Dumperor from the web browser to start dumping. News 2011-03-14 v1.0.0 released. changelog 2010-09-22 v0.1a released. changelog","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"SQL","slug":"sql","permalink":"http://0x3f.org/tags/sql/"},{"name":"Database","slug":"database","permalink":"http://0x3f.org/tags/database/"},{"name":"Dumperor","slug":"dumperor","permalink":"http://0x3f.org/tags/dumperor/"}]},{"title":"Arch不完全降溫筆記","slug":"howto-cool-archlinux-down","date":"2010-09-17T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-cool-archlinux-down/","link":"","permalink":"http://0x3f.org/post/howto-cool-archlinux-down/","excerpt":"","text":"主要目標是解決我的X200在Archlinux（本文內容均基于此發行版）下CPU溫度長期居高不下的問題，基本原理是使用cpufrequtils根據CPU負載狀況自動變頻，和使用laptop-mode-tools實現其它硬件設備的自動節能。最直接的效果是省電，從而延長電池的使用時間，產生的附加影響就是CPU及筆記本整體的溫度下降。我幾乎不用電池，所以節能不是我的關注點，但降溫卻是我所欲也。 首先安裝cpufrequtils，并將acpi-cpufreq、cpufreq_ondemand、cpufreq_powersave加入rc.conf的MODULES中，使系統在啟動時加載這些模塊。 默認情況下，內核采用cpufreq的performance模式，以獲得最高性能，現在用ondemand模式使CPU根據負載狀況自動變頻。修改/etc/conf.d/cpufreq文件，將governor項設為ondemand。 將cpufreq加入rc.conf的DAEMONS中，此守護進程會在系統啟動時讀取配置文件/etc/conf.d/cpufreq中的設置項，故上面設置的ondemand模式會在系統啟動時得以自動生效。 然後安裝laptop-mode-tools，并修改/etc/laptop-mode/laptop-mode.conf，打開所有的三個以ENABLE開頭的選項，和所有以CONTROL開頭的選項。 將laptop-mode加入rc.conf的DAEMONS中，使其隨系統自動啟動。 修改/etc/laptop-mode/conf.d/usb-autosuspend.conf，此配置文件用來配置laptop-mode如何管理USB設備的電源使用。我希望在任何時候都啟用USB設備自動節能，但需要把我的無線鼠標排除在外，故作如下配置： 12345678910# 启用USB设备自动挂起CONTROL_USB_AUTOSUSPEND=\"auto\"# 将不使用自动挂起的USB设备的ID填在下面，使用lsusb命令查看IDAUTOSUSPEND_USBID_BLACKLIST=\"04fc:05dc\"# 总是启用USB自动挂起BATT_SUSPEND_USB=1LM_AC_SUSPEND_USB=1NOLM_AC_SUSPEND_USB=1 類似地，修改intel-hda-powersave.conf，此配置文件用于配置laptop-mode如何管理Intel HDA音頻芯片的電源使用。我希望一直啟用聲卡自動節能，并適當地將自動進入節電模式的空閑時間增加到30秒，故配置如下： 12345678910# 啟用Intel音頻芯片電源管理CONTROL_INTEL_HDA_POWER=\"auto\"# 總是啟用BATT_INTEL_HDA_POWERSAVE=1LM_AC_INTEL_HDA_POWERSAVE=1NOLM_AC_INTEL_HDA_POWERSAVE=1# 適當地設置聲卡進入節電模式的超時時間INTEL_HDA_DEVICE_TIMEOUT=30 類似地，修改intel-sata-powermgmt.conf，啟用sata硬盤接口的電源管理。由于我用Blueman控制藍牙設備，一般不用時都將其關閉，同時經常使用wifi，故藍牙和無線網卡均未作配置。 最後，关闭conky,Firefox和Chromium，powertop显示conky是个很吵闹的东西，关掉它可以使Wakeups-from-idle per second的值下降很多，另外Chromium和Firefox也是耗电大户。 在此之前，系統空閑時CPU溫度一般是50多度，普通使用時一般在60多度，如果開了kvm虛擬機會達到60至90度間。經過以上設置，系统空闲时CPU温度一度下降到39度，即使開了虛擬機，一般也可維持在50到80度間。 另外，對于以上內容，我還有些沒搞明白的地方和要補充說明的東西： 雖然將laptop-mode加入rc.conf且已隨系統啟動，但使用命令“cat /proc/sys/vm/laptop_mode”查詢得到的結果仍然是0，也就是說沒有自動啟用laptop-mode，必須使用命令“sudo /etc/rc.d/laptop-mode restart”手動重啟才行。目前沒有找到解決辦法。 雖然啟用laptop-mode接管聲卡電源管理，但沒找到查看是否生效的方法，于是在/etc/rc.local中加入命令“echo 1 &gt; /sys/module/sndhdaintel/parameters/power_save”以強制聲卡節電。 Intel的powertop是個好東西，用它可以查看哪些進程最影響CPU節能。我們優化的標准之一就是使powertop中顯示的“Wakeups-from-idle per second”盡可能地減少。powertop的另一個特點就是通過自動檢查當前系統中電源使用的配置情況給出優化的建議，這是個很貼心的功能。 鑒于目前存疑較多并將繼續嘗試，所以在標題中特別注明“不完全”三個字…… 參考 http://itgen.blogspot.com/2009/03/energy-management-in-linux.html http://www.ibm.com/developerworks/cn/linux/l-cpufreq-1/index.html http://www.lesswatts.org/","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"},{"name":"wifi","slug":"wifi","permalink":"http://0x3f.org/tags/wifi/"},{"name":"Arch","slug":"arch","permalink":"http://0x3f.org/tags/arch/"},{"name":"conky","slug":"conky","permalink":"http://0x3f.org/tags/conky/"},{"name":"firefox","slug":"firefox","permalink":"http://0x3f.org/tags/firefox/"}]},{"title":"使用热键切换Vim的QuickFix窗口打开状态","slug":"howto-toggle-quickfix-in-vim-using-hotkeys","date":"2010-09-09T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-toggle-quickfix-in-vim-using-hotkeys/","link":"","permalink":"http://0x3f.org/post/howto-toggle-quickfix-in-vim-using-hotkeys/","excerpt":"","text":"QuickFix窗口只有打開和關閉的命令，而使用一個熱鍵來切換打開狀態可以減少熱鍵資源的浪費，使用也更方便。 從這裏找到使用自定義函數完成此功能的方法：使用一個全局變量記錄QuickFix窗口的打開狀態，從而判斷是應該關閉還是打開。但其提供的函數存在狀態同步的問題，假如在QuickFix窗口中使用“:q”退出窗口，此方法將不能正常工作。評論中給出了很好的解決方法，但其提供的代碼有些小問題，修改之後如下： 123456789101112131415161718192021nmap &lt;leader&gt;co :QFix&lt;CR&gt;nmap &lt;leader&gt;ct :call QFixToggle(1)&lt;CR&gt;command! -bang -nargs=? QFix call QFixToggle(&lt;bang&gt;0)function! QFixToggle(forced) if exists(\"g:qfix_win\") &amp;&amp; a:forced != 0 cclose else if exists(\"g:my_quickfix_win_height\") execute \"copen \".g:my_quickfix_win_height else copen endif endifendfunctionaugroup QFixToggle autocmd! autocmd BufWinEnter quickfix let g:qfix_win = bufnr(\"$\") autocmd BufWinLeave * if exists(\"g:qfix_win\") &amp;&amp; expand(\"&lt;abuf&gt;\") == g:qfix_win | unlet! g:qfix_win | endifaugroup END","categories":[],"tags":[{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"热键","slug":"热键","permalink":"http://0x3f.org/tags/热键/"}]},{"title":"WordPress Plugin: Batch Cat","slug":"wp-batchcat","date":"2010-09-03T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/wp-batchcat/","link":"","permalink":"http://0x3f.org/post/wp-batchcat/","excerpt":"","text":"Introduction Batch Cat is intended to help users change categories of posts in bulk. The main features are: Assign the selected categories to posts. Append the selected categories to posts. Delete the selected categories from posts. Intuitionistic operating manners which come up with people’s common practice. Configurable number of posts listed in one page. Slimming but enough searching and sorting options. More in the future. Screenshot Installation &amp; Usage As usual, upload the folder of Batch Cat to the wordpress plugin directory, activate it then. You can perform operations in the page which lies in Tools-&gt;Batch Cat in the admin panel. To alter settings of this plugin, go to Settings-&gt;Batch Cat Settings. Download Batch Cat is now hosted in the wordpress plugin repository: http://wordpress.org/extend/plugins/batch-cat/ Wish List I18NMore search optionsMore information in the post list Change Log 2011-03-20 Sunday Solve the compatibility problem under Wordpress 3.1, thanks to wongkediri. 2010-12-12 Sunday Add the ability to append the selected categories to posts Add the ability to delete the selected categories from posts 2010-09-04 SaturdayInitial release.","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"WordPress","slug":"wordpress","permalink":"http://0x3f.org/tags/wordpress/"}]},{"title":"讀完《WordPress Plug-in Development》","slug":"after-reading-wordpress-plug-in-development","date":"2010-08-28T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-reading-wordpress-plug-in-development/","link":"","permalink":"http://0x3f.org/post/after-reading-wordpress-plug-in-development/","excerpt":"","text":"花了兩天時間讀完了《WordPress Plug-in Development》，通過實例講解，很細致，適合用來入門，當然，深度和廣度都有限。","categories":[],"tags":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"},{"name":"WordPress","slug":"wordpress","permalink":"http://0x3f.org/tags/wordpress/"},{"name":"日志","slug":"日志","permalink":"http://0x3f.org/tags/日志/"},{"name":"讀書","slug":"讀書","permalink":"http://0x3f.org/tags/讀書/"}]},{"title":"批量下載視頻的BASH腳本","slug":"a-bash-script-downloading-videos-in-batch","date":"2010-08-27T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/a-bash-script-downloading-videos-in-batch/","link":"","permalink":"http://0x3f.org/post/a-bash-script-downloading-videos-in-batch/","excerpt":"","text":"兩周前為了批量下載某視頻網站中的電視劇，寫了個BASH腳本。將電視劇列表頁面的URL地址作為唯一參數傳給腳本，然後就會把所有視頻下載到當前目錄下，并自動重命名，同時生成一個M3U格式的播放列表。 由于在線視頻不支持斷點續傳，所以對于單個視頻來說無法實現。但對于整個批量下載任務來說，實現了宏觀上的斷點續傳，已經下載的視頻不會被重復下載。由于有些視頻網站會在午夜更改視頻地址，所以這一點很有用。 主流視頻網站應該是都支持的，我只測試了我下載電視劇的網站，不支持的都是非主流的！ 唯一可能需要注意的依賴是PHP，必須安裝後才能使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/bin/bashprint_help_msg () &#123; echo \"You see, I'm nothing .\" exit 0&#125;check_param () &#123; if [ $# -ne 1 ]; then print_help_msg fi&#125;check_m3u () &#123; if ! [ -a p.m3u ] || [ `wc -l p.m3u|awk '&#123; print $1 &#125;'` -eq 0 ]; then echo '#EXTM3U' &gt; p.m3u fi&#125;check_param $*check_m3uexport LC_ALL=en_US.UTF-8ue=$(php -r \"echo urlencode('$1');\")parser=\"http://www.flvcd.com/parse.php?flag=&amp;format=&amp;kw=$ue&amp;sbt=%BF%AA%CA%BCGO%21\"if ! wget $parser -U mozilla -O meta.html ; then echo \"Unable to touch the parser, check network status for the cause .\" exit 0figrep \"&lt;N&gt;\" meta.html &gt; title.lstgrep \"&lt;U&gt;\" meta.html &gt; url.lsticonv -f gbk -t utf-8 title.lst -o title.lstsed -i 's/&lt;N&gt;//g' title.lstsed -i 's/ //g' title.lstsed -i 's/&lt;U&gt;//g' url.lstl1=`wc -l title.lst|awk '&#123; print $1 &#125;'`l2=`wc -l url.lst|awk '&#123; print $1 &#125;'`if [ \"$l1\" != \"$l2\" ]; then echo \"Title.lst has $l1 lines, but url.lst got $l2.\" exit 0fiif [ $l1 -eq 0 ]; then echo \"Nothing got from the parser, check meta.html for detail info.\" exit 0fiarrTitle=(`cat title.lst`)arrURL=(`cat url.lst`)idx=$((`wc -l p.m3u|awk '&#123; print $1 &#125;'`-1))while [ $idx -lt $l1 ]; do title=$&#123;arrTitle[$idx]&#125; url=$&#123;arrURL[$idx]&#125; idx=$((idx+1)) if ! wget $url -U mozilla -O \"$&#123;title&#125;.flv\" ; then echo \"Failed fetching $&#123;title&#125;.flv, maybe its URL has been changed !\" exit 0 fi cmd=\"sed -i '\\$a\\\\$&#123;title&#125;.flv' p.m3u\" eval $cmddoneecho 'done !'exit 0 另外，使用VLC執行播放列表效果灰常不錯，視頻之間銜接平滑流暢。","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"BASH","slug":"bash","permalink":"http://0x3f.org/tags/bash/"},{"name":"下載","slug":"下載","permalink":"http://0x3f.org/tags/下載/"},{"name":"腳本","slug":"腳本","permalink":"http://0x3f.org/tags/腳本/"},{"name":"視頻","slug":"視頻","permalink":"http://0x3f.org/tags/視頻/"}]},{"title":"启动GVim时自动最大化窗口的方法","slug":"howto-auto-maximize-gvim-at-startup","date":"2010-08-24T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-auto-maximize-gvim-at-startup/","link":"","permalink":"http://0x3f.org/post/howto-auto-maximize-gvim-at-startup/","excerpt":"","text":"根据帮助文档，gvim在windows下的最大化是通过模拟打开窗口菜单并点击最大化菜单项实现的，而在Linux下的方法较为灵活。 下面的方法是在vim中通过调用wmctrl实现最大化的方法： 123456789if has('win32') au GUIEnter * simalt ~xelse au GUIEnter * call MaximizeWindow()endiffunction! MaximizeWindow() silent !wmctrl -r :ACTIVE: -b add,maximized_vert,maximized_horzendfunction 当然也可以通过配置窗口管理器规则实现自动最大化，但上面的方法更灵活。","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"Windows","slug":"windows","permalink":"http://0x3f.org/tags/windows/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"窗口管理器","slug":"窗口管理器","permalink":"http://0x3f.org/tags/窗口管理器/"}]},{"title":"InstallShield在MySQL和Oracle中执行SQL脚本的方法","slug":"howto-run-sql-scripts-in-mysql-oracle-within-installshield","date":"2010-08-23T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-run-sql-scripts-in-mysql-oracle-within-installshield/","link":"","permalink":"http://0x3f.org/post/howto-run-sql-scripts-in-mysql-oracle-within-installshield/","excerpt":"","text":"简述 InstallShield已经内建了对MySQL和Oracle的支持。但是这个功能是通过ODBC实现的，它对SQL脚本的格式要求非常严格，因此已经通过官方客户端测试的脚本在IS中执行时往往就会报错。 一般来说，数据库脚本只保证通过官方客户端测试即可，同时维护一份供IS执行的脚本费时费力。因此，考虑安装程序对两数据库的支持通过官方客户端实现。 MySQL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function InstallMySQLComponent(szComponent) NUMBER nResult; STRING szServer,szDB,szUser,szPassword,sCMD,sOPT,sResult1,sResult2,svLine,sMsg,sPath; NUMBER nvFileHandle,nvCount; LIST listStatus;begin sMsg = &apos;安装&apos;+szComponent+&apos; ...&apos;; SdShowMsg(sMsg, TRUE); // source命令不认识windows路径中的反斜杠，故将SRCDIR中的反斜杠替换成斜杠 sPath = SRCDIR; StrReplace(sPath, &apos;\\\\&apos;, &apos;/&apos;, 0); // Fetch database connection information SQLRTGetConnectionInfo( &apos;mysql&apos;, szServer, szDB, szUser, szPassword ); sCMD = WINSYSDIR^&apos;cmd.exe&apos;; sOPT = &apos; /c &apos;+SRCDIR^&apos;mysql.exe -h&apos;+szServer+&apos; -u&apos;+szUser+&apos; -p&apos;+szPassword+&apos; -D&apos;+szDB; sOPT = sOPT+&apos; -e &quot;source &apos;+sPath^szComponent+&apos;.sql&quot; &gt; &apos;+SRCDIR^&apos;dbstatus.txt 2&gt;&amp;1&apos;; // Execute the script associated with the given component in database nResult=LaunchAppAndWait(sCMD, sOPT, WAIT|LAAW_OPTION_HIDDEN); if (nResult &lt; 0) then MessageBox(&apos;Failed installing &apos;+szComponent+&apos; !&apos;, SEVERE); abort; endif; // 关闭安装提示 SdShowMsg(&apos;&apos;, FALSE); // Read dbstatus.txt OpenFileMode(FILE_MODE_NORMAL); if (OpenFile(nvFileHandle, SRCDIR, &apos;dbstatus.txt&apos;)&lt;0) then MessageBox(&apos;Failed checking the status of installing &apos;+szComponent+&apos; !&apos;, SEVERE); abort; endif; listStatus = ListCreate(STRINGLIST); while GetLine(nvFileHandle, svLine) = 0 ListAddString(listStatus, svLine, AFTER); endwhile; CloseFile(nvFileHandle); // Count how many lines fetched from dbstatus.txt nvCount = ListCount(listStatus); if nvCount &gt; 0 then sMsg = &quot;更新数据库出错，点“是”打开日志文件并退出安装，点“否”直接退出安装。\\n&quot;; sMsg = sMsg+&quot;若错误可忽略，可选择数据库类型“none”以跳过数据库更新并直接更新程序，\\n&quot;; sMsg = sMsg+&quot;然后在数据库中手工执行SQL脚本（安装后保存在script目录下）&quot;; nResult = AskYesNo(sMsg, YES); if (nResult = YES) then LaunchApp(WINSYSDIR^&apos;notepad.exe&apos;, SRCDIR^&apos;dbstatus.txt&apos;); endif; abort; endif;end;Oracle1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function InstallOracleComponent(szComponent) NUMBER nResult,nvFileHandle,nIndex,nvCount; STRING sMsg,szServer,szDB,szUser,szPassword,sCMD,sOPT,sInstance,sTmp,svLine; LIST listStatus;begin sMsg = &apos;安装&apos;+szComponent+&apos; ...&apos;; SdShowMsg(sMsg, TRUE); // Fetch database connection information SQLRTGetConnectionInfo( &apos;oracle&apos;, szServer, szDB, szUser, szPassword ); nIndex = StrFind(szServer, &apos;:&apos;); nIndex = StrFindEx(szServer, &apos;/&apos;, nIndex); StrSub(sInstance, szServer, nIndex+1, 100); sCMD = WINSYSDIR^&apos;cmd.exe&apos;; sOPT = &apos; /c &apos;+&apos;sqlplus.exe -L -S &apos;+szUser+&apos;/&apos;+szPassword+&apos;@&apos;+sInstance; sOPT = sOPT+&apos; @&apos;+SRCDIR^szComponent+&apos;.sql &gt; &apos;+SRCDIR^&apos;dbstatus.txt 2&gt;&amp;1&apos;; // Execute the script associated with the given component in database nResult=LaunchAppAndWait(sCMD, sOPT, WAIT|LAAW_OPTION_HIDDEN); if (nResult &lt; 0) then MessageBox(&apos;Failed installing &apos;+szComponent+&apos; !&apos;, SEVERE); abort; endif; // 关闭安装提示 SdShowMsg(&apos;&apos;, FALSE); // 在dbstatus.txt中查询字符串holytail，如果存在，说明脚本已执行完 if (FileGrep(SRCDIR^&apos;dbstatus.txt&apos;, &apos;holytail&apos;, svLine, nIndex, RESTART) = 0) then // 在dbstatus.txt中查询字符串ORA-，如果存在，说明脚本执行出现错误 if (FileGrep(SRCDIR^&apos;dbstatus.txt&apos;, &apos;ORA-&apos;, svLine, nIndex, RESTART) = 0) then sMsg = &quot;更新数据库出错，点“是”打开日志文件并退出安装，点“否”直接退出安装。\\n&quot;; sMsg = sMsg+&quot;若错误可忽略，可选择数据库类型“none”以跳过数据库更新并直接更新程序，\\n&quot;; sMsg = sMsg+&quot;然后在数据库中手工执行SQL脚本（安装后保存在script目录下）&quot;; nResult = AskYesNo(sMsg, YES); if (nResult = YES) then LaunchApp(WINSYSDIR^&apos;notepad.exe&apos;, SRCDIR^&apos;dbstatus.txt&apos;); endif; abort; endif; else sMsg = &quot;更新数据库出错，点“是”打开日志文件并退出安装，点“否”直接退出安装。\\n&quot;; sMsg = sMsg+&quot;若错误可忽略，可选择数据库类型“none”以跳过数据库更新并直接更新程序，\\n&quot;; sMsg = sMsg+&quot;然后在数据库中手工执行SQL脚本（安装后保存在script目录下）&quot;; nResult = AskYesNo(sMsg, YES); if (nResult = YES) then LaunchApp(WINSYSDIR^&apos;notepad.exe&apos;, SRCDIR^&apos;dbstatus.txt&apos;); endif; abort; endif;end;总结 为便于获取脚本在数据库中的执行结果，故通过官方客户端执行脚本时通过符号“&gt;”将客户端的输出信息重定向到dbstatus.txt中；同时，使用“2&gt;&amp;1”将标准错误输出重定向到标准输出设备上，当然，会进一步重定向到dbstatus.txt文件中，否则，无法获取出错信息。 sqlplus执行SQL脚本后不会自动退出，故应在Oracle的脚本后加上语句“exit;”。 重载OnSQLComponentInstalled()函数，并在其中禁止MySQL和Oracle的SQL脚本对应的Component被执行安装，然后通过以上两个函数更新数据库。","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"SQL","slug":"sql","permalink":"http://0x3f.org/tags/sql/"},{"name":"数据库","slug":"数据库","permalink":"http://0x3f.org/tags/数据库/"},{"name":"MySQL","slug":"mysql","permalink":"http://0x3f.org/tags/mysql/"},{"name":"oracle","slug":"oracle","permalink":"http://0x3f.org/tags/oracle/"},{"name":"安装","slug":"安装","permalink":"http://0x3f.org/tags/安装/"},{"name":"客户端","slug":"客户端","permalink":"http://0x3f.org/tags/客户端/"},{"name":"InstallShield","slug":"installshield","permalink":"http://0x3f.org/tags/installshield/"}]},{"title":"使Thinkpad的静音按钮能被识别的方法","slug":"howto-make-thinkpad-mute-button-detected-on-linux","date":"2010-08-08T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-make-thinkpad-mute-button-detected-on-linux/","link":"","permalink":"http://0x3f.org/post/howto-make-thinkpad-mute-button-detected-on-linux/","excerpt":"","text":"我的型号是X200，问题表现为在GNOME或XFCE下静音按钮无效，使用xev也捕获不到输入信号，而音量增加和减小按钮可以正常使用且有OSD。 解决办法是在grub的启动菜单中，给内核加上参数acpi_osi=“Linux”，如： 12345# (0) Arch Linuxtitle Arch Linuxroot (hd0,2)kernel /boot/vmlinuz26 root=/dev/sda3 resume=/dev/sda4 ro acpi_osi=\"Linux\"initrd /boot/kernel26.img 从查到的资料看，acpi_osi参数是用来指定操作系统接口的，据说有些硬件都只针对Windows做了测试或优化，对于这些硬件，如果将内核的操作系统接口指定为Linux，则有可能会出问题。所以内核从2.6.23版本开始，此参数的默认值被改成了“!Linux”，以保证更广泛的兼容性和稳定性。 而根据这里的说法，thinkpad一直以来在对Linux的兼容程度上有很好的口碑，故可以放心添加这个参数。 另外，xfce下使用OSD需要安装xfce4-volumed。","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"},{"name":"GNOME","slug":"gnome","permalink":"http://0x3f.org/tags/gnome/"},{"name":"ThinkPad","slug":"thinkpad","permalink":"http://0x3f.org/tags/thinkpad/"},{"name":"内核","slug":"内核","permalink":"http://0x3f.org/tags/内核/"},{"name":"XFCE","slug":"xfce","permalink":"http://0x3f.org/tags/xfce/"},{"name":"桌面環境","slug":"桌面環境","permalink":"http://0x3f.org/tags/桌面環境/"}]},{"title":"swfdec：简单好用的Flash播放器","slug":"swfdec-as-a-slim-flash-player","date":"2010-07-31T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/swfdec-as-a-slim-flash-player/","link":"","permalink":"http://0x3f.org/post/swfdec-as-a-slim-flash-player/","excerpt":"","text":"早在keke童鞋的博客上见过，直到今天下載了个flash视频教程要看时才想起来，毕竟已经不是几年前Flash很火的时候了，为了降低CPU占用，我连Chromium的Flash插件都禁用了。 使用后的感觉就是简单实用，有暂停，有快进，能调进度，功能一样不多，一样不少。 要装两个包，swfdec是解码包，swfdec-gnome是播放器。 http://swfdec.freedesktop.org","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"GNOME","slug":"gnome","permalink":"http://0x3f.org/tags/gnome/"},{"name":"flash","slug":"flash","permalink":"http://0x3f.org/tags/flash/"},{"name":"多媒体","slug":"多媒体","permalink":"http://0x3f.org/tags/多媒体/"}]},{"title":"TTL线在Linux下的用法","slug":"usage-of-ttl-wire-on-linux","date":"2010-07-17T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/usage-of-ttl-wire-on-linux/","link":"","permalink":"http://0x3f.org/post/usage-of-ttl-wire-on-linux/","excerpt":"","text":"虽然由于我的H108B没有TTL引脚而无法通过TTL线登入猫的BusyBox系统，但TTL线在Linux下的使用方法仍然值得一叙，因为除此之外，它还有较为广泛的用途，例如为路由器刷OpenWRT系统等等。 TTL转USB端子是目前较为常见的此类设备，这得益于它的简单易用和便携性。在这类设备上最常见的就是台湾的Prolific Technology生产的PL2303： 这种芯片的驱动已被编译进Linux内核，如果使用的是较新版本的内核，则使用该芯片的TTL转USB端子会被自动识别，通常为/dev/ttyUSB0设备，使用lsusb命令可以查看： [lenin@archer ~]$ lsusbBus 008 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hubBus 007 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hubBus 006 Device 003: ID 067b:2303 Prolific Technology, Inc. PL2303 Serial PortBus 006 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub 将四根杜邦线连接到TTL转USB插头上，并接入相应设备的对应引脚。同一根线两端连接的引脚必须对应，另外，VCC引脚不能接线，否则会烧坏TTL转 USB芯片。 在计算机上使用串口通讯程序进行操控，常见的串口通讯程序有：minicom，microcom，picocom，tinyserial，xgcom。 以minicom为例，进入minicom的设置界面： sudo minicom -s 先设置默认的通讯设备为ttyUSB0并设置硬件流控制（Hardware Flow Control）为No： 保存为缺省设置： 启动minicom： sudo minicom 理论上说，此时即可和设备进行通讯了。 Windows下要安装相应芯片的驱动，通讯程序一般用SecureCRT。","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"内核","slug":"内核","permalink":"http://0x3f.org/tags/内核/"},{"name":"破解","slug":"破解","permalink":"http://0x3f.org/tags/破解/"},{"name":"驱动","slug":"驱动","permalink":"http://0x3f.org/tags/驱动/"}]},{"title":"网通ADSL猫开启路由和自动拨号功能的方法之二","slug":"howto-enable-routing-and-auto-dialing-for-unicom-adsl-modem-2","date":"2010-07-17T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-enable-routing-and-auto-dialing-for-unicom-adsl-modem-2/","link":"","permalink":"http://0x3f.org/post/howto-enable-routing-and-auto-dialing-for-unicom-adsl-modem-2/","excerpt":"","text":"之前提到过对华为HG522、HG527的超级用户的破解方法。网通附送的另一种猫，是中兴ZXV10 H108B无线猫，体积更小，而且天线是内置的。 上次的方法不能用在这个型号的猫上，但可以用ftp的方式破解。以下步骤基于Linux，并只在硬件版本为V1.1.02、软件版本为V1.1.02T18_N的H108B上测试通过： 使用普通用户进入猫的设置页面并开启FTP服务，将用户名和密码均设为admin 连接ftp服务器： ftp 192.168.1.1 输入用户名和密码，成功登录FTP服务器： [lenin@archer ~]$ ftp 192.168.1.1Connected to 192.168.1.1.220 Welcome to virtual FTP service.Name (192.168.1.1:lenin): admin331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; 切换到/etc目录并下載配置文件board.conf： cd ../cd etcget board.conf 如下所示： ftp&gt; cd ../250 Directory successfully changed.ftp&gt; cd etc250 Directory successfully changed.ftp&gt; get board.conf200 PORT command successful. Consider using PASV.150 Opening BINARY mode data connection for board.conf (39516 bytes).226 File send OK.39516 bytes received in 0.0496 seconds (796003 bytes/s)ftp&gt; 在下載到本地的board.conf中查找right，后跟0表示超级用户，若为1则表示普通用户，如下所示： 1234567891011&lt;row id=\"0\"&gt; &lt;item&gt;\"right\", \"0\"&lt;/item&gt; &lt;item&gt;\"username\", \"bjcnchgw\"&lt;/item&gt; &lt;item&gt;\"enable\", \"1\"&lt;/item&gt; &lt;item&gt;\"password\", \"bjcnchgw72915767\"&lt;/item&gt;&lt;/row&gt;&lt;row id=\"1\"&gt; &lt;item&gt;\"right\", \"1\"&lt;/item&gt; &lt;item&gt;\"username\", \"user\"&lt;/item&gt; &lt;item&gt;\"password\", \"mypasswd\"&lt;/item&gt;&lt;/row&gt; 在如下页面使用超级用户登录： http://192.168.1.1/cnc.html 进入“网络”→“宽带设置”页面，删除所有“连接名称”列出的连接（其中，TR069是网通远程控制猫并修改超级用户密码的连接；INTERNET被设置成了桥接，所以不能实现路由功能；另外两个应该是用来屏蔽第三、四个LAN口的。所以要全部删除。），并创建新的连接： 进入“网络”→“远程管理”页面，取消“周期上报功能”。 由于“用户管理”页面不提供超级用户改密码的功能，所以此时应下載最新的board.conf，修改里面的超级用户的密码，再上传到/etc目录，假设已登入FTP并切换到/etc目录下： ftp&gt; put board.conf200 PORT command successful. Consider using PASV.150 Ok to send data.226 File receive OK.39516 bytes sent in 0.0195 seconds (2026565 bytes/s)ftp&gt; 最后重启猫即可。 据说有使用TTL转USB线登入H108B的嵌入式Linux操作系统来破解超级用户的，但是我的猫的集成电路板上居然没有焊TTL引脚，显然H108B不只一个硬件版本，TTL线白买了。 以上照片出自G7+Camera360","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"日志","slug":"日志","permalink":"http://0x3f.org/tags/日志/"},{"name":"ADSL","slug":"adsl","permalink":"http://0x3f.org/tags/adsl/"},{"name":"wifi","slug":"wifi","permalink":"http://0x3f.org/tags/wifi/"},{"name":"密码","slug":"密码","permalink":"http://0x3f.org/tags/密码/"},{"name":"破解","slug":"破解","permalink":"http://0x3f.org/tags/破解/"},{"name":"ftp","slug":"ftp","permalink":"http://0x3f.org/tags/ftp/"}]},{"title":"Linux下pppoe连接建立后仍不能上网的问题","slug":"problem-on-pppoe-connections-on-linux","date":"2010-07-09T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/problem-on-pppoe-connections-on-linux/","link":"","permalink":"http://0x3f.org/post/problem-on-pppoe-connections-on-linux/","excerpt":"","text":"问题描述 pppoe可以连接，ifconfig可以看到ppp0接口，一切正常，只是不能上网。 解决办法 使用如下命令查看路由表： 1route 正常情况下返回的结果中应该有如下内容： default * 0.0.0.0 U 0 0 0 ppp0 如果没有，可手工添加： 1route add default dev ppp0 如果可以上网，就成功了。 使用如下脚本在pppoe连接成功时自动添加路由表项： 123456#!/bin/sh if ifconfig ppp0 &gt; /dev/null 2&gt;&amp;1 ; then route del default route add default dev ppp0fi 将上述内容保存成名为01-route.sh的文件，权限755，放到/etc/ppp/ip-up.d目录下。 然后创建以下两个脚本： 123456789101112#!/bin/bash if ifconfig ppp0 &gt; /dev/null 2&gt;&amp;1 ; then echo 'PPPOE has already been switched on !' exit 0fi off sudo ponsleep 5sudo /etc/ppp/ip-up 123456789#!/bin/bash if ! ifconfig ppp0 &gt; /dev/null 2&gt;&amp;1 ; then echo 'PPPOE has already been switched off !' exit 0fi sudo poffsudo /etc/ppp/ip-down 分别命名为on和off并复制到环境变量PATH下，以后即可使用这两个脚本建立和注销pppoe连接。 原因分析 问题的原因是pppoe连接建立时，没有自动往路由表中添加相关路由项。 一般情况下，如果使用的是ppp做pppoe连接，其配置文件中默认会开启defaultroute选项，该选项的作用就是在pppoe连接建立时自动添加路由表项，但在路由表中已经存在default项时，该操作将不会进行。 一般有两种情况会使路由表中在pppoe连接建立前就存在default项。一种情况是网络接口配置中设置了route，如在archlinux下，就是rc.conf文件中的gateway项。如果使用的是静态地址，则需要做这种配置，但对于大多数使用DHCP动态分配IP地址的情况，这项配置则不需要。另一种情况就是ADSL Modem自带路由功能，在分配IP给计算机时也会自动添加一条路由表项。","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"},{"name":"BASH","slug":"bash","permalink":"http://0x3f.org/tags/bash/"},{"name":"ADSL","slug":"adsl","permalink":"http://0x3f.org/tags/adsl/"}]},{"title":"网通ADSL猫开启路由和自动拨号功能的方法之一","slug":"howto-enable-routing-and-auto-dialing-for-unicom-adsl-modem-1","date":"2010-07-03T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-enable-routing-and-auto-dialing-for-unicom-adsl-modem-1/","link":"","permalink":"http://0x3f.org/post/howto-enable-routing-and-auto-dialing-for-unicom-adsl-modem-1/","excerpt":"","text":"北京网通送的无线猫有的是华为HG522，有的是HG527，屏蔽了路由和PPPOE自动拨号功能，须使用超级用户登入才能使用这些功能。 假设网关为默认的192.168.1.1，先使用普通用户登录，然后访问地址： http://192.168.1.1/downloadconfigfile.conf 下載该文件并搜索username，找到超级用户的用户名和密码，如： 1&lt;X_ATP_UserInfoInstance InstanceID=\"1\" Username=\"bjcnchgw\" Userpassword=\"bjcnchgw27852654\" Userlevel=\"2\" Busy=\"0\" LoginIP=\"\"/&gt; 在如下地址使用超级用户登录： http://192.168.1.1/cnc.html 设置内容如下图： 终于不用再忍受公共网络了……","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"日志","slug":"日志","permalink":"http://0x3f.org/tags/日志/"},{"name":"ADSL","slug":"adsl","permalink":"http://0x3f.org/tags/adsl/"},{"name":"wifi","slug":"wifi","permalink":"http://0x3f.org/tags/wifi/"},{"name":"密码","slug":"密码","permalink":"http://0x3f.org/tags/密码/"},{"name":"破解","slug":"破解","permalink":"http://0x3f.org/tags/破解/"}]},{"title":"cd到目录下后自动ls的方法","slug":"howto-do-auto-listing-after-changing-directory","date":"2010-06-19T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-do-auto-listing-after-changing-directory/","link":"","permalink":"http://0x3f.org/post/howto-do-auto-listing-after-changing-directory/","excerpt":"","text":"每cd到一个目录下就ls，这成了我的习惯。以下Bash函数和别名可以实现cd到一个目录下就自动执行ls命令： 12345cdl() &#123; cd \"$&#123;1&#125;\"; ls;&#125;alias cd=cdl 将上述内容添加到用户主目录中的.bashrc中即可。","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"BASH","slug":"bash","permalink":"http://0x3f.org/tags/bash/"},{"name":"Shell","slug":"shell","permalink":"http://0x3f.org/tags/shell/"}]},{"title":"Linux下使用freetds连接SQL Server","slug":"connect-to-sqlserver-using-freetds-on-linux","date":"2010-06-19T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/connect-to-sqlserver-using-freetds-on-linux/","link":"","permalink":"http://0x3f.org/post/connect-to-sqlserver-using-freetds-on-linux/","excerpt":"","text":"freetds是第三方、开源的数据库客户端和连接库，支持Sybase和Microsoft SQL Server，它最大的好处是允许非Windows平台的程序连接SQL Server。 freetds的编译和安装命令如下： 123./configure --with-tdsver=8.0 --enable-msdblibmakemake install configure的这两个参数是必不可少的，否则可能无法连接SQL Server。 安装后修改freetds.conf（一般应该在/usr/local/etc/freetds.conf），添加如下内容： [mysvr] host = 10.1.29.40 port = 1433 tds version = 8.0 client charset = utf-8 上述参数应根据实际情况修改。 最后使用如下命令测试连接： 1tsql -S mysvr -U sa -P 123456 给公司产品做Linux下的安装包，把开发环境放在了Cygwin中，非常享受在全屏、半透明的mintty下敲命令。今天发现在Cygwin下也是可以编译安装Linux下的程序的，只是效率非常低下。故上述内容对Cygwin环境同样成立。","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"数据库","slug":"数据库","permalink":"http://0x3f.org/tags/数据库/"},{"name":"安装","slug":"安装","permalink":"http://0x3f.org/tags/安装/"},{"name":"客户端","slug":"客户端","permalink":"http://0x3f.org/tags/客户端/"},{"name":"cygwin","slug":"cygwin","permalink":"http://0x3f.org/tags/cygwin/"},{"name":"编译","slug":"编译","permalink":"http://0x3f.org/tags/编译/"}]},{"title":"用JavaScript实现分页打印","slug":"howto-do-paged-printing-using-javascript","date":"2010-06-18T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-do-paged-printing-using-javascript/","link":"","permalink":"http://0x3f.org/post/howto-do-paged-printing-using-javascript/","excerpt":"","text":"最近客户提的一个需求，要实现分页打印功能。公司产品对打印功能实现得不够好，排版全由程序生成，耦合度高，且不支持分页，需要用笨拙的方法变通。 于是我对如何更好地实现分页打印产生了兴趣，Google了一下，整理了一个Demo： 123456789101112131415161718192021222324252627282930313233&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"/&gt; &lt;style media=print&gt; .Noprint&#123;display:none;&#125; .PageNext&#123;page-break-after: always;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;OBJECT id=WebBrowser classid=CLSID:8856F961-340A-11D0-A96B-00C04FD705A2 height=0 width=0 VIEWASTEXT&gt; &lt;/OBJECT&gt; &lt;div class=\"Noprint\"&gt; &lt;input onclick=document.all.WebBrowser.ExecWB(6,1) type=button value=打印 name=Button&gt; &lt;input onclick=document.all.WebBrowser.ExecWB(7,1) type=button value=打印预览 name=Button&gt; &lt;input onclick=document.all.WebBrowser.ExecWB(8,1) type=button value=页面设置 name=Button4&gt; &lt;/div&gt; &lt;div class=\"PageNext\"&gt; &lt;center&gt;&lt;h1&gt;雅游&lt;/h1&gt;&lt;/center&gt; &lt;p&gt;旧院人称曲中，前门对武定桥，后门在钞库街。妓家鳞次，比屋而居。屋宇精洁，花木萧疏，迥非尘境。&lt;/p&gt; &lt;p&gt;到门则铜环半启，珠箔低垂;升阶则猧儿吠客，鹦哥唤茶；登堂则假母肃迎，分宾抗礼；&lt;/p&gt; &lt;p&gt;进轩则丫鬟毕妆，捧艳而出；坐久则水陆备至，丝肉竞陈；定情则目眺心挑，绸缪宛转。&lt;/p&gt; &lt;p&gt;纨绔少年，绣肠才子，无不魂迷色阵，气尽雌风矣。&lt;/p&gt; &lt;p&gt;妓家，仆婢称之曰娘，外人呼之曰小娘，假母称之曰娘儿。&lt;/p&gt; &lt;p&gt;有客称客曰姐夫，客称假母曰外婆。&lt;/p&gt; &lt;/div&gt; &lt;div class=\"PageNext\"&gt; &lt;center&gt;&lt;h1&gt;木兰花令·拟古决绝词&lt;/h1&gt;&lt;/center&gt; &lt;center&gt;&lt;h3&gt;清·纳兰容若&lt;/h3&gt;&lt;/center&gt; &lt;p&gt;人生若只如初见，何事秋风悲画扇。等闲变却故人心，却道故人心易变!&lt;/p&gt; &lt;p&gt;骊山语罢清宵半，泪雨零铃终不怨。何如薄幸锦衣郎，比翼连枝当日愿!&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这个方法的好处是支持以低耦合的方式分页打印，同时支持只打印页面上指定的部分内容；缺点是由于使用了ActiveX，故只支持IE浏览器。","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"},{"name":"JavaScript","slug":"javascript","permalink":"http://0x3f.org/tags/javascript/"},{"name":"HTML","slug":"html","permalink":"http://0x3f.org/tags/html/"}]},{"title":"升级到wordpress3.0","slug":"after-upgrading-to-wordpress30","date":"2010-06-18T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/after-upgrading-to-wordpress30/","link":"","permalink":"http://0x3f.org/post/after-upgrading-to-wordpress30/","excerpt":"","text":"昨天发现wordpress3.0已经发布，就顺手升级了。 略看了一下更新内容，几乎没什么让我感兴趣的，但与MU版本的合并堪称WP历史上的一个里程碑，从此一套WP可以支持创建多个博客了。 但我最近几度都想把博客换到dokuwiki下。 自从开始用dokuwiki来组织知识和GTD以来，我对wiki产生了越来越深的痴迷，最主要的原因就是它可以用很简单的语法写出格式规整的文章，我几乎可以不用考虑排版布局而只需把注意力放在文章内容上就行了。而将wiki上的文章发到博客上时，还需要重写，比较浪费时间。 但我最终放弃这个想法，最主要的原因是博客文章太多了，截至现在已经有五百多篇且大多是用HTML写的，难以转换。何况WP作为一个博客系统较wiki有着天生的优势，使用较为方便，如果用wiki来做博客，要做不少工作。","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"},{"name":"wiki","slug":"wiki","permalink":"http://0x3f.org/tags/wiki/"},{"name":"WordPress","slug":"wordpress","permalink":"http://0x3f.org/tags/wordpress/"},{"name":"升级","slug":"升级","permalink":"http://0x3f.org/tags/升级/"},{"name":"日志","slug":"日志","permalink":"http://0x3f.org/tags/日志/"},{"name":"牧碼志","slug":"牧碼志","permalink":"http://0x3f.org/tags/牧碼志/"}]},{"title":"中轉feedburner訂閱數圖標","slug":"howto-display-feedburner-subscription-image","date":"2010-06-13T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-display-feedburner-subscription-image/","link":"","permalink":"http://0x3f.org/post/howto-display-feedburner-subscription-image/","excerpt":"","text":"利用國外服務器中轉feedburner的圖標： 12345678910111213141516171819&lt;?php/* * 将$fburl替换为自己的feedburner订阅数图片地址，然后将博客中的图片地址换成此脚本的URL即可 */$fburl = 'http://feeds.feedburner.com/~fc/leninlee?bg=99CCFF&amp;amp;fg=444444&amp;amp;anim=0';$fbfl = 'fb.gif';$fp = fopen($fburl, 'rb');if ($fp) &#123; $fp_local = fopen($fbfl, 'wb'); if ($fp_local) &#123; while (!feof($fp)) &#123; fwrite($fp_local, fread($fp, 1024*8), 1024*8); &#125; fclose($fp_local); &#125; fclose($fp);&#125;header('Location: '.$fbfl);?&gt; 或者： 1234&lt;?phpheader('Content-Type: image/gif');readfile('http://feeds.feedburner.com/~fc/leninlee?bg=99CCFF&amp;fg=444444&amp;anim=0');?&gt;","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"feedburner","slug":"feedburner","permalink":"http://0x3f.org/tags/feedburner/"}]},{"title":"低碳生活：使用 cpufrequtils降低CPU温度","slug":"using-cpufrequtils-to-reduce-cpu-temperature","date":"2010-06-10T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/using-cpufrequtils-to-reduce-cpu-temperature/","link":"","permalink":"http://0x3f.org/post/using-cpufrequtils-to-reduce-cpu-temperature/","excerpt":"","text":"cpufrequtils可以根据不同的方案自动调节CPU的频率，从而达到在系统空闲时降低CPU温度、节省电力的目的。 Archlinux官方wiki已经介绍得很明白了：http://wiki.archlinux.org/index.php/Cpufrequtils_(简体中文) 使用后效果明显，CPU温度有所下降，下面是cpufrequtils在Arch上的工作情况： 123456789101112131415161718192021222324252627[lenin@archer ~]$ cpufreq-info cpufrequtils 007: cpufreq-info (C) Dominik Brodowski 2004-2009Report errors and bugs to cpufreq@vger.kernel.org, please.analyzing CPU 0: driver: acpi-cpufreq CPUs which run at the same hardware frequency: 0 1 CPUs which need to have their frequency coordinated by software: 0 maximum transition latency: 10.0 us. hardware limits: 800 MHz - 2.53 GHz available frequency steps: 2.53 GHz, 2.53 GHz, 1.60 GHz, 800 MHz available cpufreq governors: ondemand, performance current policy: frequency should be within 800 MHz and 1.60 GHz. The governor &quot;ondemand&quot; may decide which speed to use within this range. current CPU frequency is 800 MHz.analyzing CPU 1: driver: acpi-cpufreq CPUs which run at the same hardware frequency: 0 1 CPUs which need to have their frequency coordinated by software: 1 maximum transition latency: 10.0 us. hardware limits: 800 MHz - 2.53 GHz available frequency steps: 2.53 GHz, 2.53 GHz, 1.60 GHz, 800 MHz available cpufreq governors: ondemand, performance current policy: frequency should be within 800 MHz and 1.60 GHz. The governor &quot;performance&quot; may decide which speed to use within this range. current CPU frequency is 1.60 GHz.","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"}]},{"title":"Inno Setup执行SQL脚本的方法","slug":"howto-execute-sql-scripts-in-inno-setup","date":"2010-05-16T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-execute-sql-scripts-in-inno-setup/","link":"","permalink":"http://0x3f.org/post/howto-execute-sql-scripts-in-inno-setup/","excerpt":"","text":"作为和NSIS并立的、两个最流行的免费Windows应用程序安装包制作工具之一，Inno在学习难度上相对要低一些，非常适合对一些简单的桌面程序打包。但对于较复杂的安装过程，或者Web应用程序来说，我个人觉得不是Inno的强项。当然，既然Inno内嵌了Pascal语言用以扩展功能，理论上不是不可以应付复杂的安装过程，但实现起来要复杂一些。 比如对于在安装过程中连接数据库并执行SQL脚本这样的需求，使用InstallShield应该会简单地多，而Inno却不支持直接操作数据库，并且相关的资料说明少之又少，还不如NSIS丰富，以至于我踏破铁鞋无觅处，最终却在NSIS的资料中找到了思路。 主要的思路是，在安装过程中，调用数据库客户端连接数据库并执行SQL脚本，然后将执行结果或错误信息输出到文件中，最后通过分析这个文件来判断命令执行的结果。但是，既然是调用特定的客户端，那么对不同数据库的操作自然就有所区别，具体情况如下所述。 首先在打包脚本的[Files]段将必需的文件包含进来： 12345678[Files]Source: \"D:\\Development\\MyDemoApp\\code\\*\"; DestDir: \"&#123;app&#125;\"; Flags: ignoreversion recursesubdirs createallsubdirsSource: \"D:\\Development\\MyDemoApp\\sqlcmd.exe\"; Flags: dontcopySource: \"D:\\Development\\MyDemoApp\\sqlcmd.rll\"; Flags: dontcopySource: \"D:\\Development\\MyDemoApp\\mysql.exe\"; Flags: dontcopySource: \"D:\\Development\\MyDemoApp\\script_mssql.sql\"; Flags: dontcopySource: \"D:\\Development\\MyDemoApp\\script_mysql.sql\"; Flags: dontcopySource: \"D:\\Development\\MyDemoApp\\script_oracle.sql\"; Flags: dontcopy 在SQL Server中执行脚本的代码片断： 1234567891011121314151617181920212223242526272829303132function ExecScriptInMSSQL(DBHost, DBLogin, DBPass, DBName: String): Boolean;var ConnectExe: String; ConnectParam: String;begin &#123;解压临时文件&#125; ExtractTemporaryFile('sqlcmd.exe'); ExtractTemporaryFile('sqlcmd.rll'); ExtractTemporaryFile('script_mssql.sql'); &#123;构造数据库连接字符串&#125; ConnectExe := ExpandConstant('&#123;tmp&#125;') + '\\sqlcmd.exe'; ConnectParam := ' -S ' + DBHost + ' -U ' + DBLogin + ' -P ' + DBPass + ' -d ' + DBName + ' -i script_mssql.sql -o ' + ExpandConstant('&#123;tmp&#125;') + '\\dbstatus.txt'; &#123;建立数据库连接并执行脚本&#125; if Exec(ConnectExe, ConnectParam, '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then begin Result := ResultCode = 0; LoadStringFromFile(ExpandConstant('&#123;tmp&#125;') + '\\dbstatus.txt', StatusString); if StatusString &lt;&gt; '' then begin MsgBox(StatusString, mbError, MB_OK); Result := False; end else begin Result := True; end; end else begin MsgBox('Database update failed:'#10#10 + SysErrorMessage(ResultCode), mbError, MB_OK); Result := False; end;end; 在MySQL中执行脚本的代码片断： 12345678910111213141516171819202122232425262728293031function ExecScriptInMYSQL(DBHost, DBLogin, DBPass, DBName: String): Boolean;var ConnectExe: String; ConnectParam: String;begin &#123;解压临时文件&#125; ExtractTemporaryFile('mysql.exe'); ExtractTemporaryFile('script_mysql.sql'); &#123;构造数据库连接字符串&#125; ConnectExe := ExpandConstant('cmd'); ConnectParam := ' /c \"' + ExpandConstant('&#123;tmp&#125;') + '\\mysql.exe' + ' -h' + DBHost + ' -u' + DBLogin + ' -p' + DBPass + ' -D' + DBName + ' -e \"source ' + ExpandConstant('&#123;tmp&#125;') + '\\script_mysql.sql\"\" &gt; ' + ExpandConstant('&#123;tmp&#125;') + '\\dbstatus.txt 2&gt;&amp;1'; &#123;建立数据库连接并执行脚本&#125; if Exec(ConnectExe, ConnectParam, '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then begin Result := ResultCode = 0; LoadStringFromFile(ExpandConstant('&#123;tmp&#125;') + '\\dbstatus.txt', StatusString); if StatusString &lt;&gt; '' then begin MsgBox(StatusString, mbError, MB_OK); Result := False; end else begin Result := True; end; end else begin MsgBox('Database update failed:'#10#10 + SysErrorMessage(ResultCode), mbError, MB_OK); Result := False; end;end; 由于mysql.exe没有输出结果到文件的参数，故需要使用cmd.exe来运行mysql.exe以便将其输出重定向到文件dbstatus.txt中。此外，在命令的最后加上参数2&gt;&amp;1，将标准错误输出设备也重定向到文件上，否则命令执行的错误信息不会输出到文件中。 在Oracle中执行脚本的代码片断： 1234567891011121314151617181920212223242526272829303132333435363738394041function ExecScriptInORACLE(ClientPath, DBInstance, DBLogin, DBPass: String): Boolean;begin &#123;解压临时文件&#125; ExtractTemporaryFile('script_oracle.sql'); &#123;连接数据库并执行脚本&#125; if Exec(ExpandConstant('cmd'), ' /c \"' + ClientPath + ' -L -S ' + DBLogin + '/' + DBPass + '@' + DBInstance + ' @' + ExpandConstant('&#123;tmp&#125;') + '\\script_oracle.sql &gt; ' + ExpandConstant('&#123;tmp&#125;') + '\\dbstatus.txt 2&gt;&amp;1', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then begin Result := ResultCode = 0; LoadStringFromFile(ExpandConstant('&#123;tmp&#125;') + '\\dbstatus.txt', StatusString); if Pos('holytail', StatusString) &lt;&gt; 0 then begin &#123;若输出信息中有“holytail”的子串，则表示脚本成功执行&#125; &#123;若执行有误，提示用户打开日志文件&#125; if Pos('ORA-', StatusString) &lt;&gt; 0 then begin &#123;提示用户脚本执行出错&#125; if MsgBox('数据库更新出错，是否打开日志文件？', mbConfirmation, MB_YESNO) = IDYES then begin &#123;打开日志&#125; if not ShellExec('', ExpandConstant('&#123;tmp&#125;') + '\\dbstatus.txt', '', '', SW_SHOW, ewNoWait, ErrorCode) then begin MsgBox('日志文件打开错误！', mbError, MB_OK); end; end; Result := False; &#123;若执行无误，返回True&#125; end else begin Result := True; end; end else if StatusString &lt;&gt; '' then begin MsgBox(StatusString, mbError, MB_OK); Result := False; end else begin Result := True; end; end else begin MsgBox('Database update failed:'#10#10 + SysErrorMessage(ResultCode), mbError, MB_OK); Result := False; end;end; Oracle的客户端太大，不能集成到安装包中，应使用一个TInputFileWizardPage由用户选择sqlplus.exe的安装位置。同时，由于sqlplus.exe也没有输出结果到文件的参数，也须使用cmd.exe来运行它并重定向输出到文件。此外，由于sqlplus.exe执行脚本时无论成功还是失败，都会输出信息，故无法像使用sqlcmd.exe和mysql.exe那样简单地判断脚本是否执行成功，需要在脚本的最后通过select语句输出一个特殊的字符串到文件中，然后通过判断dbstatus.txt中是否存在该字符串来判断脚本的执行情况；且由于sqlplus.exe执行完脚本后不会自动退出，还要在脚本最后加上exit语句；故script_oracle.sql的最后必须是如下内容： 12SELECT 'holytail' FROM dual;exit;","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Windows","slug":"windows","permalink":"http://0x3f.org/tags/windows/"},{"name":"数据库","slug":"数据库","permalink":"http://0x3f.org/tags/数据库/"},{"name":"MySQL","slug":"mysql","permalink":"http://0x3f.org/tags/mysql/"},{"name":"oracle","slug":"oracle","permalink":"http://0x3f.org/tags/oracle/"},{"name":"安装","slug":"安装","permalink":"http://0x3f.org/tags/安装/"},{"name":"客户端","slug":"客户端","permalink":"http://0x3f.org/tags/客户端/"}]},{"title":"FreeArc：兼顾压缩比率与效率的压缩程序","slug":"freearc","date":"2010-05-08T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/freearc/","link":"","permalink":"http://0x3f.org/post/freearc/","excerpt":"","text":"FreeArc的特点在于它在压缩比率与效率上取得了一个很好的平衡。传统的压缩程序则多偏重一点，要么占用系统资源低、速度快，但压缩比率小，如ZIP、RAR；要么压缩比率高，但占用系统资源大、速度慢，如7z。 把RAR归于前者只是相对而言，除了WinZip，没有哪个压缩工具能取得像WinRAR那样的成功。之所以能做到这一点，是因为WinRAR不但继承了WinZip易用的优点，还具有对多种压缩算法广泛的兼容度，最重要的是，RAR压缩算法在效率与比率之间取得了一个非常好的平衡。凭借这些优势，WinRAR一举推翻了WinZip的王座，直到现在，它都是这个领域值得学习的榜样。 早在7-Zip刚刚推出的时候，我就用过它。在压缩比率上，7z较RAR有着明显的优势，但在系统资源占用和压缩速度上，7z的表现非常不理想。最糟糕的是，如果你的机器配置较低，再加上你使用Windows系统，并且尤其喜欢使用图形界面的压缩工具，那7-zip对你来说就是一场恶梦，我曾经有过压缩一个较大的文件时进度条半天都不移动的经历。当然，在Windows命令行或Linux的终端中使用7-zip情况要好很多。此外，随着7-zip自身的完善和电脑配置的更新换代，这些劣势对7-zip普及的限制正逐渐弱化，事实上，我倾向于推荐用7-zip取代WinRAR，因为前者免费且有较大的压缩比率，而后者是收费的。 上周偶然发现的FreeArc，它的主页上居然宣称比最好的压缩工具都快1.5到3倍，并且同时拥有超高的压缩比率。于是我拿7-zip与之作了几个粗略的对比测试，发现虽然没有宣称的那么夸张，但在压缩同样的文件并使用同样的压缩级别时，FreeArc均比7-zip快一些，而压缩比率却要稍高于后者。甚至对于某些格式的文件，FreeArc的“普通”级别的压缩比率都比7-zip“最高”级别的大。 鉴于7-zip是资源占用大户，我非常怀疑在效率上FreeArc较WinRAR会有什么优势，更遑论快上1.5到3倍，但它的效率高于7-zip却是一个不争的事实，何况还有更高的压缩比率。此外，这次的测试中使用的操作系统和7-zip都是64位的，而FreeArc却是32位的，因此在效率的比试上会有不公平的地方。 当然，FreeArc自身的缺点也很大： 尚无64位版本 只支持Windows和Linux系统 不支持多卷压缩（分割压缩） 其它一些问题 如果能在较短的时间内解决这些问题，我认为FreeArc还是很有前景的。","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"数据压缩","slug":"数据压缩","permalink":"http://0x3f.org/tags/数据压缩/"}]},{"title":"SSL证书生成方法","slug":"howto-create-ssl-certificates","date":"2010-05-02T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/howto-create-ssl-certificates/","link":"","permalink":"http://0x3f.org/post/howto-create-ssl-certificates/","excerpt":"","text":"一般情况下，如果能找到可用的证书，就可以直接使用，只不过会因证书的某些信息不正确或与部署证书的主机不匹配而导致浏览器提示证书无效，但这并不影响使用。 需要手工生成证书的情况有： 找不到可用的证书 需要配置双向SSL，但缺少客户端证书 需要对证书作特别的定制 首先，无论是在Linux下还是在Windows下的Cygwin中，进行下面的操作前都须确认已安装OpenSSL软件包。 1. 创建根证书密钥文件root.key： 1openssl genrsa -des3 -out root.key 输出内容为： 1234567[lenin@archer ~]$ openssl genrsa -des3 -out root.keyGenerating RSA private key, 512 bit long modulus.................++++++++++++..++++++++++++e is 65537 (0x10001)Enter pass phrase for root.key: ← 输入一个新密码Verifying - Enter pass phrase for root.key: ← 重新输入一遍密码 2. 创建根证书的申请文件root.req： 1openssl req -new -key root.key -out root.req 输出内容为： 123456789101112131415161718192021[lenin@archer ~]$ openssl req -new -key root.key -out root.reqEnter pass phrase for root.key: ← 输入前面创建的密码You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CN ← 国家代号，中国输入CNState or Province Name (full name) [Some-State]:BeiJing ← 省的全名，拼音Locality Name (eg, city) []:BeiJing ← 市的全名，拼音Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名Organizational Unit Name (eg, section) []: ← 可以不输入Common Name (eg, YOUR name) []: ← 此时不输入Email Address []:admin@mycompany.com ← 电子邮箱，可随意填&lt;/p&gt;Please enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []: ← 可以不输入An optional company name []: ← 可以不输入&lt;/p&gt; 3. 创建一个自当前日期起为期十年的根证书root.crt： 1openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey root.key -in root.req -out root.crt 输出内容为： 12345[lenin@archer ~]$ openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey root.key -in root.req -out root.crtSignature oksubject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany Corp./emailAddress=admin@mycompany.comGetting Private keyEnter pass phrase for root.key: ← 输入前面创建的密码 4. 创建服务器证书密钥server.key： 1openssl genrsa -out server.key 2048 输出内容为： 12345[lenin@archer ~]$ openssl genrsa -out server.key 2048Generating RSA private key, 2048 bit long modulus....+++..................................................+++e is 65537 (0x10001) 5.创建服务器证书的申请文件server.req： 1openssl req -new -key server.key -out server.req 输出内容为： 1234567891011121314151617181920[lenin@archer ~]$ openssl req -new -key server.key -out server.reqYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CN ← 国家名称，中国输入CNState or Province Name (full name) [Some-State]:BeiJing ← 省名，拼音Locality Name (eg, city) []:BeiJing ← 市名，拼音Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名Organizational Unit Name (eg, section) []: ← 可以不输入Common Name (eg, YOUR name) []:www.mycompany.com ← 服务器主机名，若填写不正确，浏览器会报告证书无效，但并不影响使用Email Address []:admin@mycompany.com ← 电子邮箱，可随便填Please enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []: ← 可以不输入An optional company name []: ← 可以不输入 6. 创建自当前日期起有效期为期两年的服务器证书server.crt： 1openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in server.req -out server.crt 输出内容为： 12345[lenin@archer ~]$ openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in server.req -out server.crtSignature oksubject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany Corp./CN=www.mycompany.com/emailAddress=admin@mycompany.comGetting CA Private KeyEnter pass phrase for root.key: ← 输入前面创建的密码 7. 创建客户端证书密钥文件client.key： 1openssl genrsa -des3 -out client.key 2048 输出内容为： 1234567[lenin@archer ~]$ openssl genrsa -des3 -out client.key 2048Generating RSA private key, 2048 bit long modulus.........................................................................................+++......................................................................................................................+++e is 65537 (0x10001)Enter pass phrase for client.key: ← 输入一个新密码Verifying - Enter pass phrase for client.key: ← 重新输入一遍密码 8. 创建客户端证书的申请文件client.req： 1openssl req -new -key client.key -out client.req 输出内容为： 12345678910111213141516171819202122232425262728[lenin@archer ~]$ openssl genrsa -des3 -out client.key 2048Generating RSA private key, 2048 bit long modulus.........................................................................................+++......................................................................................................................+++e is 65537 (0x10001)Enter pass phrase for client.key:Verifying - Enter pass phrase for client.key:[lenin@archer ~]$ openssl req -new -key client.key -out client.reqEnter pass phrase for client.key: ← 输入上一步中创建的密码You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CN ← 国家名称，中国输入CNState or Province Name (full name) [Some-State]:BeiJing ← 省名称，拼音Locality Name (eg, city) []:BeiJing ← 市名称，拼音Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名Organizational Unit Name (eg, section) []: ← 可以不填Common Name (eg, YOUR name) []:Lenin ← 自己的英文名，可以随便填Email Address []:admin@mycompany.com ← 电子邮箱，可以随便填Please enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []: ← 可以不填An optional company name []: ← 可以不填 9. 创建一个自当前日期起有效期为两年的客户端证书client.crt： 1openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in client.req -out client.crt 输出内容为： 12345[lenin@archer ~]$ openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in client.req -out client.crtSignature oksubject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany Corp./CN=www.mycompany.com/emailAddress=admin@mycompany.comGetting CA Private KeyEnter pass phrase for root.key: ← 输入上面创建的密码 10. 将客户端证书文件client.crt和客户端证书密钥文件client.key合并成客户端证书安装包client.pfx： 1openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfx 输出内容为： 1234[lenin@archer ~]$ openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfxEnter pass phrase for client.key: ← 输入上面创建的密码Enter Export Password: ← 输入一个新的密码，用作客户端证书的保护密码，在客户端安装证书时需要输入此密码Verifying - Enter Export Password: ← 确认密码 11. 保存生成的文件备用，其中server.crt和server.key是配置单向SSL时需要使用的证书文件，client.crt是配置双向SSL时需要使用的证书文件，client.pfx是配置双向SSL时需要客户端安装的证书文件","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"SSL","slug":"ssl","permalink":"http://0x3f.org/tags/ssl/"},{"name":"安全","slug":"安全","permalink":"http://0x3f.org/tags/安全/"},{"name":"服務器","slug":"服務器","permalink":"http://0x3f.org/tags/服務器/"}]},{"title":"强大的工具函数库：php.js","slug":"phpjs","date":"2010-04-23T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/phpjs/","link":"","permalink":"http://0x3f.org/post/phpjs/","excerpt":"","text":"PHP最大的特点在于它拥有一个丰富、灵活、强大的函数库，因此得以机动灵活成为软件开发语言中的轻骑兵。 php.js是一个用Javascript实现的函数库，它试图用Javascript最大程度地重写PHP的函数库。相对于JQuery、ExtJS这些Javascript库，php.js不并致力于为AJAX、DOM和界面开发提供一揽子解决方案，它只是将PHP函数的强大和简便带到前端开发中来，由于JQuery这样的库并不旨在提供完全的Javascript开发标准和手段，实际上，它弥补了这些高端的工具库与低端的Javascript开发之间的一个空白。 对于熟悉PHP的人尤其是PHP程序员来说，使用php.js是几乎不需要切换思维方式的。 这是使用php实现的日期格式校验函数： 123456function IsValidDate($strDate, $strFormat='Y-m-d') &#123; $strDate = trim($strDate); $unixTime = strtotime($strDate); $strNewDate = date($strFormat, $unixTime); return $strDate == $strNewDate;&#125; 这是使用php.js实现的日期格式校验函数： 123456function IsValidDate(strDate, strFormat) &#123; strDate = trim(strDate); var unixTime = strtotime(strDate); var strNewDate = date(strFormat, unixTime); return strDate == strNewDate;&#125;","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"JavaScript","slug":"javascript","permalink":"http://0x3f.org/tags/javascript/"}]},{"title":"在Vim中检查语法和执行代码","slug":"syntax-checking-and-code-executing-in-vim","date":"2010-04-16T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/syntax-checking-and-code-executing-in-vim/","link":"","permalink":"http://0x3f.org/post/syntax-checking-and-code-executing-in-vim/","excerpt":"","text":"《The Pragmatic Programmer》的确是本好书，虽然中文译名极为恶俗。为践行书中提到的DRY原则，我开始反思平时编码时总是重复出现的问题，其中之一就是很低级的语法错误，有时忘了语句最后的分号，有时忘了声明变量，凡此种种，不一而足。 相对于IDE，我更喜欢Vim，这也是语法错误没有检查出来的原因。因此就产生了给Vim添加语法检查功能的需求。下面是检查PHP代码的vimrc内容： 1234567891011121314151617\" Check the syntax of a PHP filefunction! CheckPHPSyntax() if &amp;filetype != 'php' echohl WarningMsg | echo 'This is not a PHP file !' | echohl None return endif setlocal makeprg=php\\ -l\\ -n\\ -d\\ html_errors=off\\ % setlocal errorformat=%m\\ in\\ %f\\ on\\ line\\ %l echohl WarningMsg | echo 'Syntax checking output:' | echohl None if &amp;modified == 1 silent write endif silent make clistendfunctionau filetype php map &lt;F5&gt; :call CheckPHPSyntax()&lt;CR&gt;au filetype php imap &lt;F5&gt; &lt;ESC&gt;:call CheckPHPSyntax()&lt;CR&gt; 以上脚本为Vim添加了一个检查PHP语法错误的函数和两个快捷键映射，此后可按F5键即时检查当前Buffer中的PHP当面的语法。和网上其它同类的函数相比，这个函数的优点在于改进了检查结果的显示，使用silent命令隐藏了所有不必要的输出。 以下是检查Python代码语法错误的脚本： 1234567891011121314151617\" Check the syntax of a python filefunction! CheckPythonSyntax() if &amp;filetype != 'python' echohl WarningMsg | echo 'This is not a Python file !' | echohl None return endif setlocal makeprg=python\\ -u\\ % set efm=%C\\ %.%#,%A\\ \\ File\\ \\\"%f\\\"\\\\,\\ line\\ %l%.%#,%Z%[%^\\ ]%\\\\@=%m echohl WarningMsg | echo 'Syntax checking output:' | echohl None if &amp;modified == 1 silent write endif exec \"silent make -c \\\"import py_compile;py_compile.compile(r'\".bufname(\"%\").\"')\\\"\" clistendfunctionau filetype python map &lt;F5&gt; :call CheckPythonSyntax()&lt;CR&gt;au filetype python imap &lt;F5&gt; &lt;ESC&gt;:call CheckPythonSyntax()&lt;CR&gt; 上面两部分的配置脚本中虽然都指定了使用F5检查代码语法，但由于使用了au filetype指定了相应的语言类型，因此没有冲突。 和PHP相比，Python似乎更受垂青，因为除了上面和PHP一样的语法检查方式，它还有令人惊艳的PyFlakes 1。 PyFlakes的意思是Make on the fly，与另一神器Emacs的Flymake遥相呼应。只需要举出PyFlakes的两三个特性，就足以说明这是怎样的一个尤物了：其一是实时和高效，PyFlakes会在输入代码的同时检查语法错误，而且用户丝毫感觉不到任何停顿（对于游戏玩家或高清电影狂可能“卡”更好理解）；其二是智能，它居然能检查出哪些导入的模块没有被使用，哪些被使用的模块没有被导入；其三，PyFlakes检查出语法错误后会使用红色波浪线标识出错误位置。它使Vim完成了一个华丽的转身。 此外，由于PyFlakes是通过解析代码来检查语法错误，因此不必担心代码会被实际执行。 需要说明的是，PyFlakes要求Vim在编译时启用了对Python的支持，这一点可以使用:ver命令查看，一般各Linux发行版自带的Vim都加入了这个特性，而Windows下的版本没有此特性的可能性较大，好在作者提供了加入Python特性的Vim的Windows编译版。 既然事已如此，不妨一不做、二不休，为Vim加上即时执行代码的功能。这个想法由来已久，出于和寻找phpsh同样的原因，我希望能在Vim中临时输入小块代码，然后即时执行并查看结果；或者即时执行正在编写的Python模块或程序。以下脚本实现了随手打开一个新的分割窗口并创建一个临时的脚本文件的功能： 1234567891011121314151617181920212223\" Open a temporary PHP file in a new windowfunction! PHPSandBox() let tmpfile = tempname().'.php' exe 'new '.tmpfile call setline('.', '&lt;?php') normal o normal o call setline('.', '?&gt;') normal k startinsertendfunction\" Open a temporary Python file in a new windowfunction! PySandBox() let tmpfile = tempname().'.py' exe 'new '.tmpfile call setline('.', '#!/usr/bin/python') normal o call setline('.', '# -*- coding: utf-8 -*-') normal o startinsertendfunctionnmap &lt;leader&gt;sbpy :call PySandBox()&lt;CR&gt;nmap &lt;leader&gt;sbph :call PHPSandBox()&lt;CR&gt; 下面的脚本则实现了即时执行当前Buffer中代码的功能： 1234567891011121314151617181920212223242526272829303132333435\" Run a PHP scriptfunction! ExecutePHPScript() if &amp;filetype != 'php' echohl WarningMsg | echo 'This is not a PHP file !' | echohl None return endif setlocal makeprg=php\\ -f\\ % setlocal errorformat=%m\\ in\\ %f\\ on\\ line\\ %l echohl WarningMsg | echo 'Execution output:' | echohl None if &amp;modified == 1 silent write endif silent make clistendfunctionau filetype php map &lt;C-F5&gt; :call ExecutePHPScript()&lt;CR&gt;au filetype php imap &lt;C-F5&gt; &lt;ESC&gt;:call ExecutePHPScript()&lt;CR&gt;\" Run a python scriptfunction! ExecutePythonScript() if &amp;filetype != 'python' echohl WarningMsg | echo 'This is not a Python file !' | echohl None return endif setlocal makeprg=python\\ -u\\ % set efm=%C\\ %.%#,%A\\ \\ File\\ \\\"%f\\\"\\\\,\\ line\\ %l%.%#,%Z%[%^\\ ]%\\\\@=%m echohl WarningMsg | echo 'Execution output:' | echohl None if &amp;modified == 1 silent write endif silent make clistendfunctionau filetype python map &lt;C-F5&gt; :call ExecutePythonScript()&lt;CR&gt;au filetype python imap &lt;C-F5&gt; &lt;ESC&gt;:call ExecutePythonScript()&lt;CR&gt; Foot Note 1 : PyFlakes本身是个通用的工具，其作者提供了一个Vim的插件调用PyFlakes的功能，故此处所说的PyFlakes实指Vim的PyFlakes插件。","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"IDE","slug":"ide","permalink":"http://0x3f.org/tags/ide/"},{"name":"Plugin","slug":"plugin","permalink":"http://0x3f.org/tags/plugin/"}]},{"title":"Buuf-Deuce：搞怪的图标主题","slug":"buuf-deuce-icon-theme","date":"2010-04-09T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/buuf-deuce-icon-theme/","link":"","permalink":"http://0x3f.org/post/buuf-deuce-icon-theme/","excerpt":"","text":"发现这个图标主题有段时间了，但直到今天偶然重新启用它，才突然觉得这套色调灰暗、风格搞怪的图标其实整体效果很好，很有个性，且极为闷骚，实为标榜非主流人士居家旅行必备。","categories":[],"tags":[{"name":"美化","slug":"美化","permalink":"http://0x3f.org/tags/美化/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"GNOME","slug":"gnome","permalink":"http://0x3f.org/tags/gnome/"}]},{"title":"Archlinux升级到GNOME2.30后的光标主题问题","slug":"problem-about-icon-theme-on-gnome230","date":"2010-04-03T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/problem-about-icon-theme-on-gnome230/","link":"","permalink":"http://0x3f.org/post/problem-about-icon-theme-on-gnome230/","excerpt":"","text":"Archlinux下的GNOME升级到2.30后，若启用了Compiz，则光标主题只能使用X默认的主题，无法自定义。尚不清楚是GNOME新版本自身的问题还是仅限于Arch发行版。 在官方提供解决方案或更新之前，可以先使用Xdefault或Xresource文件实现。 以后者为例，编辑用户主目录下的.Xresource，在文件最后添加如下内容： Xcursor.theme: faber-anthracite-shd-m faber-anthracite-sdh-m是我使用的光标主题的文件夹名。 然后执行如下命令： xrdb ~/.Xresource 最后注销并重新登录即可。","categories":[],"tags":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"},{"name":"GNOME","slug":"gnome","permalink":"http://0x3f.org/tags/gnome/"}]},{"title":"phpsh：PHP的交互式解释器","slug":"phpsh","date":"2010-03-28T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/phpsh/","link":"","permalink":"http://0x3f.org/post/phpsh/","excerpt":"","text":"时常需要测试一些简短的代码是否能得到需要的结果，如果去写测试脚本再执行，显然太麻烦。虽然PHP自身也支持通过-a参数启动交互模式，但功能较为局限。如果PHP有像bpython那样的交互式解释器，就太好了。 phpsh就是这样一个工具，它是由facebook的开发者用Python实现的PHP的交互式解释器，并具备以下特性： 命令行历史回溯 tab键自动补全 快速文档索引","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"CLI","slug":"cli","permalink":"http://0x3f.org/tags/cli/"}]},{"title":"使用cx_Freeze的distutils脚本打包Python程序","slug":"cx-freeze","date":"2010-03-25T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/cx-freeze/","link":"","permalink":"http://0x3f.org/post/cx-freeze/","excerpt":"","text":"cx_Freeze打包Python程序的命令基本格式如下： 1cxfreeze main.py --target-dir appdir 它表示把脚本main.py或以main.py为程序入口的程序打包并导出到当前路径中名为appdir的目录中。 对于Windows下的GUI应用程序，以上面的命令导出后，运行时会弹出cmd命令行的黑窗口，须加上如下命令中的参数： 1cxfreeze main.py --target-dir appdir --base-name=win32gui 对于比较复杂的程序，cx_Freeze支持distutils格式的打包脚本，当然，彼此之间在引入的模块和支持的参数上还是有差别的。 cx_Freeze的文档中有其支持的全部命令参数及说明，写到setup.py脚本中时，所有参数中的-符号应换成下划线。 我的setup.py内容大致如下： 1234567891011121314151617181920212223242526#!/usr/bin/python# -*- coding: utf-8 -*-from cx_Freeze import setup,Executableincludefiles = [('settings.ini.jctest','settings.ini') ,'README.mkd']includes = []excludes = ['Tkinter']packages = ['sqlalchemy.engine', 'sqlalchemy.orm', 'sqlalchemy.dialects.mssql']setup( name = 'pyutil', version = '0.1', description = 'A general enhancement utility for XXX', author = 'Lenin Lee', author_email = 'lenin.lee@xxx.com', options = &#123;'build_exe':&#123;'excludes':excludes,'packages':packages,'include_files':includefiles&#125;&#125;, executables = [Executable('jcitk.py') , Executable('jcvfd.py') , Executable('jcvdupcr.py') , Executable('jcddupcr.py') , Executable('jcclostfd.py') , Executable('jcvcard.py') , Executable('jcvcardii.py') , Executable('jcclostsoid.py')]) 在摸索如何写setup.py的过程中，遇到一些问题。 首先是如何将配置文件settings.ini自动复制到打包文件夹中。这个问题的解决办法是使用build_exe命令的参数include_files。此参数的值是一个列表，列表的每一项可以是一个表示要复制的文件的路径的字符串，或者是一个tuple。若是tuple，第一个元素是表示要复制的文件的路径，第二个元素是表示复制后要修改成的文件名。需要说明的是，文件夹可以和文件一样使用这样的方法复制到打包文件夹中。 其次，在打包引入了SQLAlchemy的程序后，若运行该程序时报某模块导入失败的错，应将报错信息中提示的模块所在的包填写到packages参数中。虽然也可以在程序中import这些包，但是在setup.py中使用packages参数的做法更合理。而且如果在程序中导入了没有被显式调用的模块或包的话，对于使用pyflakes检查语法错误的环境，会显示模块或包未被调用的警告，至少看起来不舒服。 再次，Windows下打包时应使用python 2.5，因为2.6版本需要Microsoft Visual C++ 2008 Redistributable，一般非开发环境的系统中都没安装这个，运行程序时就会报错。","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"SQLAlchemy","slug":"sqlalchemy","permalink":"http://0x3f.org/tags/sqlalchemy/"},{"name":"wxPython","slug":"wxpython","permalink":"http://0x3f.org/tags/wxpython/"}]},{"title":"开始玩儿茶道","slug":"starting-tea-ceremony","date":"2010-03-19T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/starting-tea-ceremony/","link":"","permalink":"http://0x3f.org/post/starting-tea-ceremony/","excerpt":"","text":"前年买了个倒把小西施开始喝茶，渐渐地就觉得喝茶的趣味一半在茶，一半在泡。这周买了茶盘、茶道组等一应物件儿，直到周五晚上才有时间过把瘾。怕睡不着觉，没敢泡生茶，新开了一饼易武大树熟茶。","categories":[],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"生活","slug":"生活","permalink":"http://0x3f.org/tags/生活/"},{"name":"茶道","slug":"茶道","permalink":"http://0x3f.org/tags/茶道/"},{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/tags/青梅煮酒/"}]},{"title":"SQL Server的自定义函数：统计两日期之间工作日的数量","slug":"counting-days-between-dates-in-sqlserver","date":"2010-03-12T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/counting-days-between-dates-in-sqlserver/","link":"","permalink":"http://0x3f.org/post/counting-days-between-dates-in-sqlserver/","excerpt":"","text":"前段时间工作中遇到的一个需求，要求计算两个日期之间工作日的数量，即排除期间所有的周六和周日之后的天数。 在网上找到一个自定义函数，原函数有些小问题，例如如果传入的截止日期如果有时间且足够大，则计算结果可能出错，修正后代码如下： 12345678910111213141516171819202122232425262728293031--函数：类似datediff，不统计期间所有的周六和周日if exists (select * from dbo.sysobjects where id=object_id(N'[dbo].[f_WorkDay]') and xtype in (N'FN',N'IF',N'TF')) drop function [dbo].[f_WorkDay] GOCREATE FUNCTION f_WorkDay(@dt_begin datetime,@dt_end datetime )RETURNS int AS BEGIN DECLARE @workday int,@i int,@bz bit,@dt datetime set @dt_begin = convert(datetime, convert(nvarchar(32), @dt_begin, 23)) set @dt_end = convert(datetime, convert(nvarchar(32), @dt_end, 23)) IF @dt_begin&gt;@dt_end SELECT @bz=1,@dt=@dt_begin,@dt_begin=@dt_end,@dt_end=@dt ELSE SET @bz=0 SELECT @i=DATEDIFF(Day,@dt_begin,@dt_end),@workday=@i/7*5,@dt_begin=DATEADD(Day,@i/7*7,@dt_begin) WHILE @dt_begin&lt;@dt_end BEGIN SELECT @workday=CASE WHEN (@@DATEFIRST+DATEPART(Weekday,@dt_begin)-1)%7 BETWEEN 1 AND 5 THEN @workday+1 ELSE @workday END,@dt_begin=@dt_begin+1 END RETURN(CASE WHEN @bz=1 THEN -@workday ELSE @workday END) END GO 此函数的原理是，使用datediff计算两日期之间的差值A，然后取A与7的商，即计算期间内有几个整周。然后使用这个商与5相乘，得到所有整周内的工作日天数B。接着，使用A除以7再乘以7得到C，这就约去了A中最后不到一个整周的天数。再在起始日期的基础上加上C，得到一个新的起始日期，然后从这个新的起始日期开始遍历至截止日期的每一天，每增加一天，判断若此日期是工作日，则在C的基础上累加一。判断一个日期（假设使用@dt_begin表示）是否是工作日的方法是：(@@datefirst+datepart(Weekday, @dt_begin)-1)%7的值在1和5之间。 此外还有一个需求是计算两个日期之间排除最后一个周六周日后的天数，仿照上面的函数实现了一个新函数，现在想来，有点儿把问题复杂化了，完全可以直接从后往前推的。 123456789101112131415161718192021222324252627282930313233343536373839404142--函数：类似datediff，不统计截止日期@dt_end前最近一次的周六和周日，若dt_end是周日，则不统计其前面的那个周六。if exists (select * from dbo.sysobjects where id=object_id(N'[dbo].[f_WorkDayOnce]') and xtype in (N'FN',N'IF',N'TF')) drop function [dbo].[f_WorkDayOnce]GOCREATE FUNCTION f_WorkDayOnce(@dt_begin datetime,@dt_end datetime )RETURNS int AS BEGIN DECLARE @day_count int,@weekday int,@weekend_dropped int,@i int,@bz bit,@dt datetime set @dt_begin = convert(datetime, convert(nvarchar(32), @dt_begin, 23)) set @dt_end = convert(datetime, convert(nvarchar(32), @dt_end, 23)) IF @dt_begin&gt;@dt_end SELECT @bz=1,@dt=@dt_begin,@dt_begin=@dt_end,@dt_end=@dt ELSE SET @bz=0 SELECT @i=DATEDIFF(Day,@dt_begin,@dt_end),@weekday=(@@datefirst+datepart(weekday,@dt_end)-1)%7,@day_count=@i,@weekend_dropped=0 if @i=0 set @day_count=0 else begin if @weekday=0 set @day_count=@i-1 else begin while @dt_begin&lt;@dt_end and @weekend_dropped&lt;2 begin select @weekend_dropped=@weekend_dropped+(case when (@@datefirst+datepart(weekday,@dt_begin)-1)%7 between 1 and 5 then 0 else 1 end),@dt_begin=@dt_begin+1 end select @day_count=@day_count-@weekend_dropped end end RETURN(CASE WHEN @bz=1 THEN -@day_count ELSE @day_count END) END GO","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://0x3f.org/tags/算法/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"SQL","slug":"sql","permalink":"http://0x3f.org/tags/sql/"},{"name":"数据库","slug":"数据库","permalink":"http://0x3f.org/tags/数据库/"}]},{"title":"Python控制外部进程的灵异事件","slug":"supernatural-phenomenon-of-controlling-external-processes-in-python","date":"2010-03-07T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/supernatural-phenomenon-of-controlling-external-processes-in-python/","link":"","permalink":"http://0x3f.org/post/supernatural-phenomenon-of-controlling-external-processes-in-python/","excerpt":"","text":"春节前的一段时间，重新拾起近一年没动过的ForeverFantasy。 虽然一年内没什么更新，但是我却一直都在用，基本上只限于将用Vim写好的Markdown格式的文档转换成HTML。 重写了相当一部分代码，较大程度地改变了界面布局，突然发现经过一年的沉淀，对wxPython的理解增进了不少，开发起来比起去年这个时候清楚了很多。 这些天来一直坚持着每天或多或少的做一些，如果说有什么主要的进展的话，那就是界面的重构，以及昨天实现了调用Vim编辑文档并回收文档内容的功能。 ForeverFantasy和Vim协同的一个最大的问题就是如何判断Vim已经退出。Python调用外部程序的方法有很多，比如传统的commands模块、os.system()等，subprocess是致力于替代这些旧有的方式的一个模块，它的一个特点是可以在启动一个外部程序作为子进程后还能监控这个进程的运行状态。这为ForeverFantasy在Vim退出后回收文档内容提供了更简捷的途径。 下面的代码可以说明如何使用subprocess运行外部程序并监控运行状态： 1234567import subprocessprocess = subprocess.Popen('gvim', shell=True)status = process.poll()if 0 == status: print 'The external program exited.'if status is None: print 'The external program is still running.' 理论上，可以拿实例process的poll()方法监视进程的运行状态，而且这一点在Windows上也确实可以做到，但是到了Linux下，诡异的事出现了，即使刚刚打开gvim，poll()方法也会马上返回一个0，同时process.pid的值总是和实际在运行的那个gvim进程的pid的值差3，而且在虚拟终端中输入gvim命令也不会阻塞终端，就像别的命令加上“&amp;”符号的效果一样。尝试用strace跟踪gvim的运行，试图找到问题原因，无果。我猜想可能/usr/bin/gvim是一个跳板，它启动后会启动一个新的gvim进程。总之，这个方法在Linux下是行不通的。 因此我觉得只能另寻出路了，既然不能监控gvim进程，那就监控gvim进程所编辑的文件，只要这个文件不被任何进程占用，就可以判定gvim已退出。这一点，在Linux下易如反掌，不用说，lsof当仁不让。 用commands.getstatusoutput('lsof file.txt')测试发现，如果文件file.txt被某进程占用，则返回的状态值为0，反之，返回256。 最终，我在程序中使用了两种判断方式，在Windows平台使用subprocess跟踪gvim.exe进程，而在Linux及Unix平台使用lsof检查文档占用情况。 剩下的就是进行这个判断的时间问题了。 很显然，如果在子进程被启动后马上使用while循环不停的检查，一来必须使用多线程，二来系统资源占用也会很高。这时就需要利用wxPython的事件机制了，当ForeverFantasy启动Gvim时，主窗口失去焦点，而当Gvim退出时，ForeverFantasy又会获得焦点，只要能在ForeverFantasy窗口获得焦点时做一次检查即可。不过，在选择最合适的事件的问题上，又是一波三折。 在wxPython的API文档中没有找到事件列表，倒是在Wiki中找到了。顾名思义，觉得wx.EVT_SET_FOCUS比较靠谱，但试用失败，看API中关于FocusEvent的说明，这个事件适用于窗口控件；然后又试了wx.EVT_CHILD_FOCUS，只有在窗口包含的控件中有获得焦点的情况才会触发；最后才发现wx.EVT_ACTIVATE，这个事件会在窗口失去焦点和获得焦点时各触发一次，使用GetActive()方法可以判断是获得焦点还是失去焦点。 完成与Vim的协同使ForeverFantasy在我手上由原来单纯的格式转换工具进化为基本可用的文档编辑器，就算是Milestone 2吧。 此外，还有一些小的经验： 1. 调用非环境变量下的程序，即命令中必须带程序所在的路径时，应当将程序所在目录的完整路径以自然字符串的形式传递给subprocess.Popen类的构造方法的cwd参数，即如下所示： 1process = subprocess.Popen('gvim.exe', cwd=r'C:\\program files\\vim\\vim72', shell=True) 这样可以有效避免路径中的空格和特殊字符对命令执行的影响。 2. Vim编辑一个文档时，实际操作的是一个临时文件，而不是原文件，这个临时文件与原文件同路径，名称为在原文件名的基础上，前面加一个句点，后面加后缀“.swp”。应该用lsof监控这个临时文件，才可以判断出编辑该文档的Vim进程的运行状态。由于对于不存在的文件使用lsof命令的返回值也是256，故可以同时判断临时文件和原文件的占用情况，这样就为对其它编辑器的支持奠定了基础。 2010-03-10 Wednesday 22:52:13 更新 感谢KL童鞋和依云童鞋指教，果然加上-f参数就可以了。","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"},{"name":"ForeverFantasy","slug":"foreverfantasy","permalink":"http://0x3f.org/tags/foreverfantasy/"},{"name":"Markdown","slug":"markdown","permalink":"http://0x3f.org/tags/markdown/"},{"name":"wxPython","slug":"wxpython","permalink":"http://0x3f.org/tags/wxpython/"},{"name":"博客","slug":"博客","permalink":"http://0x3f.org/tags/博客/"},{"name":"文本编辑器","slug":"文本编辑器","permalink":"http://0x3f.org/tags/文本编辑器/"}]},{"title":"Vim的終極自動補全插件：NeoComplCache","slug":"neocomplcache-vim","date":"2010-02-26T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/neocomplcache-vim/","link":"","permalink":"http://0x3f.org/post/neocomplcache-vim/","excerpt":"","text":"關于自動補全，最初用的是SuperTab，那個時候Vim的自動補全插件寥寥無幾，也就SuperTab比較有名。不過實際使用過程中這個插件給我的體驗不是很好，原因是補全的準确度不高。 後來出了一個新插件，AutoComplPop，功能和使用都很簡單。但是很快我就又用回SuperTab，原因是AutoComplPop在輸入的同時實時地查詢匹配的關鍵詞，導緻輸入極不流暢，效率很低。 一直就這麽湊合着用着SuperTab，随着這個插件版本的更新，舊功能不斷地完善，新功能也接二連三地引入，SuperTab在匹配關鍵詞的準确度上有了一些改善，但是新的問題又出現了。SuperTab後來加入一個新功能，對于程序源文件，可以在其引入的文件以及API文件中匹配關鍵詞。比如假設我當前正在編輯a.php，在a.php中有include ‘b.php’;這樣的語句，當我輸入array并按下Tab鍵時，SuperTab不但會在當前文件中查詢所有匹配項，還會到b.php中查詢，如果配置過vim、指定一個包含了php的API的文件，則SuperTab還會自動從這個文件中查詢匹配項。按理說這個功能的理念很好，但問題就在于SuperTab做的是實時查詢，如果源文件中包含的文件較多，各個文件又較大，問題就顯而易見了。我不得不在寫程序時小心地使用Tab鍵，否則有時就會出現按一下Tab鍵然後等着Vim在那狂搜的情況。 前兩天發現了NeoComplCache，光看名字就讓我有點兒興奮，一般使用緩存的速度都很快。這個插件會在Vim打開文件的時候對上下文作一個索引，并把索引結果保存到緩存中。同時，文件更改的内容會在保存的時候被索引。此外，NeoComplCache支持多種關鍵詞索引模式，例如它會判斷當前路徑下的文件或目錄的名字是否匹配補全條件，也可以從緩存的程序語言API中匹配補全條件。到此爲止，它就解決了SuperTab和AutoComplPop共同的效率問題，并具備它們各自的長處。看了一遍文檔，發現這個插件的功能比較細緻，大概有以下一些特點： 1、使用緩存，自動補全時效率高；2、生成的關鍵詞列表準确；3、支持下劃線分割的關鍵詞，如apple_boy_cat，就可以隻輸入a_b_c，然後補全；4、支持駝峰格式匹配關鍵詞，如AppleBoyCat，就可以隻輸入ABC，然後補全；5、既可以像AutoComplPop那樣在Vim中輸入的同時自動彈出補全列表，又可以自定義快捷鍵手動觸發；6、支持從文件名和目錄名中匹配補全條件；7、對于程序源文件，支持從語言API中匹配補全條件； NeoComplCache的缺點是文檔不全，雖然從隻言片語中發現它還支持Snippet，但從文檔中沒有找到足夠的有用信息。加之一直用SnipMate感覺不錯，所以目前還是用它來實現snippet功能。 這就有個搭配問題：雖然NeoComplCache不存在補全時的效率問題，但我仍然打算隻在需要補全時才用快捷鍵觸發此功能，最主要的原因是我既希望用Tab鍵觸發SnipMate的代碼塊補全功能，又希望修SuperTab那樣用Tab選擇補全列表中的選項。也就是要達到隻用Tab鍵就可以完成打開自動補全列表、補全列表選項選擇和SnipMate代碼塊替換的效果。但是，如果将Tab映射到觸發自動補全，則補全列表選擇和SnipMate均無法使用Tab，反之亦然。 所以我想如果能讓NeoComplCache、SuperTab、SnipMate和諧共存，那問題就解決了，幾經摸索，終于找到了辦法： 1、設置NeoComplCache不自動彈出補全列表，即在vimrc中加入： let g:NeoComplCache_DisableAutoComplete = 1 2、由于NeoComplCache在手工模式下使用快捷鍵組合&lt;C-X&gt;&lt;C-U&gt;打開補全列表，故設置SuperTab的默認補全操作爲&lt;C-X&gt;&lt;C-U&gt;，即在vimrc中加入： let g:SuperTabDefaultCompletionType = ‘&lt;C-X&gt;&lt;C-U&gt;‘ 這樣，NeoComplCache隻負責補全關鍵詞緩存的生成，SuperTab控制Tab鍵的行爲并在需要觸發補全操作時打開補全列表、進而在列表中的選項間移動焦點，而當光标前的關鍵詞是snippet時，SnipMate會被優先調用并完成代碼塊的替換。 就在寫這篇文章的時候，我突然覺得NeoComplCache自動彈出補全列表+SnipMate的方式也挺好，隻是這樣就不能用Tab鍵選擇列表中的選項了。 相關閱讀： 用neocomplete換掉了YouCompleteMe How to Make YouCompleteMe Compatible with UltiSnips","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"},{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"}]},{"title":"SQLAlchemy操作SQL Server的中文问题","slug":"chinese-problem-of-sqlalchemy-with-sqlserver","date":"2010-02-23T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/chinese-problem-of-sqlalchemy-with-sqlserver/","link":"","permalink":"http://0x3f.org/post/chinese-problem-of-sqlalchemy-with-sqlserver/","excerpt":"","text":"最初将脚本的文件编码和coding行都设定为UTF-8，在windows下执行时，中文无法保存，报编码错误。将上述两个编码改为GBK后，保存正常，但查询时报错。 Traceback内容如下： 1234567891011121314151617181920Traceback (most recent call last):File &quot;test.py&quot;, line 36, in &lt;code&gt;&amp;lt;module&amp;gt;&lt;/code&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for obj in session.query(User):File &quot;C:\\Python26\\lib\\site-packages\\sqlalchemy-0.6beta1-py2.6.egg\\sqlalchemy\\orm\\query.py&quot;, line 1411, in instances&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rows = [process[0](row, None) for row in fetch]File &quot;C:\\Python26\\lib\\site-packages\\sqlalchemy-0.6beta1-py2.6.egg\\sqlalchemy\\orm\\mapper.py&quot;, line 1788, in _instance&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;populate_state(state, dict_, row, isnew, only_load_props)File &quot;C:\\Python26\\lib\\site-packages\\sqlalchemy-0.6beta1-py2.6.egg\\sqlalchemy\\orm\\mapper.py&quot;, line 1677, in populate_state&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;populator(state, dict_, row, isnew=isnew, **flags)File &quot;C:\\Python26\\lib\\site-packages\\sqlalchemy-0.6beta1-py2.6.egg\\sqlalchemy\\orm\\strategies.py&quot;, line 118, in new_execute&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dict_[key] = row[col]File &quot;C:\\Python26\\lib\\site-packages\\sqlalchemy-0.6beta1-py2.6.egg\\sqlalchemy\\engine\\base.py&quot;, line 1634, in __getitem__&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return self.__colfuncs[key][0](self.__row)File &quot;C:\\Python26\\lib\\site-packages\\sqlalchemy-0.6beta1-py2.6.egg\\sqlalchemy\\engine\\base.py&quot;, line 1716, in getcol&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return processor(row[index])File &quot;C:\\Python26\\lib\\site-packages\\sqlalchemy-0.6beta1-py2.6.egg\\sqlalchemy\\types.py&quot;, line 568, in process&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return decoder(value)[0]File &quot;C:\\Python26\\lib\\encodings\\utf_8.py&quot;, line 16, in decode&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return codecs.utf_8_decode(input, errors, True)UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)&lt;/p&gt; 环境为： OS：Windows XP简体中文版 DB：SQL Server 2008 Express简体中文版 DB模块：pyodbc 脚本文件编码：GBK 脚本coding行：GBK 脚本内容： 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/python# -*- encoding: gbk -*-from sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmakerfrom sqlalchemy import Column, Integer, String, Text, ForeignKey, Numeric, UnicodeBase = declarative_base()class User(Base): \"\"\"User class\"\"\" __tablename__ = 'users' id = Column(Numeric(22,0), primary_key=True) name = Column(Unicode(128), nullable=False, unique=True) def __init__(self, id, name): self.id = id self.name = nameif __name__ == '__main__': db_engine = create_engine('mssql://sa:password@localhost/mydatabase', echo=True) Session = sessionmaker(bind=db_engine) session = Session() Base.metadata.drop_all(db_engine) Base.metadata.create_all(db_engine) jim = User(1, '中文') session.add(jim) session.commit() ''' for obj in session.query(User): print obj.name ''' 上面的脚本执行后，数据得以正常保存，在数据库中的查询结果也正常，没有乱码。但是，当把从drop_all()到commit()行注释掉，取消for循环前后的多行字符串起止符后，即运行查询时，抛出上面的Traceback。 Google了很长时间，没有找到有用的东西。CPyUG更没指望。 回溯Traceback，打开sqlalchemy的types.py，UnicodeEncodeError的抛出点在String类的result_processor()方法： 12345678910111213141516171819def result_processor(self, dialect, coltype): wants_unicode = self.convert_unicode or dialect.convert_unicode needs_convert = wants_unicode and \\ (not dialect.returns_unicode_strings or self.convert_unicode == 'force') if needs_convert: # note we *assume* that we do not have a unicode object # here, instead of an expensive isinstance() check. decoder = codecs.getdecoder(dialect.encoding) def process(value): if value is not None: # decoder returns a tuple: (value, len) return decoder(value)[0] else: return value return process else: return None 这个方法就是根据数据库方言dialect和字段类型coltype返回一个字符串的解码函数。若在if语句上面将needs_convert置为False，即不对该字段使用解码器，则再执行上面的脚本时，查询正常。 由于前面create_engine()函数的encoding参数缺省为UTF-8，故dialect.encoding的值为“UTF-8”，故if语句中decoder实际引用的是codecs.utf_8_decode()。也就是说，result_processor()方法在实际执行过程中返回的是一个封装了utf_8_decode()函数的函数。即，UnicodeEncodeError是在对从数据库中查询出来的中文字符串进行UTF-8解码时抛出的。 对传入process()函数的值作isinstance(value,unicode)判断，显示为True，表明从数据库中查询出来的中文本身就是unicode字节码，当对它再进行UTF-8解码时，就抛出了UnicodeEncodeError的错误。为验证以上判断，做如下实验： 12345678910111213141516171819202122232425&gt;&gt;&gt;t = '中文'&gt;&gt;&gt;u = u'中文'&gt;&gt;&gt;isinstance(t, str)True&gt;&gt;&gt;isinstance(t, unicode)False&gt;&gt;&gt;isinstance(u, str)False&gt;&gt;&gt;isinstance(u, unicode)True&gt;&gt;&gt;x = t.decode('utf-8')&gt;&gt;&gt;xu'\\u4e2d\\u6587'&gt;&gt;&gt;isinstance(x, unicode)True&gt;&gt;&gt;x == uTrue&gt;&gt;&gt; import codecs&gt;&gt;&gt; dc = codecs.getdecoder('utf-8')&gt;&gt;&gt; dc(u)Traceback (most recent call last): File \"&lt;input&gt;\", line 1, in &lt;module&gt; File \"/usr/lib/python2.6/encodings/utf_8.py\", line 16, in decode return codecs.utf_8_decode(input, errors, True)UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 得证。 在Python中，字符串类型str和unicode类型是两种不同的数据类型，str类型的数据可以通过指定正确的编码来转换成unicode类型，对unicode类型的数据作重复的解码操作就会抛出类似上面的错误。 实事上，若将name字段声明为String类，则保存和查询操作均无问题。但由于我需要sqlalchemy建表时将相应字段的类型设为nvarchar，故必须使用Unicode类声明该列。 那有没有办法使result_processor()方法不返回一个对字段值作重复解码的函数呢？ 返回result_processor()方法，self.convert_unicode对于Unicode类是True，dialect.convert_unicode由create_engine()函数的convert_unicode参数控制，缺省为False，故needs_convert变量为True，无法更改；dialect.returns_unicode_strings是由sqlalchemy.engine模块default.py中的DefaultDialect类的_check_unicode_returns()方法返回的，该方法内容为： 123456789101112131415def _check_unicode_returns(self, connection): cursor = connection.connection.cursor() cursor.execute( str( expression.select( [expression.cast( expression.literal_column(\"'test unicode returns'\"),sqltypes.VARCHAR(60)) ]).compile(dialect=self) ) ) row = cursor.fetchone() result = isinstance(row[0], unicode) cursor.close() return result 此方法的功能为生成一条SQL语句，在数据库中执行后，判断返回的值是否为unicode类型。由于SQL Server是ASCII编码，故此方法返回False。因此，dialect.returns_unicode_strings的值为False。最终，needs_convert只能为True。我觉得这是sqlalchemy的一个Bug。 在此条件下，目前尚未找到较好的解决办法，只能使用硬编码强制置result_processor()方法中的needs_convert变量为False。 2010-02-25 更新： 谢谢KL童鞋指出问题原因和解决办法，使问题得以完美解决。 1、由于Python在载入site模块时会删除setdefaultencoding()函数，故不能以在脚本开头调用此函数的方式指定默认编码；sitecustomize.py是一个python会自动导入的模块，故应当使用这个文件指定默认编码； 2、我这里需要使用utf-8作默认编码器，sitecustomize.py的内容如下： 1234#!/usr/bin/python# -*- coding: gbk -*-import syssys.setdefaultencoding('utf-8') 3、将sitecustomize.py保存到python安装目录下的Lib\\site-packages目录中； 另外，在此处发现了跟本问题相关的资料，辅助治疗，效果更佳。","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"SQL","slug":"sql","permalink":"http://0x3f.org/tags/sql/"},{"name":"SQLAlchemy","slug":"sqlalchemy","permalink":"http://0x3f.org/tags/sqlalchemy/"},{"name":"数据库","slug":"数据库","permalink":"http://0x3f.org/tags/数据库/"}]},{"title":"被迫弃UMS而用KMS","slug":"switching-from-ums-to-kms","date":"2010-02-12T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/switching-from-ums-to-kms/","link":"","permalink":"http://0x3f.org/post/switching-from-ums-to-kms/","excerpt":"","text":"昨天更新了一下系统，今天开机就白屏了。于是先关掉Compiz，看了一下Archlinux的新闻，发现新的xf86-video-intel中已经移除了UMS，也就意味着只能使用KMS做3D加速了。 UMS的全称是User Mode-Setting，是一种传统的图形界面初始化方案，即在X加载之后由它初始化图形界面。这种方案的弊端是虚拟终端不具备显示和处理图形的能力，同时虚拟终端和图形界面之间的切换显得缓慢并带有闪烁。 KMS的全称是Kernel Mode-Setting，是新一代图形界面初始化方案，它将图形界面的初始化由X加载之后由X负责进行改为在内核初始化时由内核进行。KMS的好处不仅仅是解决了上面UMS的问题，同时也使得Linux具备了在启动时显示漂亮的开机图示的能力。另外，在3D加速性能和低功耗方面，KMS也较UMS更胜一筹。 我的Thinkpad X200使用的是Intel GMA 945的芯片组，而Archlinux的Wiki上仍以915为例，所以尝试着做如下内容： 一、去除/boot/grub/menu.lst中Kernel启动参数中的vga参数； 二、加入以下内容到/etc/modprobe.d/modprobe.conf： options i945 modeset=1 三、在/etc/rc.conf中的MODULES行加入intel_agp和i945； 重启系统后，Compiz白屏问题解决，3D加速性能似乎有所上升。","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"},{"name":"ThinkPad","slug":"thinkpad","permalink":"http://0x3f.org/tags/thinkpad/"},{"name":"内核","slug":"内核","permalink":"http://0x3f.org/tags/内核/"},{"name":"新闻","slug":"新闻","permalink":"http://0x3f.org/tags/新闻/"}]},{"title":"PHP后台echo过多会导致进程崩溃","slug":"too-many-echoes-may-crash-php","date":"2010-01-30T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/too-many-echoes-may-crash-php/","link":"","permalink":"http://0x3f.org/post/too-many-echoes-may-crash-php/","excerpt":"","text":"这是去年晚些时侯发现的一个问题。 公司产品的后台定时任务应该是用独立的PHP进程驱动的。在做一个项目的时候，为了便于手工调试，我在定时任务中使用了大量的echo输出信息并在浏览器中手工执行此任务的脚本。 手工执行通过，输出信息完全没有问题。但在实际运行的过程中，一个很诡异的事情发生了：即使我将实际处理数据的代码全部注释掉，只对原始数据做简单的查询，此定时任务仍然极其健壮地中途退出。最要命的是无论程序日志还是PHP的错误日志，都没有任何相关信息。直到后来我把所有echo输出都取消，问题才解决。 事后模糊地记得很久以前似乎在哪本书上看到过在无输出设备的情况下echo过多数据会导致PHP进程崩溃的内容，但原因已想不起来了。","categories":[],"tags":[{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"},{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"bug","slug":"bug","permalink":"http://0x3f.org/tags/bug/"},{"name":"筆記","slug":"筆記","permalink":"http://0x3f.org/tags/筆記/"}]},{"title":"VirtualBox的Host Interface网络接入方式的配置","slug":"virtualbox-host-interface","date":"2010-01-30T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/virtualbox-host-interface/","link":"","permalink":"http://0x3f.org/post/virtualbox-host-interface/","excerpt":"","text":"VirtualBox安装后默认的网络接入方式是NAT，也是最简单的一种。但NAT网络中的虚拟机系统不具有和主机同一网段的IP地址，不能和主机直接通信。这对于开发者来说是不适用的。 Host Interface网络接入方式可以使虚拟机系统获得与主机同一网段的IP地址，因此也使得虚拟机系统像主机所在的局域网中的一台真实的计算机一样，可以和其它计算机通信。 对于Linux平台的VirtualBox，可以有两种方式实现Host Interface网络。一是使用系统网桥，二是使用VirtualBox内建的机制。 第一种方式复杂但通用，尤其是对于2.1.0以前的版本来说，这是唯一的途径。从2.1.0开始，VirtuaBox内建了支持Host Interface的机制，这极大地简化了此类型网络的配置。 首先，加载vboxnetflt模块： sudo modprobe vboxnetflt 然后在VirtualBox中配置虚拟机的网络连接方式，选择“Bridged Adapter”。 最后启动虚拟机即可。 另外，若虚拟机系统是精简版的Windows，网卡驱动可能不会自动安装，这时需要另外下載网卡的驱动并安装。 为方便起见，可将vboxnetflt模块加入到开机自动启动的模块列表中，每种发行版设置自启动模块的位置和方法不一样，在Archlinux下，是在/etc/rc.conf文件中的modules行中设置。 参考文章：Archlinux Wiki: VirtualBox","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"},{"name":"局域网","slug":"局域网","permalink":"http://0x3f.org/tags/局域网/"},{"name":"虚拟技术","slug":"虚拟技术","permalink":"http://0x3f.org/tags/虚拟技术/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://0x3f.org/tags/计算机网络/"}]},{"title":"立方体归来","slug":"cube-is-back","date":"2009-11-23T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/cube-is-back/","link":"","permalink":"http://0x3f.org/post/cube-is-back/","excerpt":"","text":"上次鼓捣出立方体还是几年前在学校的时候，Ubuntu+Beryl。 我那个时候的台式机，Celeron Tualatin+256M SDRAM+GForce 440，跑XP要了亲命，忍无可忍而投奔Linux，结果一不小心鼓捣出了立方体，捎带着Firefox、OpenOffice开了一大堆，屁事儿没有，我就是这么死心塌地地上了贼船，直至今天。 后来一直用Archlinux，习惯了Fluxbox和Openbox的简洁。买了X200后曾试图找寻一下旧日华丽的记忆，但却人是物非，新的X200、新的Archlinux、新的Compiz-fusion远不如当年的老牛破车那么搭调。虽说也搞出了立方体，但所有的窗口都没有边框，于是作罢。 上周六鬼使神差的进入GNOME并打开Fusion-icon，奇迹就这么出现了：","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Ubuntu","slug":"ubuntu","permalink":"http://0x3f.org/tags/ubuntu/"},{"name":"Archlinux","slug":"archlinux","permalink":"http://0x3f.org/tags/archlinux/"},{"name":"FluxBox","slug":"fluxbox","permalink":"http://0x3f.org/tags/fluxbox/"},{"name":"GNOME","slug":"gnome","permalink":"http://0x3f.org/tags/gnome/"},{"name":"桌面日记","slug":"桌面日记","permalink":"http://0x3f.org/tags/桌面日记/"},{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"}]},{"title":"Windows下GVim的全屏","slug":"fullscreen-for-gvim-on-windows","date":"2009-09-16T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/fullscreen-for-gvim-on-windows/","link":"","permalink":"http://0x3f.org/post/fullscreen-for-gvim-on-windows/","excerpt":"","text":"下載gvim的一個擴展“gvimfullscreen_win32”，并解壓縮。 将gvimfullscreen.dll複制到gvim安裝目錄下，與gvim.exe同目錄。 修改gvim配置文件_vimrc，在其中添加如下内容： 123if has('win32') map &lt;F11&gt; &lt;Esc&gt;:call libcallnr(\"gvimfullscreen.dll\", \"ToggleFullScreen\", 0)&lt;CR&gt;endif 此後，即可使用F11鍵開關gvim的全屏狀态。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Vim","slug":"vim","permalink":"http://0x3f.org/tags/vim/"},{"name":"Windows","slug":"windows","permalink":"http://0x3f.org/tags/windows/"},{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/tags/計算機/"}]},{"title":"歐拉工程第十一解","slug":"project-euler-11","date":"2009-05-11T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-11/","link":"","permalink":"http://0x3f.org/post/project-euler-11/","excerpt":"","text":"In the 20×20 grid below, four numbers along a diagonal line have been marked in red. 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48 The product of these numbers is 26 × 63 × 78 × 14 = 1788696. What is the greatest product of four adjacent numbers in any direction (up, down, left, right, or diagonally) in the 20×20 grid? 这道题最难的地方在于将上面400个数输入到程序中的矩阵里，嘿嘿，后来看别人的解，真有这么干的，饿滴神呀。 我直接把这个矩阵复制到一个文本文件里，然后在程序里解析： 123456789101112131415161718192021222324#!/bin/python# -*- coding: utf-8 -*-matrix = []products = []metaFile = open('c:/matrix.txt', 'rb')for line in metaFile.readlines(): matrix.append(line.split())metaFile.close()for row in range(20): for col in range(20): if col+3 &lt; 20: products.append( int(matrix[row][col]) * int(matrix[row][col+1]) * int(matrix[row][col+2]) * int(matrix[row][col+3]) ) if row+3 &lt; 20: products.append( int(matrix[row][col]) * int(matrix[row+1][col]) * int(matrix[row+2][col]) * int(matrix[row+3][col]) ) if col+3 &lt; 20 and row+3 &lt; 20: products.append( int(matrix[row][col]) * int(matrix[row+1][col+1]) * int(matrix[row+2][col+2]) * int(matrix[row+3][col+3]) ) if row+3 &lt; 20 and col-3 &gt; 0: products.append( int(matrix[row][col]) * int(matrix[row+1][col-1]) * int(matrix[row+2][col-2]) * int(matrix[row+3][col-3]) )products.sort()print products","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"数学","slug":"数学","permalink":"http://0x3f.org/tags/数学/"},{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"算法","slug":"算法","permalink":"http://0x3f.org/tags/算法/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"}]},{"title":"rxvt-unicode的真透明","slug":"true-transparent-of-rxvt-unicode","date":"2009-02-27T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/true-transparent-of-rxvt-unicode/","link":"","permalink":"http://0x3f.org/post/true-transparent-of-rxvt-unicode/","excerpt":"","text":"nacre同学说，urxvt是可以实现真透明的。起初我以为是要用transset-df来实现，但这个东西一般需要手动操作，不具有太大的实用性，而且会把整个窗口透明化。不过后来发现真的不需要用它来画蛇添足，有xcompmgr足矣。 因为我用openbox，要实现窗口的阴影和动画效果，xcompmgr是必须的，我把它设成了开机自启动。比起xcompmgr默认的参数值，下面这条定制的命令实现了简洁的阴影和合理的渐隐渐显时间，因此提供了一个各方面都比较均衡、合理的桌面体验： xcompmgr -Ss -n -Cc -fF -I-10 -O-10 -D1 -t-3 -l-4 -r4 然后在.Xresources中添加以下两行： URxvt.depth:32 URxvt.background:rgba:0000/0000/0000/dddd 最后当然要执行一下： xrdb ~/.Xresources 此后直接启动urxvt即可。 这里面最有意思的就是background项的配置，它有两种形式，一种是： URxvt.background:[80]black 还有一种就是前面提到的形式。 第一种形式中，中括号里的数字表示半透明度对应的百分比，括号外是颜色名称；第二种形式提供了比第一种更多的色彩选择，四组数字都是十六进制数，前三组是RGB颜色值，最后一组是半透明度，数值越大，透明度越低。 在查阅“man urxvt”的时候，发现urxvt的man pages里的内容真是异常丰富，大部分功能都讲解得言简意赅。以往还抱怨这个东西在网上连个健全的文档都找不到，原来全在这儿呢，真不知道以往无数次地man的时候为什么没有注意到这些，难道man了rxvt了？ PS：这样实现urxvt的真半透明后，貌似xcompmgr实现的阴影在urxvt身上就消失了，求解中……","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"終端","slug":"終端","permalink":"http://0x3f.org/tags/終端/"},{"name":"美化","slug":"美化","permalink":"http://0x3f.org/tags/美化/"},{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"}]},{"title":"完美的終端模擬器：rxvt-unicode","slug":"rxvt-unicode-256color-is-perfect","date":"2009-02-07T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/rxvt-unicode-256color-is-perfect/","link":"","permalink":"http://0x3f.org/post/rxvt-unicode-256color-is-perfect/","excerpt":"","text":"urxvt（rxvt的unicode版本，支持多國語言，官方網站）。 具有以下特性： 支持真半透明 支持Unicode編碼，支持多國語言 支持英文和非英文字符使用不同的字體 支持CS模式，節省系統資源 輕量，速度快 支持Perl擴展功能 但是urxvt有一个很影响情绪的缺陷，就是字符的间距过大，看起来很不舒服。不過已有補丁用來解決這個問題，例如Archlinux用戶可以安裝rxvt-unicode-chinese： urxvt的配置選項可以參考其官方網站上的說明，另外這裏有一份詳細的配置文件。 更新日志： 2011-01-15 修改文章標題 重寫文章內容 由于原來的rxvt-unicode-256color包已不存在，更換為rxvt-unicode-chinese 補充一份配置文件","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"rxvt","slug":"rxvt","permalink":"http://0x3f.org/tags/rxvt/"},{"name":"終端","slug":"終端","permalink":"http://0x3f.org/tags/終端/"}]},{"title":"歐拉工程第十解","slug":"project-euler-10","date":"2008-11-17T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-10/","link":"","permalink":"http://0x3f.org/post/project-euler-10/","excerpt":"","text":"The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17. Find the sum of all the primes below two million. 题目越来越变态，开始好玩儿了。 第七解里的算法在这里算是废了，一万个素数都算得那么费劲，两百万以下的素数有十几万个，不得不用筛选法了。 普通的筛选效率也不行，当初就是因为这个原因才没用它。不过优化过的筛选法就很奇妙了，下面是Lua的实现： 123456789101112131415161718192021222324252627require('math')local limit = 2000000local primes = &#123;&#125;for i=1,limit do table.insert(primes,true)endprimes[0] = falseprimes[1] = falsefor i=0,math.floor(math.sqrt(limit)) do if primes[i] then for j=math.pow(i,2),limit,i do primes[j] = false end endendlocal sumVal = 0for i,j in ipairs(primes) do if j then sumVal = sumVal + i endendprint(sumVal) 在我这里两秒半就出结果了，Python的表现也不错，四秒半出结果： 123456789101112131415161718from math import sqrtlimit = 2000000primes = [True for i in range(0,limit)]primes[0] = Falseprimes[1] = Falsefor i in range(1,int(sqrt(limit))+1): if primes[i]: for j in range(i**2,limit,i): primes[j] = FalsesumVal = 0for i in range(len(primes)): if primes[i]: sumVal += iprint sumVal","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"数学","slug":"数学","permalink":"http://0x3f.org/tags/数学/"},{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"算法","slug":"算法","permalink":"http://0x3f.org/tags/算法/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Lua","slug":"lua","permalink":"http://0x3f.org/tags/lua/"}]},{"title":"歐拉工程第九解","slug":"project-euler-9","date":"2008-11-09T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-9/","link":"","permalink":"http://0x3f.org/post/project-euler-9/","excerpt":"","text":"A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, a2 + b2 = c2 For example, 32 + 42 = 9 + 16 = 25 = 52. There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc. 解： 12345678910flag = Falsefor a in range(1,1000): for b in range(1,1000): if a ** 2 + b ** 2 == (1000 - a - b) ** 2: print a,b,(1000 - a - b) print a * b * (1000 - a - b) flag = True break if flag: break","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"数学","slug":"数学","permalink":"http://0x3f.org/tags/数学/"},{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"算法","slug":"算法","permalink":"http://0x3f.org/tags/算法/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"}]},{"title":"歐拉工程第八解","slug":"project-euler-8","date":"2008-11-08T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-8/","link":"","permalink":"http://0x3f.org/post/project-euler-8/","excerpt":"","text":"Find the greatest product of five consecutive digits in the 1000-digit number. 73167176531330624919225119674426574742355349194934 96983520312774506326239578318016984801869478851843 85861560789112949495459501737958331952853208805511 12540698747158523863050715693290963295227443043557 66896648950445244523161731856403098711121722383113 62229893423380308135336276614282806444486645238749 30358907296290491560440772390713810515859307960866 70172427121883998797908792274921901699720888093776 65727333001053367881220235421809751254540594752243 52584907711670556013604839586446706324415722155397 53697817977846174064955149290862569321978468622482 83972241375657056057490261407972968652414535100474 82166370484403199890008895243450658541227588666881 16427171479924442928230863465674813919123162824586 17866458359124566529476545682848912883142607690042 24219022671055626321111109370544217506941658960408 07198403850962455444362981230987879927244284909188 84580156166097919133875499200524063689912560717606 05886116467109405077541002256983155200055935729725 71636269561882670428252483600823257530420752963450 穷举，解： 12345678910111213141516171819202122def MakeProduct(strNum): prod = 1 for char in strNum: prod = prod * int(char) return prod def GetTheFirstProduct(strNum): if len(strNum) &lt; 5: return 0,0 return MakeProduct(strNum[:5]),strNum[1:]num = '7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450'largestProduct = 0while len(num) &gt;= 5: tmp = GetTheFirstProduct(num) if tmp == (0,0): break num = tmp[1] if largestProduct &lt; tmp[0]: largestProduct = tmp[0]print largestProduct 如果先找到下五个均不为零的连续整数，然后计算它们的积并以之参与比较，效率会更高： 123456789101112131415161718192021222324252627def MakeProduct(strNum): prod = 1 for char in strNum: prod = prod * int(char) return proddef GetTheFirstProduct(strNum): if len(strNum) &lt; 5: return 0,0 subStr = strNum[:5] index = subStr.rfind('0') if index == -1: return MakeProduct(subStr),strNum[1:] else: return GetTheFirstProduct(strNum[index+1:])num = '7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450'largestProduct = 0while len(num) &gt;= 5: tmp = GetTheFirstProduct(num) if tmp == (0,0): break num = tmp[1] if largestProduct &lt; tmp[0]: largestProduct = tmp[0]print largestProduct","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"数学","slug":"数学","permalink":"http://0x3f.org/tags/数学/"},{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"算法","slug":"算法","permalink":"http://0x3f.org/tags/算法/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"}]},{"title":"歐拉工程第七解","slug":"project-euler-7","date":"2008-10-30T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-7/","link":"","permalink":"http://0x3f.org/post/project-euler-7/","excerpt":"","text":"第七解： By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13. What is the 10001st prime number? 穷举，并加以最大程度的优化：对大于2的素数，只判断奇数；判断一个奇数是否素数时，只拿已经找到的素数中小于第这个数平方根的数来相除，如果均不能整除，就是素数。Python的实现： 1234567891011121314151617181920def IsPrimeNum(num,feed): from math import sqrt tmp = feed[:] while tmp[-1] &gt; int(sqrt(num)): tmp.pop() for i in tmp: if num % i == 0: return False return Truelimit = 10001feed = [2,3,5,7]temp = 7counter = 4while counter &lt; limit : temp += 2 if IsPrimeNum(temp,feed): feed.append(temp) counter += 1print temp 执行了一下，在我这里居然用了五百秒才出结果，神啊，差不多十分钟啊。想到PHP号称速度很快，于是用PHP重新实现了一下： 12345678910111213141516171819202122232425function IsPrimeNum($num,$feed)&#123; $base = floor(sqrt($num)); foreach($feed as $i=&gt;$v)&#123; if($v &gt; $base)&#123; return true; &#125; if($num % $v == 0)&#123; return false; &#125; &#125;&#125;$limit = 10001;$feed = array(2,3,5,7);$counter = 4;$tmp = 7;while($counter &lt; $limit)&#123; $tmp += 2; if(IsPrimeNum($tmp,$feed))&#123; $counter++; $feed[] = $tmp; &#125;&#125;echo $tmp; 还好，七十四秒出结果，看来PHP的牛皮不是吹的。当然，Lua会更快： 1234567891011121314151617181920212223242526function IsPrimeNum(num,feed) require('math') local limit = math.floor(math.sqrt(num)) for i,v in ipairs(feed) do if v &gt; limit then return true end if num % v == 0 then return false end endendlocal limit = 10001local feed = &#123;2,3,5,7&#125;local counter = 4local tmp = 7while counter &lt; limit do tmp = tmp + 2 if IsPrimeNum(tmp,feed) then counter = counter + 1 table.insert(feed,tmp) endendprint(tmp) 执行完后还是吓了一跳，0.3秒，同样是语言，效率的差别咋就那么大呢？！我在想用Java会不会算到2009去。 我不相信这道题用Python就那么难解，下面是用递归实现的程序： 123456789101112131415161718192021222324252627282930313233from math import sqrtdef GuessPrime(feed,limit): if feed == 2 : return [2] elif feed == 3 : return [2,3] tmp = int(sqrt(feed)) primes = GuessPrime(tmp,limit) base = 0 if tmp % 2 == 0: base = tmp + 1 else: base = tmp for i in range(base,feed,2): flag = 0 for j in primes: if i % j == 0: flag = 1 break if flag == 0: primes.append(i) if len(primes) == limit: return primes return primeslimit = 10001feed = 1000000primes = GuessPrime(feed,limit)print primes[limit-1] 11秒就出了结果，说到底，算法的改进才是硬道理！","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"数学","slug":"数学","permalink":"http://0x3f.org/tags/数学/"},{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"算法","slug":"算法","permalink":"http://0x3f.org/tags/算法/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"},{"name":"Lua","slug":"lua","permalink":"http://0x3f.org/tags/lua/"},{"name":"PHP","slug":"php","permalink":"http://0x3f.org/tags/php/"}]},{"title":"歐拉工程第六解","slug":"project-euler-6","date":"2008-10-28T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-6/","link":"","permalink":"http://0x3f.org/post/project-euler-6/","excerpt":"","text":"第六解： The sum of the squares of the first ten natural numbers is, 12 + 22 + &hellip; + 102 = 385 The square of the sum of the first ten natural numbers is, (1 + 2 + &hellip; + 10)2 = 552 = 3025 Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 385 = 2640. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum. 解： 123456sumSquare = 0sum = 0for i in range(1,101): sumSquare += i**2 sum += iprint sum**2 - sumSquare","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"数学","slug":"数学","permalink":"http://0x3f.org/tags/数学/"},{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"算法","slug":"算法","permalink":"http://0x3f.org/tags/算法/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"}]},{"title":"歐拉工程第五解","slug":"project-euler-5","date":"2008-10-26T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-5/","link":"","permalink":"http://0x3f.org/post/project-euler-5/","excerpt":"","text":"第五解： 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest number that is evenly divisible by all of the numbers from 1 to 20? 解： 1234567891011121314151617181920212223#为简洁明了，此处不作校验def GetGreatestCommonDivisor(min,max): '''辗转相除法求最大公约数''' while min &gt; 0: tmp = min min = max % min max = tmp return maxdef GetLeastCommonMultiple(a,b): if a &gt; b: max = a min = b else: max = b min = a div = GetGreatestCommonDivisor(min,max) return min * max / divtemp = 1for i in range(1,21): temp = GetLeastCommonMultiple(i,temp)print temp 本题旨在求最小公倍数。此算法有意思的是，它的精华在于如何求解两个正整数的最大公约数，有点围魏救赵的意思。 在这里可以找到另外一些求解最小公倍数的方法。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"数学","slug":"数学","permalink":"http://0x3f.org/tags/数学/"},{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"算法","slug":"算法","permalink":"http://0x3f.org/tags/算法/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"}]},{"title":"歐拉工程第四解","slug":"project-euler-4","date":"2008-10-21T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-4/","link":"","permalink":"http://0x3f.org/post/project-euler-4/","excerpt":"","text":"第四解： A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99. Find the largest palindrome made from the product of two 3-digit numbers. 解： 1234567largestPalindrome = 0for i in range(100,1000): for j in range(100,1000): product = i * j if int(str(product)[::-1]) == product and product &gt; largestPalindrome: largestPalindrome = productprint largestPalindrome 穷举，有没有效率高的办法？","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"数学","slug":"数学","permalink":"http://0x3f.org/tags/数学/"},{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"算法","slug":"算法","permalink":"http://0x3f.org/tags/算法/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"}]},{"title":"歐拉工程第三解","slug":"project-euler-3","date":"2008-10-20T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-3/","link":"","permalink":"http://0x3f.org/post/project-euler-3/","excerpt":"","text":"第三解： The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ? 解： 1234567891011feed = 600851475143def GetFactor(feed,footmark): while footmark &lt; feed: footmark += 2 if feed % footmark == 0: print footmark GetFactor(feed / footmark,footmark) breakGetFactor(feed,1)","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"数学","slug":"数学","permalink":"http://0x3f.org/tags/数学/"},{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"算法","slug":"算法","permalink":"http://0x3f.org/tags/算法/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"}]},{"title":"歐拉工程第二解","slug":"project-euler-2","date":"2008-10-18T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-2/","link":"","permalink":"http://0x3f.org/post/project-euler-2/","excerpt":"","text":"第二解： Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, &hellip; Find the sum of all the even-valued terms in the sequence which do not exceed four million. 解： 12345678910i = 1j = 2sum = 0while j &lt; 4000000 : if j % 2 == 0 : sum = sum + j t = i i = j j = t + jprint sum","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"数学","slug":"数学","permalink":"http://0x3f.org/tags/数学/"},{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"算法","slug":"算法","permalink":"http://0x3f.org/tags/算法/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"}]},{"title":"歐拉工程第一解","slug":"project-euler-1","date":"2008-10-05T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/project-euler-1/","link":"","permalink":"http://0x3f.org/post/project-euler-1/","excerpt":"","text":"“歐拉工程”是一个很有意思的网站，它每周会提供一道数学题，要求访问者使用任一种编程语言设计一个计算机程序求解。到现在为止已经出了二百一十一道题，当然，题的难度是依次递增的。几十个国家的程序员已参与了这个工程，截至目前，中国有四百多人参与，但是解决所有的二百多道题的只有一个人。 我觉得没事儿的时候做一道很有意思，下面是第一道，很简单： If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. 最容易想到的一算法就是依次取出一到一千的整数，只要是三或五的倍数，就累加起来，最终的和就是结果： 1234567sum = 0for num in range(1,1000): if not (num % 3 != 0 and num % 5 != 0): sum += numprint sum 但是我觉得这个算法太普通了，从一到一千要做一千次循环，时间复杂度会比较高。所以我设想只取出三和五的倍数，然后相加就行了，所需要考虑的只是怎么处理三和五的公倍数的问题。下面是我的算法，只有三百多次循环： 123456789101112131415161718192021def SumMultiple(feed,limit): threeMultiple = 3 * feed fiveMultiple = 5 * feed if threeMultiple &gt;= limit: return None if fiveMultiple &gt;= limit: return threeMultiple if fiveMultiple % 3 == 0: return threeMultiple return threeMultiple + fiveMultiplesum = 0for feed in range(1,500): if SumMultiple(feed,1000) == None: break; sum += SumMultiple(feed,1000)print sum 不过事与愿违，通过测试，这个算法的效率要比上一种低，我想应该是SumMultiple()函数中运算和比较次数较多导致的。 不管怎样，第一个问题已经顺利解决了：","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Python","slug":"python","permalink":"http://0x3f.org/tags/python/"},{"name":"数学","slug":"数学","permalink":"http://0x3f.org/tags/数学/"},{"name":"歐拉工程","slug":"歐拉工程","permalink":"http://0x3f.org/tags/歐拉工程/"},{"name":"算法","slug":"算法","permalink":"http://0x3f.org/tags/算法/"},{"name":"編程","slug":"編程","permalink":"http://0x3f.org/tags/編程/"}]},{"title":"为rxvt-unicode开启标签和链接支持","slug":"let-rxvt-unicode-support-tags-and-links","date":"2008-03-19T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/let-rxvt-unicode-support-tags-and-links/","link":"","permalink":"http://0x3f.org/post/let-rxvt-unicode-support-tags-and-links/","excerpt":"","text":"写完urxvt-unicode快速上手，本以为已将urxvt的用法一网打尽，不料AndyWxy网友又找到了两个新的功能：使urxvt启用标签和在urxvt中打开网页链接。 标签功能很实用，一般为了达到复用终端窗口的目的会采用两种方式：一是配合screen使用，另一个就是启用标签。然而前者有一个缺点就是不直观，标签页恰好能弥补这个缺陷。urxvt不愧是个功能强大的终端工具，如果在编译时开启perl支持，则urxvt可启用多标签功能。用法如下： 一是在启动的时候加入命令行参数： urxvt -pe tabbed 二是在配置文件“.Xresources”中添加如下配置信息： URxvt.perl-ext-common: default,tabbed 则默认情况下执行urxvt就会打开多标签功能。urxvt的标签支持使用鼠标操作，同时可以使用Ctrl+Shift+左右箭头来切换标签页，使用Ctrl+Shift+向下箭头开启新标签。 另外一个功能就是可以通过在urxvt中的链接上点击鼠标左键来通过设定的浏览器打开之。首先在“.Xresources”文件中添加如下内容： URxvt.urlLauncher: firefox URxvt.matcher.button: 1 然后使用如下命令打开urxvt： urxvt -pe matcher 即可。也可以在配置文件中添加上述内容之后再添加一行： URxvt.perl-ext-common: matcher 此后即默认开启在终端窗口中打开链接的功能。注意修改“.Xresources”文件后需要执行如下命令才能使修改后的配置文件生效： xrdb ~/.Xresources","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"rxvt","slug":"rxvt","permalink":"http://0x3f.org/tags/rxvt/"},{"name":"終端","slug":"終端","permalink":"http://0x3f.org/tags/終端/"},{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"}]},{"title":"rxvt-unicode快速上手","slug":"quick-guide-for-rxvt-unicode","date":"2008-03-06T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/quick-guide-for-rxvt-unicode/","link":"","permalink":"http://0x3f.org/post/quick-guide-for-rxvt-unicode/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;rxvt是我最喜欢的虚拟终端，它有以下优点： &nbsp;&nbsp;&nbsp;&nbsp;轻量：体积小，启动速度快，占用系统资源极低 &nbsp;&nbsp;&nbsp;&nbsp;美观：各种外观（如颜色、字体、半透明等）均可定制 &nbsp;&nbsp;&nbsp;&nbsp;功能强：具备一个终端工具应当有的各种实用功能 &nbsp;&nbsp;&nbsp;&nbsp;然而它很难被初学者接受，一是因为它的缺省外观很难看，而自身又不提供图形界面的配置工具，只能通过修改配置文件来设置，然而网上相关的资料却非常少；二是因为在rxvt中使用复制和粘贴非常“不方便”，它并不支持人们已经习惯的Ctrl+C和Ctrl+V的复制、粘贴方式，这也是网上关于rxvt问得最多的问题；最后一个门槛是它对中文等东亚文字的支持不好。 &nbsp;&nbsp;&nbsp;&nbsp;其实rxvt以上三个所谓的门槛都是初学者对它的误解。首先rxvt的配置文件非常简单，只要学过英语的人都能看明白，通过简单的配置就可以使之变得非常漂亮，丝毫不逊色于Konsole、Gnome-terminal等主流终端。 &nbsp;&nbsp;&nbsp;&nbsp;其次，rxvt虽然不支持Ctrl+C和Ctrl+V的复制、粘贴，但是它有自己的一套操作方式。Linux下普遍使用的图形界面均为X11，而X11支持一种独特的复制粘贴方式，即如果你在另一个程序比如文本编辑器中使用鼠标拖动来高亮一段文字后，不用进行任何操作，此时选中的内容已经复制到剪贴板中了，随后在rxvt中单击鼠标中键即可将选中内容粘贴到其中，此外，如果鼠标没有中键，可以同时按下左右键以达到同样的效果，还可以使用Shift+Insert组合键来完成粘贴；反之，从rxvt中向外复制内容同样如此。 &nbsp;&nbsp;&nbsp;&nbsp;最后，虽然rxvt对东亚文字支持不好，但是rxvt有几个修改版，其中一个就是rxvt-unicode。顾名思义，rxvt-unicode支持unicode编码，因此对东亚文字的支持完全没有问题。安装完成后，使用urxvt即可打开之。 &nbsp;&nbsp;&nbsp;&nbsp;此外，rxvt-unicode还有一个很好的特性，它可以工作在C/S模式。使用urxvtd启动rxvt的后台程序，此后任何时候使用urxvtc即可打开一个rxvt终端，所有的rxvtc共用一个urxvtd，因此在同时运行的终端比较多的时候，在内存占用上要比全部使用urxvt少一些。不过据我粗略计算，如果打开的终端不是非常多（比如说几十个），那么使用普通模式和使用C/S模式对内存的占用没有太大的差距，因为普通模式下的urxvt占用内存本身就非常少。在我看来使用C/S模式的最大好处是启动速度比普通模式要快一些。 &nbsp;&nbsp;&nbsp;&nbsp;关于rxvt的美化和设置，可以参看我以前写的一篇文章。下图是我现在使用的rxvt的截图： &nbsp;&nbsp;&nbsp;&nbsp;以下是我当前的rxvt配置文件的内容： !Xft.dpi:96 !fontforge.FontView.FontFamily:wenquanyi bitmap song Rxvt.geometry:192×144 Rxvt.background:#2e2e2e Rxvt.foreground:antiquewhite Rxvt.colorBD:yellow Rxvt.colorUL:green Rxvt.multichar_encoding:utf-8 Rxvt.scrollBar:Fault Rxvt.scrollBar_right:True Rxvt.scrollBar_floating: True Rxvt.scrollstyle: next Rxvt.saveLines:10000 Rxvt.color0:black Rxvt.color1:red3 Rxvt.color2:springgreen Rxvt.color3:wheat3 Rxvt.color4:navy Rxvt.color5:magenta4 Rxvt.color6:steelblue1 Rxvt.color7:gray85 Rxvt.color8:gray10 Rxvt.color9:SkyBlue3 Rxvt.color10:chartreuse3 Rxvt.color11:lightgoldenrod2 Rxvt.color12:SkyBlue1 Rxvt.color13:pink1 Rxvt.color14:lightblue1 Rxvt.color15:#dbeff9 Rxvt.font:xft:Vera Sans YuanTi Mono :size=10,xft:Monospace:size=10 Rxvt.menu:/etc/X11/rxvt.menu Rxvt.preeditType:Root Rxvt.transparency:255","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"rxvt","slug":"rxvt","permalink":"http://0x3f.org/tags/rxvt/"},{"name":"終端","slug":"終端","permalink":"http://0x3f.org/tags/終端/"},{"name":"美化","slug":"美化","permalink":"http://0x3f.org/tags/美化/"},{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"}]},{"title":"rxvt-unicode的半透明方案","slug":"half-transparent-for-rxvt-unicode","date":"2007-10-15T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/half-transparent-for-rxvt-unicode/","link":"","permalink":"http://0x3f.org/post/half-transparent-for-rxvt-unicode/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;rxvt是个快速且节省内存的模拟终端，原版rxvt对中文等非字母语言的支持不好，所以它有许多修改版，rxvt-unicode-ml是比较适合中国人使用的rxvt修改版。 &nbsp;&nbsp;&nbsp;&nbsp;rxvt轻量但不简单，它有许多设置选项和启动参数，用户可以在命令行使用“rxvt -help”查看其常用启动参数，使用“rxvt --help”查看更为详细的启动参数。 &nbsp;&nbsp;&nbsp;&nbsp;通过修改用户主目录下的“.Xresources”文件可以配置urxvt的行为，从而不必每次都加启动参数，我的\".Xresources\"文件内容如下： Rxvt.background:white Rxvt.foreground:black Rxvt.colorBD:yellow Rxvt.colorUL:green Rxvt.multichar_encoding:gb2312 Rxvt.scrollBar:Fault Rxvt.scrollBar_right:True Rxvt.scrollBar_floating: True Rxvt.scrollstyle: next Rxvt.saveLines:10000 Rxvt.color0:black Rxvt.color1:red3 Rxvt.color2:springgreen Rxvt.color3:wheat3 Rxvt.color4:navy Rxvt.color5:magenta4 Rxvt.color6:steelblue1 Rxvt.color7:gray85 Rxvt.color8:gray10 Rxvt.color9:SkyBlue3 Rxvt.color10:chartreuse3 Rxvt.color11:lightgoldenrod2 Rxvt.color12:SkyBlue1 Rxvt.color13:pink1 Rxvt.color14:lightblue1 Rxvt.color15:#dbeff9 Rxvt.font:xft:Vera Sans YuanTi Mono :size=10,xft:Monospace:size=10 Rxvt.menu:/etc/X11/rxvt.menu Rxvt.preeditType:Root Rxvt.geometry:192×174 Rxvt.transparency:255 &nbsp;&nbsp;&nbsp;&nbsp;这个配置文件是白底黑字，当然可以修改为全透明或者半透明，不过，只要在启动时加入启动参数就可以实现全透明： urxvt -tr &nbsp;&nbsp;&nbsp;&nbsp;也可以实现半透明： urxvt -fg lightgray -bg black -bc -tr -tint lightgray -sh 60 -sr","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"http://0x3f.org/tags/linux/"},{"name":"rxvt","slug":"rxvt","permalink":"http://0x3f.org/tags/rxvt/"},{"name":"終端","slug":"終端","permalink":"http://0x3f.org/tags/終端/"},{"name":"配置","slug":"配置","permalink":"http://0x3f.org/tags/配置/"}]},{"title":"UBUNTU 6.10 Edgy Eft 入门全程导用","slug":"ubuntu-610-tutorial","date":"2007-04-07T16:00:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/ubuntu-610-tutorial/","link":"","permalink":"http://0x3f.org/post/ubuntu-610-tutorial/","excerpt":"","text":"http://forum.ubuntu.org.cn/viewtopic.php?t=32798&amp;highlight= 目录 一、安装Edgy与硬盘的分区（1）安装与分区——————————————————————————————–3（2）多硬盘需要注意的一点———————————————————————————3（3）Linux下硬盘分区的概念——————————————————————————-4二、改变账户操作理念———————————————————————————-4三、修改源并配置网络（1）源及其使用方法—————————————————————————————-5（2）配置ADSL网络—————————————————————————————-6四、系统的中文化与输入法（1）系统的中文化——————————————————————————————6（2）中文字体的美化—————————————————————————————-6（3）中文输入法的安装与配置——————————————————————————8（4）主要程序界面的汉化———————————————————————————–11（5）Abiword中文乱码的解决办法————————————————————————-11五、多媒体播放器的安装与配置（1）万能播放器 mplayer———————————————————————————-12（2）音频播放器 audacious 及 mp3 文件 tag 乱码的解决————————————————-12（3）媒体解码库 gstreamer——————————————————————————–13六、网络工具的安装与配置（1）Opera 的安装与配置及中文输入法问题的解决———————————————————13（2）即时通讯程序——————————————————————————————14（a）集成即时通讯工具 gaim————————————————————————-14（b）最逼真的 QQ 工具——————————————————————————15（c）功能最强大的 QQ 工具 Eva———————————————————————16（d）多协议即时通讯工具 Kopete——————————————————————-16（3）新闻阅读———————————————————————————————-16（4）邮件客户端——————————————————————————————–17（5）下載工具———————————————————————————————-17（6）p2p 工具———————————————————————————————-17七、编辑器、编译环境与词典（1）编辑器————————————————————————————————17（2）编译环境———————————————————————————————-17（3）词典—————————————————————————————————18八、NVIDA 显卡驱动与 Beryl 的安装（1）nvida 显卡驱动的安装——————————————————————————–18（2）安装 Beryl——————————————————————————————–20（3）Splash Screen 的安装——————————————————————————–22九、Wine 的安装—————————————————————————————22十、虚拟机 Vmware———————————————————————————–23十一、磁盘分区的挂载（1）挂载一个原先存在而没有挂载的分区——————————————————————23（2）新加入一块还没有分区的全新的硬盘——————————————————————24十二、游戏（1）linux 下面的游戏————————————————————————————-25（2）win 下的游戏—————————————————————————————–25十三、一些常用工具（1）读写 ntfs 分区—————————————————————————————-25（2）java 日记本——————————————————————————————-26（3）图片管理 Picasa————————————————————————————–26（4）光碟烧录 GnomeBaker——————————————————————————-26（5）CHM 阅读器——————————————————————————————26（6）数学程序———————————————————————————————-27十四、Linux 下程序的安装（1）deb 软件包的安装————————————————————————————27（2）rpm 软件包的安装————————————————————————————27（3）使用源码进行安装————————————————————————————28（4）绿色软件———————————————————————————————29十五、其它 GUI 的安装（1）KDE————————————————————————————————–29十六、进阶技巧（1）关于 Grub 的 FAQ————————————————————————————29（2）桌面图标隐藏、显示设置——————————————————————————31（3）在/var/cache/apt/archives 里面发现大量原来使用 apt-get 下来的 deb 包，太占空间了，能不能删掉？31（4）gvim 的字体太难看，怎样设置为雅黑?—————————————————————31（5）为什么键盘上的左右箭头不能用了？——————————————————————31（6）有些常用命令记不住怎么办?————————————————————————–32（7）快速搜索文件—————————————————————————————–32（8）“不打开”音乐播放器预听 mp3———————————————————————33 一、安装Edgy与硬盘的分区 （1）安装与分区 安装就不用多说了，使用LiveCD安装非常简单，如果你装过Windows系统，这个将比它更简单。 首先将LiveCD的安装盘放入光驱，在BIOS里面设置成从光驱启动，使用LiveCD光盘启动后，系统桌面上有个“Install”的图标，双击后启动安装程序，一步一步地配置选项就行了。 关键是硬盘分区的问题。 如果你是想在硬盘上原有的一个分区上安装ubuntu，那么首先应确保这个分区上的重要数据都已被转移，然后在选择磁盘分区的时候选择手动分区，再将这个分区删除，在删除分区后得到的空间上新建一个swap分区，这个相当于windows下面的虚拟内存，一般要求不小于你的内存容量，我的内存是256M，划分的swap是512M。 然后在剩余的空间上建立一个主分区，用来安装系统所必需的文件，这个分区建议不低于5个G，当然，如果你的硬盘容量很大，还可以划分主分区以外的逻辑分区。 （2）多硬盘需要注意的一点 如果你有两块以上的硬盘，并想在不同的硬盘上安装不同的系统，那么需要注意一点，就是硬盘的连接顺序。 每块硬盘都在其电源线与数据线之间有两排共八个针，每两个针是一组，通过一个接头用来决定磁盘的一些功能。其中有一组是用来决定该磁盘是不是主盘的，有接头的是主盘，没有接头的是从盘，主机中只有一块硬盘的无需在意这个，有没有这个接头都能用，但若是有多块硬盘，那么必需只有一块是主盘，否则有两块主盘的话系统启动会出问题。 说了这么多，现在该切入正题了。 对于多块硬盘，如果先前使用的是windows，那么它对硬盘接在总线上的顺序没什么要求。但对于linux，它要求主盘必须接在总线上距离主板上IDE接口近的那个接口上，而从盘接在总线上离IDE接口远的地方。拿我来说，我有两块硬盘，原来就一块主盘，就随便接在了总线上的末端，后来增加一块从盘时，就接在了剩下的那个位于总线中间的接口上，在windows下没有出过任何问题。后来装了ubuntu,发现总是正在操作，突然就死了机，系统没有任何反应，按了主机上的reset键后，当出现启动画面时，又死了，有时需要从windows启动，然后再使用热启动，有时候要关了机再开，然后才可以进入系统。 起先我还以为是edgy不稳定，后来发现是硬盘接口惹的祸，于是把主盘和从盘的接口顺序对调了一下，问题迎刃而解。 （3）Linux下硬盘分区的概念 与windows的fat、fat32和ntfs文件系统格式不同，linux的ext2和ext3文件系统非常的高明和优秀，它具有比windows文件系统更好的安全性、稳定性和低碎片率，它产生的碎片率一般不高于0.4%,几乎不影响系统性能。所以，windows下面那套多分几个区以方便文件管理的思想可以扔到火星上去了。 另外linux对磁盘分区的管理采取“挂载”的概念，它把所有的分区都挂载到主分区的一个一个的文件夹上，任何一个文件在硬盘上的路径都是按文件夹的路径划分，而不是windows下的先按C、D、E、F分区，再按文件夹路径的方法。 具体的说，例如我的一首音乐文件在windows下的存放格式为“C:\\Music\\Classic\\一意孤行.mp3”,在linux下就可能是“/home/lans/Music/Classic/一意孤行.mp3”。 所以在划分完磁盘分区后，还有一个挂载磁盘分区的步骤，也就是将划分好的分区挂到某个目录下，swap分区无须挂载，主分区应挂载在“/”下面，其它分区可自行选择目录，建议将“/home”挂到主分区外的别的逻辑分区上（如果你分区的时候除了主分区还划分了别的逻辑分区的话），因为/home下面是你的帐户所在的主目录，而你经常使用和存放的文件大多数也都放在这里，即使以后要重装系统，也不必担心会丢失。 二、改变帐户操作理念 在windows下面，大家一般使用的都是有超级用户权限的帐户。也就是说，使用者可以为所欲为，你可以随意地、不受限制地修改硬盘中的所有数据。这就给了木马病毒以可乘之机，另外用户的任何失误都可能造成难以挽回的灾难，如果平常使用一般权限的帐户的话，由于windows本身的问题，又多有不便。 在linux下面，也有这样的超级用户，叫“根用户”，帐户名为“root”,但是由于linux的功能太强大了，一条命令就可以毁了整个系统。所以一般不使用，而是使用在安装系统时由用户自己设定的帐户，这个帐户没有超级用户的权限，只拥有对主目录（即”/home/用户名”）目录下文件的读写权限，对此外的文件只有读权限，没有写权限。 不过不必担心会遇到像windows下的困难，下面会看到，我们对系统的操作会大量使用控制台这个东西，它就相当于windows下的命令行。不过linux的命令行实在太强大了，远非DOS那个玩具可比，所以结合命令行的灵活强大和GUI的美观方便使得linux才是操作系统中的王道。 此外，如果对所做的操作很有把握，有时候使用root权限在图形界面下工作会比较方便，这需要使用root帐户登录，ubuntu默认关闭root在登录界面登录，所以需要开启它。 System -&gt; Administration -&gt; Login Screen Setup 系统 -&gt; 系统管理 -&gt; 登录屏幕设置 Login Screen Setup 登录屏幕设置 Security Tab -&gt; Options -&gt; Allow root to login with GDM (‘’’Checked’’’) 安全 -&gt; 选项 -&gt; 允许 root 通过 GDM 登录（“勾选”） 另外，还要修改root的密码，打开“系统”－“系统管理”－“用户和组” 在里面修改root的密码。 三、修改源并配置网络 （1）源及其使用方法 什么是源呢。 在windows下面，要安装程序的话，首先要选择一个你喜欢的软件下載站，在搜索引擎里面输入该软件的名字，搜到后还要选择一个快速的下載链接，使用你喜欢的下載工具，下載回来以后再执行该安装程序。很多时候还要重新启动系统，等等。 但是在linux下，这一切将会变得十分简单，你只需要在系统自带的“新立得”软件包管理器里选择想要使用的程序，然后连接上网即可。如果你事先知道想要安装的程序的名字，那么更简单，你只需要在控制台输入一条简单的命令即可。剩下的事，什么都不用你管了。这一切都是因为系统会自动从源里下載并自动安装这个软件。 系统安装后，自带的有一个源，但是由于需要选择一个下載速度快的源，另外安装别的一些软件还需要有特殊的源，所以需要修改一下源。 打开控制台输入命令： sudo gedit /etc/apt/sources.listsudo 就是 super user do 的意思 如果你安装时选择的是中文的话，那么缺省的源是位于国内的ubuntu亚洲官方源，可以在源文件上添加多个源，但速度慢的源最好不要加，否则速度将会非常的慢。wiki上的快速指南上有很多源可以选择。需要注意的是不同版本的ubuntu有不同的源，千万不要选错了源，ubuntu6.10的代号是edgy，所以打开wiki上edgy的快速指南就行了。 添加了选定的源后，保存并退出gedit。然后连上网，在控制台输入： sudo apt-get update 以更新软件列表。 sudo apt-get dist-upgrade 这个是为了更新系统 （2）配置ADSL网络 对于一直在线的用户，网络配置很容易，这里不作赘述，下面介绍一下ADSL上网的要点。 在控制台执行 sudo pppoeconf 然后按着它的提示一步一步操作即可，需要注意的是在输入ADSL帐户的时候，输入框里面缺省的有几个字，先把它们删掉再输入。后面它会提示你是不是开机自动连接上网，如果你的ADSL是按时收费，一定要选择no。 以后如果要上网，只需执行 pon dsl-provider 如果要断开连接，执行 poff 四、系统的中文化与输入法 （1）系统的中文化 ubuntu是一个国际化的操作系统，它可以兼容多个语言平台，不像windows那样还要分成多个语言的版本。 如果在安装操作系统的时候已经选择了安装中文，那么系统安装后就是简体中文的。如果安装时没有在意而装了英文版，或者想在多个语言版本之间切换，那么可又打开菜单中“系统”里面的“系统管理”，然后点选里面的“语言支持”选择即可。 （2）中文字体的美化 ubuntu的中文界面并不太美观，似乎是开源的字体还不完善，为了养眼，不得不使用一些商业字体来美化界面了。有一种也是比较流行的字体美化方案是使用苹果机的Mac系统的圆体，但是我试过后发现它只能在大于等于十四号的字体才会显示为圆体，而正常的10号却显示的是宋体，圆体虽好看，但只好望洋兴叹。这里介绍一下我的美化方案：方正黑体＋微软雅黑 方正黑体可以到百度上搜一下，微软雅黑建议到远景论坛下載。下面以我的系统为例,我的帐户名是lans,下載回来的东西都放在主目录下面： 分别是“FZHTJW.ttf””msyh.ttf”“msyhbd.ttf”“segoeui.ttf”“segoeuib.ttf”“segoeuipr.ttf”“segoeuiprb.ttf”,将它们放在主目录下新建的font目录下面 执行 sudo mv /home/lans/font/* /usr/share/fonts/truetype 将其挪入系统的字体文件夹 备份现有的 fonts.conf sudo cp /etc/fonts/fonts.conf /etc/fonts/fonts.conf.bak 以后若要恢复原来的配置，只需执行 sudo cp /etc/fonts/fonts.conf.bak /etc/fonts.conf 即可 修改字体配置文件 sudo gedit /etc/fonts/fonts.conf 在里面加入下面的内容： 12345678910111213&lt;alias&gt; &lt;family&gt;Segoe UI&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Segoe UI&lt;/family&gt; &lt;family&gt;Microsoft YaHei&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;alias&gt; &lt;family&gt;FZHei-B01S&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;FZHei-B01S&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; 在“系统”－“首选项”－“字体”里选择：应用程序字体－方正黑体－10；窗口标题－微软雅黑粗体－10；其余都是微软雅黑－10即可。如果是LCD显示器，为了更好的显示效果，建议在字体渲染里面选择“次象素平滑”。并安装类似于windows下面的cleartype的显示优化程序,执行 sudo gedit /etc/apt/sources.list 添加以下的源 deb http://www.elisanet.fi/mlind/ubuntu edgy fonts deb-src http://www.elisanet.fi/mlind/ubuntu edgy fonts 然后sudo apt-get update sudo apt-get dist-upgrade 然后刷新字体缓存 sudo fc-cache -f -v 执行完后，按Ctrl+Alt+BackSpace重新启动X-window即可。 （3）中文输入法的安装配置 a、scim 如果你在安装的时候就一直在线，那么中文输入法已经完全安装，按Ctrl+Space即可使用。若不是这样，那么系统安装的不是一个完整的中文输入法。 中文输入法比较有名的有两个，系统默认安装的是scim，我们就说这个。 执行 sudo apt-get install scim-pinyin im-switch scim-tables-zh scim-qtimm 其中scim-pinyin和scim-tables-zh可选其一，也可都安装，前者是拼音输入方案，后者包括常用的二笔和五笔等方案。 安装成功之后按Ctrl+At+BackSpace重启X-window即可使用。 b、fcitx fcitx是一款很好用的中文输入法，听到很多人说scim与系统中许多软件存在冲突，我在使用中没有发现什么问题，但是使用fcitx后确实爱不释手，因为这个工具功能上要比scim强得多，很像我以前在windows下面最喜欢使用的极点中文。 sudo apt-get install im-switch fcitx 如果是使用上面的方法安装，直接执行下面第二步，如果是使用下載的安装包安装，执行下面： 1、如果是使用下載的安装包安装，还应该执行下面的命令： sudo chmod -R 755 /usr/share/fcitx 任意位置新建立一个文件叫 fcitx，内容如下： XIM=fcitx XIM_PROGRAM=/usr/bin/fcitx XIM_ARGS=”” GTK_IM_MODULE=XIM QT_IM_MODULE=XIM DEPENDS=”fcitx” 复制到 /etc/X11/xinit/xinput.d/ 下以保证im-switch 能找到它 2、执行 代码: sudo im-switch -s fcitx 和 代码: im-switch -s fcitx 将二个帐号的输入法都换成 fcitx 3，如果是在英文local 下而无法调出输入法（XIM）(如果是中文local 不必进行此操作)修正步骤如下： 编辑 /etc/gtk-2.0/gtk.immodules 文件（sudo gedit /etc/gtk-2.0/gtk.immodules），在xim 的 local 增加 en 也就是说： 代码: “/usr/lib/gtk-2.0/2.4.0/immodules/im-xim.so” “xim” “X Input Method” “gtk20” “/usr/share/locale” “ko:ja:th:zh” 改成 代码: “/usr/lib/gtk-2.0/2.4.0/immodules/im-xim.so” “xim” “X Input Method” “gtk20” “/usr/share/locale” “en:ko:ja:th:zh” 保存退出，重启x-window就好了。 其它参考： 1，不希望使用一大堆用不着的输入法，可以关闭它： sudo gedit /usr/share/fcitx/data/tabels.conf 把里面不要的输入法整段删除，至于双拼可以在下面说的config 里关闭 2，在打字时要输入,.号经常按不出来，可以这样： ~/.fcitx 目录下有一个 config 文件（启动至少一次fcitx 才会自动建立）可以配置翻页键把里面的 ,. 二个删除，不然在出联想时打不出,. 号 3，不想让它一直显示在那，可以这样： ~/.fcitx 目录下有一个 config 文件可以配置 代码: 主窗口隐藏模式=1 4，在英文local 下 fcitx 打出的字全方块，可以这样： 修改上面说的这个config 里的 代码: 显示字体(中)=字体名 5，使用ctrl+左shift键可以切换输入方案 6，其它应用技巧可以到fcitx的主页下載其最新版的使用说明书（pdf文档）。 （4）主要程序界面的汉化 据说如果安装系统的时候一直在线，那么不但输入法会完整安装，而且各种软件的简体中文包都会安装，如果像我这样不是一直在线的，那么需要到源上下載相应的中文包，才可以实现openoffice、firefox界面的中文显示。 sudo apt-get install mozilla-firefox-locale-zh-cn openoffice.org-help-zh-cn openoffice.org-l10n-zh-cn (5)Abiword 中文乱码的解决办法 Abiword是个很好的轻量级的文字编辑排版工具，我最欣赏它的是打开文档的速度和支持文档格式的种类多样性。但是安装后的Abiword默认只支持英文，输入中文会显示乱码，想显示正常的话还要设置字体为中文字体，每次都要设置，太麻烦。 究其原因，是因为Styles的设置文件在/usr/share/AbiSuite-2.4/templates/下面，如果你使用的系统语言是简体中文，那么对应的abiword设置文件是normal.awt-zh_CN。可以使用以下方法来修改： sudo gedit /usr/share/AbiSuite-2.4/templates/normal.awt-zh_CN 将Times New Roman替换为Microsoft YaHei（或者其它你喜欢的字体），然后保存即可。 如果喜欢使用vim编辑，使用以下命令： sudo vim /usr/share/AbiSuite-2.4/templates/normal.awt-zh_CN 然后在正常模式下输入冒号，键入以下命令： %s/\\/Microsoft YaHei/g 再输入冒号，输入wq，回车即可。 五、多媒体播放器的安装与配置 （1）万能播放器mplayer 这是个linux下面很流行的播放器，系统安装完后自带的有音频和视频播放器，但是都没有很全的解码器，所以很多东西都不能播放. 从源上下載并安装mplayer： sudo apt-get install mplayer 然后安装解码器包： sudo apt-get install w32codecs 这时候，你就可以使用mplayer播放大多数媒体文件了。需要注意的是，如果打开媒体文件时提示视频设备有问题，那么可以在设置界面换一个视频驱动即可，直到没有问题为止。 mplayer皮肤的安装：假设下載回来的是名字是skin_name.tar.bz2的压缩包： sudo tar jxvf /路径名/skin_name.tar.bz2 sudo mkdir -p ~/.mplayer/skins #如果你是第一次安装皮肤，只需执行一次 sudo cp /路径名/skin_name ~/.mplayer/skins/ &amp;&amp; mv ~/.mplayer/skins/{skin_name,the_other_name} #mplayer皮肤列表中将显示为the_other_name （2）音频播放器audacious及mp3文件tag乱码的解决 a、audacious mplayer虽是万能的，但是听音频文件最好还是用专门的音乐播放器，这里推荐现在开始流行的audacious. sudo apt-get install audacious 安装audacious的解码器 sudo apt-get install audacious-plugins audacious-plugins-extra audacious-plugins-extra-console 安装完成，现在可以使用它来听多种格式的音频文件了。 另外，audacious的播放列表默认使用UTF-8的编码，但大多数mp3使用的是GBK编码，所以播放列表上会出现乱码，我只发现一种不彻底解决的办法，就是打开audacious的设置界面，在插件栏目里面选择mpeg插件，在其首选项里面的“标题”里把“ID3格式”后面填上“GBK”，保存即可。这样以后再往播放列表里面添加歌曲的时候虽说刚开始还是乱码，但是当开始播放这首音乐的时候就会变成正常的标题，目前似乎还没有更好的方法。 b、mp3的tag乱码 使用工具：ID3iconv 0.2.1 使用方法：cd 到你要的文件夹下，用这个命令转换： java -jar ~/id3iconv-0.2.1.jar -e GBK /路径/*.mp3 注意：我这边用 -e 指定 mp3 原来的编码是 GBK 的。繁体中文就改为 Big5 如果有很多个子文件夹，又不想一个一个 cd 到里面转换，可以配合 find 命令来解决： find . -iname “*.mp3” -execdir java -jar ~/id3iconv-0.2.1.jar -e GBK {} \\; find 命令中的 -execdir 参数是让转换的程序在 找到的文件的 那个目录里执行， 也就相当于一个一个 cd 到里面再转换了。 （3）媒体解码库gstreamer gstreamer是针对系统自带的音频和视频播放器的解码包，打开“新立得”软件包管理器在里面搜索gstreamer，你会得到一大堆结果，在里面选择你需要的解码包即可。 六、网络工具的安装与配置 （1）Opera的安装与配置及中文输入法问题的解决 Opera是linux上另一款可以和Firefox比美的浏览器，占用系统资源比firefox低，性能比firefox要好，而且是唯一一个得到国际认证的浏览器，我尤其喜欢它极其强大的快捷键设置。但是源里现在似乎没有，需要从网上下載。 打开www.opera.com，如果你在linux下使用firefox浏览的话，那么第一个页面应该就是opera的linux版，注意选择ubuntu下載包。 下載下来之后双击运行，将会用deb解包器打开，点选上面的安装即可。下面介绍使用控制台安装的命令：（假设下載回来的文件名是opera.deb） sudo dpkg -i opera.deb 卸载的时候使用： sudo dpkg -r opera dpkg是专门用来处理”.deb”格式的安装包的命令，更深的应用可在控制台下输入 dpkg –help 来了解。 下面介绍opera界面的汉化，安装完成后只有英文语言文件，输入以下命令获取9.01版本的中 文语言文件： wget -c http://www.opera.com/download/lng/901/ouw901_zh-cn.lng gedit ouw*.lng ctrl+H 9.01-&gt;9.10 在opera浏览器的语言设置中选中*_zh-cn.lng即可 opera安装后如果遇到中文输入法不能使用的问题，输入以下命令修改文件： sudo gedit /usr/bin/opera 在开头添加: export QT_IM_MODULE=XIM #使 SCIM 能够输入中文 export LC_ALL=zh_CN #使 Opera 能够以你选择的字体显示中文 现在可以正常使用了。 （2）即时通讯程序 (a)集成即时通讯工具gaim 系统已默认安装了集成即时通讯工具Gaim,但是系统默认安装的gaim不带QQ插件，现在打开“新立得”，在里面搜索gaim，然后卸载它。 再到Gaim中国下載集成了QQ的gaim版本，网址是：www.gaimcn.com 下載下来的是个deb包，使用刚才介绍的安装方法安装即可，安装完毕后就可以使用了，里面已集成有QQ协议。 Gaim使用中你会发现，如果你使用的是多帐号，那么它们要么同时在线，如果你设置状态为隐身，那么所有的帐号都被隐身，如果你希望设置帐号之间使用不同的状态，那么点击软件界面最下方的状态选择处，最下面有新建的按钮，新建一个状态，你可以设置有的帐号隐身，有的帐号在线，然后保存这个状态，以后选择相应的状态即可选择谁在线，谁隐身，需要注意的是你设置的时候要在这个新建的状态中为每个帐号选择一个状态，即你新建的其实是一个状态组合。 (b)最逼真的QQ工具 LumaQQ是linux下最逼真的QQ工具。 它需要java运行时环境的支持，所以要先安装java运行时环境： sudo apt-get install sun-java5-jre 设置当前默认的java解释器: sudo update-alternatives –config java 执行后会出现类似如下的画面: 12345678There are 4 alternatives which provide `java&apos;. Selection Alternative ----------------------------------------------- *+ 1 /usr/lib/jvm/java-gcj/jre/bin/java 2 /usr/bin/gij-wrapper-4.1 3 /usr/bin/gij-wrapper-4.0 4 /usr/lib/jvm/java-1.5.0-sun/jre/bin/java Press enter to keep the default[*], or type selection number: 输入 有包含 “sun” 的行的前面的数字。如上面显示，则输入 4，然后回车确定。 然后到LumaQQ官方站点下載相应的压缩包，解压，然后将目录移入/opt目录： sudo mv /路径/LumaQQ /opt 建立快捷方式： sudo gedit /usr/share/applications/LumaQQ.desktop 在新增的文件内加入下面这几行 12345678[Desktop Entry] Name=LumaQQ Comment=QQ Client Exec=/opt/LumaQQ/lumaqq Icon=/opt/LumaQQ/QQ.png Terminal=false Type=Application Categories=Application;Network; 保存编辑过的文件,到(应用程序 -&gt; Internat -&gt; LumaQQ)执行之。 （c）功能最强大的QQ工具Eva Eva是KDE下面的一个QQ客户端，这里需要说明的是GNOME与KDE下的程序在彼此环境里是可以通用的，我使用后就毅然抛弃其它几种QQ客户端，因为它的界面不但小巧好看，而且最重要的是它的功能是linux下面最强的。 Eva可以接收图片、自定义表情，进行屏幕截图，传送图片，传送文件，可以说和官方QQ相比，除了视频、语音之外，它具备了所有实用的功能。 sudo apt-get install eva （d）多协议即时通讯工具Kopete Kopete也是KDE下面的工具，它类似GNOME下的gaim，但是我觉得不管是界面还是功能，都比gaim要好，如果你喜欢使用MSN,yahoo msg,ICQ等，可以安装这个东西： sudo apt-get install kopete （3）新闻阅读 如果你希望阅读RSS聚合新闻，那么还要安装RSS新闻阅读器，这里推荐liferea: sudo apt-get install liferea 另外我现在使用的一款KDE下的工具也很好： sudo apt-get install akregator （4）邮件客户端 系统自带的evolution已经是很好的邮件客户端了，需要指出的是，在evolution里面设置gmail的帐号不用另外设置其pop和smtp的端口号，因为gmail的端口号与别的邮箱不同，在windows下面需要另外设置。 （5）下載工具 比较有名的是d4x，现在新兴的有个MultiGet,如果使用d4x的话，输入命令： sudo apt-get install d4x 如果希望使用MultiGet,请到论坛下載，源里似乎没有。 （6）p2p工具 sudo apt-get install amule #win下的emule用这个代替 sudo apt-get install Azureus #win下的bitcomet用这个代替 七、编辑器、编译环境与词典 （1）编辑器 Linux下面的编辑器十分强大，功能也十分丰富，是windows下面的那些文本编辑器所不能比拟的。比较有名的是vim和emacs. 这里以vim为例，使用源安装，输入命令： sudo apt-get install gvim vim的功能非常丰富和强大，最好找一些专门的资料去学习，另外它自带的也有很详细的帮助文件，只不过是英文的，英文好的可以看一下。 （2）编译环境 Linux是开源的，所以有很多发行版，像redhat,redflag,suse,ubuntu等等，这些发行版虽然都是使用的是linux内核，但是由于种种原因，系统的环境变量不尽相同，使用在一个系统上打包的安装包在另一个系统上安装程序，往往会出现问题，但是在所有的linux发行版中安装程序有一个普适的方法，就是使用源代码安装，这就需要编译环境，另外如果你想在linux下面编程，也需要它。 输入命令： sudo apt-get install build-essential bin86 kernel-package libqt3-headers libqt3-mt-dev （3）词典 星际译王是个很好的词典工具，它的功能相当于windows下面的金山词霸。 sudo apt-get install stardict 这里安装的只是星际译王的词典程序，它有很多词典供你选择安装，你可以到源上去选择： sudo apt-get install stardict* 然后选择你喜欢的词典安装即可。也可以到其官方站点选择词典下載后安装。 http://stardict.sourceforge.net/ 将下載的词典解压，然后复制或移动到/usr/share/stardict/dic 八、NVIDA显卡驱动与Beryl的安装 Beryl是linux下的一个主题管理程序，说它相当于windows下面的windowblinds不知道恰当不恰当。安装了beryl之后，linux的桌面变得比之windows vista有过之而无不及，喜欢漂亮界面的可以试用一下。 当然，使用beryl的代价是牺牲系统性能，使用beryl的机子工作效率会比之前低一些。而且有人反映装了beryl之后会使系统变得非常慢，不知道是硬件的原因还是别的什么东西，不过大多数人应该不会出现什么问题，我的机子配置并不高，好几年前配的了，但是一直使用beryl都没有什么问题，速度也完全可以接受。 下面介绍的是NVIDA的显卡下，beryl的安装。因为我用的就是nvida的显卡。 另外需要说明的是下面的内容借鉴了论坛里面“NV 1.0-9629驱动+edgy+aiglx+Beryl方法汇总”的帖子，在此对作者表示感谢。 （1）nvida显卡驱动的安装 首先，要确认你的系统是全新安装的ubuntu6.10,而不是从6.06升级上来的，否则可能会出问题。 其次，到http://www.nvidia.com/object/unix.html下載对应32/64位版本的驱动，假设放在/home/lans/下面， 删除原有驱动(假设你安装过源里面的nvidia-glx驱动，如果没有装过或曾经手动安装驱动的可以跳过）： sudo apt-get –purge remove nvidia-glx 然后灰复X的设置 sudo cp /etc/X11/xorg.conf.backup /etc/X11/xorg.conf 重启，确定起动正常 然后，执行命令： sudo gedit /etc/default/linux-restricted-modules-common 在最后的双引号里面添加nv两个字，添加后就是“nv” 预防起动X失败 sudo cp /etc/X11/xorg.conf /etc/X11/xorg.conf.mybackup 如果起动X失败，可以用sudo cp /etc/X11/xorg.conf.mybackup /etc/X11/xorg.conf来灰复X设置，然后起动 以下为网络上留传的要点，原贴作者多台机器安装没有使用，我安装的时候也没有用，如果不 行，可以尝试（但是会删除受限制模块，导致某些别的硬件无法使用： sudo apt-get –purge remove nvidia-settings nvidia-kernel-common sudo rm /etc/init.d/nvidia-* 下面开始安装（对于曾经手动安装nv驱动的，可以在安装的时候选择卸载旧版的驱动）： 请拿出一张纸和一支笔，记录下一下的命令，因为我们要去到纯终端里面安装 注销后，按Ctrl+Alt+F1，输入用户名和密码，登录后关闭gdm： sudo /etc/init.d/gdm stop 然后开始安装（假设下載的文件放在/home/lans/目录下） sudo sh /home/lans/NVIDIA-Linux-x86-1.0-9629-pkg1.run(如果你下載的是64位驱动 sudo sh /home/lans/NVIDIA-Linux-x86_64-1.0-9629-pkg1.run） 进入安装界面后，首先接受协议，选“接受” 可能会有提示已经安装了旧的驱动（视乎你自己是否有手动安装过），是否删除，选yes就是了， 一般会提示缺少模块，问是否网上下載，选“no”， 提示需要自己编译模块，选“ok”，然后编译安装开始， 最后提示需要修改xorg.conf，是否允许，选yes，完成安装，选ok。 然后回到终端界面,重启gdm: sudo /etc/init.d/gdm start 现在可以重启试试驱动是否已经装好，在“应用程序-》系统工具-》NVIDIA X server setting里面可以看到驱动的信息 提示：每次更新内核后都需要重新安装nv的驱动！ （2）安装Beryl 1.添加源 ： sudo gedit /etc/apt/sources.list 加入以下源的其中一个 ： deb http://www.beerorkid.com/compiz edgy main-edgy deb http://media.blutkind.org/xgl/ edgy main-edgy deb http://compiz-mirror.lupine.me.uk/ edgy main-edgy deb http://ubuntu.compiz.net/ edgy main-edgy 如果是64位的： deb http://www.beerorkid.com/compiz edgy main-edgy main-edgy-amd64 deb http://media.blutkind.org/xgl/ edgy main-edgy main-edgy-amd64 deb http://compiz-mirror.lupine.me.uk/ edgy main-edgy main-edgy-amd64 deb http://ubuntu.compiz.net/ edgy main-edgy main-edgy-amd64 保存后退出 然后加入钥匙，在控制台输入：（下面的任选其一） wget http://www.beerorkid.com/compiz/quinn.key.asc -O - | sudo apt-key add - wget http://media.blutkind.org/xgl/quinn.key.asc -O - | sudo apt-key add - wget http://compiz-mirror.lupine.me.uk/quinn.key.asc -O - | sudo apt-key add - wget http://ubuntu.compiz.net/quinn.key.asc -O - | sudo apt-key add - 刷新库 sudo apt-get update sudo apt-get dist-upgrade 2.安装beryl sudo apt-get install beryl emerald emerald-themes 修改xorg.conf sudo gedit /etc/X11/xorg.conf 在 Section “Screen” 里面添加 Option “AddARGBGLXVisuals” “True” 保存并退出. 下面为可选(我没有使用)： 在 Section “Device” 里面添加 Option “TripleBuffer” “true” 添加如下一项：（本人没有添加） Section “Extensions” Option “Composite” “Enable” EndSection 保存退出 3.最后,在系统-》首选项-》会话-》起动程序 里面添加一项”beryl-manager“ 注销 alt+ctrl+backspace，重启X 再登录，就可以看到beryl的效果了。 附：错误解决 如果出现窗口框闪烁，可以在系统-》首选项-》会话-》起动程序 里面添加一项”emerald –replace“ beryl 除了自己附带的主题，还可以到 http://browse.deviantart.com/customizat … linuxutil/ http://gnome-look.org/ 去下載。 （3）Splash Screen的安装 a、Ubuntu Splash 即输入用户名和密码后进入桌面时显示的那个长方形图形，喜欢换皮的可以在以下路径修改： /usr/share/pixmaps/splash/ubuntu-splash.png b、OpenOffice Splash 即运行openoffice时显示的那个图片，在以下路径： /usr/lib/openoffice2/program/openintro_ubuntu.bmp c、gimp splash /usr/share/gimp/2.0/images 九、Wine的安装 wine用来在linux下面运行一些windows下面的程序，不是所有的windows的程序都可以使用wine来运行，只是一部分。 输入以下命令从源里安装wine： sudo apt-get install wine 为了方便使用，建议安装EasyWine,这是个wine的辅助工具。 可以到linux公社下載。 安装完毕后，在控制台输入 EasyWine即可启动程序，注意大小写，linux严格区分大小写。需要注意的是，如果运行时出现错误，就使用以下命令运行EasyWine, bash EasyWine 通过以下命令可以设置wine的参数： winecfg 运行程序时使用以下命令： wine /程序路径/程序名称.exe 十、虚拟机VMware 如果有些事需要在windows下面做而又嫌装双系统麻烦的可以使用这个虚拟机。可以到linux公社下載，然后安装。linux公社上面有它的注册码，安装完后在“帮助”菜单里面输入注册码。 解压后在控制台执行： cd /路径 即进入该目录 执行./vmware-install.pl 十一、磁盘分区的挂载 如果你在装系统时有的分区没有挂载，或者装完系统后磁盘分区有所变更，那么需要使用一些命令来重新挂载分区。 （1）挂载一个原先存在而没有挂载的分区 例如，我要挂载第二块磁盘第一分区(对应的是/dev/目录下面的hdd1,第二第三分区对应的是什么应在“系统管理”里面参看“设备管理器”) 1.建立挂载目录 一般把分区挂在/media下面，建立hdd1目录，此目录名字任意 sudo mkdir /media/hdd1 2、挂载分区 分区为ntfs格式： sudo mount -t ntfs /dev/hdd1 /media/hdd1 分区为fat32格式： sudo mount -t vfat /dev/hdd1 /media/hdd1 3、自动挂载分区 按照第二步的方法挂载的话，下次启动系统时不会自动挂载，要想让系统自动挂载该分区，输入以下命令： sudo cp /etc/fstab /etc/fstab_backup sudo gedit /etc/fstab 在打开的文件里最后一行加入： /dev/hdd1 /media/hdd1 ntfs utf8,umask=0222 0 0 如果是fat32分区，输入： /dev/hdd1 /media/hdd1 vfat utf8,umask=000 0 0 保存并退出，重新启动系统即可。 （2）新加入一块还没有分区的全新的硬盘 论坛里有相应的帖子，此处不再赘言。 十二、游戏 （1）linux下面的游戏 linux志在成为一个稳定高效的操作平台，由于其应用方向和用户人群的特定性，所以这上面的游戏都是一些休闲类、智力类的小游戏。这并不是说linux就做不出大型的高质量的游戏来，比如DOOM，据说CS就是对DOOM的拙劣模仿。 1、泡泡龙 sudo apt-get install frozen-bubble 2、百战天虫 当然不是官方的东西，一个2D模仿百战天虫的东东 sudo apt-get install wormux 3、linux下的雷电 看起来不错，但是我装上后速度非常慢，不知道什么原因。 sudo apt-get install chromium 4、等等 在菜单中的“添加删除程序”中还有很多，可自行选择。 （2）win下的游戏 如果你安装了wine,那么windows下面的一些游戏你仍然可以玩，众所周知的就是魔兽争霸了，具体的设置方法见论坛上的相关帖子，由于我不常玩儿游戏，这里不作介绍，相信你选择linux也不是为了玩儿游戏的。 十三、一些常用工具 （1）读写ntfs分区 ubuntu默认只支持对ntfs分区的读操作，而不支持写操作，现在使用ntfs-3g已经可以实现对ntfs分区的写操作。 需要特别说明的是，现在ntfs-3g还没有完美支持这项功能，据我使用的体会而言，在ntfs上建立文件和文件夹是没有问题的，但是删除文件的时候，回收站没有提示，文件其实已经移入该分区的”.Trash-用户名”目录里面了，只能手工清除了。另外，对中文的支持也不完美，有时候会出现带有中文的文件及文件夹均无法显示的问题。 sudo apt-get install ntfs-3g sudo gedit /etc/fstab 修改你的ntfs分区那一行，原先的”ntfs”改为”ntfs-3g”即可。例如我的是 /dev/hda5 /media/hda5 ntfs-3g efaults,nls=utf8,umask=007,gid=46 0 0 sudo gedit /etc/modules 在文件末尾加上一行内容”fuse” 重启生效，或是使用命令重新挂载 sudo modprobe fuse sudo umount -a sudo mount -a 如果出现问题，只需将上面的ntfs-3g替换为ntfs然后再重启或重新挂载即可。 （2）java日记本 一直觉得linux下面写日记没有什么好东西，后来想起来原来在windows下就用过一个java日记本，还不错。 首先你应该确认已经安装了java运行时环境，如果没有，请参看lumaqq的安装部分。 我在网上没有找到linux下面的压缩包，于是下了一个windows下面的安装程序，在虚拟机里安装后，将其文件夹复制出来。 执行里面的jdiary.sh就行了，如果没有运行，那是因为该脚本是在win下编写的，里面的回车bash不认所致，使用gedit打开该脚本，然后把里面的回车全部删除，再重新回车即可。 （3）图片管理Picasa Google的这款图片管理软件相信很多人都知道吧，到它的主页下載并安装即可。 （4）光碟烧录GnomeBaker sudo apt-get install gnomebaker （5）CHM阅读器 很多电子书都是chm格式的，如果需要阅读，可以使用这个工具，在“新立得”或“添加删除程序”里面找吧。 有些chm文件阅读时会出现乱码或者左边的目录显示不出来的问题，这时需要使用别的工具来阅读了，我现在使用的是firefox的一款插件chm reader，你可以到它的插件下載网页下載安装，一次看不完时还可以把当前页面加入收藏夹，下次直接打开收藏夹中链接即可，很方便。 （6）数学程序 a、scilab:功能相当于matlab,法国科学院出品。 sudo apt-get install scilab b、Maxima:出身名门，上个世纪六十年代由MIT（麻省理工）开发，原来美军赞助的东东，功能相当于mathematica，我现在就是以它为计算工具，非常好用。 sudo apt-get install maxima 安装后的maxima没有图形用户界面，它是在控制台上运行的，当然你可以安装它的图形用户界面： sudo apt-get install wxmaxima 十四、Linux下程序的安装 （1）deb软件包的安装 deb是Debian Linux提供的一个包管理器，优点是不被严格的依赖性检查所困扰。ubuntu使用的就是这种软件包。 安装方法： sudo dpkg -i /软件包路径/软件包名字.deb 卸载方法： sudo dpkg -r 软件名字 另外在ubuntu桌面版中你也可以直接双击该软件包，里面有安装按钮。 （2）rpm软件包的安装 RPM全称是Red Hat Package Manager（Red Hat包管理器）。它最初是RedHat开发的软件包，在很多linux发行版上应用很广泛。在ubuntu中，应先将其转化为deb包，然后再安装，转化方法为： sudo alien 软件包名称.rpm 然后再执行sudo dpkg -i 软件包名称.deb 如果提示不认alien命令，执行： sudo apt-get install alien （3）使用源码进行安装 使用源代码安装软件，能按照用户的需要选择定制的安装方式进行安装，而不是仅仅依靠那些在安装包中的预配置的参数选择安装。它可以克服linux发行版众多的问题。 首先将下載回来的源码解压到一个目录里，然后进入这个目录： cd /目录路径 获得root权限： su root 执行： ./configure 配置选项 #本步非必须，你下載源码的时候一般在下載页面都会有安装提示，源码包里的Readme和Install文件也会有说明，如果说要执行这一步，那么按照提示操作即可。 下面编译： make 如果提示出错，那么看看上面./configure后有没有提示有什么东西不存在，如果有，只要执行：sudo apt-get install 该缺失组件名称 即可。 下面安装： make install 下一步为可选，用来清除安装时产生的临时文件： make clean 卸载时进入该源码目录，执行： make uninstall （4）绿色软件 解压即可运行的程序。 解压后cp或mv到任一目录即可。 十五、其它GUI的安装 1、KDE KDE是和GNOME齐名的一个GUI，它可以和GNOME共存，在登录界面可以选择是从KDE启动还是从GNOME启动，KDE和GNOME下面的程序在彼此上面都可以运行。使用下面命令安装KDE及KDE下常用工具： sudo apt-get install kubuntu-desktop 安装完成后会提示你使用KDM还是GDM，这两个分别是两者之下的桌面管理程序，随便选择一个即可，以后如果想切换，执行以下命令： sudo dpkg-reconfigure kdm 十六、进阶技巧 （1）关于Grub的FAQ 1、如何使用liveCD修复Grub？ 在终端下输入： sudo su grub 你应该看到像这样的东西： grub&gt; 接着输入： root (hdx,y) setup (hdx) 不要完全照样输入，先弄懂这些命令的含义。 hd表示硬盘，格式是 (hd硬盘号,分区号) 从零开始计算。 所以（按照日常的习惯，从1开始数），(hd0,0)表示第一个硬盘的第一个分区，(hd0,1)表示第一个硬盘的第2个分区，(hd1,4)表示第2个硬盘的第5个分区。 （注意，linux系统里是用hda1表示第一个硬盘的第一个分区，不要把它和grub中的表示混起来。） root (hdx,y) 这里的(hdx,y) 是/boot 目录所在的分区（通常情况下，也就是你装ubuntu系统的分区，除非你安装的时候把/boot分出去了。）如果你不知道你把ubuntu装在第几个分区，可以在输入root (hd0, 时按Tab键来补全。（假设你把ubuntu装在第一块硬盘上） 按了tab后，你将看到一些有关各个分区的信息。通常你可以通过分区的大小和格式看出你把ubuntu系统装在哪里了。 setup (hdx) 通常情况下，是setup (hd0)。（多半你把ubuntu装在第一块硬盘上。）要注意的是，不要输入setup (hd0,0)。我曾经犯过这个错误。(如果你没把命令抄下来，凭记忆操作的话，可能会犯这种错误。） 最后，用 quit 退出grub,重启系統。 2、两块硬盘，第一块装ubuntu，第二块装winxp,怎样设置grub使之可引导xp? sudo gedit /boot/grub/menu.lst 然后在最后加上如下内容即可： title Microsoft Windows XP Professional root (hd1,0) makeactive map (hd0) (hd1) map (hd1) (hd0) chainloader +1 （2）桌面图标隐藏、显示设置 执行： gconf-editor 在下面路径设置： app-&gt;nautilus-&gt;desktop-&gt;vomules_visible （3）在/var/cache/apt/archives里面发现大量原来使用apt-get下来的deb包，太占空间了，能不能删掉？ 执行： sudo apt-get clean （4）gvim的字体太难看，怎样设置为雅黑? 首先应确认你已安装雅黑字体，然后执行： touch ~/.gvimrc //已存在~/.gvimrc文件就直接执行下面的 cat &gt;&gt; ~/.gvimrc “设置默认字体 set guifont=Microsoft\\ YaHei （5）为什么键盘上的左右箭头不能用了？ 不知道是系统自己的bug还是别的什么原因，这是因为你在“系统”－“首选项”里面设置了快捷键，在快捷键里面删除使用左右箭头的键即可解决问题。 (6)有些常用命令记不住怎么办? 如今的GNOME和KDE图形用户界面已经可以完成几乎一切工作了，但是命令行在做很多工作的时候非常方便，所以经常使用的命令比较长或者不容易记住会是件很崩溃的事情，不过可以使用以下方法缩短这些命令: 在终端中输入: sudo gedit /etc/bash.bashrc 在打开的文件里面加入以下代码: alias update=’sudo apt-get update’ alias upgrade=’sudo apt-get dist-upgrade’ alias go=’pon dsl-provider’ 这里列出了三个自定义命令:第一个使用update代替单引号中的命令，这样以后在终端中直接输入update就可以更新源中程序的列表了；第二个使用upgrade代替后面单引号中的内容，以后使用upgrade即可在源得到更新后更新系统，第三个使用go来代替后面的ADSL拨号命令。 自定义命令是可以任意起名字的，但是事前你应该确认系统中没有这个命令，可以在终端中输入你想用的单词并回车，如果提示没有这个命令，才可以自定义。 （7）快速搜索文件 当然你可以使用系统自带的图形界面的搜索工具，事实上我也经常使用它；也可以安装类似windows下面的百度硬盘、Google桌面一样的桌面搜索工具“Beagle”；但是我不喜欢前者的低速和后者过于占用内存，以前在windows下，我喜欢使用一款叫“locate32”的搜索工具，它只需先建立一个硬盘中数据的数据库，然后什么时候需要搜索，什么时候打开它就行了。这种工具借鉴了桌面搜索的快速和普通搜索工具的平时不占用系统资源的优点，所以我很喜欢。 在linux下面，系统同样提供了这样一个工具，它应该是默认就安装上了的。 首先，在控制台下输入命令： sudo updatedb 键入密码后开始建立数据库，完成后输入： locate 关键词 即可找到硬盘中所有携带该关键词的文件。 这种工具的缺点也很明显，由于它平时不运行，所以它不能实时捕捉到硬盘上文件的变化，如果你所要找的文件比数据库建立的时间要新，那么可能就找不到。所以要经常利用系统空闲的时间更新数据库。 （8）“不打开”音乐播放器预听mp3 windows下面可以在某音乐文件上单击鼠标选中后在文件夹中预听，在linux下会更简单、有趣： sudo apt-get install mpg123 mpg123是linux命令行界面下听mp3的工具，经常工作在CLI（COMMAND LINE INTERFACE）下又喜欢听歌的人是不会陌生的。 在GNOME（KDE下我没有试）下它会有另一种妙用，安装成功后，打开音乐文件夹，找到一个mp3格式的文件，将鼠标箭头放上去，什么都不用做，音乐会自动播放，当你将鼠标箭头移走时，音乐自动停止。 这是因为鼠标箭头放在mp3文件上时，系统会自动调用mpg123在后台播放该文件，箭头移走后，mpg123自动关闭，所以不用担心会无谓的占用系统资源。","categories":[{"name":"計算機","slug":"計算機","permalink":"http://0x3f.org/categories/計算機/"}],"tags":[{"name":"Ubuntu","slug":"ubuntu","permalink":"http://0x3f.org/tags/ubuntu/"},{"name":"教程","slug":"教程","permalink":"http://0x3f.org/tags/教程/"}]},{"title":"「熊貓燒香」","slug":"panda-burning-joss-sticks","date":"2007-02-17T10:28:00.000Z","updated":"2018-04-01T15:00:55.000Z","comments":true,"path":"post/panda-burning-joss-sticks/","link":"","permalink":"http://0x3f.org/post/panda-burning-joss-sticks/","excerpt":"","text":"前一段的維金，現在的熊貓燒香，windows上總是不消停。 當年的衝擊波，那是我唯一一次中毒的經歷，居然還很興奮。自從轉到Linux，感覺這些都離我越來越遠，竊自暗爽。 說到瑞星和卡巴斯基的撕逼，曾經也為選殺毒軟件很頭疼，後來幡然醒悟，只是個心理安慰，隨便裝一個就行了。當然，還是現在在Linux上裸奔更好。","categories":[{"name":"青梅煮酒","slug":"青梅煮酒","permalink":"http://0x3f.org/categories/青梅煮酒/"}],"tags":[{"name":"隨筆","slug":"隨筆","permalink":"http://0x3f.org/tags/隨筆/"},{"name":"新聞","slug":"新聞","permalink":"http://0x3f.org/tags/新聞/"}]}]}