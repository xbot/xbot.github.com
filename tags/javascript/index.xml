<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JavaScript on 晴耕雨讀</title><link>http://0x3f.org/tags/javascript/</link><description>Recent content in JavaScript on 晴耕雨讀</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>© 淘气 2021</copyright><lastBuildDate>Tue, 21 Feb 2017 14:58:08 +0000</lastBuildDate><atom:link href="http://0x3f.org/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>在Vim中格式化Javascript、HTML和CSS</title><link>http://0x3f.org/posts/vim-js-beautify/</link><pubDate>Tue, 21 Feb 2017 14:58:08 +0000</pubDate><guid>http://0x3f.org/posts/vim-js-beautify/</guid><description>依赖 vim-jsbeautify js-beautify js-beautify的安装：
1 2 3 npm -g install js-beautify # 或 pip install jsbeautifier 配置快捷键 1 2 3 4 vmap &amp;lt;leader&amp;gt;jsb :&amp;#39;&amp;lt;,&amp;#39;&amp;gt;!js-beautify -i&amp;lt;CR&amp;gt;autocmd FileType javascript noremap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;jsb :call JsBeautify()&amp;lt;CR&amp;gt;autocmd FileType html noremap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;htmlb :call HtmlBeautify()&amp;lt;CR&amp;gt;autocmd FileType css noremap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;cssb :call CSSBeautify()&amp;lt;CR&amp;gt;</description></item><item><title>BiuBiu: A Chrome Extension Blocking AJAX Requests</title><link>http://0x3f.org/posts/chrome-extension-biubiu/</link><pubDate>Thu, 31 Dec 2015 14:19:00 +0000</pubDate><guid>http://0x3f.org/posts/chrome-extension-biubiu/</guid><description>BiuBiu BiuBiu is an extension for Google Chrome Browser which intends to make life easier for debugging and profiling.
For now, it only blocks AJAX requests made by JQuery, more features may be added in the future.
Features Toggle to enable or disable BiuBiu. Block requests made by JQuery by URL. Author Donie Leigh &amp;lt;donie.leigh at gmail.com&amp;gt; Links Project: https://github.com/xbot/chrome-biubiu FAQ &amp;ndash; &amp;ndash; Change Log version 1.</description></item><item><title>用Dojo实现拖放操作的最佳实践</title><link>http://0x3f.org/posts/practical-drag-and-drop-implementation-with-dojo/</link><pubDate>Tue, 05 Nov 2013 16:58:00 +0000</pubDate><guid>http://0x3f.org/posts/practical-drag-and-drop-implementation-with-dojo/</guid><description>网上关于Dojo实现拖放操作的资料都讲得很浅，所以我在研究这个东西的时候在一些细节上费了不少功夫，例如创建自定义样式的拖拽物件、将光标置于拖拽开始时的位置等等。这些细节一般在实现个性化的拖放操作时都要涉及，但几乎找不到任何直接的资料，所以本文斗胆宣称是当前Dojo拖放的最佳实践。
创建自定义样式的拖拽物件 Dojo缺省的拖拽物件样式很丑，通过覆盖官方文档里列出的几个CSS的class可以有限地调整部分样式，如果需要更多个性化，就需要使用自定义的物件模板。
通过重载Source对象的creator方法可以实现这一点。这个方法会在创建拖拽物件的时候被调用，如果hint参数的值为“avatar”就表示将被创建的是被拖拽物件，此时可以使用预先定义好的模板avatarTmpl创建物件的node。
1 2 3 4 5 6 7 8 9 10 11 this.dndSrc = new Source(this.itemList.domNode, { copyOnly:true, selfAccept:true, creator: function(item, hint) { var n; if (hint == &amp;#39;avatar&amp;#39;) { n = domConstruct.toDom(lang.replace(avatarTmpl, item)); } return {node:n, data:item, type:[&amp;#39;text&amp;#39;]}; } }); 置光标位置于拖拽起始处 在拖拽开始后，Dojo默认将光标置于被拖拽物件的左上角，而一般把光标置于拖拽开始时相对于物件的位置处显得比较自然。
实现方式是先记录拖拽开始时光标的位置，然后设置dojo.dnd.Manager的两个位移属性。
1 2 3 4 5 6 7 8 9 10 on(this.domNode, &amp;#39;mousedown&amp;#39;, lang.hitch(this, this._setDndOffset)) _setDndOffset: function(evt){ // summary: 鼠标按下时将光标相对于组件的位移设置为dojo.dnd.Manager的位移 // 即使光标在拖动开始后位于拖动开始时的位置 var cPos = Functions.</description></item><item><title>IE中使用IFrame上传文件报错——TypeError:拒绝访问</title><link>http://0x3f.org/posts/typeerror-access-denied/</link><pubDate>Sat, 03 Aug 2013 01:03:00 +0000</pubDate><guid>http://0x3f.org/posts/typeerror-access-denied/</guid><description>场景为：
点击一个图标，打开文件选择对话框，选择好文件后即时上传。
之前的实现方式是在一个隐藏表单中放一个file类型的input元素，通过调用input.click()打开对话框，同时监听input.onchange，最后通过dojo/request/iframe上传文件。
这个实现方式在Chrome和Firefox里都没问题，但是在IE里报错：“TypeError:拒绝访问”。原因是IE要求必须通过点击file类型的input的按钮打开选择对话框，否则就报这个错误。
解决办法是修改input元素的样式，或者直接用dojox.form.Uploader替代。
因为这个破问题又血战到半夜，只支持IE9+的世界你们好吗，还支持IE7+的屌丝伤不起……不起……起……啊。IE不死，吾难未已！！！</description></item><item><title>Dojo DnD: Cannot read property 'type' of undefined</title><link>http://0x3f.org/posts/dojo-dnd-cannot-read-property-type-of-undefined/</link><pubDate>Thu, 11 Jul 2013 22:44:00 +0000</pubDate><guid>http://0x3f.org/posts/dojo-dnd-cannot-read-property-type-of-undefined/</guid><description>场景如下：
假设有两个Widget：ItemListWidget和ItemWidget，后者要被创建多份并追加到前者内部，同时ItemListWidget要作为dojo/dnd/Source，每个ItemWidget作为一个单元可被拖拽到另外一个dojo/dnd/Target容器中。
问题是，当Source被创建后，再添加到ItemListWidget的ItemWidget实例在被拖拽时会报如下错误：
Uncaught TypeError: Cannot read property &amp;lsquo;type&amp;rsquo; of undefined
在Chrome开发工具中点开这个错误，显示以下内容：
从方法的注释或API中可以看到，checkAcceptance()是用来判断当前拖拽对象是否在这个target接受的范围之内，接受规则用Source和Target的构造参数中的“accept”定义。在这个方法里通过Source.getItem()方法拿到的对象是null，上述错误就是从这儿报出来的。
接合API和Reference Guide发现，每个Source中的可拖拽项目在Source中都要有一个对应的对象，这个对象至少包括两个属性：“data”和“type”。在Reference Guide中，对这两个属性有详细说明，简言之，data是向Target传递的数据，type是被Target用来判断拖拽个体是否属于接受范围的依据。
当Source实例被创建时，已经存在于ItemListWidget中的ItemWidget实例会被自动创建对应的上述对象，但之后加入的不会。解决的办法是调用Source.setItem()方法为每一个新加入的ItemWidget关联相应的对象，或在ItemWidget中添加一个构造参数，用于指定Source，并在postCreate()方法中为当前ItemWidget实例关联相应的对象:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 define([ &amp;#34;dojo/_base/declare&amp;#34;, &amp;#34;dijit/_WidgetBase&amp;#34;, ], function(declare, _WidgetBase){ return declare(&amp;#34;ItemWidget&amp;#34;, [_WidgetBase], { // 本Widget实例所属的Source实例 dndSrc: null, postCreate: function() { this.inherited(arguments); // 不需要传递数据时，可忽略data参数 if (this.dndSrc !== null) this.dndSrc.setItem(this.id, {type:[&amp;#34;text&amp;#34;]}); } }); });</description></item><item><title>读过"ZK: AJAX without the JavaScript Framework"</title><link>http://0x3f.org/posts/after-reading-zk-ajax-without-the-javascript-framework/</link><pubDate>Tue, 19 Jun 2012 21:47:00 +0000</pubDate><guid>http://0x3f.org/posts/after-reading-zk-ajax-without-the-javascript-framework/</guid><description>前段时间，某天凌晨无故醒来，读完了这本书。
虽然是ZK框架的开发者写的书，不过实在不敢恭维。开发环境搭建的一章已经过时，其余内容也显得蜻蜓点水，加上全书结构显得不是很合理，总之看完对ZK的感觉仍是朦朦胧胧的，更别说上手做东西了。</description></item><item><title>读完『Ext JS IN Action』</title><link>http://0x3f.org/posts/after-reading-extjs-in-action/</link><pubDate>Tue, 21 Jun 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/after-reading-extjs-in-action/</guid><description>这是本需要仔细读的书，对ExtJS的主要控件有比较详细的解说，有一定的原理性解释，并且对扩展ExtJS和ExtJS项目开发的模式有一些介绍。但不涉及底层特性，例如DOM、AJAX等。
Posted via UltraBlog.vim.</description></item><item><title>用JavaScript实现分页打印</title><link>http://0x3f.org/posts/howto-do-paged-printing-using-javascript/</link><pubDate>Sat, 19 Jun 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/howto-do-paged-printing-using-javascript/</guid><description>最近客户提的一个需求，要实现分页打印功能。公司产品对打印功能实现得不够好，排版全由程序生成，耦合度高，且不支持分页，需要用笨拙的方法变通。
于是我对如何更好地实现分页打印产生了兴趣，Google了一下，整理了一个Demo：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html;charset=utf-8&amp;#34;/&amp;gt; &amp;lt;style media=print&amp;gt; .Noprint{display:none;} .PageNext{page-break-after: always;} &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;OBJECT id=WebBrowser classid=CLSID:8856F961-340A-11D0-A96B-00C04FD705A2 height=0 width=0 VIEWASTEXT&amp;gt; &amp;lt;/OBJECT&amp;gt; &amp;lt;div class=&amp;#34;Noprint&amp;#34;&amp;gt; &amp;lt;input onclick=document.all.WebBrowser.ExecWB(6,1) type=button value=打印 name=Button&amp;gt; &amp;lt;input onclick=document.all.WebBrowser.ExecWB(7,1) type=button value=打印预览 name=Button&amp;gt; &amp;lt;input onclick=document.all.WebBrowser.ExecWB(8,1) type=button value=页面设置 name=Button4&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;PageNext&amp;#34;&amp;gt; &amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;雅游&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt; &amp;lt;p&amp;gt;旧院人称曲中，前门对武定桥，后门在钞库街。妓家鳞次，比屋而居。屋宇精洁，花木萧疏，迥非尘境。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;到门则铜环半启，珠箔低垂;升阶则猧儿吠客，鹦哥唤茶；登堂则假母肃迎，分宾抗礼；&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;进轩则丫鬟毕妆，捧艳而出；坐久则水陆备至，丝肉竞陈；定情则目眺心挑，绸缪宛转。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;纨绔少年，绣肠才子，无不魂迷色阵，气尽雌风矣。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;妓家，仆婢称之曰娘，外人呼之曰小娘，假母称之曰娘儿。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;有客称客曰姐夫，客称假母曰外婆。&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;PageNext&amp;#34;&amp;gt; &amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;木兰花令·拟古决绝词&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt; &amp;lt;center&amp;gt;&amp;lt;h3&amp;gt;清·纳兰容若&amp;lt;/h3&amp;gt;&amp;lt;/center&amp;gt; &amp;lt;p&amp;gt;人生若只如初见，何事秋风悲画扇。等闲变却故人心，却道故人心易变!</description></item><item><title>强大的工具函数库：php.js</title><link>http://0x3f.org/posts/phpjs/</link><pubDate>Sat, 24 Apr 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/phpjs/</guid><description>PHP最大的特点在于它拥有一个丰富、灵活、强大的函数库，因此得以机动灵活成为软件开发语言中的轻骑兵。
php.js是一个用Javascript实现的函数库，它试图用Javascript最大程度地重写PHP的函数库。相对于JQuery、ExtJS这些Javascript库，php.js不并致力于为AJAX、DOM和界面开发提供一揽子解决方案，它只是将PHP函数的强大和简便带到前端开发中来，由于JQuery这样的库并不旨在提供完全的Javascript开发标准和手段，实际上，它弥补了这些高端的工具库与低端的Javascript开发之间的一个空白。
对于熟悉PHP的人尤其是PHP程序员来说，使用php.js是几乎不需要切换思维方式的。
这是使用php实现的日期格式校验函数：
```php function IsValidDate($strDate, $strFormat='Y-m-d') { $strDate = trim($strDate); $unixTime = strtotime($strDate); $strNewDate = date($strFormat, $unixTime); return $strDate == $strNewDate; } ``` 这是使用php.js实现的日期格式校验函数：
```javascript function IsValidDate(strDate, strFormat) { strDate = trim(strDate); var unixTime = strtotime(strDate); var strNewDate = date(strFormat, unixTime); return strDate == strNewDate; } ```</description></item></channel></rss>