<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>博客 on 晴耕雨讀</title><link>http://0x3f.org/tags/%E5%8D%9A%E5%AE%A2/</link><description>Recent content in 博客 on 晴耕雨讀</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>© 淘气 2022</copyright><lastBuildDate>Fri, 19 Jun 2020 17:41:52 +0800</lastBuildDate><atom:link href="http://0x3f.org/tags/%E5%8D%9A%E5%AE%A2/index.xml" rel="self" type="application/rss+xml"/><item><title>从 Hexo 到 Hugo</title><link>http://0x3f.org/posts/migrate-from-hexo-to-hugo/</link><pubDate>Fri, 19 Jun 2020 17:41:52 +0800</pubDate><guid>http://0x3f.org/posts/migrate-from-hexo-to-hugo/</guid><description>&lt;p>一切源于我这个颜党的喜新厌旧。&lt;/p>
&lt;p>总想找到一个极简而不失现代感的主题，在这个过程中，发现越来越多比较贴近我口味的主题都是适配 Hugo 的。趁最近有时间，就换了过来。&lt;/p></description></item><item><title>用Github当图床</title><link>http://0x3f.org/posts/take-github-as-image-hosting-service/</link><pubDate>Thu, 06 Feb 2020 22:00:00 +0000</pubDate><guid>http://0x3f.org/posts/take-github-as-image-hosting-service/</guid><description>&lt;p>微博图床的域名不知道什么时候改了，Google找不到相关信息，经过排查发现原域名中的“ws”改成了“wx”，浪费了不少时间。&lt;/p>
&lt;p>于是打算换图床。&lt;/p></description></item><item><title>把博客字体改成了方正北魏楷书</title><link>http://0x3f.org/posts/set-blog-webfont-to-fzbeiweikaishu/</link><pubDate>Mon, 14 Aug 2017 16:05:30 +0000</pubDate><guid>http://0x3f.org/posts/set-blog-webfont-to-fzbeiweikaishu/</guid><description>我曾说过方正北魏楷书是最佳的阅读字体，不过后来感觉长时间阅读的体验还是普通的楷体更好。但这并不妨碍在Reeder、博客这种短时阅读场合突出页面的设计感。
今天把博客（hexo）的webfont改成了方正北魏楷书，用font-spider压缩后，从13M缩减到1.4M。方法是这样的：
首先把完整的字体复制到主题的字体目录中（themes/crisp/source/fonts），文件名为FZBeiWeiKaiShu-full.ttf。
在CSS中加入webfont配置：
1 2 3 4 5 @font-face { font-family: &amp;#39;FZBeiWeiKaiShu&amp;#39;; src: url(&amp;#39;../fonts/FZBeiWeiKaiShu.ttf&amp;#39;) format(&amp;#39;truetype&amp;#39;), url(&amp;#39;../fonts/FZBeiWeiKaiShu-full.ttf&amp;#39;) format(&amp;#39;truetype&amp;#39;); } FZBeiWeiKaiShu.ttf是压缩后的字体文件名，这样访问时浏览器会优先下载压缩后的字体。
然后把CSS中使用字体的地方都指定为FZBeiWeiKaiShu。
在博客根目录下创建脚本update_fonts.sh：
1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/sh hexo clean hexo g find public -name &amp;#34;*.html&amp;#34; |xargs sed -i &amp;#39;&amp;#39; &amp;#34;s#/styles/crisp.css#$HOME/Projects/blog/public/styles/crisp.css#g&amp;#34; find public -name &amp;#34;*.html&amp;#34;|xargs font-spider cp -f public/fonts/FZBeiWeiKaiShu.ttf themes/crisp/source/fonts/FZBeiWeiKaiShu.ttf hexo clean hexo s -g 除非用到新的字符，否则不需要经常更新字体。
font-spider会提示一共使用了多少种字符，我这么多年也只用到三千多种，真是太没文化了。🤥</description></item><item><title>从 Octopress 迁移到 Hexo</title><link>http://0x3f.org/posts/migrate-octopress-to-hexo/</link><pubDate>Wed, 08 Feb 2017 20:24:16 +0000</pubDate><guid>http://0x3f.org/posts/migrate-octopress-to-hexo/</guid><description>因为原来的主题没有针对中文优化，显示效果不太好，在搜索新主题的时候顺便了解了一下其它几个静态博客生成工具，发现Hexo比Octopress有很大的优势，就迁移了过来。
Hexo的优势：
速度快：几百篇文章只需要几秒，而Octopress需要几十秒 易用：配置、部署简单，文章被修改后会立即更新浏览器中的预览页面 轻量：基于node.js，目录结构简明 迁移的过程不算顺利，先是遇到「MODULE_NOT_FOUND」的问题，搜到的方法都不起作用，原因大概是因为墙的问题导致dtrace模块安装出错，理论上用代理安装是可以解决的，结果在反复安装的过程中莫名其妙地就好了。
再一个问题是选主题，喜欢极简的风格，但是极简又大气的主题很少，相对最喜欢的是kael，不过生成速度非常慢，而且生成的页面有大量乱码。于是退而求其次，选择了crisp。然而还是有不满意的地方，比如过于简单、没有搜索、不区分首页和归档等，还有待自己修改。</description></item><item><title>UltraBlog.vim v3.6.1: 文章分类自动补全</title><link>http://0x3f.org/posts/ultrablog-v361-released/</link><pubDate>Sun, 20 Apr 2014 22:50:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v361-released/</guid><description>春节期间收到两个issue，一直拖到今天才有时间完成。
增加了一个功能，在文章编辑视图的元数据中分类那行，使用热键&amp;lt;C-X&amp;gt;&amp;lt;C-U&amp;gt;自动完成文章的分类。在配置数组ub_blog中增加键值对“categories”，默认使用这一项的值实现自动完成，如下：
1 2 3 4 5 6 7 let ub_blog = {&amp;#39;login_name&amp;#39;:&amp;#39;admin&amp;#39;, \&amp;#39;password&amp;#39;:&amp;#39;pass2011&amp;#39;, \&amp;#39;url&amp;#39;:&amp;#39;http://www.sample.com/&amp;#39;, \&amp;#39;xmlrpc_uri&amp;#39;:&amp;#39;xmlrpc.php&amp;#39;, \&amp;#39;db&amp;#39;:&amp;#39;$VIM/UltraBlog.db&amp;#39;, \&amp;#39;categories&amp;#39;: &amp;#39;News|Computer|Image&amp;#39; \} 如果这一项不存在，将从博客中拉取分类数据。
自从迁移到Octopress，有两年不用Wordpress了，没想到居然还有人在用UltraBlog.vim。</description></item><item><title>迁移到 Octopress</title><link>http://0x3f.org/posts/migrate-blog-to-octopress/</link><pubDate>Sat, 23 Jun 2012 23:13:00 +0000</pubDate><guid>http://0x3f.org/posts/migrate-blog-to-octopress/</guid><description>关于迁移 前段时间，用了五年的虚拟主机突然限制了PHP内存上限，导致Wordpress只能启用有限的几个插件，根本不能满足需要。
所以毅然决定迁移到JeckyII+GitHub，在摸索的过程中发现octopress比JeckyII易用，于是导出所有文章，开始迁移。因为我这几年博客写得比较乱，无论是内容上，还是发表方式上，结果用了几个导出脚本，效果都不甚理想，还是有很多地方需要手工修改。六百篇文章，正好趁这个机会挑拣一下，较早的文章质量低的比较多。断断续续地迁移了一些，剩下的工作量还是很大的，留著以后慢慢来吧。另外这次把URL也改成永久格式了，这一来真的伤筋动骨了，连永久重定向都没的做。
至于Feed输出，以前订阅Feedburner烧录的两个地址的读者不受影响，直接订阅Wordpress输出的地址的就丢了，这里再公布一下：
本博客聚合输出：http://feeds.feedburner.com/sinolog 我的全部资讯聚合：http://feeds.feedburner.com/leninlee 迁移那点事 Python 版本的问题 Archlinux很激进，早已把Python的缺省版本进化到了3.x，octopress会用到2.x，结果在生成全站的时候，会报如下错误：
File &amp;#34;&amp;lt;string&amp;gt;&amp;#34;, line 1 import sys; print sys.executable ^ SyntaxError: invalid syntax 在这里找到解决方法。在octopress的plugins目录里创建文件：
1 2 3 4 5 require &amp;#39;pygments&amp;#39; if !!RUBY_PLATFORM[&amp;#39;linux&amp;#39;] RubyPython.configure :python_exe =&amp;gt; &amp;#39;/usr/bin/python2&amp;#39; end 不足 用了这段时间octopress，感觉缺点也不小，每次修改后都要重新生成全站，占用系统资源不小，而且理论上以后会越来越慢。</description></item><item><title>UltraBlog.vim v3.5.0: 内建浏览器</title><link>http://0x3f.org/posts/ultrablog-v350-released/</link><pubDate>Mon, 30 Apr 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v350-released/</guid><description>此前预览文章是通过调用系统默认的网络浏览器实现的，缺点是这些功能完备的浏览器启动速度不甚理想，尤其是火狐，谁用谁知道。
前两天看了TuxRadar的一个Podcast，几分钟内就可以用pywebkitgtk拼装出一个五脏俱全的网络浏览器，pywebkitgtk这个东西实在是非常的好用。不过我实测后发现这东西加载页面的速度比较慢，而且貌似是单线程的，因为图片都是放在最后才加载，不知道是这个绑定本身的问题，还是有API可以实现的。于是突然想到拿这个东西实现一个简单的浏览器，很适合在UB里预览文章。
增加了一个选项“ub_use_ubviewer”，默认值是1，即默认使用这个内建的浏览器预览文章。当这个选项的值被设为0时，仍然使用系统的默认浏览器，并且在Vim启动时不会加载内建的浏览器。这样做一是为了多一种选择，再一个也可以避开烦人的GTK警告：
** (gvim:13629): WARNING **: Trying to register gtype 'GMountMountFlags' as enum when in fact it is of type 'GFlags'
** (gvim:13629): WARNING **: Trying to register gtype 'GDriveStartFlags' as enum when in fact it is of type 'GFlags'
** (gvim:13629): WARNING **: Trying to register gtype 'GSocketMsgFlags' as enum when in fact it is of type 'GFlags'
这些警告是GTK或其它一些程序库的Bug造成的，虽然只在虚拟终端中启动Vim时会显示并且不影响使用，但总会有警告恐惧症患者会觉得这种东西很闹心。如果这样，就把这个选项的值设成0，用回巨型浏览器好了。
本次更新的全部内容如下：
Feature: Add a tiny web browser to do previewing, which starts much faster than full-functional browsers like firefox and chromium.</description></item><item><title>UltraBlog.vim v3.4.0: 正则表达式、批量替换和调试模式</title><link>http://0x3f.org/posts/ultrablog-v340-released/</link><pubDate>Sun, 29 Apr 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v340-released/</guid><description>这次的更新主要引入了支持正则表达式的全文检索、批量替换和调试模式。
正则表达式 我一直觉得原来的全文检索有一个遗憾，虽然可以通过多个关键词实现较为精确的查询，但还是不如正则表达式灵活和精确。
这是个蓄谋已久的需求，但直到真正做起来，才发现很多有意思的东西。虽然SQLite3提供支持正则表达式查询的“REGEX”关键词，但并没有实际实现这个功能，而是需要写程序实现并在数据库接口中注册这个函数：
```python import sqlite3 conn = sqlite3.connect('/tmp/your-database-file.db') # 使用正则表达式匹配给定内容的函数，返回布尔类型 def regexp_search(expr, item): """Check if the item has a sub-string which matches the expr""" reg = re.compile(expr) return reg.search(item) is not None # 在数据库中注册这个函数 conn.create_function('REGEXP', 2, regexp_search) cur = conn.execute('select id,title from post where content REGEXP ?', '\babc\b') row = cur.fetchone() print row conn.close() ``` 在SQLAlchemy中具体的实现方式是：
```python # 注册函数 dbe = sqlalchemy.create_engine("sqlite:///tmp/your-database-file.db") conn = dbe.connect() conn.connection.create_function('REGEXP', 2, regexp_search) # 在SQL Expression Language中创建查询条件 tbl = Post.</description></item><item><title>UltraBlog.vim v3.3.0：I18N、超时时间和其它</title><link>http://0x3f.org/posts/ultrablog-v330-released/</link><pubDate>Sun, 15 Apr 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v330-released/</guid><description>UB一岁了，这算是个周年纪念版吧。
在这一年里，因为各种原因，博客写得没有以前多了，但每篇都是用这个插件写的，我觉得很好用。断断续续地做了一些修改，因为一切都是一个人在做，所以大的变化不多。这次这个版本里有些改动还是要感谢荒野无灯童鞋，他的建议很大程度上催生了这个新版本：比如加入保存命令的热键映射选项，这样可以使用保存普通文件的热键保存UB中的内容，我自己以前也经常习惯性地用错热键；还有socket超时时间的选项，最近我这里也经常性地在UB操作博客时报超时的异常，荒童鞋关于自定义socket超时时间的建议一语惊醒了梦中人。
此外，似乎与近期Vim的一次升级有关，在Vim中调用Python接口打印任何内容到标准IO都会导致Vim崩溃，所以这次把所有的输出都改成了调用Vim的输出命令来做。
本次修改的内容中，还有一项比较重要的内容就是实现了国际化，目前只提供英文和简体中文两种语言，由于Vimball不能处理二进制文件，所以从此以后UB改用zip格式压缩包打包。
以下是本次更新的详细内容：
Feature: Add i18n support ! Feature: Add a new option ub_hotkey_save_current_item, users can define their own hotkey for :UBSave. Feature: Add a new option ub_socket_timeout, users can customize the timeout period in seconds, useful for slow networks. Bugfix: Exception raised when one event is processed by more than one event handlers. Change: Echoing messages now uses the command :echoerr instead of python's sys.stderr, because Vim crashes on this due to an upgrade recently.</description></item><item><title>启用新域名0x3f.org</title><link>http://0x3f.org/posts/enable-the-new-domain-name-0x3f-org/</link><pubDate>Mon, 09 Jan 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/enable-the-new-domain-name-0x3f-org/</guid><description>元旦假期第三天，还是把域名给换了。
原因主要是.it太贵，年费十几刀，而.org只有它的一半。另外，原来的sinolog.it有点儿长，也显老气，想换个更个性、更短的。
可惜中意的0xff有主了，只好退而求0x3f。0x3f在ASCII里面代表问号，象征“保持好奇心”。
按照上次的经验，对著数据库一通改，加上这两年四处沾花惹草，很多网站上的相关信息都得跟著改，长此以往，以后连域名都换不起了。
好在RSS订阅早已经换成了FeedBurner烧录，只是对于直接用原域名订阅的需要改一下订阅地址了。
用了几年国家域名，现在也用上国际域名了……
Posted via UltraBlog.vim.</description></item><item><title>UltraBlog.vim v3.1释出：代码重构与MacVim支持</title><link>http://0x3f.org/posts/ultrablog-v310-released/</link><pubDate>Sat, 05 Nov 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v310-released/</guid><description>距离上一个版本的释出已经有三个月了，这次新版并没有增加多少功能性的内容，主要是代码的重构和对在MacVim下稳定性的改进。
对依赖关系检查的不细致导致了一些麻烦，抛出的错误信息有时与实际原因相距甚远。由于开始时是以实现功能为主，所以都是直接用函数实现的，之后修修补补，代码冗余而且维护麻烦。于是著手重构主要功能的源码，面向对象，把所有检查逻辑放到父类中去实现，子类只关注自身逻辑，最后新版减少了二百多行的代码量。
在重构的过程中偶然发现，在MacVim中，程序抛出任何异常，即便是有捕获逻辑，也会导致编辑器崩溃。在这里简略地提到：
the failure was actual a crash, through some strange combination of threading, matplotlib pyplot backend, and ssh X11 forwarding, sys.stderr had somehow been assigned to something which python complained wasn't a file-like object
于是将所有标准输出与标准错误输出语句换成另一种形式：
```python # 原形式 sys.stdout.write('xxx') sys.stderr.write('xxx') # 新形式 print >> sys.stdout, 'xxx' print >> sys.stderr, 'xxx' ``` 以上是新版主要变更的内容，此外，也顺便解决了开发过程中发现的个别Bug和做了其它一些改动：
Change: The key "xmlrpc" of the settings list is dropped, a new one with the name "</description></item><item><title>Enable Code Snippet Highlighting For UltraBlog.vim Templates</title><link>http://0x3f.org/posts/enable-code-snippet-highlighting-for-ultrablog-vim-templates/</link><pubDate>Sat, 27 Aug 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/enable-code-snippet-highlighting-for-ultrablog-vim-templates/</guid><description>Templates make it possible for users previewing posts in custom formats in UltraBlog.vim. However, there is more you can do with our highly customizable templates. This article discusses how to highlight code snippets in posts by the use of some third-party open-source tools.
Before setting out to work, let me introduce the tools we are about to use:
highlight.js: A javascript library which highlights code blocks in web pages automatically. jquery: The famous RIA development javascript library.</description></item><item><title>UltraBlog.vim v3.0释出：全文检索与事件驱动</title><link>http://0x3f.org/posts/ultrablog-v300-released/</link><pubDate>Mon, 25 Jul 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v300-released/</guid><description>用了一周的业余时间，昨天我释出了UltraBlog.vim的3.0版。新版本主要加入了全文检索的功能，并引入事件驱动的模式。
全文检索是我蓄谋已久的功能，一个不能搜索的博客客户端的管理功能是大打折扣的。得益于SQLite数据库和SQLAlchemy框架，全文检索的实现是很简单的，新增加的:UBFind命令将在所有文章和页面的标题与内容中查询，并将搜索结果显示在一个可分页的列表中。这个命令支持任意多个关键词，各关键词之间遵循与的关系。此外，检索结果中，所有的关键词将被自动标记为高亮。
事件驱动模式的引入是我悍然将版本号跳跃到3.x的主要原因。
在前几个版本中，我实现了对多窗口的支持，它使得用户可以在新窗口中打开列表中的文章。但UltraBlog.vim最初开发的时候并没有考虑到多窗口的问题，所有命令都只针对当前窗口进行操作。这就有了缓冲区内容同步的问题，假如在一个新的缓冲区中打开了和另一个缓冲区相同的文章，则一个缓冲区内容的改变不会同步到另外一个中，这多少是有些隐患的。
最直接的做法是在所有可能改变缓冲区内容的功能中加入对其它缓冲区的处理，但这样做有不少问题：
代码耦合度太高，违反K.I.S.S原则，不利于今后的开发和维护 函数体过长，我讨厌难看的代码 代码冗余，重复劳动 事件驱动模式可以很好的解决以上问题，一个函数只干一件事，做完后一个事件抛出去，至于连带著要做什么，谁监听这个事件谁去处理，代码的耦合度很低，复用度很高，易于维护和阅读。
UltraBlog.vim引入事件驱动模式处理缓冲区同步的问题。不同的操作抛出不同的事件，所有的事件继承自父类UBEvent：
```python class UBEvent: def __init__(self, srcObj): self.srcObj = srcObj class UBDebugEvent(UBEvent): pass class UBTmplDelEvent(UBEvent): pass class UBTmplSaveEvent(UBEvent): pass class UBLocalPostDelEvent(UBEvent): pass class UBRemotePostDelEvent(UBEvent): pass class UBPostSendEvent(UBEvent): pass class UBPostSaveEvent(UBEvent): pass ``` 一个可能改变缓冲区内容的操作执行完后，创建一个特定的事件并将其加入到事件队列中。事件队列类中存放两个列表，一是事件队列，二是事件监听器列表；提供三个方法，分别用来注册事件监听器、对事件执行入队列操作和处理队列中所有事件：
```python class UBEventQueue: queue = [] listeners = [] @classmethod def fireEvent(cls, evt): cls.queue.append(evt) @classmethod def processEvents(cls): for evt in cls.queue: for listener in cls.listeners: if listener.isTarget(evt): cls.queue.remove(evt) listener.</description></item><item><title>UltraBlog.vim v2.3.0 Released With Templates</title><link>http://0x3f.org/posts/ultrablog-v230-released/</link><pubDate>Mon, 13 Jun 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v230-released/</guid><description>I released the new version 2.3.0 of UltraBlog.vim last week. The main improvement in this version is that templates are introduced in.
Templates are simply HTML strings, they are used to preview posts/pages in the browser locally. This feature is a reparation for the remote previewing, due to the limit of the API, users cannot send a post to Wordpress as draft and preview it without affecting the post status if the post has been published.</description></item><item><title>聚合个人资讯</title><link>http://0x3f.org/posts/burn-personal-info-into-one-feed-using-yahoo-pipes/</link><pubDate>Wed, 08 Jun 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/burn-personal-info-into-one-feed-using-yahoo-pipes/</guid><description>前段时间我把Twitter整合进博客之后，忽然觉得，既然微博已经很重要了，就应该加强它的地位，使其与博客分庭抗礼。于是开始用blueprint做CSS框架，对两三年没变过的iterse做一些调整。
我对前端不太熟悉，这时候CSS框架的优越性就充分体现出来了，它让页面的布局变得相当容易，尤其是对前端设计最烦人的对多浏览器的兼容问题。现在的主题采用流行的950px宽度，比以前800px要宽裕了不少。其中，三分之一的宽度分给侧边栏，剩余部分留给博客文章列表，仍然采用两栏结构。
我在页面顶部加了顶栏，将原来侧边栏中的分类、归档、页面、搜索框、RSS订阅全部扔到里面。同时提升Twitter和最新评论列表的位置，增加它们显示条目的数量，以加强这两个时效性和互动性比较强的栏目。
然后我觉得资讯订阅中的内容也不应该再仅仅局限于博客文章了，应该把我在用的Twitter、豆瓣、Google Reader分享、PicasaWeb等服务中我的资讯也聚合进来。开始的时候打算用Yahoo! Pipes，后来突然发现FriendFeed就可以做这个事，而且更好用，于是将原来烧录的http://feeds.feedburner.com/leninlee指向FriendFeed。
所以对于订阅原来的FeedBurner烧录的feed的读者，如果希望仍然只订阅博客文章，可以订阅http://feeds.feedburner.com/sinolog。这两个feed都放到了顶栏中，请以各种姿态翻墙订阅。
2011-06-08 更新
时隔一天，我认识到一个错误，FriendFeed毕竟还是一个微博，用它聚合个人资讯是不合适的，比如不能全文输出博客文章。最终还是使用Yahoo! Pipes，这货很强大、很好用。
另外，twitter2rss是支持OAuth的Twitter烧录服务，非常好用。
Posted via UltraBlog.vim.</description></item><item><title>UltraBlog.vim开发手记</title><link>http://0x3f.org/posts/ultrablog-development-note/</link><pubDate>Mon, 11 Apr 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-development-note/</guid><description>对于博客已死的说法，我一点都不感到奇怪。早在几年前博客还比较火的时候我就表达过对博客泡沫的看法。
经历了短暂的tumblog的风头，微博成为现在最火的媒介。说博客已死，无非就是说微博将成为个人信息传播的主流。好吧，现在我知道那时候我所说的不懂什么是博客的人都去干什么了。
但是博客还是会继续发展，微博的兴起只会减少滥竽充数。因为微博突出的是时效性，最缺乏的是系统性和可重复更新的能力。微博的短处，正是博客的长处。这让我对博客有了一个新的、迟到了很久的认识──一个好的博客，它的文章不应该是写掉就忘的，而应该是不断地更新著的。
UltraBlog.vim就是出于这个需要而写的。
我对博客客户端的使用大概可以追溯到四五年前，那时候博客正火，在比较了几个BSP后选择了中国博客网，就是因为他们提供桌面客户端。后来独博之后也试用过几个通用的客户端，但都没坚持多久，最根本的原因是它们几乎无一例外地都是WYSIWYG。而WYSIWYG的编辑器生成的HTML源码几乎都使用inline的样式，这就导致文章的排版布局很难控制，我对WYSIWYG其实是很抵触的，至今都不怎么用Office这类东西。
后来我意识到，我所需要的是样式与内容分离，于是准备自己写一个客户端，后来由于工作的原因不了了之。与此同时，我自定义了一套文章格式并用Java写了一个转换文章到HTML的工具，直到后来发现Markdown，我才知道我其实是需要一个轻量标记语言。
使用Markdown之后，写博客开始变得轻松愉快。我一度用过一段时间SciTE，还用Lua写了个辅助脚本。但是我需要一个完整的客户端来管理文章，而这是一个编辑器所不能胜任的，所以就著手实现一个支持Markdown的客户端。这一次走得比较远，ForeverFantasy最终达到了可用的程度，我一度用它写过一段时间的博客。但是作为一个Vim重症患者，wxPython的编辑器部件是远远达不到我需要的水平的。虽然后来还实现了调用外部程序处理文章内容（当然也可以调用Vim），但总归觉得不舒服，至今已经一年没更新了。
直到前段时间试用了一下VimRepress，在修改这个插件的时候突然受到启发，我这几年的需求原来是可以这么简单地解决的。
其实在几年前vimpress刚刚发布的时候我就了解过这个东西，包括此后接连发布的几个Vim写博客的插件，它们和我原来写的SciTE的那个辅助脚本没有本质的区别，都是博客编辑器。与完整的客户端相比，编辑器缺少对本地文章源码的管理，而且它们不记录文章源码和发布的文章的关联关系，简单地说是无状态的。这不符合博客文章持续更新的观点。
UltraBlog.vim使用SQLAlchemy做数据库抽象层，将所有文章的源码及其状态保存在本地的一个SQLite数据库中，并且以此为基础，通过XMLRPC接口实现对博客文章、页面的CRUD操作。同时利用Vim分模式的特点实现了可分页的文章列表和文章编辑视图。
UltraBlog.vim目前支持Markdown和HTML两种格式的文章，它最大的特点是在Markdown格式的源码和发布到博客中的文章之间建立联系，你可以随时修改本地数据库中的Markdown源码并更新博客中对应的文章。
新的功能还会不断地加入。
Posted via UltraBlog.vim.</description></item><item><title>从iG:Syntax Hiliter转换到WP-Syntax</title><link>http://0x3f.org/posts/migrate-from-igsyntax-hiliter-to-wp-syntax/</link><pubDate>Wed, 06 Apr 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/migrate-from-igsyntax-hiliter-to-wp-syntax/</guid><description>终于决定放弃使用了三年多的iG:Syntax Hiliter，将代码语法高亮插件换成WP-Syntax。
原因是Vim的Markdown语法高亮插件有问题，会把iG的标签[LANG]当作Markdown的超链接处理，结果导致插入代码后，后面的内容被错误地著色，很难看。而Syntax使用&amp;lt;pre lang="LANG"&amp;gt;格式的标签，不会有这个问题。
其实很早就想过要换了，只是受累于使用iG进行高亮的文章太多，替换起来不方便。加上后来解决了由于iG停止更新导致的不支持更多的语法的问题，所以就一致拖到现在。今天晚上花了一个小时就完成了替换，比想象中的要容易地多。
根据我使用过的语法的情况，使用以下语句在数据库中替换iG的标签到Syntax的标签：
```sql update wp_posts set post_content=replace(post_content,'[bash]','&amp;lt;pre lang="bash" line="1"&amp;gt;'); update wp_posts set post_content=replace(post_content,'[/bash]','&amp;lt;/pre&amp;gt;'); update wp_posts set post_content=replace(post_content,'[python]','&amp;lt;pre lang="python" line="1"&amp;gt;'); update wp_posts set post_content=replace(post_content,'[/python]','&amp;lt;/pre&amp;gt;'); update wp_posts set post_content=replace(post_content,'[vim]','&amp;lt;pre lang="vim" line="1"&amp;gt;'); update wp_posts set post_content=replace(post_content,'[/vim]','&amp;lt;/pre&amp;gt;'); update wp_posts set post_content=replace(post_content,'[java]','&amp;lt;pre lang="java" line="1"&amp;gt;'); update wp_posts set post_content=replace(post_content,'[/java]','&amp;lt;/pre&amp;gt;'); update wp_posts set post_content=replace(post_content,'[lua]','&amp;lt;pre lang="lua" line="1"&amp;gt;'); update wp_posts set post_content=replace(post_content,'[/lua]','&amp;lt;/pre&amp;gt;'); update wp_posts set post_content=replace(post_content,'[sql]','&amp;lt;pre lang="sql" line="1"&amp;gt;'); update wp_posts set post_content=replace(post_content,'[/sql]','&amp;lt;/pre&amp;gt;'); update wp_posts set post_content=replace(post_content,'[plsql]','&amp;lt;pre lang="</description></item><item><title>UltraBlog.vim: Ultimate Vim Blogging Plugin</title><link>http://0x3f.org/posts/ultrablog-as-an-ultimate-vim-blogging-plugin/</link><pubDate>Sat, 02 Apr 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-as-an-ultimate-vim-blogging-plugin/</guid><description>Introduction UltraBlog.vim is yet another Vim blogging script for Wordpress.
The biggest difference between UB and other similar scripts is that UB is an ultimate client, which stores posts locally in an SQLite database, while others just operate remotely. In this way, many things can be done easily by the advantage of local storage and many other utilities, for example, you can search for posts stored in the database with a few keywords by typing a simple command, also you can preview drafts with any of your favorite templates as soon as you want to.</description></item><item><title>使用Vim写博客</title><link>http://0x3f.org/posts/blogging-with-vim/</link><pubDate>Sat, 19 Mar 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/blogging-with-vim/</guid><description>VimRepress是Vim写博客的插件中较新的一个，是久未更新的Vimpress的一个衍生版。
虽然不是所有此类插件中功能最多的一个，但VimRepress非常实用，除包含最常用的几个功能外，还支持Markdown。但是当前版本的VimRepress在转换Markdown格式的字符串到HTML时，是通过直接调用外部命令markdown来实现的，这显然只是针对Linux（及其它类UNIX）系统设计的。
为了使VimRepress支持在Windows下使用Markdown写文章，可以对它做一些改进。
修改VimRepress的源文件blog.vim，在if __name__ == "__main__":这一行的上方加入如下两个函数：
```python def markdown_preview2(): import sys reload(sys) sys.setdefaultencoding('utf-8') import markdown2 as mkd global vimpress_temp_dir if vimpress_temp_dir == '': vimpress_temp_dir = tempfile.mkdtemp(suffix="vimpress") temp_htm = os.path.join(vimpress_temp_dir, "vimpress_temp.htm") html_heads = \ """&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> """ tmp_file = open(temp_htm, 'w') tmp_file.write(html_heads) txt = "\n".join(vim.current.buffer[:]) #txt = unicode(txt,'cp936') tmp_file.write(mkd.markdown(txt)) #tmp_file.write(mkd.markdown("\n".join(vim.current.buffer[:]))) tmp_file.close() webbrowser.open("file://%s" % temp_htm) def markdown_newpost2(): import sys reload(sys) sys.setdefaultencoding('utf-8') import markdown2 as mkd global vimpress_temp_dir if vimpress_temp_dir == '': vimpress_temp_dir = tempfile.</description></item><item><title>升级到wordpress3.0</title><link>http://0x3f.org/posts/after-upgrading-to-wordpress30/</link><pubDate>Sat, 19 Jun 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/after-upgrading-to-wordpress30/</guid><description>昨天发现wordpress3.0已经发布，就顺手升级了。
略看了一下更新内容，几乎没什么让我感兴趣的，但与MU版本的合并堪称WP历史上的一个里程碑，从此一套WP可以支持创建多个博客了。
但我最近几度都想把博客换到dokuwiki下。
自从开始用dokuwiki来组织知识和GTD以来，我对wiki产生了越来越深的痴迷，最主要的原因就是它可以用很简单的语法写出格式规整的文章，我几乎可以不用考虑排版布局而只需把注意力放在文章内容上就行了。而将wiki上的文章发到博客上时，还需要重写，比较浪费时间。
但我最终放弃这个想法，最主要的原因是博客文章太多了，截至现在已经有五百多篇且大多是用HTML写的，难以转换。何况WP作为一个博客系统较wiki有着天生的优势，使用较为方便，如果用wiki来做博客，要做不少工作。</description></item><item><title>中转feedburner订阅数图标</title><link>http://0x3f.org/posts/howto-display-feedburner-subscription-image/</link><pubDate>Mon, 14 Jun 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/howto-display-feedburner-subscription-image/</guid><description>利用国外服务器中转feedburner的图标：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &amp;lt;?php /* * 将$fburl替换为自己的feedburner订阅数图片地址，然后将博客中的图片地址换成此脚本的URL即可 */ $fburl = &amp;#39;http://feeds.feedburner.com/~fc/leninlee?bg=99CCFF&amp;amp;amp;fg=444444&amp;amp;amp;anim=0&amp;#39;; $fbfl = &amp;#39;fb.gif&amp;#39;; $fp = fopen($fburl, &amp;#39;rb&amp;#39;); if ($fp) { $fp_local = fopen($fbfl, &amp;#39;wb&amp;#39;); if ($fp_local) { while (!feof($fp)) { fwrite($fp_local, fread($fp, 1024*8), 1024*8); } fclose($fp_local); } fclose($fp); } header(&amp;#39;Location: &amp;#39;.$fbfl); ?&amp;gt; 或者：
1 2 3 4 &amp;lt;?php header(&amp;#39;Content-Type: image/gif&amp;#39;); readfile(&amp;#39;http://feeds.feedburner.com/~fc/leninlee?bg=99CCFF&amp;amp;fg=444444&amp;amp;anim=0&amp;#39;); ?&amp;gt;</description></item><item><title>Python控制外部进程的灵异事件</title><link>http://0x3f.org/posts/supernatural-phenomenon-of-controlling-external-processes-in-python/</link><pubDate>Mon, 08 Mar 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/supernatural-phenomenon-of-controlling-external-processes-in-python/</guid><description>春节前的一段时间，重新拾起近一年没动过的ForeverFantasy。
虽然一年内没什么更新，但是我却一直都在用，基本上只限于将用Vim写好的Markdown格式的文档转换成HTML。
重写了相当一部分代码，较大程度地改变了界面布局，突然发现经过一年的沉淀，对wxPython的理解增进了不少，开发起来比起去年这个时候清楚了很多。
这些天来一直坚持着每天或多或少的做一些，如果说有什么主要的进展的话，那就是界面的重构，以及昨天实现了调用Vim编辑文档并回收文档内容的功能。
ForeverFantasy和Vim协同的一个最大的问题就是如何判断Vim已经退出。Python调用外部程序的方法有很多，比如传统的commands模块、os.system()等，subprocess是致力于替代这些旧有的方式的一个模块，它的一个特点是可以在启动一个外部程序作为子进程后还能监控这个进程的运行状态。这为ForeverFantasy在Vim退出后回收文档内容提供了更简捷的途径。
下面的代码可以说明如何使用subprocess运行外部程序并监控运行状态：
```python import subprocess process = subprocess.Popen('gvim', shell=True) status = process.poll() if 0 == status: print 'The external program exited.' if status is None: print 'The external program is still running.' ``` 理论上，可以拿实例process的poll()方法监视进程的运行状态，而且这一点在Windows上也确实可以做到，但是到了Linux下，诡异的事出现了，即使刚刚打开gvim，poll()方法也会马上返回一个0，同时process.pid的值总是和实际在运行的那个gvim进程的pid的值差3，而且在虚拟终端中输入gvim命令也不会阻塞终端，就像别的命令加上“&amp;amp;”符号的效果一样。尝试用strace跟踪gvim的运行，试图找到问题原因，无果。我猜想可能/usr/bin/gvim是一个跳板，它启动后会启动一个新的gvim进程。总之，这个方法在Linux下是行不通的。
因此我觉得只能另寻出路了，既然不能监控gvim进程，那就监控gvim进程所编辑的文件，只要这个文件不被任何进程占用，就可以判定gvim已退出。这一点，在Linux下易如反掌，不用说，lsof当仁不让。
用commands.getstatusoutput('lsof file.txt')测试发现，如果文件file.txt被某进程占用，则返回的状态值为0，反之，返回256。
最终，我在程序中使用了两种判断方式，在Windows平台使用subprocess跟踪gvim.exe进程，而在Linux及Unix平台使用lsof检查文档占用情况。
剩下的就是进行这个判断的时间问题了。
很显然，如果在子进程被启动后马上使用while循环不停的检查，一来必须使用多线程，二来系统资源占用也会很高。这时就需要利用wxPython的事件机制了，当ForeverFantasy启动Gvim时，主窗口失去焦点，而当Gvim退出时，ForeverFantasy又会获得焦点，只要能在ForeverFantasy窗口获得焦点时做一次检查即可。不过，在选择最合适的事件的问题上，又是一波三折。
在wxPython的API文档中没有找到事件列表，倒是在Wiki中找到了。顾名思义，觉得wx.EVT_SET_FOCUS比较靠谱，但试用失败，看API中关于FocusEvent的说明，这个事件适用于窗口控件；然后又试了wx.EVT_CHILD_FOCUS，只有在窗口包含的控件中有获得焦点的情况才会触发；最后才发现wx.EVT_ACTIVATE，这个事件会在窗口失去焦点和获得焦点时各触发一次，使用GetActive()方法可以判断是获得焦点还是失去焦点。
完成与Vim的协同使ForeverFantasy在我手上由原来单纯的格式转换工具进化为基本可用的文档编辑器，就算是Milestone 2吧。
此外，还有一些小的经验：
1. 调用非环境变量下的程序，即命令中必须带程序所在的路径时，应当将程序所在目录的完整路径以自然字符串的形式传递给subprocess.Popen类的构造方法的cwd参数，即如下所示：
```python process = subprocess.Popen('gvim.exe', cwd=r'C:\program files\vim\vim72', shell=True) ``` 这样可以有效避免路径中的空格和特殊字符对命令执行的影响。
2. Vim编辑一个文档时，实际操作的是一个临时文件，而不是原文件，这个临时文件与原文件同路径，名称为在原文件名的基础上，前面加一个句点，后面加后缀“.swp”。应该用lsof监控这个临时文件，才可以判断出编辑该文档的Vim进程的运行状态。由于对于不存在的文件使用lsof命令的返回值也是256，故可以同时判断临时文件和原文件的占用情况，这样就为对其它编辑器的支持奠定了基础。
2010-03-10 Wednesday 22:52:13 更新
感谢KL童鞋和依云童鞋指教，果然加上-f参数就可以了。</description></item></channel></rss>