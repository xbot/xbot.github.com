<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>编程 - 标签 - 晴耕雨讀</title><link>http://0x3f.org/tags/%E7%BC%96%E7%A8%8B/</link><description>编程 - 标签 - 晴耕雨讀</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 17 Aug 2021 14:48:12 +0800</lastBuildDate><atom:link href="http://0x3f.org/tags/%E7%BC%96%E7%A8%8B/" rel="self" type="application/rss+xml"/><item><title>PHPUnit 9.x 性能分析的方法</title><link>http://0x3f.org/post/method-for-phpunit-9.x-performance-analysis/</link><pubDate>Tue, 17 Aug 2021 14:48:12 +0800</pubDate><author>作者</author><guid>http://0x3f.org/post/method-for-phpunit-9.x-performance-analysis/</guid><description><![CDATA[<p>利用 PHPUnit 9.x 的 extension 特性，可以记录每个测试用例的耗时并存储到 CSV 文件中。</p>
<p>Extension 代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

<span class="k">declare</span><span class="p">(</span><span class="nx">strict_types</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>

<span class="k">namespace</span> <span class="nx">Tests</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">PHPUnit\Runner\AfterTestHook</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">LongRunningTestsLogger</span> <span class="k">implements</span> <span class="nx">AfterTestHook</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="k">private</span> <span class="nx">string</span> <span class="nv">$log_file</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">executeAfterTest</span><span class="p">(</span><span class="nx">string</span> <span class="nv">$test</span><span class="p">,</span> <span class="nx">float</span> <span class="nv">$time</span><span class="p">)</span><span class="o">:</span> <span class="nx">void</span>
    <span class="p">{</span>
        <span class="nv">$fp</span> <span class="o">=</span> <span class="nx">fopen</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">log_file</span> <span class="o">.</span> <span class="s1">&#39;.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">);</span>
        <span class="nx">fputcsv</span><span class="p">(</span><span class="nv">$fp</span><span class="p">,</span> <span class="p">[</span><span class="nv">$test</span><span class="p">,</span> <span class="nv">$time</span><span class="p">]);</span>
        <span class="nx">fclose</span><span class="p">(</span><span class="nv">$fp</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>phpunit.xml 的配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml">    <span class="nt">&lt;extensions&gt;</span>
        <span class="nt">&lt;extension</span> <span class="na">class=</span><span class="s">&#34;Tests\LongRunningTestsLogger&#34;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;arguments&gt;</span>
                <span class="nt">&lt;string&gt;</span>profiling<span class="nt">&lt;/string&gt;</span>
            <span class="nt">&lt;/arguments&gt;</span>
        <span class="nt">&lt;/extension&gt;</span>
    <span class="nt">&lt;/extensions&gt;</span>
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>MySQL 事务的一致性、隔离级别与幻读问题</title><link>http://0x3f.org/post/isolation-levels-and-phantom-reads-in-mysql/</link><pubDate>Tue, 21 Jul 2020 16:25:09 +0800</pubDate><author>作者</author><guid>http://0x3f.org/post/isolation-levels-and-phantom-reads-in-mysql/</guid><description><![CDATA[<h2 id="数据库事务的一致性">数据库事务的一致性</h2>
<p>数据库事务有四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），简称“ACID”。</p>
<p>其中，“一致性”指的是数据库层面的一致性，与应用层面的一致性不同。</p>
<p>数据库层面的一致性是说，事务具备把数据库从一个正确的状态迁移到另一个正确的状态的特性。所谓正确的状态，是指任何写入数据库的数据都满足数据库既定的规则，这些规则包括各种约束、级联回滚、触发器以及任何它们的组合。</p>
<p>与数据库层面的一致性不同，应用层面的一致性要求保证结果的正确性。例如，当执行如下 SQL 语句时：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">update</span> <span class="n">accounts</span> <span class="k">set</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></td></tr></table>
</div>
</div><p>我希望最终的结果是在事务开始时 id = 3 的这行数据 balance 列的值的基础上加一，否则，结果就是不正确的。</p>
<p>因此，只要写入的数据满足数据库的规则，就保证了数据库层面的一致性。<strong>数据库层面的一致性并不保证数据正确</strong><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<h2 id="mysql-事务的隔离级别与幻读问题">MySQL 事务的隔离级别与幻读问题</h2>
<h3 id="隔离级别">隔离级别</h3>
<p>隔离性是指：多个事务并发执行时，每个事务对数据库所做的更改必须与其它事务隔离。</p>
<p>隔离性是并发控制的主要目标<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>，并发控制用来实现在保证应用层面一致性的前提下，尽可能快地对并发请求做出响应。由此可见，隔离性和并发能力是一对此消彼长的关系。极端情况下，如果并发的请求按顺序执行，隔离性是最好的，但是响应最慢，反之亦然。</p>
<p>在此基础上，产生了四个隔离级别的划分。由低到高依次为：读未提交、读已提交、可重复读、序列化。据前所述，它们的并发能力是依次下降的。</p>
<p>因此，<strong>隔离级别的本质是通过适度地破坏隔离性来提高并发能力。</strong></p>
<h3 id="隔离级别的问题">隔离级别的问题</h3>
<p>隔离级别不同，存在的问题也不一样。</p>
<p>“读未提交”的级别最低、并发能力最高，存在的问题也最多，包括：脏读、不可重复读、幻读。其中，脏读是这个级别独有的，即事务 A 读取了并发事务 B 未提交的数据。</p>
<p>“读已提交”顾名思义，事务 A 不会读取并发事务 B 未提交的数据，但可以读取其已提交的。因此，这个级别存在不可重复读和幻读的问题。</p>
<p>在“可重复读”级别下，同一事务中两次同样的查询结果一致，不会受并发事务的影响，它因此也解决了不可重复读的问题。但还会存在幻读问题。</p>
<p>“序列化”级别要求对查询的对象加范围锁并保持到事务结束，因此，它避免了幻读的问题。</p>
<h3 id="幻读问题phantom-reads">幻读问题（Phantom Reads）</h3>
<p>幻读问题是个很 tricky 的问题，以至于网上找到的很多文章对它的理解都是不全面甚至是错误的。</p>
<p>幻读即同一事务中两次相同查询的结果集不一致。乍一看，好像和不可重复读是一样的。那它们的区别是什么呢？</p>
<p>事实上，幻读是不可重复读的一种特殊情况。换句话说，<strong>只要存在幻行（Phantom Rows），就是幻读问题</strong>。</p>
<p>所谓幻行，即同一事务中两次相同的查询结果集的非空差集里的元素，或者说第二次查询后发现不存在于前一次结果集中的行。</p>
<p>幻行产生的原因主要是除“序列化”之外的隔离级别不要求对查询结果加范围锁，导致并发事务在查询范围内插入新的行后被当前事务查到。</p>
<h4 id="mvcc">MVCC</h4>
<p>在此基础上，MySQL 的 InnoDB 引擎实现了“多版本并发控制”（MVCC: Multiversion Concurrency Control）。</p>
<p>简单地说，InnoDB 的表存在两个隐藏列，用于记录每行数据的版本信息。当插入一行数据时，InnoDB 将当前事务的版本信息一并写入。当修改一行数据时，InnoDB 先将该行做一次复制，并把当前版本信息写入进去。查询时，只返回版本小于等于当前事务版本的数据。通过这样保证一个事务中查询到的是事务开始前已经存在的数据或当前事务写入的数据。其它事务写入的数据则不会被读取。</p>
<p>从这个意义上讲，InnoDB 通过 MVCC 解决了这种幻读问题。</p>
<h4 id="next-key-lock">Next-Key Lock</h4>
<p>上述普通的 SELECT 查询属于 InnoDB 读操作的一种：快照读。此外，还存在一种“当前读”。快照读顾名思义读取的是快照中的内容，而当前读读取的是当前最新的数据。INSERT、DELETE、UPDATE、SELECT &hellip; FOR UPDATE 都是当前读。</p>
<p>因此，还存在一种特殊情况：</p>
<p><figure><a class="lightgallery" href="https://www.plantuml.com/plantuml/svg/dP91Inj15CVlyoaUUbWZQzaau26WQ9iA7Wf5Ul4uoRx4mTsPC3jRzIP5gTQqKL4KyQ8WtX8F8j7aspIp9gT-XRx482nuybtUpEFFx__Ucrc83DSc3WF6edKXQrpp4FoQWBpdCMQ42H3iuuDj7FMU3kolgwHnR7Tlx66zrzxkjJk3a-RpnKvoUfVyRjfMj__pdgxsiTDlTGPdpS7rEGkmYj9dGF52W6-RMUYr_r3EZT79_ct_glwlMnS-sBspv7BVdhJ8uFd-sdPF_sx_O8I0COdnib5wI64-Dxp48uJYnzTgZWInKJ8EIwWP6vhDpCoJeW0bh0h9XhRfIaeKOO1b0zDGqIg4E48TmSOQQWHgRWxoJ2g3e4LrpO2gZ8QPzBnFdulP0dYWrKO4GXB5i9IJa4Gob8mQGwU4xmAleWkIXvY1xpo8aSfvbtRlWkChAT39f2Xb5OR2Z9QPQlhzz3UcMLfQf2Z0LDQRpRamKOnhWIXpqg4qUWkSl0CLslKwqddazk7holANnPLLPoB3s08z4lsd_m00" title="并发事务插入同一主键的数据导致的幻读问题" data-thumbnail="https://www.plantuml.com/plantuml/svg/dP91Inj15CVlyoaUUbWZQzaau26WQ9iA7Wf5Ul4uoRx4mTsPC3jRzIP5gTQqKL4KyQ8WtX8F8j7aspIp9gT-XRx482nuybtUpEFFx__Ucrc83DSc3WF6edKXQrpp4FoQWBpdCMQ42H3iuuDj7FMU3kolgwHnR7Tlx66zrzxkjJk3a-RpnKvoUfVyRjfMj__pdgxsiTDlTGPdpS7rEGkmYj9dGF52W6-RMUYr_r3EZT79_ct_glwlMnS-sBspv7BVdhJ8uFd-sdPF_sx_O8I0COdnib5wI64-Dxp48uJYnzTgZWInKJ8EIwWP6vhDpCoJeW0bh0h9XhRfIaeKOO1b0zDGqIg4E48TmSOQQWHgRWxoJ2g3e4LrpO2gZ8QPzBnFdulP0dYWrKO4GXB5i9IJa4Gob8mQGwU4xmAleWkIXvY1xpo8aSfvbtRlWkChAT39f2Xb5OR2Z9QPQlhzz3UcMLfQf2Z0LDQRpRamKOnhWIXpqg4qUWkSl0CLslKwqddazk7holANnPLLPoB3s08z4lsd_m00" data-sub-html="<h2>并发事务插入同一主键的数据导致的幻读问题</h2><p>并发事务插入同一主键的数据导致的幻读问题</p>">
        
    </a><figcaption class="image-caption">并发事务插入同一主键的数据导致的幻读问题</figcaption>
    </figure></p>
<p>以及另一种特殊情况：</p>
<p><figure><a class="lightgallery" href="https://www.plantuml.com/plantuml/svg/pPBFJjj04CRl-nGZzP2c2fAJ2Acg14A5la5VO1DFaXNsRcIleOSUeWh4Vo8G0LIWKY9Lt0Y7g8AIjsdM9AU-GcTj2_2XTtpvTdTcV_jz8o-5cWSwyZt6mbKXsppWFhXj0LN7OKmBxI745wFuzDRS_pBTeydlFRFRZxl7PlFdu_UDk7SR7zoOuNYwDQAjkN-O3XzcPpUpmJdpi8dIPK1VUWi-Vod3vEwGj08fBjwvdlRt_uxtUHF1R9_5bpkpgn_cP3YvwpoE1cRS-zFvnWW36OtnkbQ19J6NQrxZ8SBAnwVJ2ZL4Mid8hs70c7rmRcwHEZv03Pj2Cljq_YJN5AA7TGtle14e7w8GWn3MMnWW29VwzJgYXB83d1ozTvXK6Y4GpPO6rKZYlN6SvKyhvIJrLtl9YWrdLN8_MMJLIYhpJggkaW9jrSQrP9PpAoIvqIHQPSRU2hTasQK4N8GrxaL8nzKICKjGI825OevILxulT68W5pngqpWn0uUeKwyBKD3ABsGZi34M2Frg9aRUu4Mr-f_gypoNQ4d_-Zy0" title="更新并发事务插入的数据导致的幻读问题" data-thumbnail="https://www.plantuml.com/plantuml/svg/pPBFJjj04CRl-nGZzP2c2fAJ2Acg14A5la5VO1DFaXNsRcIleOSUeWh4Vo8G0LIWKY9Lt0Y7g8AIjsdM9AU-GcTj2_2XTtpvTdTcV_jz8o-5cWSwyZt6mbKXsppWFhXj0LN7OKmBxI745wFuzDRS_pBTeydlFRFRZxl7PlFdu_UDk7SR7zoOuNYwDQAjkN-O3XzcPpUpmJdpi8dIPK1VUWi-Vod3vEwGj08fBjwvdlRt_uxtUHF1R9_5bpkpgn_cP3YvwpoE1cRS-zFvnWW36OtnkbQ19J6NQrxZ8SBAnwVJ2ZL4Mid8hs70c7rmRcwHEZv03Pj2Cljq_YJN5AA7TGtle14e7w8GWn3MMnWW29VwzJgYXB83d1ozTvXK6Y4GpPO6rKZYlN6SvKyhvIJrLtl9YWrdLN8_MMJLIYhpJggkaW9jrSQrP9PpAoIvqIHQPSRU2hTasQK4N8GrxaL8nzKICKjGI825OevILxulT68W5pngqpWn0uUeKwyBKD3ABsGZi34M2Frg9aRUu4Mr-f_gypoNQ4d_-Zy0" data-sub-html="<h2>更新并发事务插入的数据导致的幻读问题</h2><p>更新并发事务插入的数据导致的幻读问题</p>">
        
    </a><figcaption class="image-caption">更新并发事务插入的数据导致的幻读问题</figcaption>
    </figure></p>
<p>以上两种情况都是在有当前读操作时可能发生的幻读问题。这是 MVCC 无法解决的。</p>
<p>InnoDB 用 Next-Key Lock 解决这种幻读问题。</p>
<p>Next-Key Lock 实际上是记录锁（Record Lock）和间隙锁（Gap Lock）的结合。加锁规则如下：</p>
<ol>
<li>Next-Key Lock 的格式是左开右闭。例如：( 5, 9 ] 表示间隙 ( 5, 9 ) 的间隙锁和 9 的行锁。</li>
<li>对查询条件范围的“行和间隙”（如果存在）加锁。</li>
<li>对于等值查询：
<ol>
<li>对于唯一索引，Next-Key Lock 退化为行锁。</li>
<li>向右遍历至查询条件范围内最后一个值右侧节点时，若该节点不满足等值条件，Next-Key Lock 退化为间隙锁。</li>
</ol>
</li>
</ol>
<p>例如，users 表结构如下：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>类型</th>
<th>索引</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>bigint</td>
<td>唯一</td>
</tr>
<tr>
<td>age</td>
<td>smallint</td>
<td>不唯一</td>
</tr>
</tbody>
</table>
<p>表中的数据：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td>5</td>
<td>50</td>
</tr>
<tr>
<td>11</td>
<td>30</td>
</tr>
</tbody>
</table>
<p>对于上述第一种问题，事务 A 中通过任何一种当前读操作 id = 3 的行（例如 INSERT），都会自动给这个索引值加记录锁。此时，事务 B 中再插入 id = 3 的数据时就会被阻塞。从而避免了这种幻读问题。</p>
<p>对于第二种问题，事务 A 中对 age = 30 的数据加排他锁：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span> <span class="k">where</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">30</span> <span class="k">for</span> <span class="k">update</span>
</code></pre></td></tr></table>
</div>
</div><p>数据库会加 ( (10, 1), (30, 11) ] 和 ( (30, 11), (50, 5) ] 两个 Next-Key Lock 。注意，由于 InnoDB 使用 B+ 树存储索引，且对于辅助索引， B+ 树叶子节点存储的是索引值和主键值，所以这里间隙用 <code>( ( 头节点索引值, 头节点主键值 ), ( 尾节点索引值, 尾节点主键值 ) )</code> 表示。而且，由于 (30, 11) 右侧间隙的尾结点 (50, 5) 不满足等值条件，所以这个 Next-Key Lock 退化为间隙锁 ( (30, 11), (50, 5) ) 。</p>
<p>此时，事务 B 更新 age = 30 的数据时将会被阻塞。也就避免了这种幻读问题。</p>
<h4 id="总结">总结</h4>
<p>InnoDB 通过 MVCC 解决了普通查询中的幻读问题，通过 Next-Key Lock 解决了当前读导致的幻读问题。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><a href="https://en.wikipedia.org/wiki/Consistency_(database_systems)">https://en.wikipedia.org/wiki/Consistency_(database_systems)</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p><a href="https://en.wikipedia.org/wiki/ACID#Isolation">https://en.wikipedia.org/wiki/ACID#Isolation</a> <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></description></item><item><title>在 VS Code 中快速创建 PHPUnit 测试类的方法</title><link>http://0x3f.org/post/quickly-create-phpunit-test-cases-with-vscode/</link><pubDate>Tue, 18 Feb 2020 22:49:45 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/quickly-create-phpunit-test-cases-with-vscode/</guid><description><![CDATA[<p>通过单元测试解决问题或者调试代码，可以避开错综复杂的依赖关系、直击问题的核心，从而极大地节约时间、提高效率。</p>
<p>但是，当创建测试类成为一个经常发生的操作时，每次都手动创建类、引入基类、添加测试方法就显得很烦琐。我需要这样一个解决方案，让我可以立即开始着手写测试代码。</p>
<h2 id="方案一文件模板">方案一：文件模板</h2>
<p>通过VS Code的插件<a href="https://marketplace.visualstudio.com/items?itemName=yongwoo.template" target="_blank" rel="noopener noreffer">Template</a>，可以实现把事先准备好的一个测试类文件模板复制到工程目录下。</p>
<p>安装完后，第一次执行<code>Template: Create New</code>命令会在当前工程根目录下创建文件“template.config.js”和目录“.templates”。</p>
<p>在“.templates”中创建测试类模板文件，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

<span class="k">namespace</span> <span class="nx">Tests</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Tests\TransactionalTestCase</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AnyTest</span> <span class="k">extends</span> <span class="nx">TransactionalTestCase</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">testAnything</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下次再执行Template的命令或者侧边栏文件管理器中的右键菜单项时，就可以选择该模板了。</p>
<p>Template有个很大的短板，目前的版本还不支持全局模板，每个工程下都维护一套模板还是很烦琐的。</p>
<h2 id="方案二代码片断">方案二：代码片断</h2>
<p>代码片断（以下统称Snippet）可能是VS Code做得最烂的一个功能，我曾无数次泪流满面地回想起有Vim和UltiSnips相伴的美好时光。</p>
<p>解决方案是这样的：</p>
<p>先通过插件<a href="https://marketplace.visualstudio.com/items?itemName=sleistner.vscode-fileutils" target="_blank" rel="noopener noreffer">File Utils</a>的<code>File: New File Relative to Project Root</code>命令在工程目录下创建一个空白文件（如AnyTest.php）。然后再通过Snippet快速插入测试类的脚手架代码。</p>
<p>这里有一个问题，VS Code的PHP Snippet只有在<code>&lt;?php</code>标签之内才能生效，所以如果创建一个针对PHP语言的Snippet，在上面创建的这个空白文件里是无法触发的。</p>
<p>VS Code的Snippet总体上分为工程和通用两类，所谓工程类（Project Snippet Scope），就是只对当前工程生效，存储在工程根目录下的“.vscode”目录中。通用类（Language Snippet Scope）是我们平时最常用的，对所有工程都会生效。它又分为语言和全局两种。语言类（Language Snippet File）是针对具体的语言定义的Snippet集合，文件名为语言名称，后缀是“.json”，如“php.json”。全局类（Global Snippet File）通常是不受限于语言的，当然也可以指定单个Snippet对哪些语言启用，文件名随意，后缀是“.code-snippets”。</p>
<p>因此，测试类脚手架代码的Snippet不能定义在“php.json”中，而应放在“global.code-snippets”里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JSON" data-lang="JSON"><span class="s2">&#34;PHPUnit：新测试类&#34;</span><span class="err">:</span> <span class="p">{</span>
    <span class="nt">&#34;prefix&#34;</span><span class="p">:</span> <span class="s2">&#34;newcase&#34;</span><span class="p">,</span>
    <span class="nt">&#34;body&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&#34;&lt;?php&#34;</span><span class="p">,</span>
        <span class="s2">&#34;&#34;</span><span class="p">,</span>
        <span class="s2">&#34;namespace Tests${1:\\\\${2:SubNameSpace}};&#34;</span><span class="p">,</span>
        <span class="s2">&#34;&#34;</span><span class="p">,</span>
        <span class="s2">&#34;use Tests\\\\${3|TransactionalTestCase,TestCase|};&#34;</span><span class="p">,</span>
        <span class="s2">&#34;&#34;</span><span class="p">,</span>
        <span class="s2">&#34;class ${TM_FILENAME_BASE} extends $3&#34;</span><span class="p">,</span>
        <span class="s2">&#34;{&#34;</span><span class="p">,</span>
        <span class="s2">&#34;    $0&#34;</span><span class="p">,</span>
        <span class="s2">&#34;}&#34;</span>
    <span class="p">],</span>
    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;PHPUnit：新测试类&#34;</span><span class="p">,</span>
    <span class="nt">&#34;scope&#34;</span><span class="p">:</span> <span class="s2">&#34;html,php&#34;</span><span class="p">,</span>
<span class="p">}</span><span class="err">,</span>
</code></pre></td></tr></table>
</div>
</div><p>这里通过选项“scope”设定只对“html”和“php”两种语言生效，注意如果只设定“php”也是只能在<code>&lt;?php</code>标签内才能生效的。</p>]]></description></item><item><title>关于Lumen的Facade不支持引用传递的看法</title><link>http://0x3f.org/post/lumen-facade-doesnot-support-pass-by-reference-param/</link><pubDate>Tue, 04 Feb 2020 17:40:34 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/lumen-facade-doesnot-support-pass-by-reference-param/</guid><description><![CDATA[<p>今天遇到一个奇怪的问题，一次调用带引用传递形参的方法后，该形参对应的变量值没有按预期改变。</p>
<p>先后排除了方法声明、调用和被调方法内部逻辑的问题，唯一的可能应该是框架自身的某些因素导致的。由于该行代码的作者是通过Facade调用Service中的这个方法，所以怀疑问题可能出在Facade上。于是改用从容器中获取Service实例的方式，发现变量值是可以改变的，也进一步验证了这个猜测。</p>
<p>通过单步调试，发现<code>Illuminate\Support\Facades\Facade::__callStatic()</code>直接把所有参数的值作为一个一维数组传递给被调方法，导致被调方法中的引用传递参数在方法执行后没有被改变。</p>
<p>我个人的观点是，应该尽量避免使用引用传递、全局变量这种东西，所有方法和函数应该按标准的IO模型封装，甚至在Controller的方法中都不应该直接echo &amp; die，而是应该将结果返回并由框架处理对调用方的输出行为。</p>
<p>保持实现方式的简单统一，从长期看可以较好地降低开发和维护成本。大道至简。</p>]]></description></item><item><title>用C4-PlantUML画软件架构图</title><link>http://0x3f.org/post/design-software-architecture-with-c4-plantuml/</link><pubDate>Fri, 17 Jan 2020 17:29:24 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/design-software-architecture-with-c4-plantuml/</guid><description><![CDATA[<p><a href="https://c4model.com" target="_blank" rel="noopener noreffer">C4 Model</a>是一种简洁有序的架构模型，四个“C”分别表示“Context”、“Container”、“Component”和“Code”，是由上而下逐步细化的四个层级。</p>
<p>Contex即上下文，它表示我们正在构架的软件系统和用户、其它系统之间的关系。例如：</p>
<p><figure><a class="lightgallery" href="https://www.plantuml.com/plantuml/svg/0/TLHBRzim3BxxLt2vD0NIP8UTTceUnbeiZo8F53qPYaB7GcJ9a-IcmR3_FigE4xjrSeh8Z-H7ygCVhMF6vQaClWd5PRx3t4X8dClipy70i6D_BroIRtEBXclbKBa-r-bWAJWpEpqNcA4SZ7yyl4Yct6Os7QJCEZHaYiOU_-7wcKz_1xcYm9GIW4iGOYsbFWgr1oaK0bCxQBY5iVHF0nK6gJcJyaGvAfBmENrmDns-BJRhQBruYIQBr_d5C5n5gz_XUln4uMVJw_FwAPg6lyBv90YSS19XTIBMAKo9X-KiGzW9jZSi9Pu6Hc8F8wOEa4aU12zeh5PTdbkdKpGzw9GM9WkGRsbyzdN8EOGA2JekUjiIgWT7cYjaLQIt0UDSvyhPVkS-24BgpcH6M8n6PDqnS-hoxvImpgPp3ty3e5_9lxij2KIsU1BusMTHw2xKIc11p2_0NjXPF-rtWKSGYffEcHDQ0TlglDY8C4sElM9bAJiWPEpazrRIlfA9mW_NPSwp6AvdjohwCUn8Py2PJNo6JmbI9kIrdV31ly5UcbZJF4NH8mrn9hZHLiSEmW-UCBL7m7f06q5ogvWMZPHiLlrlcTRAQOCMI8VL6ZaPu3pmbfbTkkpLPkOCKvPn3wCNEdwXL6gee5H5HdHpxu9xPfMWO5MQOELO77VgdZCOhFSKOnNg8hTgiBKgMyOFaOxZii28Nh0eNjVSmrqgbB14kkoB5cxpBDF6tQxoBmYMAACvYdsorQPs9b-qkR5eASB3bpLSAPdNiovi8Gpw353e6Uovrl1DXQoGBlYyTYymFz_F5Le6FBG72tzojCLgV9mN5qhC4gsmIZBvSc2tYpSeByj3g8kjqNrBsZRWf4KRDw2Rve9RKC6KdIXZGQnPl-chIjuNnatp8g_EH-gTliJ_0G00" title="System Landscape diagram for Big Bank plc" data-thumbnail="https://www.plantuml.com/plantuml/svg/0/TLHBRzim3BxxLt2vD0NIP8UTTceUnbeiZo8F53qPYaB7GcJ9a-IcmR3_FigE4xjrSeh8Z-H7ygCVhMF6vQaClWd5PRx3t4X8dClipy70i6D_BroIRtEBXclbKBa-r-bWAJWpEpqNcA4SZ7yyl4Yct6Os7QJCEZHaYiOU_-7wcKz_1xcYm9GIW4iGOYsbFWgr1oaK0bCxQBY5iVHF0nK6gJcJyaGvAfBmENrmDns-BJRhQBruYIQBr_d5C5n5gz_XUln4uMVJw_FwAPg6lyBv90YSS19XTIBMAKo9X-KiGzW9jZSi9Pu6Hc8F8wOEa4aU12zeh5PTdbkdKpGzw9GM9WkGRsbyzdN8EOGA2JekUjiIgWT7cYjaLQIt0UDSvyhPVkS-24BgpcH6M8n6PDqnS-hoxvImpgPp3ty3e5_9lxij2KIsU1BusMTHw2xKIc11p2_0NjXPF-rtWKSGYffEcHDQ0TlglDY8C4sElM9bAJiWPEpazrRIlfA9mW_NPSwp6AvdjohwCUn8Py2PJNo6JmbI9kIrdV31ly5UcbZJF4NH8mrn9hZHLiSEmW-UCBL7m7f06q5ogvWMZPHiLlrlcTRAQOCMI8VL6ZaPu3pmbfbTkkpLPkOCKvPn3wCNEdwXL6gee5H5HdHpxu9xPfMWO5MQOELO77VgdZCOhFSKOnNg8hTgiBKgMyOFaOxZii28Nh0eNjVSmrqgbB14kkoB5cxpBDF6tQxoBmYMAACvYdsorQPs9b-qkR5eASB3bpLSAPdNiovi8Gpw353e6Uovrl1DXQoGBlYyTYymFz_F5Le6FBG72tzojCLgV9mN5qhC4gsmIZBvSc2tYpSeByj3g8kjqNrBsZRWf4KRDw2Rve9RKC6KdIXZGQnPl-chIjuNnatp8g_EH-gTliJ_0G00" data-sub-html="<h2>System Landscape diagram for Big Bank plc</h2><p>System Landscape diagram for Big Bank plc</p>">
        
    </a><figcaption class="image-caption">System Landscape diagram for Big Bank plc</figcaption>
    </figure></p>
<p>容器（Container）把关注点放在被架构的系统本身，显示组成系统的容器（例如：APP、Web端、API、微服务、数据库等）及彼此之间的关系。例如：</p>
<p><figure><a class="lightgallery" href="https://www.plantuml.com/plantuml/svg/0/bLN1Zjf84BtxAsh98KJo35ffJtiA0sXdae7nZfcTv6ILsmMqqkwskjiG5Es_RxMn0KEKP3dPHTMhrwzUjTyxZzRNfOf-argekg3QAjXuNxa_HoEBkzkrz9iwhnrPORGdxM-5AKVFKg0jp49IHMeq-UCcKQZzo_nnLABpP3cKJJWVfIPxMuK6Rw7MN5eo1FWDmSeePNPIhq5n4g0keFUtj8wV371hK4QWKdl6w6Z2TOFeSVpvwMMPBP-IRFhqkeZUje5ncgKVPyl9FTUteTU7vNtsEFjhjfX6aPTUCM271eN4jSMI6Lfuu3DRJHxkK7y9PDCzdw-CeeIiCteeQkTDIJQ6oV5fC8Ok36RLd2RdwXXsh2LKJI6g9WOeXAcrTuDtKNI0pkuuKA3T3yNlZ7L9OF0ElaN0loFVuOxo3AkAaryfXt5LAPwEbqOFEFG1jnX3Mjb0VlxF9CIcfEIMQJJKs05U2cYdsymXX8zzy-xWoPX9zZkxYh47AV-jw2R1DONkNTTKM5dv6CPwNIkq8PnOivK5EU1fVh_BYaqIgAEIVX_6B-f6I0TRYQ54Mk3pGcxDZZrvnQWqkLJKoZ5lNZfEapSnVC8IMOa-5pPWAJqLuEhSCPTsPh_2pLsHEn20WhPIq2MzQJuiq6EEZi8OsiV09ltx4NhltbZc5lOEBAsbynQvDKZDhYoRwSQmuUG2i6PN2Ki5Zq-YSd4m5Jd7MxFc5_BYzagc7CKNqWNh98DVauVlssPgECsUwdgw_KIV80a3S-j_ZzQUVVL3Ab6gp3K1XflTpFczNQk0lsJfPGFDEpANmXfdLXvcNyK6DJliKCcmPvWjWnCgO-eLxp1TxEsPjC62xQG51uwdE5COC3UrFuqvFgvh33mFxR0vxqdaw9dKsPLmMimNHoxqlbykavGJ-tc7DVfnJi_OJUgXNROWkTxavkmQEC1rIzuYDS7-sBk6wFPQnF0XVLgCpfkVj_nVbTaTPv-8dIpVHtacB1oih2cRMsTdUGdvJZ81kGMUtaswSmRCCpqkR9Goh0Ew2T46uqJamd5z3lswseKRzjW-dI-J5kXuc5xvbUywOKBzg5Nd4tyLEt7USob_g_u3" title="Container diagram for Internet Banking System" data-thumbnail="https://www.plantuml.com/plantuml/svg/0/bLN1Zjf84BtxAsh98KJo35ffJtiA0sXdae7nZfcTv6ILsmMqqkwskjiG5Es_RxMn0KEKP3dPHTMhrwzUjTyxZzRNfOf-argekg3QAjXuNxa_HoEBkzkrz9iwhnrPORGdxM-5AKVFKg0jp49IHMeq-UCcKQZzo_nnLABpP3cKJJWVfIPxMuK6Rw7MN5eo1FWDmSeePNPIhq5n4g0keFUtj8wV371hK4QWKdl6w6Z2TOFeSVpvwMMPBP-IRFhqkeZUje5ncgKVPyl9FTUteTU7vNtsEFjhjfX6aPTUCM271eN4jSMI6Lfuu3DRJHxkK7y9PDCzdw-CeeIiCteeQkTDIJQ6oV5fC8Ok36RLd2RdwXXsh2LKJI6g9WOeXAcrTuDtKNI0pkuuKA3T3yNlZ7L9OF0ElaN0loFVuOxo3AkAaryfXt5LAPwEbqOFEFG1jnX3Mjb0VlxF9CIcfEIMQJJKs05U2cYdsymXX8zzy-xWoPX9zZkxYh47AV-jw2R1DONkNTTKM5dv6CPwNIkq8PnOivK5EU1fVh_BYaqIgAEIVX_6B-f6I0TRYQ54Mk3pGcxDZZrvnQWqkLJKoZ5lNZfEapSnVC8IMOa-5pPWAJqLuEhSCPTsPh_2pLsHEn20WhPIq2MzQJuiq6EEZi8OsiV09ltx4NhltbZc5lOEBAsbynQvDKZDhYoRwSQmuUG2i6PN2Ki5Zq-YSd4m5Jd7MxFc5_BYzagc7CKNqWNh98DVauVlssPgECsUwdgw_KIV80a3S-j_ZzQUVVL3Ab6gp3K1XflTpFczNQk0lsJfPGFDEpANmXfdLXvcNyK6DJliKCcmPvWjWnCgO-eLxp1TxEsPjC62xQG51uwdE5COC3UrFuqvFgvh33mFxR0vxqdaw9dKsPLmMimNHoxqlbykavGJ-tc7DVfnJi_OJUgXNROWkTxavkmQEC1rIzuYDS7-sBk6wFPQnF0XVLgCpfkVj_nVbTaTPv-8dIpVHtacB1oih2cRMsTdUGdvJZ81kGMUtaswSmRCCpqkR9Goh0Ew2T46uqJamd5z3lswseKRzjW-dI-J5kXuc5xvbUywOKBzg5Nd4tyLEt7USob_g_u3" data-sub-html="<h2>Container diagram for Internet Banking System</h2><p>Container diagram for Internet Banking System</p>">
        
    </a><figcaption class="image-caption">Container diagram for Internet Banking System</figcaption>
    </figure></p>
<p>组件（Component）把一个容器放大，拆分成不同的抽象逻辑，这一层级已经涉及代码层面的内容。例如：</p>
<p><figure><a class="lightgallery" href="https://www.plantuml.com/plantuml/svg/0/fLLDRnen4BtlhvXoQ45AmgMddaf8sYJA1mBIZnEQzGwBMt-iR2yKLVtl7Nk1NPAeYjHSuXsFPzwyzsm--e0kr5fbRwGHgYweTWfM8LJ-mt3eS7DMoh2gyzgJ4zO4Ck5CM3sSIe6kiFUIAbB3yVlJYK8J7kzkXnfz8CUXnTZgoffueeeDta5j-AZc08GLmT8gPJVIbA2a8K1JmD6sT9vN5hWrA2jGgItNsCE4vmsosz7tXyVvuklr_6fnU_dvylwYFyYo88FYz7qk519BXvhxExZcYPoX0ETeVaOeiosZrt0AeyarZAfAyPn1MfDbOvuU6QZh-mfFe3VZTAuxmPAwYJtU-e5hzCB9AgIfq9IrGXTt9iwkPK4UU9eqfTm3o7S0banIh8DAXcqSNzG-M4tEmrfYF2CTR2Y7tDaDYtBM6tIWwOZipkPI9L2nvJVKwAGvxiwKQnce05_ddhlRy1zeTDDlzw-WjHHq1EiYxnSvzx_0W3bwYbYcfB2f3FimpCIADCRTMR2ESKRNWQDI-k1IDYDasNHQdy0A_Ofdm9fncB0J08IZ8dwYyYU0Gf3tx9-IFoY8YAlHU77vA_HrxYDXZ7B9bg0dDkWWYNhPPI99SE10K0SFO6xhq3AKcjlQ15unVECnKTdYQ0bQd7DUWMxRnqfoqoVcwmtWTmRyTp1ntylI91EMXaqCiPBZ-qJ9PNTVnZ0blZs7S8oEudLhEFLHobY2ySVbYzhxXeF1ayxjKBtHRWcpMhF9jg-2SJ1XQwKDFp7iISzLB5TfU6PZHIG74fy1yIHgnxQCDEoMxMwIhd9nZdF2O_SVczf58xAB4YEcR4Gz0R72vgD2xpVM5Qrknp3OGaiKMD0_Z0IVKiOBe4RG70QcgD517seS2v4S4rlppTd9ts7WqTEUeRZVYjI5zoIfFPvkvvImWBUmuH0n6n7TpSNvk7EWKwkvEAbWV6FutR-QpoSpJlwJPQbuV2HtBjsdtSmUxWzvXwIEeLvCJ9dw5TNqAufz95FmRyLV" title="Component diagram for Internet Banking System - API Application" data-thumbnail="https://www.plantuml.com/plantuml/svg/0/fLLDRnen4BtlhvXoQ45AmgMddaf8sYJA1mBIZnEQzGwBMt-iR2yKLVtl7Nk1NPAeYjHSuXsFPzwyzsm--e0kr5fbRwGHgYweTWfM8LJ-mt3eS7DMoh2gyzgJ4zO4Ck5CM3sSIe6kiFUIAbB3yVlJYK8J7kzkXnfz8CUXnTZgoffueeeDta5j-AZc08GLmT8gPJVIbA2a8K1JmD6sT9vN5hWrA2jGgItNsCE4vmsosz7tXyVvuklr_6fnU_dvylwYFyYo88FYz7qk519BXvhxExZcYPoX0ETeVaOeiosZrt0AeyarZAfAyPn1MfDbOvuU6QZh-mfFe3VZTAuxmPAwYJtU-e5hzCB9AgIfq9IrGXTt9iwkPK4UU9eqfTm3o7S0banIh8DAXcqSNzG-M4tEmrfYF2CTR2Y7tDaDYtBM6tIWwOZipkPI9L2nvJVKwAGvxiwKQnce05_ddhlRy1zeTDDlzw-WjHHq1EiYxnSvzx_0W3bwYbYcfB2f3FimpCIADCRTMR2ESKRNWQDI-k1IDYDasNHQdy0A_Ofdm9fncB0J08IZ8dwYyYU0Gf3tx9-IFoY8YAlHU77vA_HrxYDXZ7B9bg0dDkWWYNhPPI99SE10K0SFO6xhq3AKcjlQ15unVECnKTdYQ0bQd7DUWMxRnqfoqoVcwmtWTmRyTp1ntylI91EMXaqCiPBZ-qJ9PNTVnZ0blZs7S8oEudLhEFLHobY2ySVbYzhxXeF1ayxjKBtHRWcpMhF9jg-2SJ1XQwKDFp7iISzLB5TfU6PZHIG74fy1yIHgnxQCDEoMxMwIhd9nZdF2O_SVczf58xAB4YEcR4Gz0R72vgD2xpVM5Qrknp3OGaiKMD0_Z0IVKiOBe4RG70QcgD517seS2v4S4rlppTd9ts7WqTEUeRZVYjI5zoIfFPvkvvImWBUmuH0n6n7TpSNvk7EWKwkvEAbWV6FutR-QpoSpJlwJPQbuV2HtBjsdtSmUxWzvXwIEeLvCJ9dw5TNqAufz95FmRyLV" data-sub-html="<h2>Component diagram for Internet Banking System - API Application</h2><p>Component diagram for Internet Banking System - API Application</p>">
        
    </a><figcaption class="image-caption">Component diagram for Internet Banking System - API Application</figcaption>
    </figure></p>
<p>而抽象逻辑内部代码之间的关系由Code这一层展示。</p>
<p><a href="https://github.com/RicardoNiepel/C4-PlantUML" target="_blank" rel="noopener noreffer">C4-PlantUML</a>是为PlantUML封装的一套模板，用来画C4架构图既美观又方便。下面是我画的样子：</p>
<p><figure><a class="lightgallery" href="https://www.plantuml.com/plantuml/svg/0/jLXVJzjM57_Ff_3oKYAnvcLFUse7Q7Ib445GDMcIPHmRh3fsP3ljq5I9m4ef8v0MwDgDjGqjRRKL1rG68H7amyptElaMkzVNyP_43cPXUOXkxZs_txddt7FEFJStL8rHj7nMZCM-42HMp6SuQaxJSkhNoQJ2FBW-AsXp-PcyoYciB6cSf5rdvMnoKc0P9IEF2roE4vD3NtsP4Xb9cxupbimogiOfQ8eUGlAC877AzHoclqRb9GJD8WfAc-CeNXP5-O4WpL8Y4g8OAKFvbWL5HIEPGgefKMOPKPn77CuUknN4ncv-Fp6TfjCJANfuukuuahPdRaxHKxT7qaEZ0mbtykwjz2WzDlBjoFWmcevfWYPob57x03OBIQFs3hxOJ3QFTi5g6VvTCAg_uS6hO_ZgvrWinIcgB0ta53cJPpKwoqZCBASCsc2plc6MbXDjAJQlQdAMKsX6LGNaQqaRf82-2tUAtI8E4nPOEUbWObXMpak4WUoilKIF_AWvB6sqRp73gSAiX1UR-dbJBuFg2h9v11seabC4bQE_GTGPHfaVU20hzsOuYPqRfEBWPCyusm4R1_44zLECGf-fUNIwMLUwxGEMmrG8GdnWLFT1Oyb1uOzpM0CvbkOLAvOoMCUJelbN9Ov6tp7t6PLLX1ooxwQa3LjRZZiYhVAf-RiUJmGppZ3iFPkmj6uJfaPJWzHO7eLKt9c7wtjWusqGo_0Cviam6ZF3g5o7AN3x01PrKDl4JAqNZTRZDQFsr9qbV0zZWKvYbIn23KtU2N48MhzgZs3AAt499lBu11dHbojuGM8abdFZXGHoptZXhpnU-2kA5zuNBrvJeZhfON0Iec97eufxNs0v5M_bN4Vr0f67vg57k4FIRxajHzjvwqIv3UfsmigoULZ_Pw4mbPh6txUd0ntQfaMb6Nl2h3NCezqmJh9gwcLKt13d3n8ehS7zFVFJ9wFw13u_TMAifoevbvFHlIK9sZpUv_OotAc5Mc6jzglHBR1nKc53rP7gRQdhpOXc5COw1b1QmPiAOxHM-tQPaY4vf--2udQOBhAAj83z4Xdt9BKpsed_C5guLJ7gBu1UXc-gY1nk7SDFvwtDusPv3HJBZcbmesIk7pXYnjdBrkuVw0Q61qVeP-ljEbp_q7C_agm9F0u9nDHQVXRgqOsdhOM2-NhVQ9HxycdCB2PxyzZSFm-DQ6ltHCQi7u7QUso9zTCPW6The7BQF2o3Hv-RXItqRNwkzowMCkg355yTU7GCzAM01BUH-APNLHbB5hVDnLFpPHsSUO_FAsVRXpixRCBMHpUYUmAuB2E8kAejwaRzs8Umwjcr__n1lHdPXd7MG0E04lfbfH--IKxixjByxKTJRxH-rV4XZgRJgIba20O5DMqTj_G5G4TT99YtjUFPoyb7Kj2P7PvQHdA0P4k7j7tK7c7xq8E4szHkgnc1sYFSGTrV77bxjpuZY9xqTwo-PhDPEO67YrOtCZKndiGkjmtrOKXIskdO8UpgS6ZzVQYh8psKIjxoA700NdxufjpwSoraIowYgn7eQKeNpYuRyFLUix9hPoqwwaAboxo-pX5TRFqVdpz3_ArnkDL-L8GJz15tzCqXP-Y3H3j4FyJVTy7D8dglaVugCjRVI14AqZ15L-yM21jlTK3HyMuVPEEjVYUw2NPZGy1sqn8L73cIGndS728aTl6v78cdZ-ePabr0f-7njJHHqUtRd8193RxQ5FO-Y_hFPT_jo4ShnVmbIx6NbezIYlbBbsAUxIiBWk1E4bWnI9A0n21SUMuqTBXrIYRDrMEuK8XAUwdq23JBKnmi4b8SBaSI9Jk2S96J8mZy_-S6g2w1muK-EKxUeuT5wwo4_zfavkdXNlSy_lyJhgvwdpFeOU9zkS6jSx1oW5-MjJNqDeiHogvIvtaU9IwI8OTmeLWxK2uKj8F1jWMyUzvQ-cY_NwpDmvq5e_eBUXPt45bFkNR7cGXQTBVWEDEV1xxGI3X2dHK6uM-WSJuh_Wi0" title="产品 交易 财务流业务架构" data-thumbnail="https://www.plantuml.com/plantuml/svg/0/jLXVJzjM57_Ff_3oKYAnvcLFUse7Q7Ib445GDMcIPHmRh3fsP3ljq5I9m4ef8v0MwDgDjGqjRRKL1rG68H7amyptElaMkzVNyP_43cPXUOXkxZs_txddt7FEFJStL8rHj7nMZCM-42HMp6SuQaxJSkhNoQJ2FBW-AsXp-PcyoYciB6cSf5rdvMnoKc0P9IEF2roE4vD3NtsP4Xb9cxupbimogiOfQ8eUGlAC877AzHoclqRb9GJD8WfAc-CeNXP5-O4WpL8Y4g8OAKFvbWL5HIEPGgefKMOPKPn77CuUknN4ncv-Fp6TfjCJANfuukuuahPdRaxHKxT7qaEZ0mbtykwjz2WzDlBjoFWmcevfWYPob57x03OBIQFs3hxOJ3QFTi5g6VvTCAg_uS6hO_ZgvrWinIcgB0ta53cJPpKwoqZCBASCsc2plc6MbXDjAJQlQdAMKsX6LGNaQqaRf82-2tUAtI8E4nPOEUbWObXMpak4WUoilKIF_AWvB6sqRp73gSAiX1UR-dbJBuFg2h9v11seabC4bQE_GTGPHfaVU20hzsOuYPqRfEBWPCyusm4R1_44zLECGf-fUNIwMLUwxGEMmrG8GdnWLFT1Oyb1uOzpM0CvbkOLAvOoMCUJelbN9Ov6tp7t6PLLX1ooxwQa3LjRZZiYhVAf-RiUJmGppZ3iFPkmj6uJfaPJWzHO7eLKt9c7wtjWusqGo_0Cviam6ZF3g5o7AN3x01PrKDl4JAqNZTRZDQFsr9qbV0zZWKvYbIn23KtU2N48MhzgZs3AAt499lBu11dHbojuGM8abdFZXGHoptZXhpnU-2kA5zuNBrvJeZhfON0Iec97eufxNs0v5M_bN4Vr0f67vg57k4FIRxajHzjvwqIv3UfsmigoULZ_Pw4mbPh6txUd0ntQfaMb6Nl2h3NCezqmJh9gwcLKt13d3n8ehS7zFVFJ9wFw13u_TMAifoevbvFHlIK9sZpUv_OotAc5Mc6jzglHBR1nKc53rP7gRQdhpOXc5COw1b1QmPiAOxHM-tQPaY4vf--2udQOBhAAj83z4Xdt9BKpsed_C5guLJ7gBu1UXc-gY1nk7SDFvwtDusPv3HJBZcbmesIk7pXYnjdBrkuVw0Q61qVeP-ljEbp_q7C_agm9F0u9nDHQVXRgqOsdhOM2-NhVQ9HxycdCB2PxyzZSFm-DQ6ltHCQi7u7QUso9zTCPW6The7BQF2o3Hv-RXItqRNwkzowMCkg355yTU7GCzAM01BUH-APNLHbB5hVDnLFpPHsSUO_FAsVRXpixRCBMHpUYUmAuB2E8kAejwaRzs8Umwjcr__n1lHdPXd7MG0E04lfbfH--IKxixjByxKTJRxH-rV4XZgRJgIba20O5DMqTj_G5G4TT99YtjUFPoyb7Kj2P7PvQHdA0P4k7j7tK7c7xq8E4szHkgnc1sYFSGTrV77bxjpuZY9xqTwo-PhDPEO67YrOtCZKndiGkjmtrOKXIskdO8UpgS6ZzVQYh8psKIjxoA700NdxufjpwSoraIowYgn7eQKeNpYuRyFLUix9hPoqwwaAboxo-pX5TRFqVdpz3_ArnkDL-L8GJz15tzCqXP-Y3H3j4FyJVTy7D8dglaVugCjRVI14AqZ15L-yM21jlTK3HyMuVPEEjVYUw2NPZGy1sqn8L73cIGndS728aTl6v78cdZ-ePabr0f-7njJHHqUtRd8193RxQ5FO-Y_hFPT_jo4ShnVmbIx6NbezIYlbBbsAUxIiBWk1E4bWnI9A0n21SUMuqTBXrIYRDrMEuK8XAUwdq23JBKnmi4b8SBaSI9Jk2S96J8mZy_-S6g2w1muK-EKxUeuT5wwo4_zfavkdXNlSy_lyJhgvwdpFeOU9zkS6jSx1oW5-MjJNqDeiHogvIvtaU9IwI8OTmeLWxK2uKj8F1jWMyUzvQ-cY_NwpDmvq5e_eBUXPt45bFkNR7cGXQTBVWEDEV1xxGI3X2dHK6uM-WSJuh_Wi0" data-sub-html="<h2>产品 交易 财务流业务架构</h2><p>产品 交易 财务流业务架构</p>">
        
    </a><figcaption class="image-caption">产品 交易 财务流业务架构</figcaption>
    </figure></p>
<p>和上面的例子相比，好像不太适合画较复杂的架构，布局不太好处理，另外连线太多容易重叠在一块傻傻分不清楚。</p>]]></description></item><item><title>用 PlantUML 实现 ERD</title><link>http://0x3f.org/post/plantuml-erd/</link><pubDate>Fri, 03 Jan 2020 17:01:41 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/plantuml-erd/</guid><description><![CDATA[<p>很长一段时间，我们都在用 MySQLWorkbench 画 ER 图。但是这个东西有一些缺陷，导致体验很不好。</p>
<p>首先它生成的文件是二进制的，做不了版本控制。这意味着在版本迭代的过程中做数据结构评审的体验很糟糕。其次，离线文件难以管理，不利于团队协作。第三，图形界面虽然简单，但并不等价于高效。用它画图的成本还是比较高的。</p>
<p>PlantUML 是个基于文本、灵活且强大的 UML 画图工具，高度可定制，而且可以集成到多种开发工具中。主流的 IDE 、文本编辑器都可以集成 PlantUML ，以便用自己最熟悉的工具画图并实时预览。基于文本的特性使得版本控制和 Code Review 很容易实现。如果 VCS 用的是 Gitlab ，可以更进一步，借助 PlantUML Server 实现实时预览。即使对于像 Github 这种暂时没有提供支持的 Web 平台，也有变通的解决方案。</p>
<p>基于以上情况，我封装了一个用 PlantUML 画 ER 图的模板。用这个模板画图的源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">@startuml

!include https://raw.githubusercontent.com/xbot/plantuml-erd/master/src/Library.iuml

&#39; avoid problems with angled crows feet
skinparam linetype ortho

&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;
&#39; Entities
&#39;
&#39; Relationships
&#39; one-to-one relationship
&#39;     user -- user_profile : &#34;A user only \nhas one profile&#34;
&#39; one to may relationship
&#39;     user --&gt; session : &#34;A user may have\n many sessions&#34;
&#39; many to many relationship
&#39; Add mark if you like
&#39;     user &#34;1&#34; --&gt; &#34;*&#34; user_group : &#34;A user may be \nin many groups&#34;
&#39;     group &#34;1&#34; --&gt; &#34;0..N&#34; user_group : &#34;A group may \ncontain many users&#34;
&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;

Table(posts, 文章表) {
    PRIMARY_KEY
    TIMESTAMPS
    Column(&#34;title&#34;, &#34;NVARCHAR[30]&#34;, 1, &#34;&#34;, &#34;标题&#34;)
    Column(&#34;status&#34;, UN(&#34;TINYINT&#34;), 1, &#34;1&#34;, &#34;状态&#34;, &#34;1:草稿; 2:已发布&#34;)
    Column(&#34;source&#34;, UN(&#34;TINYINT&#34;), 1, &#34;&#34;, &#34;来源：1，原创；2，转载&#34;)
    Column(&#34;category_id&#34;, PK_TYPE, 1, &#34;&#34;, &#34;分类&#34;)
    Column(&#34;created_by&#34;, PK_TYPE, 1, &#34;0&#34;, &#34;创建者ID&#34;)
    Column(&#34;published_at&#34;, &#34;DATETIME&#34;, 0, &#34;&#34;, &#34;发表时间&#34;)
    Column(&#34;content&#34;, &#34;TEXT&#34;, 1, &#34;&#34;, &#34;内容&#34;)
}

Table(comments, 评论表) {
    PRIMARY_KEY
    TIMESTAMPS
    Column(&#34;post_id&#34;, PK_TYPE, 1, &#34;&#34;, &#34;文章ID&#34;)
    Column(&#34;user_id&#34;, PK_TYPE, 1, &#34;&#34;, &#34;用户ID&#34;)
    Column(&#34;content&#34;, &#34;NVARCHAR[255]&#34;, 1, &#34;&#34;, &#34;评论内容&#34;)
}

Table(post_logs, 文章日志表) {
    PRIMARY_KEY
    TIMESTAMPS
    Column(&#34;post_id&#34;, PK_TYPE, 1, &#34;&#34;, &#34;文章ID&#34;)
    Column(&#34;user_id&#34;, PK_TYPE, 1, &#34;&#34;, &#34;操作者ID&#34;)
    Column(&#34;action&#34;, UN(&#34;TINYINT&#34;), 1, &#34;0&#34;, &#34;操作类型&#34;, &#34;1:创建; 2:修改; 3:删除&#34;)
    Column(&#34;data&#34;, &#34;TEXT&#34;, 0, &#34;&#34;, &#34;操作详情&#34;)
}

posts ||..o{ comments
posts ||..|{ post_logs

@enduml
</code></pre></td></tr></table>
</div>
</div><p>效果：</p>
<p></p>
<p>具体的源码和例子可以参考 <a href="https://github.com/xbot/plantuml-erd" target="_blank" rel="noopener noreffer">Git 仓库</a>。</p>
<p>下面说说怎么集成到 Gitlab。</p>
<p>首先需要一个可用的 PlantUML Server 。官方提供了一个现成的、开放的服务（<code>http://www.plantuml.com/plantuml/</code>）。如果对响应速度或私密性有要求，就需要部署私有的服务了。</p>
<p><a href="https://github.com/plantuml/plantuml-server" target="_blank" rel="noopener noreffer">官方</a>提供了多种部署方式，我用的是最简单的 docker 方式。</p>
<p>首先克隆官方仓库。</p>
<p>然后在仓库根目录下执行命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">docker run -d -p 18080:8080 plantuml/plantuml-server:jetty
</code></pre></td></tr></table>
</div>
</div><p>其中“18080”是服务器提供对外服务的端口。</p>
<p>最后，把上述服务地址配置到 Gitlab 里即可，选项路径为<code>管理区域→Settings→PlantUML</code>。</p>
<p>之后，可以创建 Markdown 文件，格式为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-markdown" data-lang="markdown"><span class="s">```plantuml
</span><span class="s"></span>PlantUML源码
<span class="s">```</span>
</code></pre></td></tr></table>
</div>
</div><p>当在 Gitlab 中点击该文件时，就会显示实时渲染的图了。</p>
<p>对于 Github 这种暂时不支持集成 PlantUML 的平台，可以利用 PlantUML Server 提供的代理服务实现，拼接一个如下所示的 URL 并当作图片链接插入网页即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">http://www.plantuml.com/plantuml/proxy?cache=no&amp;src=https://raw.githubusercontent.com/xbot/plantuml-erd/master/examples/Posts.md
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>解决Laravel中makeWith()无法取到被mock的实例的问题</title><link>http://0x3f.org/post/mocking-objects-made-by-laravel-container-with-parameters/</link><pubDate>Fri, 16 Aug 2019 10:55:40 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/mocking-objects-made-by-laravel-container-with-parameters/</guid><description><![CDATA[<p>被测单元有一行实例化一个类的代码，而且该类的构造方法需要参数。基于面向单元测试编程的原则，通过容器的makeWith()方法实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php">$api = app()-&gt;makeWith(Api::class, [&#39;config&#39; =&gt; $config]);
</code></pre></td></tr></table>
</div>
</div><p>但是在执行单元测试时发现，虽然测试代码中已经mock了这个类且注入到容器，但在被测单元中取到的还是原类的实例。</p>
<p>实际上，测试代码中在将mock的实例注入容器时使用的是instance()方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php">$this-&gt;app-&gt;instance($class, $mockedObj);
</code></pre></td></tr></table>
</div>
</div><p>而容器在取带构造参数的类的实例时，并不取通过instance()方法注册进来的实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php">protected function resolve($abstract, $parameters = [])
{
    $abstract = $this-&gt;getAlias($abstract);

    $needsContextualBuild = ! empty($parameters) || ! is_null(
        $this-&gt;getContextualConcrete($abstract)
    );

    // If an instance of the type is currently being managed as a singleton we&#39;ll
    // just return an existing instance instead of instantiating new instances
    // so the developer can keep using the same objects instance every time.
    if (isset($this-&gt;instances[$abstract]) <span class="err">&amp;&amp;</span> ! $needsContextualBuild) {
        return $this-&gt;instances[$abstract];
    }

    $this-&gt;with[] = $parameters;

    $concrete = $this-&gt;getConcrete($abstract);

    // We&#39;re ready to instantiate an instance of the concrete type registered for
    // the binding. This will instantiate the types, as well as resolve any of
    // its &#34;nested&#34; dependencies recursively until all have gotten resolved.
    if ($this-&gt;isBuildable($concrete, $abstract)) {
        $object = $this-&gt;build($concrete);
    } else {
        $object = $this-&gt;make($concrete);
    }
    
    // ...
    
}
</code></pre></td></tr></table>
</div>
</div><p>当存在构造参数时，容器认为是“上下文相关的构造”（needsContextualBuild），所以尝试通过具体的（concrete）逻辑实时构造。</p>
<p>进一步地，getConcrete()方法的实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php">protected function getConcrete($abstract)
{
    if (! is_null($concrete = $this-&gt;getContextualConcrete($abstract))) {
        return $concrete;
    }

    // If we don&#39;t have a registered resolver or concrete for the type, we&#39;ll just
    // assume each type is a concrete name and will attempt to resolve it as is
    // since the container should be able to resolve concretes automatically.
    if (isset($this-&gt;bindings[$abstract])) {
        return $this-&gt;bindings[$abstract][&#39;concrete&#39;];
    }

    return $abstract;
}
</code></pre></td></tr></table>
</div>
</div><p>它从bindings数组中获取构造逻辑。因此，可以将测试代码中注册被mock的实例的方法改成如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php">$this-&gt;app-&gt;offsetSet($class, $mockedObj);
</code></pre></td></tr></table>
</div>
</div><p>因为offsetSet()方法就是通过bind()方法把被mock的实例注册到容器的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php">public function offsetSet($key, $value)
{
    $this-&gt;bind($key, $value instanceof Closure ? $value : function () use ($value) {
        return $value;
    });
}
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>利用单元测试为开发提效</title><link>http://0x3f.org/post/use-unit-test-as-an-efficiency-tool/</link><pubDate>Tue, 13 Aug 2019 16:38:02 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/use-unit-test-as-an-efficiency-tool/</guid><description><![CDATA[<p>单元测试可以方便地伪造和回滚测试数据，这个特性决定了它其实是一个效率工具。</p>
<p>例如在开发退款单、发票的时候，由于这种后置的功能依赖订单、支付、库存等前置的数据，因此需要频繁地创建这些测试数据，这就导致开发的效率极低，有时甚至需要切换多个系统做诸如增加库存、下单、支付等操作。虽然在开发环境可以通过直接修改数据使之恢复可被测试的状态，但仍然存在效率很低、遗留垃圾数据和存在隐患等问题。</p>
<p>单元测试可以完美地解决这些问题。</p>
<h2 id="伪造测试数据">伪造测试数据</h2>
<p>在Laravel/Lumen中，利用Model Factory、Faker可以很方便地伪造测试数据。进一步地，只需要伪造被测单元依赖的数据，不需要真实、完整的数据。这些在<a href="/phpunit-tips" rel="">《单元测试的技巧》</a>一文中有详细介绍。</p>
<p>测试数据只是被测单元依赖关系的一种，利用Mockery框架对依赖关系做伪造和断言是非常重要的知识。Mock是单元测试的灵魂！</p>
<h2 id="回滚数据库">回滚数据库</h2>
<p>Laravel/Lumen提供了DatabaseTransactions和DatabaseMigrations（不同版本可能有差异）这样的Trait，可以自动在每个测试方法执行后自动回滚数据库。</p>
<h2 id="调试代码">调试代码</h2>
<p>不管是调试测试代码还是被测单元，调试代码在结合单元测试的开发过程中都是个强需求。通常调试代码有两种方式：打印并中断（echo &amp; die）和单步调试。这两者在单元测试中都可以很方便地实现。</p>
<h3 id="打印并中断">打印并中断</h3>
<p>某些版本的PHPUnit会抑制标准输出，某些配置项（<code>beStrictAboutOutputDuringTests=&quot;true&quot;</code>）也会导致在有标准输出时中断单元测试的执行。可通过把信息打印到标准错误输出设备绕过：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php">fwrite(STDERR, &#34;Behold:\n&#34; . var_export($order, true) . &#34;\n&#34;);
</code></pre></td></tr></table>
</div>
</div><h3 id="单步调试">单步调试</h3>
<p>单元测试是通过命令行执行的，因此可以利用XDebug支持CLI的特性触发单步调试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">export</span> <span class="nv">XDEBUG_CONFIG</span><span class="o">=</span><span class="s2">&#34;idekey=VSCODE&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="性能调优">性能调优</h2>
<p>和单步调试一样，可以通过环境变量实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">export</span> <span class="nv">XDEBUG_CONFIG</span><span class="o">=</span><span class="s2">&#34;idekey=VSCODE profiler_enable=1&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>但是性能分析会极大地降低代码执行效率，因此建议通过命令参数的方式实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">php -d <span class="s2">&#34;xdebug.profiler_enable=1&#34;</span> ./vendor/bin/phpunit
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>面向单元测试编程</title><link>http://0x3f.org/post/unit-test-oriented-programming/</link><pubDate>Tue, 13 Aug 2019 16:35:15 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/unit-test-oriented-programming/</guid><description><![CDATA[<p>同一逻辑可以有多种实现方式，选择对单元测试友好的方式可以提高写测试代码的效率。</p>
<h2 id="返回被创建的对象">返回被创建的对象</h2>
<p>通常创建数据的接口只需要返回错误信息，成功时返回空即可，不需要返回被创建的数据。故创建数据的方法可以定义成无返回值。并且，如果我们并不关注数据是不是实际上被插入到数据库中，可以通过mock那部分的逻辑实现，事实上，这其实是更符合单元测试的理念的。</p>
<p>但如果希望测试这一点，就需要到数据库中查询数据是否存在。有时候，如果被创建数据的特征不明显或不唯一，按这种方式实现就很困难。此时，如果被测单元返回被创建的对象实例，就可以省掉这一步，从而简化测试代码、提高执行效率。</p>
<h2 id="唾弃乱注入的恶习">唾弃乱注入的恶习</h2>
<p>遵循MVCSR的分层规范：</p>
<ol>
<li>Controller只实现校验参数、获取参数、调用Service、返回值，不封装具体业务逻辑。</li>
<li>Service只注入本对象的Repository，对其它对象的逻辑的调用均通过该对象的Facade实现。</li>
<li>Repository只注入本对象的Model，只封装本对象的逻辑。</li>
<li>Controller和Service中对任何其它Service的调用均通过Facade实现。</li>
</ol>
<p>否则，写测试代码时对被测单元的依赖关系的处理会很麻烦。</p>
<h2 id="使用facade">使用Facade</h2>
<p>Laravel/Lumen的Facade集成了Mockery，可以极大简化mocking。</p>
<p>对使用依赖注入的方式调用的逻辑做mocking时代码是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php">$fakeOrderService = \Mockery::mock(OrderService::class);
$fakeOrderService-&gt;shouldReceive(&#39;update&#39;)-&gt;once()-&gt;andReturn(true);
$this-&gt;app-&gt;instance(OrderService::class, $fakeOrderService);
</code></pre></td></tr></table>
</div>
</div><p>而当使用Facade时，只需一行代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php">OrderFacade::shouldReceive(&#39;udpate&#39;)-&gt;once()-&gt;andReturn(true);
</code></pre></td></tr></table>
</div>
</div><h2 id="使用appmodelclass而不是new-model">使用app(Model::class)而不是new Model()</h2>
<p>在Laravel/Lumen中，当代码中需要获取一个对象Model的实例时，通过容器实现会比直接new对单元测试更友好。因为借助容器，可以方便地mock这个Model。</p>]]></description></item><item><title>PHP单元测试的技巧</title><link>http://0x3f.org/post/phpunit-tips/</link><pubDate>Tue, 13 Aug 2019 14:21:48 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/phpunit-tips/</guid><description><![CDATA[<p>以下是我平时写单元测试时总结的一些最佳实践，有些是和具体的框架强相关的。</p>
<h2 id="利用model-factory生成测试数据">利用Model Factory生成测试数据</h2>
<p>Laravel/Lumen的Model Factory是个很好的工具。</p>
<p>事先定义好主要对象的Model Factory，可以在写单元测试的代码时方便地生成临时数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php">// 在数据库中创建一条发票的数据，并返回其Model的实例
$invoice = factory(\App\Models\Invoice::class)-&gt;create();
</code></pre></td></tr></table>
</div>
</div><p>此外，借助<a href="https://github.com/fzaninotto/Faker" target="_blank" rel="noopener noreffer">Faker</a>，可以为Model Factory定义仿真数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php">$factory-&gt;define(\App\Models\Invoice::class, function () {
    $faker = Faker\Factory::create(&#39;zh_CN&#39;);
    $enFaker = Faker\Factory::create(&#39;en_US&#39;);

    return [
        &#39;user_id&#39;                      =&gt; 1,
        &#39;amount&#39;                       =&gt; 100,
        &#39;title&#39;                        =&gt; $faker-&gt;company,
        &#39;taxpayer_id&#39;                  =&gt; $faker-&gt;randomNumber(),
        &#39;bank&#39;                         =&gt; $faker-&gt;bank,
        &#39;account&#39;                      =&gt; $enFaker-&gt;bankAccountNumber,
        &#39;company_registration_address&#39; =&gt; $faker-&gt;address,
        &#39;company_registration_phone&#39;   =&gt; $faker-&gt;phoneNumber,
        &#39;consignee_name&#39;               =&gt; $faker-&gt;name,
        &#39;consignee_province&#39;           =&gt; $faker-&gt;state,
        &#39;consignee_city&#39;               =&gt; $faker-&gt;city,
        &#39;consignee_district&#39;           =&gt; $faker-&gt;citySuffix,
        &#39;consignee_address&#39;            =&gt; $faker-&gt;address,
        &#39;consignee_phone&#39;              =&gt; $faker-&gt;phoneNumber,
        &#39;zip_code&#39;                     =&gt; $faker-&gt;postcode,
        &#39;remark&#39;                       =&gt; $faker-&gt;text,
        &#39;status&#39;                       =&gt; 1,
    ];
});
</code></pre></td></tr></table>
</div>
</div><h2 id="只伪造被测单元所需的数据">只伪造被测单元所需的数据</h2>
<p>单元测试只关注被测单元本身，并不关注整体功能，所以无须保证测试数据的完整性。换言之，如果被测单元只用到了订单主表数据，就没必要创建一个包含子单、SPU/SKU、支付记录等在内的完整订单。</p>
<h2 id="利用dataprovider简化测试代码">利用dataProvider简化测试代码</h2>
<p>当多个测试用例逻辑相似时，可以把它们抽象成一个测试方法，并用dataProvider提供每个用例的数据和断言。从而使测试代码变得更为简洁、易懂和便于维护。</p>
<h2 id="单独测试被测单元的校验逻辑">单独测试被测单元的校验逻辑</h2>
<p>通常我们会用标准的IO模型实现一个方法，同时对包含校验不合法在内的异常情况抛出相应异常。</p>
<p>PHPUnit提供了expectException()系列方法用于断言异常的抛出。但由于代码抛出了异常、程序被中断，故无法在一次测试中对多个异常做断言。</p>
<p>因此，可以把对一个方法校验逻辑的测试单独抽象出一个测试方法，并用dataProvider提供测试数据和断言。</p>
<h2 id="利用工具查看代码覆盖率">利用工具查看代码覆盖率</h2>
<p>PHPUnit提供参数<code>--coverage-html</code>生成覆盖率分析结果的HTML页面，但在IDE或编辑器里相对实时地查看结果会更方便。</p>
<p>主流IDE或编辑器一般都集成了这个功能或提供了相关插件，如<a href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters" target="_blank" rel="noopener noreffer">Coverage Gutters</a>。</p>]]></description></item></channel></rss>