<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程 on 晴耕雨讀</title><link>http://0x3f.org/tags/%E7%BC%96%E7%A8%8B/</link><description>Recent content in 编程 on 晴耕雨讀</description><generator>Hugo</generator><language>zh-cn</language><copyright>© 淘气 2022</copyright><lastBuildDate>Sun, 25 Sep 2022 22:33:13 +0800</lastBuildDate><atom:link href="http://0x3f.org/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Leaderf-phpnamespace: Yet another PHP namespace resolver</title><link>http://0x3f.org/posts/leaderf-phpnamespace-yet-another-php-namespace-resolver/</link><pubDate>Sun, 25 Sep 2022 22:33:13 +0800</pubDate><guid>http://0x3f.org/posts/leaderf-phpnamespace-yet-another-php-namespace-resolver/</guid><description>This plugin uses the power of LeaderF to perform PHP namespace related tasks.
https://github.com/xbot/Leaderf-phpnamespace
Features Insert use statements for FQCNs. Sort use statements alphabetically. Expand class names to FQCNs. Insert namespace for the current file. All the above features support the fuzzy searching function and all the three modes (nameonly, fullpath and regex) provided by LeaderF. Requirements LeaderF ctags is properly configured in Vim/Neovim. Install Use any of your favourite plugin manager to install it, for example:</description></item><item><title>Leaderf-folder: Quickly open a subfolder</title><link>http://0x3f.org/posts/the-leaderf-folder-plugin/</link><pubDate>Sun, 07 Aug 2022 17:31:50 +0800</pubDate><guid>http://0x3f.org/posts/the-leaderf-folder-plugin/</guid><description>LeaderF-folder is a plugin for LeaderF that aims to open a subfolder quickly.
Requirements LeaderF fd Dirbuf: Optional, can be changed to other file managers. Setup This plugin takes Dirbuf as the default solution to open the chosen subfolder. You can use the following option to customize it:
1 let g:Lf_FolderAcceptSelectionCmd = &amp;#39;Dirbuf&amp;#39; Usage 1 :LeaderfFolder Press F1 to get more help</description></item><item><title>Laravel Horizon 简介</title><link>http://0x3f.org/posts/an-introduction-of-laravel-horizon/</link><pubDate>Sat, 06 Aug 2022 20:22:36 +0800</pubDate><guid>http://0x3f.org/posts/an-introduction-of-laravel-horizon/</guid><description>简介 Horizon 针对 Laravel 的 Redis 队列，增加了可视化、进程池等特性。
特性 可视化仪表板 Worker 进程池的维护和调度 词汇表 master supervisor: 主进程，通过 proc_open() 启动 supervisor 子进程。 environments: 可以按 APP_ENV 针对不同环境创建多套配置。 supervisors: Horizon 自己的进程池概念，与托管后台进程的软件 Supervisor 没有关系。 workers: 队列消费者进程，每个 supervisor 中包含多个 worker。 负载均衡策略 false 一个 supervisor 下的所有 worker 全部用于按队列名称的顺序逐个队列消费任务。
simple 一个 supervisor 下的所有 worker 被平均分配给每个队列。
auto 一个 supervisor 下空闲的 worker 会被优先分配给负载最高的队列。同时保证空闲队列有配置项 minProcesses 数量的 worker 待命。
超时提醒 如果一个队列执行任务的时间超过预先配置的时间限制，horizon 将终止该任务并可以通过短信、邮件或 Slack 发送通知。
Horizon 每分钟查询一次执行任务的时间超过配置值的队列：
每 5 分钟发送一次通知：
吞吐量和平均耗时统计 需要通过定时任务周期性执行 artisan horizon:snapshot 命令生成统计数据并存储到 Redis 中。</description></item><item><title>解决 PHPUnit 生成代码覆盖报告时抛出重复定义类的错误的办法</title><link>http://0x3f.org/posts/the-solution-of-class-redeclaration-error-raised-while-generating-php-code-coverage-report/</link><pubDate>Thu, 23 Jun 2022 14:42:34 +0800</pubDate><guid>http://0x3f.org/posts/the-solution-of-class-redeclaration-error-raised-while-generating-php-code-coverage-report/</guid><description>在生成 Cobertura 格式的代码覆盖报告时程序报了如下错误：
Generating code coverage report in Cobertura XML format &amp;hellip; PHP Fatal error: Cannot declare class App\FakeNamespace\GenericProvider, because the name is already in use in /builds/fake_project/app/FakeNamespace/GenericProvider.php on line 17
对应的代码和单元测试执行均无问题。
经排查，直接原因是使用了 Mockery 的 Instance Mocking 1特性 mock 代码中的硬依赖关系（Hard Dependency）。
该特性的实现利用了类的自动加载机制和依赖注入技术。对依赖关系 mock 的实例保存在 Mockery 的容器中，同时生成一个 stub 文件：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &amp;lt;?php namespace Mockery; class Mockery_App_FakeNamespace_GenericProvider { private Container $container; function doSomething($param) { // internal code check expectations return $this-&amp;gt;container-&amp;gt;get(&amp;#39;App\FakeNamespace\GenericProvider::doSomething&amp;#39;)-&amp;gt;expectations(); } } 当代码中实例化这个类的时候，Mockery 自动加载该文件，从而代替了对原类文件的加载。</description></item><item><title>使用 lemonade 和 autossh 辅助 Neovim 远程开发</title><link>http://0x3f.org/posts/assisting-neovim-with-remote-development-using-lemonade-and-autossh/</link><pubDate>Thu, 19 May 2022 16:02:34 +0800</pubDate><guid>http://0x3f.org/posts/assisting-neovim-with-remote-development-using-lemonade-and-autossh/</guid><description>我的开发环境部署在 Linux VM 里，普通的远程复制用 vim-oscyank 插件是可以实现的。但是当我想用 fugitive 的 :GBrowse 命令打开 Gitlab 链接的时候遇到了困难，甚至我想退而求其次、通过 :GBrowse! 复制链接都不可得，因为 fugitive 的代码里通过 has('clipboard') 判断 Vim 是否可以使用系统剪贴板，且我的 Linux VM 不满足该特性的条件（见 :help clipboard）。所以用 lemonade 解决这个问题。
实现方式 lemonade 虽然支持客户端和服务端直接通信，但是并不提供安全保障，所以我采取 SSH 端口远程转发的方式并用 autossh 保持连接。
首先分别在服务端（MacOS）和客户端（Linux VM）创建 lemonade 的配置文件（~/.config/lemonade.toml）：
服务端：
1 2 3 port = 2489 allow = &amp;#39;127.0.0.1&amp;#39; line-ending = &amp;#39;lf&amp;#39; 客户端：
1 2 3 4 5 port = 2489 host = &amp;#39;localhost&amp;#39; trans-loopback = true trans-localfile = true line-ending = &amp;#39;lf&amp;#39; 然后创建 MacOS 的服务配置文件：</description></item><item><title>Hammerspoon 快速入门</title><link>http://0x3f.org/posts/hammerspoon-quick-start/</link><pubDate>Mon, 13 Dec 2021 00:38:06 +0800</pubDate><guid>http://0x3f.org/posts/hammerspoon-quick-start/</guid><description>Hammerspoon（以下简称 HS）是个很好用的效率工具脚手架，我一直用它实现 APP 启动器、窗口控制、桌面常亮等功能。
HS 可以通过写脚本可以实现很多个性化的需求。最快的上手方式是直接安装别人写好的脚本，然后根据自己的需要稍加修改即可。如果需要深度定制，可以自行实现新的模块。
HS 使用 Lua 语言。我在 08 年左右用过一年的 SciTE 编辑器，它也通过内嵌的 Lua 配置和扩展功能，所以学了这个语言。当时 NGINX 也才刚起步， Lua 主要还是被用在游戏脚本的开发，并没有现在使用得如此广泛。当时对这个语言的印象是两个极端，一是速度非常快，远远超过 PHP 和 Python ，比 C 也只慢一点点；二是开发库非常简陋，其它脚本语言一行就能实现的常见功能，它往往要从头开始写。
总之 Lua 是个很精简的语言，可以通过 Y 分钟速成 X 的教程快速熟悉它的语法，然后浏览一遍官方入门指南。HS 提供了很多方便的模块，通过 API 文档查看。
由于经常需要切换键盘映射方案，所以我写了一个简单的模块来实现这个功能：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local hotkey = require &amp;#34;hs.</description></item><item><title>PHPUnit 9.x 性能分析的方法</title><link>http://0x3f.org/posts/method-for-phpunit-9.x-performance-analysis/</link><pubDate>Tue, 17 Aug 2021 14:48:12 +0800</pubDate><guid>http://0x3f.org/posts/method-for-phpunit-9.x-performance-analysis/</guid><description>利用 PHPUnit 9.x 的 extension 特性，可以记录每个测试用例的耗时并存储到 CSV 文件中。
Extension 代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 &amp;lt;?php declare(strict_types=1); namespace Tests; use PHPUnit\Runner\AfterTestHook; class LongRunningTestsLogger implements AfterTestHook { public function __construct(private string $log_file) { } public function executeAfterTest(string $test, float $time): void { $fp = fopen($this-&amp;gt;log_file . &amp;#39;.csv&amp;#39;, &amp;#39;a&amp;#39;); fputcsv($fp, [$test, $time]); fclose($fp); } } phpunit.xml 的配置：</description></item><item><title>MySQL 事务的一致性、隔离级别与幻读问题</title><link>http://0x3f.org/posts/isolation-levels-and-phantom-reads-in-mysql/</link><pubDate>Tue, 21 Jul 2020 16:25:09 +0800</pubDate><guid>http://0x3f.org/posts/isolation-levels-and-phantom-reads-in-mysql/</guid><description>数据库事务的一致性 数据库事务有四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），简称“ACID”。
其中，“一致性”指的是数据库层面的一致性，与应用层面的一致性不同。
数据库层面的一致性是说，事务具备把数据库从一个正确的状态迁移到另一个正确的状态的特性。所谓正确的状态，是指任何写入数据库的数据都满足数据库既定的规则，这些规则包括各种约束、级联回滚、触发器以及任何它们的组合。
与数据库层面的一致性不同，应用层面的一致性要求保证结果的正确性。例如，当执行如下 SQL 语句时：
1 update accounts set balance = balance + 1 where id = 3 我希望最终的结果是在事务开始时 id = 3 的这行数据 balance 列的值的基础上加一，否则，结果就是不正确的。
因此，只要写入的数据满足数据库的规则，就保证了数据库层面的一致性。数据库层面的一致性并不保证数据正确1。
MySQL 事务的隔离级别与幻读问题 隔离级别 隔离性是指：多个事务并发执行时，每个事务对数据库所做的更改必须与其它事务隔离。
隔离性是并发控制的主要目标2，并发控制用来实现在保证应用层面一致性的前提下，尽可能快地对并发请求做出响应。由此可见，隔离性和并发能力是一对此消彼长的关系。极端情况下，如果并发的请求按顺序执行，隔离性是最好的，但是响应最慢，反之亦然。
在此基础上，产生了四个隔离级别的划分。由低到高依次为：读未提交、读已提交、可重复读、序列化。据前所述，它们的并发能力是依次下降的。
因此，隔离级别的本质是通过适度地破坏隔离性来提高并发能力。
隔离级别的问题 隔离级别不同，存在的问题也不一样。
“读未提交”的级别最低、并发能力最高，存在的问题也最多，包括：脏读、不可重复读、幻读。其中，脏读是这个级别独有的，即事务 A 读取了并发事务 B 未提交的数据。
“读已提交”顾名思义，事务 A 不会读取并发事务 B 未提交的数据，但可以读取其已提交的。因此，这个级别存在不可重复读和幻读的问题。
在“可重复读”级别下，同一事务中两次同样的查询结果一致，不会受并发事务的影响，它因此也解决了不可重复读的问题。但还会存在幻读问题。
“序列化”级别要求对查询的对象加范围锁并保持到事务结束，因此，它避免了幻读的问题。
幻读问题（Phantom Reads） 幻读问题是个很 tricky 的问题，以至于网上找到的很多文章对它的理解都是不全面甚至是错误的。
幻读即同一事务中两次相同查询的结果集不一致。乍一看，好像和不可重复读是一样的。那它们的区别是什么呢？
事实上，幻读是不可重复读的一种特殊情况。换句话说，只要存在幻行（Phantom Rows），就是幻读问题。
所谓幻行，即同一事务中两次相同的查询结果集的非空差集里的元素，或者说第二次查询后发现不存在于前一次结果集中的行。
幻行产生的原因主要是除“序列化”之外的隔离级别不要求对查询结果加范围锁，导致并发事务在查询范围内插入新的行后被当前事务查到。
MVCC 在此基础上，MySQL 的 InnoDB 引擎实现了“多版本并发控制”（MVCC: Multiversion Concurrency Control）。
简单地说，InnoDB 的表存在两个隐藏列，用于记录每行数据的版本信息。当插入一行数据时，InnoDB 将当前事务的版本信息一并写入。当修改一行数据时，InnoDB 先将该行做一次复制，并把当前版本信息写入进去。查询时，只返回版本小于等于当前事务版本的数据。通过这样保证一个事务中查询到的是事务开始前已经存在的数据或当前事务写入的数据。其它事务写入的数据则不会被读取。</description></item><item><title>在 VS Code 中快速创建 PHPUnit 测试类的方法</title><link>http://0x3f.org/posts/quickly-create-phpunit-test-cases-with-vscode/</link><pubDate>Tue, 18 Feb 2020 22:49:45 +0000</pubDate><guid>http://0x3f.org/posts/quickly-create-phpunit-test-cases-with-vscode/</guid><description>&lt;p>通过单元测试解决问题或者调试代码，可以避开错综复杂的依赖关系、直击问题的核心，从而极大地节约时间、提高效率。&lt;/p>
&lt;p>但是，当创建测试类成为一个经常发生的操作时，每次都手动创建类、引入基类、添加测试方法就显得很烦琐。我需要这样一个解决方案，让我可以立即开始着手写测试代码。&lt;/p></description></item><item><title>关于Lumen的Facade不支持引用传递的看法</title><link>http://0x3f.org/posts/lumen-facade-doesnot-support-pass-by-reference-param/</link><pubDate>Tue, 04 Feb 2020 17:40:34 +0000</pubDate><guid>http://0x3f.org/posts/lumen-facade-doesnot-support-pass-by-reference-param/</guid><description>&lt;p>今天遇到一个奇怪的问题，一次调用带引用传递形参的方法后，该形参对应的变量值没有按预期改变。&lt;/p></description></item><item><title>用C4-PlantUML画软件架构图</title><link>http://0x3f.org/posts/design-software-architecture-with-c4-plantuml/</link><pubDate>Fri, 17 Jan 2020 17:29:24 +0000</pubDate><guid>http://0x3f.org/posts/design-software-architecture-with-c4-plantuml/</guid><description>&lt;p>&lt;a href="https://c4model.com">C4 Model&lt;/a>是一种简洁有序的架构模型，四个“C”分别表示“Context”、“Container”、“Component”和“Code”，是由上而下逐步细化的四个层级。&lt;/p></description></item><item><title>用 PlantUML 实现 ERD</title><link>http://0x3f.org/posts/plantuml-erd/</link><pubDate>Fri, 03 Jan 2020 17:01:41 +0000</pubDate><guid>http://0x3f.org/posts/plantuml-erd/</guid><description>&lt;p>很长一段时间，我们都在用 MySQLWorkbench 画 ER 图。但是这个东西有一些缺陷，导致体验很不好。&lt;/p>
&lt;p>首先它生成的文件是二进制的，做不了版本控制。这意味着在版本迭代的过程中做数据结构评审的体验很糟糕。其次，离线文件难以管理，不利于团队协作。第三，图形界面虽然简单，但并不等价于高效。用它画图的成本还是比较高的。&lt;/p>
&lt;p>PlantUML 是个基于文本、灵活且强大的 UML 画图工具，高度可定制，而且可以集成到多种开发工具中。主流的 IDE 、文本编辑器都可以集成 PlantUML ，以便用自己最熟悉的工具画图并实时预览。基于文本的特性使得版本控制和 Code Review 很容易实现。如果 VCS 用的是 Gitlab ，可以更进一步，借助 PlantUML Server 实现实时预览。即使对于像 Github 这种暂时没有提供支持的 Web 平台，也有变通的解决方案。&lt;/p></description></item><item><title>解决Laravel中makeWith()无法取到被mock的实例的问题</title><link>http://0x3f.org/posts/mocking-objects-made-by-laravel-container-with-parameters/</link><pubDate>Fri, 16 Aug 2019 10:55:40 +0000</pubDate><guid>http://0x3f.org/posts/mocking-objects-made-by-laravel-container-with-parameters/</guid><description>&lt;p>被测单元有一行实例化一个类的代码，而且该类的构造方法需要参数。基于面向单元测试编程的原则，通过容器的makeWith()方法实现：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-php" data-lang="php">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">$api&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">app&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="na">makeWith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">Api&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;config&amp;#39;&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="nv">$config&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但是在执行单元测试时发现，虽然测试代码中已经mock了这个类且注入到容器，但在被测单元中取到的还是原类的实例。&lt;/p></description></item><item><title>利用单元测试为开发提效</title><link>http://0x3f.org/posts/use-unit-test-as-an-efficiency-tool/</link><pubDate>Tue, 13 Aug 2019 16:38:02 +0000</pubDate><guid>http://0x3f.org/posts/use-unit-test-as-an-efficiency-tool/</guid><description>&lt;p>单元测试可以方便地伪造和回滚测试数据，这个特性决定了它其实是一个效率工具。&lt;/p>
&lt;p>例如在开发退款单、发票的时候，由于这种后置的功能依赖订单、支付、库存等前置的数据，因此需要频繁地创建这些测试数据，这就导致开发的效率极低，有时甚至需要切换多个系统做诸如增加库存、下单、支付等操作。虽然在开发环境可以通过直接修改数据使之恢复可被测试的状态，但仍然存在效率很低、遗留垃圾数据和存在隐患等问题。&lt;/p>
&lt;p>单元测试可以完美地解决这些问题。&lt;/p></description></item><item><title>面向单元测试编程</title><link>http://0x3f.org/posts/unit-test-oriented-programming/</link><pubDate>Tue, 13 Aug 2019 16:35:15 +0000</pubDate><guid>http://0x3f.org/posts/unit-test-oriented-programming/</guid><description>&lt;p>同一逻辑可以有多种实现方式，选择对单元测试友好的方式可以提高写测试代码的效率。&lt;/p></description></item><item><title>PHP单元测试的技巧</title><link>http://0x3f.org/posts/phpunit-tips/</link><pubDate>Tue, 13 Aug 2019 14:21:48 +0000</pubDate><guid>http://0x3f.org/posts/phpunit-tips/</guid><description>&lt;p>以下是我平时写单元测试时总结的一些最佳实践，有些是和具体的框架强相关的。&lt;/p></description></item><item><title>Lumen单元测试提示自定义校验规则不存在的问题</title><link>http://0x3f.org/posts/unit-test-in-laravel-complains-validation-rule-not-exist/</link><pubDate>Fri, 02 Aug 2019 15:12:17 +0000</pubDate><guid>http://0x3f.org/posts/unit-test-in-laravel-complains-validation-rule-not-exist/</guid><description>&lt;p>执行单元测试时遇到报错：&lt;/p>
&lt;pre tabindex="0">&lt;code>BadMethodCallException: Method [validateIdList] does not exist.
&lt;/code>&lt;/pre></description></item><item><title>对比Laravel Excel和Spout的读写性能</title><link>http://0x3f.org/posts/performance-comparation-for-laravel-excel-and-spout/</link><pubDate>Sun, 07 Jul 2019 20:23:26 +0000</pubDate><guid>http://0x3f.org/posts/performance-comparation-for-laravel-excel-and-spout/</guid><description>./artisan excel:write --driver=spout --amount=100000 写入数据100000行。 用时：156秒。 最大使用内存：2750.5106964111 M。 ./artisan excel:write --driver=laravel-excel --amount=100000 写入数据100000行。 用时：305秒。 最大使用内存：1330.7370758057 M。 ./artisan excel:read ./storage/app/test.xlsx --driver=spout 读取数据100001行。 用时：576秒。 最大使用内存：122.15303039551 M。 ./artisan excel:read ./storage/app/test.xlsx --driver=laravel-excel 读取数据100001行。 用时：166秒。 最大使用内存：739.48976898193 M。 基本上，Laravel Excel写XLSX的性能是Spout的一半，但内存占用是对方的一半。而在读文件上，前者的性能是后者的约3倍多，而内存占用是后者的6倍。
测试环境：
MBP 3.1 GHz Intel Core i5 8G内存 PHP 7.1.30 Laravel 5.8.27 Laravel Excel 3.1.14 Spout 3.0.1</description></item><item><title>基于Laravel的项目的单元测试规范</title><link>http://0x3f.org/posts/unit-testing-standard-for-laravel-based-projects/</link><pubDate>Sun, 24 Mar 2019 22:42:08 +0000</pubDate><guid>http://0x3f.org/posts/unit-testing-standard-for-laravel-based-projects/</guid><description>&lt;p>单元测试是个好东西，解决了我很多问题，不论开发效率还是代码质量，都给我助益良多。最近想在团队内部推广，就拟了个规范草稿：&lt;/p></description></item><item><title>生成PDF的方案调研</title><link>http://0x3f.org/posts/pdf-creating-solutions/</link><pubDate>Wed, 16 May 2018 15:41:36 +0000</pubDate><guid>http://0x3f.org/posts/pdf-creating-solutions/</guid><description>结论 倾向于通过wkhtmltopdf+消息队列实现。
工作流程：
用户保存表单 推送生成pdf的任务到队列 同时页面显示「正在生成PDF文档，请稍候」并轮询后端接口 PDF生成后，页面显示下载按钮 后端 dompdf 纯PHP实现。工作原理是把HTML转换成PDF。
优点：
不需要PHP调用命令行，安全性高。 缺点：
HTML/CSS支持不完全，实测多个网页转换后排版错乱。 中文网页转换后，中文都是问号（网上说有解决办法1、2，未测试）。 CPU占用比较高（网上的说法，没有实测具体有多高）。 参考：
laravel-dompdf主页 mpdf 纯PHP实现。工作原理是把HTML转换成PDF。
优点：
不需要PHP调用命令行，安全性高。 缺点（未实测）：
HTML/CSS支持不完整。 生成PDF耗时长。 参考：
laravel-pdf主页 mpdf文档 mpdf主页 mpdf与fpdf的使用比较 PDFtk Server PDFtk Server是个命令行程序。工作原理是利用FDF表单替换PDF模板中的占位符。实现方案有：纯PHP实现FDF + PDFtk、FPDI + PDFtk。
优点：
直接替换PDF模板，实现成本低，最大程度保证生成的PDF的效果。 缺点：
需要允许PHP调用命令行，有安全隐患。 只能实现简单的字符串替换（例如公司名称），不能替换有格式文本。 参考：
FPDI PHP的FDF手册 PDFtk的使用方法 纯PHP实现FDF + PDFtk wkhtmltopdf wkhtmltopdf是个命令行程序。工作原理是转换HTML到PDF。实现方案是laravel-snappy。
优点：
由于内嵌webkit核心，HTML/CSS的支持没有问题。 缺点：
需要允许PHP调用命令行，有安全隐患。 wkhtmltopdf体积40M，并发较多时影响服务器性能和稳定性（需要考虑用队列辅助实现，异步执行，需要需求变更交互方式）。 参考：
laravel-snappy主页 CutyCapt 命令行程序。工作原理和wkhtmtopdf相同。
优缺点同wkhtmltopdf，但是最近的更新在13年。
参考：
CutyCapt主页 Prince 命令行程序。工作原理是转换HTML到PDF。
优点：
HTML/CSS的支持很好。 文档很全 缺点：</description></item><item><title>对XSS的防御更适合放在前端</title><link>http://0x3f.org/posts/better-to-do-defenses-against-xss-in-front-end/</link><pubDate>Tue, 06 Feb 2018 15:13:17 +0000</pubDate><guid>http://0x3f.org/posts/better-to-do-defenses-against-xss-in-front-end/</guid><description>很多项目会把转义操作放在后端接口获取参数的地方，从而忽略了这样一个问题——为什么主流框架都不在获取参数的方法里实现这一点？
以Laravel为例，如果可以这样获取转义后的参数：$request-&amp;gt;escape('content')，代码会显得更优雅，而实际上只能用自己封装的函数手工转义：my_escape($request-&amp;gt;get('content'))，很丑陋的代码。
事实上，主流框架并非没有提供防御XSS的封装，只是都放在模板引擎里。这样做的依据是，XSS的原理是在原本用于展示的数据里包含了可执行的文本，但不是所有展示的位置都不应该包含可执行的文本。从另一角度上说，后端应该校验前端传递的数据，但不应该篡改它。</description></item><item><title>解决Laravel的Facade在被Mock时不自动注入依赖的一种方法</title><link>http://0x3f.org/posts/manual-dependency-injection-with-laravel/</link><pubDate>Tue, 30 Jan 2018 15:41:16 +0000</pubDate><guid>http://0x3f.org/posts/manual-dependency-injection-with-laravel/</guid><description>由于集成了Mockery，Laravel的Facade对单元测试非常友好，只需要一行代码就能实现mocking。
例如，测试目标方法中调用了订单工具类的一个方法，在使用依赖注入的方式时，需要用三行代码实现对这个方法的mocking：
1 2 3 $fakeOrderTool = m::mock(\App\Tool\Order::class); $fakeOrderTool-&amp;gt;shouldReceive(&amp;#39;getById&amp;#39;)-&amp;gt;once()-&amp;gt;with($id)-&amp;gt;andReturn($fakeOrder); $this-&amp;gt;app-&amp;gt;instance(\App\Tool\Order::class, $fakeOrderTool); 而用Facade是这样的：
1 OrderFacade::shouldReceive(&amp;#39;getById&amp;#39;)-&amp;gt;once()-&amp;gt;with($id)-&amp;gt;andReturn($fakeOrder); 当测试目标方法也属于订单工具类时，需要部分mock这个类，所以还要加上一行：
1 OrderFacade::makePartial(); 但如果订单工具类的构造方法里有需要注入的依赖关系，这里并不会被执行。所以我在工具类基类里封装了一个方法，用反射机制实现手工注入依赖关系：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * 注入依赖，用于单元测试 * * @return void * @author donieli * @since 5 * @version 5 */ public function injectDependencies() { $reflector = new \ReflectionClass(get_class($this)); $params = $reflector-&amp;gt;getConstructor()-&amp;gt;getParameters(); $args = []; foreach ($params as $param) { $paramClass = $param-&amp;gt;getClass(); if (empty($paramClass)) { throw new \Exception(&amp;#39;Dependency named &amp;#39;.</description></item><item><title>Laravel单元测试错误：1205 Lock wait timeout exceeded</title><link>http://0x3f.org/posts/1205-lock-wait-timeout-exceeded/</link><pubDate>Fri, 22 Dec 2017 15:47:32 +0000</pubDate><guid>http://0x3f.org/posts/1205-lock-wait-timeout-exceeded/</guid><description>错误信息：
1205 Lock wait timeout exceeded; try restarting transaction
原因之一是测试用例里重写的tearDown()方法中没有调用父类的该方法。因为DatabaseTransaction这个trait自动开启了事务，对应的回滚方法在测试用例基类的tearDown()中执行。</description></item><item><title>用Charles拦截iOS APP HTTPS请求</title><link>http://0x3f.org/posts/ios-app-intercepting-using-charles/</link><pubDate>Fri, 22 Dec 2017 15:17:04 +0000</pubDate><guid>http://0x3f.org/posts/ios-app-intercepting-using-charles/</guid><description>实践环境 Charles 4.2 iOS 11.2.1 安装证书 按照Charles菜单（Help -&amp;gt; SSL Proxying -&amp;gt; Install Charles Root Certificate on a Mobile Device or Remote Browser）的指示，设置iOS的系统代理。
为了以后使用方便，可以在代理工具（如ShadowRocket）里设置，注意使用时应配置代理工具对全部流量使用代理，如果使用PAC之类动态代理可能会拦截不到。
在iOS的Safari中访问上面提示中的网址，会弹出提示安装证书。iOS 10.3以后还要设置信任该证书（设置-&amp;gt;通用-&amp;gt;关于本机-&amp;gt;证书信任设置）。
配置Charles拦截HTTPS请求 路径为：Proxy -&amp;gt; SSL Proxying Settings
可以设置对特定的主机名和端口拦截，也可以直接保存，此时对所有请求均会拦截。
拦截 iOS中打开上述代理，APP中发送的请求就会在Charles里列出来。</description></item><item><title>测试驱动开发的实际收益</title><link>http://0x3f.org/posts/the-real-income-of-tdd/</link><pubDate>Sun, 17 Dec 2017 14:20:02 +0000</pubDate><guid>http://0x3f.org/posts/the-real-income-of-tdd/</guid><description>我并不试图系统地谈TDD，因为我在这方面的经验还不足以做到这一点。但是TDD的一些方法论和工具确实解决了我在实际开发过程中遇到的一些问题。
第一个问题是健壮性。尤其是对于我这样思维发散、容易迷失又喜欢重构的人，TDD给了我一个明确的目标，在一切刚开始的时候，我要做的只是满足测试用例，让它们由红变绿。到了重构阶段，我就可以把精力放到优化代码上面，且不必对健壮性有过多的担心。在此之前，由于手动测试比较麻烦，很多时候惰性会说服潜意识告诉自己这部分逻辑很简单、不会有什么bug，结果提交测试后却一再地发生问题。
第二个问题是效率。曾经只有不忙的时候才会写测试用例，但是现在一般都会写，因为确实可以提高开发效率，而不只是保证重构的健壮性。可能对于所有对单元测试不熟悉的人来说，这都是匪夷所思的，我也曾认为单元测试只是用来保证健壮性的，必然和开发效率是一对矛盾，因为要花很多时间写测试代码。这种想法首先是因为对单元测试不熟悉，所以才需要花很多时间在上面。其次是没有看到它所带来的好处。
例如你要实现一整套退款单的功能，退款单是依赖订单的，这意味著你需要不只一条符合条件的订单数据。但是订单是有状态的，随著时间的推移、人为的操作或者开发过程中程序的影响，状态会变得不再符合你的要求，这时候你就必须停下来去做更多符合要求的订单。而创建订单也存在很多麻烦，你需要找到有库存的商品，有时候还要去库管系统中补充库存，然后下单并支付。最后花了很多时间做出来的订单，因为正在开发的退款单的程序出现的一个小问题变得不能使用！时间被大量浪费在创建所依赖的上游数据上。
这时候如果用单元测试并mock出依赖关系，就可以随时随地、无限制地执行相关的业务逻辑。对效率的提高不言而喻。
特别的，mock并不是随时可以抓起的救命稻草，它的原罪在于：不负责任地滥用mock会导致很多问题被掩盖。因此，对mock的使用应该是节制的、目标明确的。
当然，这并不包括单纯地为了提高代码覆盖率而使用mock，只所以这是个在很多强制TDD的团队里的普遍现象，归根结底是因为KPI是万恶之源，任何好的方法论，一旦沦为KPI，就离死不远了。</description></item><item><title>用vim-test简化单元测试的编写</title><link>http://0x3f.org/posts/make-writing-unit-tests-easier-with-vim-test/</link><pubDate>Mon, 14 Aug 2017 16:43:59 +0000</pubDate><guid>http://0x3f.org/posts/make-writing-unit-tests-easier-with-vim-test/</guid><description>vim-test允许在Vim中直接执行一个或多个单元测试，并使用预设的或自定义的执行策略。
例如，命令:TestNearest可以执行当前测试文件中离光标最近的一个测试方法。而:TestFile、:TestSuite和:TestLast分别执行整个测试文件、测试项目和最近一次执行过的测试。这在编写测试代码时能很大地提高效率。
执行策略是执行测试的方式和环境。例如缺省状态下，将使用:!执行测试命令，这会从Vim切换回终端。而在MacVim下，可以选择在iTerm或者系统自带的Terminal中执行。</description></item><item><title>Mock Laravel的DB Facade的方法</title><link>http://0x3f.org/posts/how-to-mock-the-db-facade-of-laravel/</link><pubDate>Mon, 14 Aug 2017 15:51:41 +0000</pubDate><guid>http://0x3f.org/posts/how-to-mock-the-db-facade-of-laravel/</guid><description>关于数据库操作是否应该mock的问题，我认为查询一般不应该mock，可以避免一些问题，但如果查询的结果可能影响到断言，就应该mock了。
Laravel的DB facade完整的mock实例是这样的：</description></item><item><title>GraphQL：RESTful之外的接口实现方案</title><link>http://0x3f.org/posts/graphql-vs-restful/</link><pubDate>Tue, 01 Aug 2017 17:36:27 +0000</pubDate><guid>http://0x3f.org/posts/graphql-vs-restful/</guid><description>和RESTfull一样，GraphQL也是一种基于HTTP的接口实现方式。它区别于前者的主要有两点：数据格式的自定义和请求的合并。
本质上，GraphQL是为了解决RESTful中前后端在业务逻辑上的耦合关系。在RESTful中，接口是为前端具体的业务需求定制的，从实现什么样的功能，到返回哪些数据，都是既定的，所以很难被其它业务逻辑共用，即使可以共用，前端也必须发送多个请求到后端，因而造成资源浪费、效率下降。
GraphQL实现的是一套逻辑积木，每个封装好的业务逻辑都是原子的，前端可以自由选择使用哪些，也可以定制返回数据的格式。并且这一切，都可以通过一次请求实现。
当然，GraphQL也有一些短板。比如缓存，对于RESTfull接口，可以根据操作的幂等性实现负载均衡层面的缓存，而对于GraphQL，由于请求数据格式灵活且可能很大，请求会用POST方式发送，这样就必须改变缓存的实现方式。再一点是嵌套的层级问题，GraphQL的灵活性允许查询类型之间彼此嵌套，如果层级过多，可能导致严重的性能和可用性问题，因此需要注意限制嵌套的层级。还有就是GraphQL的实现复杂度比RESTful要高，需要权衡使用哪种实现方案。
GraphQL用schema管理接口，可以根据业务等因素划分schema，例如需要权限验证的和公开的。每个schema包含两类接口：query和mutation，分别用来查询和变更数据。
下面在Laravel中简单实现一个query接口。
先安装folklore/graphql库。
实现文章类型：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 namespace App\GraphQL\Type; use GraphQL\Type\Definition\Type; use Folklore\GraphQL\Support\Type as GraphQLType; class PostType extends GraphQLType { public function fields() { return [ &amp;#39;id&amp;#39; =&amp;gt; [ &amp;#39;type&amp;#39; =&amp;gt; Type::nonNull(Type::string()), &amp;#39;description&amp;#39; =&amp;gt; &amp;#39;The id of the post&amp;#39; ], &amp;#39;title&amp;#39; =&amp;gt; [ &amp;#39;type&amp;#39; =&amp;gt; Type::string(), &amp;#39;description&amp;#39; =&amp;gt; &amp;#39;Post title&amp;#39; ] ]; } protected function resolveTitleField($root, $args) { return $root-&amp;gt;post_title; } } 实现文章的查询逻辑：</description></item><item><title>怎样测试PHP的Private或Protected方法</title><link>http://0x3f.org/posts/how-to-test-private-or-protected-methods-in-php/</link><pubDate>Mon, 03 Jul 2017 13:17:30 +0000</pubDate><guid>http://0x3f.org/posts/how-to-test-private-or-protected-methods-in-php/</guid><description>利用闭包绑定：
1 2 3 4 5 6 7 $ctrlr = new UserController; $tester = function () use ($uid) { $this-&amp;gt;getUser($uid); }; $runner = $tester-&amp;gt;bindTo($ctrlr, $ctrlr); $runner();</description></item><item><title>用MySQL的全文检索实现相关性排序</title><link>http://0x3f.org/posts/fulltext-searching-in-mysql/</link><pubDate>Mon, 19 Jun 2017 23:10:41 +0000</pubDate><guid>http://0x3f.org/posts/fulltext-searching-in-mysql/</guid><description>实现根据文章的关键词搜索出相关的文章，并按相关性排序。
数据库版本是5.6.x，还不能像5.7那样支持中文的全文检索，所以另外创建一列保存关键词的编码。方法为base64转码并去掉「%」符号：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &amp;lt;?php /** * 转换关键词到全文检索的格式 * * @param mixed $keywords 关键词数组或英文逗号分隔的字符串 * @return string */ function encode_keywords($keywords) { $encoder = function ($keyword) { return str_replace(&amp;#39;%&amp;#39;, &amp;#39;&amp;#39;, urlencode(trim($keyword))); }; if (!is_array($keywords)) { $keywords = explode(&amp;#39;,&amp;#39;, $keywords); } return implode(&amp;#39; &amp;#39;, array_map($encoder, $keywords)); } 对该列创建全文检索的索引：
1 CREATE FULLTEXT INDEX idx_post_keywords ON posts (keywords_ft); 查询语句：</description></item><item><title>通过比较截图检查网页变化</title><link>http://0x3f.org/posts/check-changes-of-webpage-by-comparing-screenshots/</link><pubDate>Sun, 30 Apr 2017 17:21:52 +0000</pubDate><guid>http://0x3f.org/posts/check-changes-of-webpage-by-comparing-screenshots/</guid><description>有时候我们希望检查代码或数据的更新对网页产生的影响，如果能把这个过程集成到git等版本控制系统中，在提交成果的同时自动批量执行，将会极大地提高生产力。
首先网页的截图可以用PhantomJS、Headless Chrome实现：
1 2 3 4 5 var page = require(&amp;#39;webpage&amp;#39;).create(); page.open(&amp;#39;http://github.com/&amp;#39;, function() { page.render(&amp;#39;github.png&amp;#39;); phantom.exit(); }); 图片的差异比较用GraphicsMagick实现：
1 gm compare old.png new.png -file diff.png -highlight-style assign 为方便查看，还可以把截图做成gif动图：
1 gm convert -delay 20 old.png diff.png new.png diff.gif</description></item><item><title>PHPUnit代码覆盖率的统计方法</title><link>http://0x3f.org/posts/how-to-count-code-coverage-of-phpunit/</link><pubDate>Sun, 30 Apr 2017 14:20:41 +0000</pubDate><guid>http://0x3f.org/posts/how-to-count-code-coverage-of-phpunit/</guid><description>关于PHPUnit代码覆盖率的很多概念，官方文档中讲的十分清楚，本文仅就部分语焉不详的细节做些补充。
虽然phpunit.xml不是必需，但每次都输入完整的命令很不方便，所以一般都要生成这个配置文件。用phpunit --generate-configuration生成的phpunit.xml默认包含forceCoversAnnotation=&amp;quot;true&amp;quot;，它表示必须在测试方法头部的注释里显式使用@covers标签声明统计范围，例如：
1 2 3 4 5 6 7 8 9 10 /** * @covers Ox3f\LaravelUtils\Log\Log::&amp;lt;public&amp;gt; * @covers Ox3f\LaravelUtils\Log\Log::parseCallStack * @covers Ox3f\LaravelUtils\Log\Log::__construct * @covers Ox3f\LaravelUtils\Log\Log::__callStatic */ public function testAll() { // ... } 否则在执行统计代码覆盖率的命令时，会报risk：
There was 1 risky test:
Ox3f\LaravelUtils\Log\LogTest::testAll This test does not have a @covers annotation but is expected to have one 如果希望单元测试覆盖全部代码、且不用一一显式声明，可以将此选项的值改成 false。
之后即可使用明令phpunit —coverage-html ./report统计代码覆盖率，统计结果保存在report目录中。
参考 官方文档：第11章-代码覆盖率分析</description></item><item><title>利用依赖注入Mock PHP的内建函数</title><link>http://0x3f.org/posts/mock-php-built-in-functions-using-dependency-injection/</link><pubDate>Sun, 30 Apr 2017 09:57:50 +0000</pubDate><guid>http://0x3f.org/posts/mock-php-built-in-functions-using-dependency-injection/</guid><description>简述 上篇文章讨论了如何利用命名空间实现对PHP内建函数的mocking，本文介绍另一种实现方法——依赖注入。
出于编写可测试代码的需要，依赖注入是经常使用的一种技术。通过把代码中依赖的其它数据获取服务提取出来、和原有逻辑解耦，提高代码的可测试性。只需mock这些依赖并注入到测试对象中即可。
实现 对原有代码的重构 先把原有代码用依赖注入的方式重构（为突出重点，省略了和上篇文章中重复的部分）：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // ... use Ox3f\LaravelUtils\Services\Builtins; /** * Class Log * @author donie */ class Log { // ... private $builtins; // Builtin functions private function __construct() { $this-&amp;gt;builtins = new Builtins(); // .</description></item><item><title>利用命名空间Mock PHP的内建函数</title><link>http://0x3f.org/posts/mock-php-built-in-functions-using-namespace/</link><pubDate>Sun, 30 Apr 2017 09:06:17 +0000</pubDate><guid>http://0x3f.org/posts/mock-php-built-in-functions-using-namespace/</guid><description>简述 Mock PHP的内建函数一般有两种方法：命名空间法和依赖注入法。
命名空间法是利用PHP优先使用同命名空间内函数的特性，在测试对象的命名空间内重载内建函数来实现。前提是内建函数在被调用时没有使用命名空间，例如：\debug_backtrace()是不能使用本方法的。
上篇文章《接口编程中记录日志的最佳实践》中实现的日志类中，核心部分调用了debug_backtrace()函数获取方法调用堆栈。下面讨论下如何利用命名空间法实现对此函数的mock。
实现 先看代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 &amp;lt;?</description></item><item><title>接口编程中记录日志的最佳实践</title><link>http://0x3f.org/posts/the-best-practice-of-logging-in-api-programming/</link><pubDate>Tue, 25 Apr 2017 15:50:41 +0000</pubDate><guid>http://0x3f.org/posts/the-best-practice-of-logging-in-api-programming/</guid><description>解决什么问题 快速定位日志 降低记录成本 提高代码可读性 日志框架是项目开始阶段应该最先搭建好的内容之一，有助于极大地节约以后解决问题的时间和成本。但这也是最让我头疼的问题之一，因为记日志不光包括用什么记、怎么记，也包括记什么内容，这恰恰是最容易被忽略的问题。
一条好的日志需要做到能让问题的跟踪者快速定位它在程序中的位置且包含关键数据。工作中不乏这样的团队成员，在移交接口问题的时候没有主动提供关键信息的意识，所谓关键信息，是指像问题发生的环境、接口名、传递的实参和返回结果这样的内容，使得面向契约编程本来是很好的开发模式，却得不到最好的应用。这时我们可以从自己接口的日志中得到一些弥补。
但是日志的记录不应该占用很大的代码量，一来降低了代码的可读性，二来会耗费太多的时间精力。
本文目的在于讨论一种日志记录的最佳实践方式，使得可以兼顾以上这些问题。
实践 这里针对Laravel实现一个日志工具类，实现以下功能：
兼容Laravel自己的日志系统 自动记录关键的业务数据 自动记录日志所属的接口名 自动记录接口的实参 记录接口的返回值 生成简洁规范的日志内容 代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 &amp;lt;?</description></item><item><title>Cross-site Request Forgery简介</title><link>http://0x3f.org/posts/introduction-of-cross-site-request-forgery/</link><pubDate>Sun, 23 Apr 2017 20:55:58 +0000</pubDate><guid>http://0x3f.org/posts/introduction-of-cross-site-request-forgery/</guid><description>什么是CSRF Cross-site Request Forgery（简称CSRF），意思是跨站请求伪造。原理是利用网站服务器对浏览器的信任，通过一些技术手段欺骗用户的浏览器访问自己曾经认证过的网站，并执行一些危害用户利益的操作。
例如，假设网站的会话信息保存在cookie中，提现的请求是GET http://www.sample.com/withdraw?toCard=123456&amp;amp;amount=10000，攻击者在自己的网页中通过img标签、iframe或者AJAX访问这个链接，并诱使用户访问这个网页，如果用户刚刚登录过sample.com，余额就会被转走。
防止CSRF的方法 CSRF的关键在于用户的鉴权信息保存在cookie中，或攻击者可以拿到它。目前防止CSRF攻击的方法主要有两种：JWT和表单校验token。
JWT的token通过HTTP请求的header传递，且由于浏览器的跨站限制，钓鱼网页中的JS无法拿到token，从而达到防止CSRF的目的。关于JWT更详细的介绍在「JSON Web Token简介」。
表单校验token通常是存储在表单的隐藏字段中的一个随机字符串，服务器端通过比对表单提交的token判断请求是否伪造，此时需要注意服务器端的CORS配置，即便在有需要的情况下开放了，也应该严格限制允许的HTTP方法和域，否则，钓鱼网页的JS就可以拿到这个token，从而实现CSRF。</description></item><item><title>JSON Web Token简介</title><link>http://0x3f.org/posts/introduction-of-json-web-token/</link><pubDate>Sun, 23 Apr 2017 18:29:06 +0000</pubDate><guid>http://0x3f.org/posts/introduction-of-json-web-token/</guid><description>什么是JWT？ JSON Web Token（简称JWT）是一种token格式，通常用来解决身份认证的问题，和会话（session）作用相同，常用在RESTful API或者OAuth认证上。
和session相比，JWT有以下优势：
服务器端的开销低 服务器端扩展方便 不用专门处理CSRF 由于session的实现方式需要在服务器端存储会话数据，所以当存在大量会话时，服务器端的存储压力会很大，并由此带来扩展上的复杂度（共享session）。而JWT可以把这些数据存储在token里，不需要服务器端存储，优势自然很明显。
对于CSRF，由于session一般使用cookie实现，所以需要专门处理这个安全隐患。JWT借助HTTP请求的header传递，所以伪造成本更高。
JWT和Bearer Token的关系 JWT在使用的时候要在token前面加上字符串「bearer」再填到HTTP请求的header里，这个值就是「Bearer Token」。为什么要这么做？它和JWT是什么关系？
简单地说，JWT是一种token格式，Bearer Token是一种鉴权方案。
HTTP的header项「Authorization」是在HTTP 1.0引入的，它的值的格式是类型+token，支持多种鉴权方案，bearer只是其中的一种。bearer方案中使用的token是JWT格式，这就是它们之间的关系。
JWT的格式 JWT是一个用英文点号连接起来的、分成三个部分的字符串：header、payload和signature。
header header是个base64字符串，解密后是个JSON对象，包含一些元数据。例如：
1 2 3 4 { &amp;#39;typ&amp;#39;: &amp;#39;JWT&amp;#39;, &amp;#39;alg&amp;#39;: &amp;#39;HS256&amp;#39; } 「typ」是格式，「alg」是加密方法。
payload payload也是个base64字符串，解密后也是个JSON对象，一般包含两种数据：JWT标准数据和自定义数据。
JWT标准数据常见的有：
iss：提供方。 sub：主题，一般是用户ID。 exp：过期时间。 iat：创建时间。 jti：token的唯一标识。 此外，和session一样，可以把一些自定义的数据存储在payload里。但由于token存储在客户端，所以不应该在这里存储敏感数据。
signature signature也是个base64字符串，解密后是个使用header里描述的加密方法针对header和payload加密的字符串。目的是防止这两部分的数据被篡改。
JWT的使用原则 不存放敏感信息 保护好私钥 结合https使用 都是出于安全角度考虑。token存储在客户端，而且base64可以被解密，所以不能存储敏感数据。如果私钥泄漏，意味著签名可以被随意伪造。使用https可以更好的保护数据，防止中间人攻击。
JWT相关开发资源 jwt.io有各种语言的JWT开发资源。</description></item><item><title>设计RESTful API的几个原则</title><link>http://0x3f.org/posts/some-principles-on-designing-restful-api/</link><pubDate>Fri, 21 Apr 2017 10:07:29 +0000</pubDate><guid>http://0x3f.org/posts/some-principles-on-designing-restful-api/</guid><description>REST不是一项技术，而是一种设计风格。它的核心思想是实现一种清晰明确的语义，用来描述Web操作。包含两个主要因素：HTTP动词和资源地址。
HTTP动词的使用原则 参与Web操作的HTTP动词主要有GET、POST、DELETE、PUT、HEAD、PATCH。实际上，几乎所有的操作只需GET和POST就可以实现，为什么还要有其它几种呢？目的就是为了实现清晰明确的语义：DELETE /api/v1/post/18肯定比GET /api/v1/post?id=18&amp;amp;action=delete更清楚。
因此HTTP动词使用的重点在于明确语义。例如更新操作，很多文章会说创建资源用POST、修改用PUT，实际上是对REST风格理解不透彻。
总体上，HTTP动词分为两类：幂等和非幂等。幂等是个数学概念，对于一元操作，如果它作用于任一元素两次以上后所得的结果和第一次相同，就认为它是幂等的。简单地说，如果一个接口，传递同样的实参，多次请求的结果和一次没有不同，就认为它是安全的、幂等的，反之，就是不安全、非幂等的。
GET、DELETE、PUT、HEAD是幂等操作，POST和PATCH是非幂等操作。因此，修改操作用POST还是PUT，要看操作本身的幂等与否。举个例子，对于修改用户描述的接口，调用任意次得到的结果都是相同的，所以它是幂等的，应该用PUT。而对于修改用户登录积分的操作，假设每次登录加十分，重复调用会导致分数重复增加，这就是不安全、非幂等的，应该用POST。
资源地址的命名原则 资源地址是对被操作资源位置的描述，因此应该有以下几个原则：
全部使用名词 不使用驼峰风格 资源名称统一使用复数 对于前两个，因为对资源的操作已由HTTP动词表述，资源地址里不应该存在动词，否则会造成语义的混乱。此外，不存在动词也就不需要使用驼峰风格。例如，GET /api/v1/getUser/89，「get」在语义上就重复了。
关于资源名称用复数的原则，主要是为了API在风格上的统一，同一种资源用同一个单词表示，单、复数用资源的id表示，URI里有id的就是单数，否则是复数。
结论 REST是风格而不是技术，出bug的可能性不大，并不是能实现业务逻辑、没有bug就是好代码。风格错了，连REST都不算。</description></item><item><title>Postman的Pre-request Script和Tests</title><link>http://0x3f.org/posts/pre-request-script-and-tests-in-postman/</link><pubDate>Wed, 19 Apr 2017 17:05:55 +0000</pubDate><guid>http://0x3f.org/posts/pre-request-script-and-tests-in-postman/</guid><description>Pre-request Script和Tests都是Javascript代码块。前者在请求发起前执行，通常用来生成请求数据，例如对用户注册接口随机生成用户名。后者在请求结束后执行，通常用来测试和处理返回值。
以下是随机生成用户名的Pre-request Script：
1 postman.setEnvironmentVariable(&amp;#34;random_username&amp;#34;, &amp;#34;测试用户&amp;#34; + Math.floor(Math.random()*1000000)); 产生的值存储在环境变量里，表单里直接引用环境变量即可。
对于REST接口普遍使用的JWT，可以在登录接口的Tests里直接把返回的token更新到环境变量里，这样其它接口直接引用这个环境变量即可：
1 2 3 4 var data = JSON.parse(responseBody); tests[&amp;#34;token is returned&amp;#34;] = typeof(data.token) == &amp;#34;string&amp;#34; &amp;amp;&amp;amp; data.token.length &amp;gt; 0 postman.setEnvironmentVariable(&amp;#34;token&amp;#34;, data.token);</description></item><item><title>CORS：另一种前端跨域请求方式</title><link>http://0x3f.org/posts/cors/</link><pubDate>Mon, 27 Feb 2017 17:07:17 +0000</pubDate><guid>http://0x3f.org/posts/cors/</guid><description>CORS的全称是「Cross-Origin Resource Sharing」，即跨域资源共享。
CORS是比JSONP更强大的前端跨域请求的实现方式。JSONP只支持GET请求，而CORS支持更多种类。JSONP的优势是支持老版本的浏览器。
实现CORS需要浏览器和服务器同时支持，主流框架有实现CORS的中间件，如：laravel-cors。
具体参考：http://www.ruanyifeng.com/blog/2016/04/cors.html</description></item><item><title>在Vim中格式化Javascript、HTML和CSS</title><link>http://0x3f.org/posts/vim-js-beautify/</link><pubDate>Tue, 21 Feb 2017 14:58:08 +0000</pubDate><guid>http://0x3f.org/posts/vim-js-beautify/</guid><description>依赖 vim-jsbeautify js-beautify js-beautify的安装：
1 2 3 npm -g install js-beautify # 或 pip install jsbeautifier 配置快捷键 1 2 3 4 vmap &amp;lt;leader&amp;gt;jsb :&amp;#39;&amp;lt;,&amp;#39;&amp;gt;!js-beautify -i&amp;lt;CR&amp;gt; autocmd FileType javascript noremap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;jsb :call JsBeautify()&amp;lt;CR&amp;gt; autocmd FileType html noremap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;htmlb :call HtmlBeautify()&amp;lt;CR&amp;gt; autocmd FileType css noremap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;cssb :call CSSBeautify()&amp;lt;CR&amp;gt;</description></item><item><title>Postman: Could Not Get Any Response</title><link>http://0x3f.org/posts/postman-could-not-get-any-response/</link><pubDate>Tue, 14 Feb 2017 14:37:54 +0000</pubDate><guid>http://0x3f.org/posts/postman-could-not-get-any-response/</guid><description>Postman如果不显示API返回结果，而是报错：
Could not get any response
有一种原因是响应的header存在错误：
图中以双引号开头的第一行是有问题的。
PS：httpie是个好东西。</description></item><item><title>用NGINX实现WSS</title><link>http://0x3f.org/posts/implement-wss-with-nginx/</link><pubDate>Tue, 14 Feb 2017 13:35:41 +0000</pubDate><guid>http://0x3f.org/posts/implement-wss-with-nginx/</guid><description>实现基于SSL的安全的WebSocket。
NGINX配置 server { listen 4431; server_name ws.sample.com; ssl on; ssl_certificate ssl/server.crt; ssl_certificate_key ssl/server.key; ssl_session_timeout 5m; ssl_session_cache shared:SSL:50m; ssl_protocols SSLv3 SSLv2 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; location / { proxy_pass http://127.0.0.1:4759; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &amp;#34;Upgrade&amp;#34;; proxy_set_header X-Real-IP $remote_addr; proxy_read_timeout 60s; } } 常见问题 连不上或连接时报错 WebSocket network error: OSStatus Error -9807: Invalid certificate chain
如果使用的是自签证书或者证书针对的域名和连接所指定的不符，会出这种问题。
wss一分钟自动断开 NGINX里设置proxy_read_timeout或者程序实现心跳。</description></item><item><title>WebSocket: Connection Header Value Must Contain Upgrade</title><link>http://0x3f.org/posts/websocket-connection-header-value-must-contain-upgrade/</link><pubDate>Sat, 11 Feb 2017 21:52:30 +0000</pubDate><guid>http://0x3f.org/posts/websocket-connection-header-value-must-contain-upgrade/</guid><description>用NGINX反向代理实现WSS后，创建连接时报错：
Error during WebSocket handshake: &amp;lsquo;Connection&amp;rsquo; header value must contain &amp;lsquo;Upgrade&amp;rsquo;
根据官方文档，NGINX从1.3.13开始才支持这个特性，所以解决方法是升级到最新版。</description></item><item><title>两条分组的SQL语句</title><link>http://0x3f.org/posts/two-grouping-sql-statements/</link><pubDate>Fri, 27 Jan 2017 17:51:00 +0000</pubDate><guid>http://0x3f.org/posts/two-grouping-sql-statements/</guid><description>最近做访问统计解决的两个问题：
根据日期分组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 select ( case when visit_at &amp;gt;= 1485014400 then from_unixtime(visit_at, &amp;#39;%Y-%m-%d&amp;#39;) when visit_at &amp;gt;= 1484928000 and visit_at &amp;lt; 1485014400 then from_unixtime(visit_at, &amp;#39;%Y-%m-%d&amp;#39;) else 0 end ) col, count(*) as pv, count(distinct session_id) as uv from `statistics` where `visit_at` &amp;gt;= 1484496000 group by ( case when visit_at &amp;gt;= 1485014400 then from_unixtime(visit_at, &amp;#39;%Y-%m-%d&amp;#39;) when visit_at &amp;gt;= 1484928000 and visit_at &amp;lt; 1485014400 then from_unixtime(visit_at, &amp;#39;%Y-%m-%d&amp;#39;) else 0 end ) 选择每组数据的第一条 1 2 3 4 5 6 7 8 9 10 11 12 13 select a.</description></item><item><title>用OpenResty自动转换silk到MP3</title><link>http://0x3f.org/posts/convert-silk-to-mp3-with-openresty/</link><pubDate>Wed, 25 Jan 2017 18:59:00 +0000</pubDate><guid>http://0x3f.org/posts/convert-silk-to-mp3-with-openresty/</guid><description>PHP没有原生的转换silk格式音频到mp3的方案，所以考虑用NGINX+Lua调用命令行工具实现。
思路 当访问以「.silk.mp3」为后缀的文件时，查找对应的mp3文件，存在则返回，否则，如果对应的silk文件存在，调用命令行工具转换文件格式，然后内部重定向到新生成的mp3。
安装 OpenResty silk-v3-decoder ffmpeg NGINX配置 1 2 3 location ~* /.*\.silk\.mp3$ { content_by_lua_file &amp;#34;/opt/script/silk2mp3.lua&amp;#34;; } Lua脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function file_exists(name) local f=io.open(name,&amp;#34;r&amp;#34;) if f~=nil then io.close(f) return true else return false end end local resource = ngx.var.request_filename; local realResource = resource:sub(1, #resource - 9).</description></item><item><title>Kindle Lazybones: Control Kindle From Your Phone</title><link>http://0x3f.org/posts/kindle-lazybones/</link><pubDate>Mon, 06 Jun 2016 10:33:00 +0000</pubDate><guid>http://0x3f.org/posts/kindle-lazybones/</guid><description>Kindle Lazybones .-. _ ( `. .' ) `\ ` .' | | | | | 66|_ | ,__) |(,_| | | | \_, | | | | .' \ ( , ) '--' '-' Remote controlling utilities for Kindle.
Feature Flip over Kindle with your smartphone. Issues Currently only Kindle PaperWhite is supported, PW2/PW3 are not yet. Kindle still goes to sleep after 10 minutes, a temporary solution is running the searchbox command ~ds to disable screensaver, but only a restart can resume it.</description></item><item><title>Alfred-pushbullet: Push a text to your phone</title><link>http://0x3f.org/posts/alfred-pushbullet/</link><pubDate>Wed, 13 Apr 2016 17:30:00 +0000</pubDate><guid>http://0x3f.org/posts/alfred-pushbullet/</guid><description>Pushbullet workflow for Alfred.
Features Push a text to another device. Installation Download the latest release and rename it to pushbullet.alfredworkflow. Double click it to import it into Alfred. Double click the &amp;ldquo;Run Script&amp;rdquo; button and replace &amp;ldquo;ACCESS_TOKEN&amp;rdquo; and &amp;ldquo;DEVICE_NAME&amp;rdquo; according to your pushbullet settings. Activate alfred and input &amp;ldquo;push blablabla&amp;rdquo;, then press enter. Author base64decode IkRvbmllIExlaWdoIiA8ZG9uaWUubGVpZ2hAZ21haWwuY29tPgo=
Download https://github.com/xbot/alfred-pushbullet/</description></item><item><title>简化Vim Addons Manager安装扩展的操作</title><link>http://0x3f.org/posts/simplify-vim-addon-installation-issues/</link><pubDate>Wed, 20 Jan 2016 18:05:00 +0000</pubDate><guid>http://0x3f.org/posts/simplify-vim-addon-installation-issues/</guid><description>相对Sublime的Package Control，VAM安装和卸载扩展的操作很烦琐。以下脚本在安装完扩展后自动注册，无须手工添加到vimrc，另外增加命令:UninstallAddons，从注册表中删除扩展。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 set runtimepath+=~/.vim/addons/vim-addon-manager let active_addons = [] let s:vamRegistryFile = expand(&amp;#39;~&amp;#39;).&amp;#39;/.vim/vam_registry&amp;#39; if filereadable(s:vamRegistryFile) let active_addons += readfile(s:vamRegistryFile) endif call vam#ActivateAddons(active_addons) &amp;#34; Addon post-install hook.</description></item><item><title>BiuBiu: A Chrome Extension Blocking AJAX Requests</title><link>http://0x3f.org/posts/chrome-extension-biubiu/</link><pubDate>Thu, 31 Dec 2015 14:19:00 +0000</pubDate><guid>http://0x3f.org/posts/chrome-extension-biubiu/</guid><description>BiuBiu BiuBiu is an extension for Google Chrome Browser which intends to make life easier for debugging and profiling.
For now, it only blocks AJAX requests made by JQuery, more features may be added in the future.
Features Toggle to enable or disable BiuBiu. Block requests made by JQuery by URL. Author Donie Leigh &amp;lt;donie.leigh at gmail.com&amp;gt; Links Project: https://github.com/xbot/chrome-biubiu FAQ &amp;ndash; &amp;ndash; Change Log version 1.0.1 (2015-12-31)
Fix the complaining when there is no jQuery or jQuery.</description></item><item><title>Swoole与PHP-FPM性能对比</title><link>http://0x3f.org/posts/swoole-vs-php-fpm/</link><pubDate>Tue, 14 Jul 2015 16:40:00 +0000</pubDate><guid>http://0x3f.org/posts/swoole-vs-php-fpm/</guid><description>测试环境：
CPU: Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz MEM: 4G OS: Archlinux 64bit 测试命令：
1 ab -c 200 -n 200000 -k http://127.0.0.1/test NGINX + PHP-FPM Requests per second: 16240.50 [#/sec] (mean)
Time per request: 12.315 [ms] (mean)
NGINX + Swoole Requests per second: 31284.57 [#/sec] (mean)
Time per request: 6.393 [ms] (mean)
Swoole Requests per second: 99926.55 [#/sec] (mean)
Time per request: 2.001 [ms] (mean)
结论 对一个最简单的PHP脚本做测试，排除业务逻辑的消耗的影响。Swoole威武。</description></item><item><title>在i3wm状态栏显示股票信息</title><link>http://0x3f.org/posts/show-stocks-in-i3status/</link><pubDate>Fri, 12 Jun 2015 17:39:00 +0000</pubDate><guid>http://0x3f.org/posts/show-stocks-in-i3status/</guid><description>效果如图：
创建脚本，并赋可执行权限：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/bin/sh # shell script to prepend i3status with more stuff STOCK_SCRIPT=`realpath &amp;#34;$0&amp;#34;|xargs dirname`/stock.php i3status | while : do stock_info=&amp;#34;&amp;#34; if [[ -x &amp;#34;$STOCK_SCRIPT&amp;#34; ]]; then stock_info=`$STOCK_SCRIPT` fi read line # if output_format = i3bar in i3status.conf stock_info=&amp;#34;[{ \&amp;#34;full_text\&amp;#34;: \&amp;#34;${stock_info}\&amp;#34; },&amp;#34; echo &amp;#34;${line/[/$stock_info}&amp;#34; || exit 1 # # if not output_format = i3bar in i3status.</description></item><item><title>运行时可装卸的Mixin的PHP实现</title><link>http://0x3f.org/posts/php-implementation-of-runtime-mixin/</link><pubDate>Thu, 04 Dec 2014 11:52:00 +0000</pubDate><guid>http://0x3f.org/posts/php-implementation-of-runtime-mixin/</guid><description>PHP的Trait可以实现加载时（load time）的混入（mixin）。作为元编程的一部分，运行时（run time）的混入拥有更大的灵活性。下面利用PHP的魔术方法实现运行时的混入。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 &amp;lt;?</description></item><item><title>Phalcon项目中PHPUnit的初始化</title><link>http://0x3f.org/posts/testing-with-phpunit-in-phalcon/</link><pubDate>Sat, 29 Nov 2014 09:58:00 +0000</pubDate><guid>http://0x3f.org/posts/testing-with-phpunit-in-phalcon/</guid><description>参考官方文档，稍作修改。
在项目下创建目录 unittests ，进入目录执行：
1 composer require phpunit/phpunit 创建 tests 目录并在其中创建文件 Bootstrap.php ：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 &amp;lt;?php use Phalcon\DI, Phalcon\DI\FactoryDefault; ini_set(&amp;#39;display_errors&amp;#39;,1); error_reporting(E_ALL); define(&amp;#39;ROOT_PATH&amp;#39;, __DIR__); define(&amp;#39;PROJECT_DIR&amp;#39;, &amp;#39;/home/taoqi/workspace&amp;#39;); set_include_path( ROOT_PATH . PATH_SEPARATOR . get_include_path() ); // required for phalcon/incubator include __DIR__ . &amp;#34;/../vendor/autoload.php&amp;#34;; // 加载项目文件 $config = require_once PROJECT_DIR.</description></item><item><title>用好代码时光机</title><link>http://0x3f.org/posts/leverage-code-time-machine/</link><pubDate>Fri, 21 Nov 2014 23:19:00 +0000</pubDate><guid>http://0x3f.org/posts/leverage-code-time-machine/</guid><description>今天看了篇文章，讲几种常见的、糟糕的注释用法。其中之一是把废弃的代码注释起来，而不是直接删掉，原因是担心以后可能会用。
这个其实就是版本控制系统（VCS）要解决的问题之一。包括对于团队协作的项目，经常需要看某段代码是谁改的、什么时间、什么原因。都是可以用VCS很方便地解决的问题。
我以前是用二分法在提交列表里找的。其实有更好的解决方法，思路是列出源码在历次提交中修改的内容，然后在其中查找要找的东西就行了。
git的解决方法：
1 git log -p abc.php svn的解决方法：
1 svn log --diff --internal-diff abc.php vim的辅助函数：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 &amp;#34; Show commit history of the current file under the given VCS in a new window function! ShowCommitHistory(vcs) &amp;#34; Check parameter if a:vcs != &amp;#39;svn&amp;#39; &amp;amp;&amp;amp; a:vcs != &amp;#39;git&amp;#39; echoerr &amp;#39;Unknow VCS: &amp;#39;.</description></item><item><title>接管PHP致命错误的方法</title><link>http://0x3f.org/posts/how-to-take-over-php-fatal-error-handling/</link><pubDate>Wed, 12 Nov 2014 00:47:00 +0000</pubDate><guid>http://0x3f.org/posts/how-to-take-over-php-fatal-error-handling/</guid><description>Yii 2.0引入了一项新特性，可以接管PHP的致命错误。在此之前，如果PHP源码有语法错误，框架本身是不会处理的。
实现的思路如下：
禁止显示错误 注册自定义的shutdown回调函数 在回调函数中获取最近的错误 若错误是致命错误，调用相应的处理逻辑 代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &amp;lt;?php // ... ini_set(&amp;#39;display_errors&amp;#39;, false); register_shutdown_function(function(){ $error = error_get_last(); if (isset($error[&amp;#39;type&amp;#39;]) &amp;amp;&amp;amp; in_array($error[&amp;#39;type&amp;#39;], [E_ERROR, E_PARSE, E_CORE_ERROR, E_CORE_WARNING, E_COMPILE_ERROR, E_COMPILE_WARNING])) { ob_clean(); echo &amp;#39;&amp;lt;pre&amp;gt;&amp;#39;; var_dump($error); echo &amp;#39;&amp;lt;/pre&amp;gt;&amp;#39;; exit(1); } }); // ... ?&amp;gt;</description></item><item><title>Project Euler Problem 25 Solved</title><link>http://0x3f.org/posts/project-euler-25-solved/</link><pubDate>Sat, 16 Aug 2014 17:32:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-25-solved/</guid><description>1000-digit Fibonacci number The Fibonacci sequence is defined by the recurrence relation:
Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.
Hence the first 12 terms will be:
F1 = 1
F2 = 1
F3 = 2
F4 = 3
F5 = 5
F6 = 8
F7 = 13
F8 = 21
F9 = 34
F10 = 55
F11 = 89
F12 = 144
The 12th term, F12, is the first term to contain three digits.</description></item><item><title>Project Euler Problem 24 Solved</title><link>http://0x3f.org/posts/project-euler-24/</link><pubDate>Sun, 27 Apr 2014 21:17:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-24/</guid><description>Lexicographic permutations A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:
012 021 102 120 201 210
What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?</description></item><item><title>Project Euler Problem 23 Solved</title><link>http://0x3f.org/posts/project-euler-23/</link><pubDate>Fri, 25 Apr 2014 23:56:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-23/</guid><description>Non-abundant sums A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.
A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.</description></item><item><title>UltraBlog.vim v3.6.1: 文章分类自动补全</title><link>http://0x3f.org/posts/ultrablog-v361-released/</link><pubDate>Sun, 20 Apr 2014 22:50:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v361-released/</guid><description>春节期间收到两个issue，一直拖到今天才有时间完成。
增加了一个功能，在文章编辑视图的元数据中分类那行，使用热键&amp;lt;C-X&amp;gt;&amp;lt;C-U&amp;gt;自动完成文章的分类。在配置数组ub_blog中增加键值对“categories”，默认使用这一项的值实现自动完成，如下：
1 2 3 4 5 6 7 let ub_blog = {&amp;#39;login_name&amp;#39;:&amp;#39;admin&amp;#39;, \&amp;#39;password&amp;#39;:&amp;#39;pass2011&amp;#39;, \&amp;#39;url&amp;#39;:&amp;#39;http://www.sample.com/&amp;#39;, \&amp;#39;xmlrpc_uri&amp;#39;:&amp;#39;xmlrpc.php&amp;#39;, \&amp;#39;db&amp;#39;:&amp;#39;$VIM/UltraBlog.db&amp;#39;, \&amp;#39;categories&amp;#39;: &amp;#39;News|Computer|Image&amp;#39; \} 如果这一项不存在，将从博客中拉取分类数据。
自从迁移到Octopress，有两年不用Wordpress了，没想到居然还有人在用UltraBlog.vim。</description></item><item><title>Project Euler Problem 22 Solved</title><link>http://0x3f.org/posts/project-euler-22/</link><pubDate>Sun, 20 Apr 2014 08:03:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-22/</guid><description>Names scores Using names.txt (right click and &amp;lsquo;Save Link/Target As&amp;hellip;&amp;rsquo;), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.
For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list.</description></item><item><title>Project Euler Problem 21 Solved</title><link>http://0x3f.org/posts/project-euler-21/</link><pubDate>Thu, 17 Apr 2014 22:18:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-21/</guid><description>Amicable numbers Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers.
For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284.</description></item><item><title>Project Euler Problem 20 Solved</title><link>http://0x3f.org/posts/project-euler-20/</link><pubDate>Mon, 14 Apr 2014 22:19:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-20/</guid><description>Factorial digit sum n! means n × (n − 1) × &amp;hellip; × 3 × 2 × 1
For example, 10! = 10 × 9 × &amp;hellip; × 3 × 2 × 1 = 3628800,
and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
Find the sum of the digits in the number 100!</description></item><item><title>Project Euler Problem 19 Solved</title><link>http://0x3f.org/posts/project-euler-19/</link><pubDate>Sat, 12 Apr 2014 21:21:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-19/</guid><description>Counting Sundays You are given the following information, but you may prefer to do some research for yourself.
1 Jan 1900 was a Monday. Thirty days has September, April, June and November.
All the rest have thirty-one,
Saving February alone,
Which has twenty-eight, rain or shine.
And on leap years, twenty-nine. A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.</description></item><item><title>Project Euler Problem 18&amp;67 Solved</title><link>http://0x3f.org/posts/project-euler-18-and-67/</link><pubDate>Thu, 10 Apr 2014 21:28:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-18-and-67/</guid><description>Maximum path sum I By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
3
7 4
2 4 6
8 5 9 3
That is, 3 + 7 + 4 + 9 = 23.
Find the maximum total from top to bottom of the triangle below:
75
95 64
17 47 82</description></item><item><title>Project Euler Problem 17 Solved</title><link>http://0x3f.org/posts/project-euler-17/</link><pubDate>Wed, 09 Apr 2014 22:29:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-17/</guid><description>Number letter counts If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters.</description></item><item><title>Project Euler Problem 16 Solved</title><link>http://0x3f.org/posts/project-euler-16/</link><pubDate>Tue, 08 Apr 2014 21:57:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-16/</guid><description>Power digit sum 2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
What is the sum of the digits of the number 2^1000?
Solution 1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/python # -*- coding: utf-8 -*- import math if __name__ == &amp;#39;__main__&amp;#39;: str = format(math.pow(2, 1000), &amp;#39;f&amp;#39;) sum = 0 for c in str[:str.</description></item><item><title>Project Euler Problem 15 Solved</title><link>http://0x3f.org/posts/project-euler-15/</link><pubDate>Wed, 02 Apr 2014 21:44:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-15/</guid><description>Lattice paths Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.
How many such routes are there through a 20×20 grid?
Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/bin/python # -*- coding: utf-8 -*- if __name__ == &amp;#39;__main__&amp;#39;: (steps, a, b) = (20, 1, 1) i = steps * 2 while i &amp;gt; steps: a *= i i -= 1 while steps &amp;gt; 1: b *= steps steps -= 1 print a / b I&amp;rsquo;m the 86747th person to have solved this problem.</description></item><item><title>Project Euler Problem 14 Solved</title><link>http://0x3f.org/posts/project-euler-14/</link><pubDate>Tue, 01 Apr 2014 22:17:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-14/</guid><description>Longest Collatz sequence The following iterative sequence is defined for the set of positive integers:
n → n/2 (n is even)
n → 3n + 1 (n is odd)
Using the rule above and starting with 13, we generate the following sequence:
13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms.</description></item><item><title>PHP框架实战（六）：依赖注入</title><link>http://0x3f.org/posts/flamework-dependency-injection/</link><pubDate>Sun, 30 Mar 2014 10:00:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-dependency-injection/</guid><description>简述 依赖注入是个很好的解耦方法，也可以优雅的实现懒加载。
以数据库连接为例，当一个组件用到数据库时，最简单粗暴的办法是在使用前创建连接：
1 2 3 4 5 6 7 8 9 10 11 &amp;lt;?php class Component { public function doSth() { // ... $db = new DatabaseConnection($schema, $host, $port, $login, $password); // ... } } ?&amp;gt; 这样做的缺点是代码一旦执行，Component行为将不可更改，有时我们需要在程序执行的过程中决定其行为。很直接地，可以想到给Component添加一个Setter方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &amp;lt;?php class Component { private $__db; public function doSth() { // ... if ($this-&amp;gt;__db !</description></item><item><title>Project Euler Problem 13 Solved</title><link>http://0x3f.org/posts/project-euler-13/</link><pubDate>Sun, 30 Mar 2014 09:50:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-13/</guid><description>Large sum Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
37107287533902102798797998220837590246510135740250 46376937677490009712648124896970078050417018260538 74324986199524741059474233309513058123726617309629 91942213363574161572522430563301811072406154908250 23067588207539346171171980310421047513778063246676 89261670696623633820136378418383684178734361726757 28112879812849979408065481931592621691275889832738 44274228917432520321923589422876796487670272189318 47451445736001306439091167216856844588711603153276 70386486105843025439939619828917593665686757934951 62176457141856560629502157223196586755079324193331 64906352462741904929101432445813822663347944758178 92575867718337217661963751590579239728245598838407 58203565325359399008402633568948830189458628227828 80181199384826282014278194139940567587151170094390 35398664372827112653829987240784473053190104293586 86515506006295864861532075273371959191420517255829 71693888707715466499115593487603532921714970056938 54370070576826684624621495650076471787294438377604 53282654108756828443191190634694037855217779295145 36123272525000296071075082563815656710885258350721 45876576172410976447339110607218265236877223636045 17423706905851860660448207621209813287860733969412 81142660418086830619328460811191061556940512689692 51934325451728388641918047049293215058642563049483 62467221648435076201727918039944693004732956340691 15732444386908125794514089057706229429197107928209 55037687525678773091862540744969844508330393682126 18336384825330154686196124348767681297534375946515 80386287592878490201521685554828717201219257766954 78182833757993103614740356856449095527097864797581 16726320100436897842553539920931837441497806860984 48403098129077791799088218795327364475675590848030 87086987551392711854517078544161852424320693150332 59959406895756536782107074926966537676326235447210 69793950679652694742597709739166693763042633987085 41052684708299085211399427365734116182760315001271 65378607361501080857009149939512557028198746004375 35829035317434717326932123578154982629742552737307 94953759765105305946966067683156574377167401875275 88902802571733229619176668713819931811048770190271 25267680276078003013678680992525463401061632866526 36270218540497705585629946580636237993140746255962 24074486908231174977792365466257246923322810917141 91430288197103288597806669760892938638285025333403 34413065578016127815921815005561868836468420090470 23053081172816430487623791969842487255036638784583 11487696932154902810424020138335124462181441773470 63783299490636259666498587618221225225512486764533 67720186971698544312419572409913959008952310058822 95548255300263520781532296796249481641953868218774 76085327132285723110424803456124867697064507995236 37774242535411291684276865538926205024910326572967 23701913275725675285653248258265463092207058596522 29798860272258331913126375147341994889534765745501 18495701454879288984856827726077713721403798879715 38298203783031473527721580348144513491373226651381 34829543829199918180278916522431027392251122869539 40957953066405232632538044100059654939159879593635 29746152185502371307642255121183693803580388584903 41698116222072977186158236678424689157993532961922 62467957194401269043877107275048102390895523597457 23189706772547915061505504953922979530901129967519 86188088225875314529584099251203829009407770775672 11306739708304724483816533873502340845647058077308 82959174767140363198008187129011875491310547126581 97623331044818386269515456334926366572897563400500 42846280183517070527831839425882145521227251250327 55121603546981200581762165212827652751691296897789 32238195734329339946437501907836945765883352399886 75506164965184775180738168837861091527357929701337 62177842752192623401942399639168044983993173312731 32924185707147349566916674687634660915035914677504 99518671430235219628894890102423325116913619626622 73267460800591547471830798392868535206946944540724 76841822524674417161514036427982273348055556214818 97142617910342598647204516893989422179826088076852 87783646182799346313767754307809363333018982642090 10848802521674670883215120185883543223812876952786 71329612474782464538636993009049310363619763878039 62184073572399794223406235393808339651327408011116 66627891981488087797941876876144230030984490851411 60661826293682836764744779239180335110989069790714 85786944089552990653640447425576083659976645795096 66024396409905389607120198219976047599490197230297 64913982680032973156037120041377903785566085089252 16730939319872750275468906903707539413042652315011 94809377245048795150954100921645863754710598436791 78639167021187492431995700641917969777599028300699 15368713711936614952811305876380278410754449733078 40789923115535562561142322423255033685442488917353 44889911501440648020369068063960672322193204149535 41503128880339536053299340368006977710650566631954 81234880673210146739058568557934581403627822703280 82616570773948327592232845941706525094512325230608 22918802058777319719839450180888072429661980811197 77158542502016545090413245809786882778948721859617 72107838435069186155435662884062257473692284509516 20849603980134001723930671666823555245252804609722 53503534226472524250874054075591789781264330331690</description></item><item><title>Project Euler Problem 12 Solved</title><link>http://0x3f.org/posts/project-euler-12/</link><pubDate>Fri, 28 Mar 2014 22:51:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-12/</guid><description>Highly divisible triangular number The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, &amp;hellip;
Let us list the factors of the first seven triangle numbers:
1: 1
3: 1,3</description></item><item><title>读完《The C Programming Language》</title><link>http://0x3f.org/posts/after-reading-the-c-programming-language/</link><pubDate>Sun, 09 Mar 2014 22:47:00 +0000</pubDate><guid>http://0x3f.org/posts/after-reading-the-c-programming-language/</guid><description>谭书可能因为面向学生而显得啰嗦，这本书比谭书精炼。</description></item><item><title>PHP框架实战（∝）：烈焰之终章</title><link>http://0x3f.org/posts/flamework-summary/</link><pubDate>Thu, 02 Jan 2014 15:15:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-summary/</guid><description>写“烈焰”（Flame）用了一周的业余时间，主要是对平时一些想法的总结和验证。实现了比较完整的控制器层和视图层，对模型层的ActiveRecord实现思路做了一下梳理。
当然，一个可实用的框架需要包含的东西远不止这些。比如框架中用到代码动态调用的地方，一定要做好语言安全子集的过滤，否则就是很大的安全漏洞。再比如需要支持依赖反转的缓存机制，实现对多种缓存方式的平滑支持。此外，像URI路由、可扩展、多模板方案支持也都是现代框架的标配。这些留待以后有时间再讨论。然而在这次练习的过程中，我突然想到一个问题——PHP是不是适合实现一个完备的框架。
曾见过一句话，说PHP本身就是一个框架，后来明白，这才是微言大义。PHP有很多高级选项、高级函数和扩展，用得好事半功倍，用不好就是魔鬼。
PHP本身有很多问题，协议不统一、函数命名混乱、命名空间语法怪异而且鸡肋等等都是老生常谈。在运行模式上，无论是Apache+PHP模块，还是NGINX+FastCGI，都只能实现在纵向层面上对一次请求的处理，由于缺乏在内存中持续运行程序的机制，凡是对程序全局共享并持续占有的东西都不能实现，比如数据库连接池等，以至于很多初始化的工作对于每次请求都要重新执行一次，这意味著面向对象越彻底、封装越多，系统资源的重复消耗越厉害，所以PHP的程序在性能和内存占用上与Java相比有一定缺陷。因此PHP更适合短平快的应用场景，不适合实现复杂的业务逻辑。
基于这个观点，我认同混合编程。没有哪种语言是完美的，用对的工具做对的事是最理想的。用PHP实现一个完备的框架也许不是个明智的选择，从短平快的角度出发，它更适合用来实现微框架。
现在微框架是个比较热门的话题，我最早接触的是Python的Bottle和Flask，短小精悍，非常容易上手。微框架主要实现控制器层和视图层，一般不包括模型层。为了以最快的速度将请求路由到处理逻辑，一般以最直接的方式建立URI模板和回调物件之间的映射，控制器层可以以极简的方式实现，例如只做一个像本文后面例子中那样简单的约定。微框架应该尽可能少地包含配置，大部分时候并不需要像Java的S.S.H那样滥用配置，CoC原则就持这样的观点，约定可以解决的问题就不要用配置去做。
下面只使用两个函数和五条约定实现一个微框架：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 &amp;lt;?php /** * 路由定义与应用 * @param string $route 用作定义路由规则时，此参数为模板字符串， * 使用冒号加参数名作为参数占位符，例如： * on(&amp;#39;/post/edit/:id&amp;#39;, function($id){}); * 用做应用路由规则时，此参数为URI，例如： * on($_SERVER[&amp;#39;REQUEST_URI&amp;#39;]); * @param callable $callback 路由规则的回调逻辑，如果路由规则中 * 含有参数占位符，回调中需存在同名的参数；当函数作为应用路 * 由规则使用时，此参数不指定 * @return void * @since 1.</description></item><item><title>PHP框架实战（五）：ORM与ActiveRecord</title><link>http://0x3f.org/posts/flamework-active-record/</link><pubDate>Wed, 01 Jan 2014 20:45:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-active-record/</guid><description>简述 Model是MVC框架中最复杂的部分，它要提供与业务逻辑相关的数据及数据处理方法的封装，一般要提供数据对象、数据库连接、事务管理、SQL语句构造、数据CRUD、高级通用业务逻辑等一系列功能。由于Model与Controller和View是解耦的，并且本身具备很高的通用性和复杂性，所以有很多独立的实现。本文希望能通过开发一个简单的ActiveRecord，验证这种Model实现方案的原理和过程。
ORM：对象关系映射 ORM的全称是Object Relational Mapping，即对象关系映射。它是为了解决关系数据库的数学模型和编程语言的对象模型之间的阻抗不匹配问题而提出的解决方案。
阻抗不匹配是个逼格很高的词。
阻抗是指电路中的电容、电感、电阻对交流电的障碍作用，就像电阻对直流电的障碍作用。两个系统传递信号可以形象地看成电压的传递，公式为：
U(out) * Z(in)
U(in) = &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
Z(in) + Z(out)
即输入电压等于输出电压与输入阻抗的积除以输入阻抗与输出阻抗的和。
理想情况肯定是输入电压等于输出电压，这时信号是没有失真的，也就是要求Z(in)与Z(in)+Z(out)之商无限逼近1，这个过程就叫阻抗匹配。关系型数据库是建立在数学模型的基础上，而编程语言中的对象是建立在人对客观世界认知的具象模型上。说白了，阻抗不匹配问题就是说因这两种模型不一致而导致的问题。
ORM通过建立表与对象、列与属性（这只是一般情况）之间的映射关系而解决问题，这可以实现像操作对象一样对数据库中的数据进行增删改查，简化了开发过程。不过ORM的缺点是不能很好地处理复杂数据关系，会出现效率低下的问题，因此必要时仍然需要直接使用SQL。
ActiveRecord ActiveRecord是Ruby on Rails提出的一个概念，其实就是ORM的一种实现，它是对象类型、数据、CRUD方法的合体，使对数据的操作以更具象化的方式实现。下面介绍在Flamework中实现一个简单的ActiveRecord的过程。
首先实现数据库的接口，提供数据库连接、查询、执行SQL语句、事务管理等基本功能。这里使用PDO实现：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 &amp;lt;?</description></item><item><title>PHP框架实战（四）：View的模板与渲染</title><link>http://0x3f.org/posts/flamework-view-rendering/</link><pubDate>Mon, 30 Dec 2013 21:05:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-view-rendering/</guid><description>目标 实现MVC模型的View层，Controller的Action中应可以将从Model层获取的数据填充到View模板中，并将渲染结果返回给访问者。本文并不志在实现一个完备的模板框架，相应的需求可借助Smarty这样现有的实现。
获取代码 1 git checkout v0.4 设计与实现 View的模板是最好实现的，因为PHP本身就是一个模板语言，所以这里实现的模板主要是指几条约定：
模板文件本身是一个普通PHP文件，文件名后缀是“.php”； 模板文件应存储在项目指定的模板基础目录中； 模板名称指模板文件相对于项目的模板基础目录的路径，并且去掉文件后缀； 模板本身的实际效果等同于在Controller的Action中执行的代码，故可以调用Controller的所有方法以及Flame对象的方法等内容； 所有要填充到模板中的数据以键值对的形式存储在一个关联数组中，并传递给渲染模板的方法，在模板中使用与键名相同的变量调用数据； View的渲染方法
添加Controller::render()方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 &amp;lt;?php // ... /** * Render the view template with data * @param string $view View template relative path to base path of the templates * For example, &amp;#39;post/list&amp;#39; point to file /srv/http/mysite/protected/view/post/list.</description></item><item><title>PHP框架实战（三）：实现Controller和Filter</title><link>http://0x3f.org/posts/flamework-controller-and-filter/</link><pubDate>Sun, 29 Dec 2013 20:40:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-controller-and-filter/</guid><description>目标 实现Controller和Filter，程序可以从HTTP请求中解析Controller和Action，并在这两个切面级别实现Filter链。此外，在Controller中，可以使用Action的参数直接访问HTTP请求中的同名参数。
获取代码 项目目录结构做了调整，framework目录存放Flamework框架源码，demo目录存放示例项目。
1 git checkout v0.3 设计与实现 Controller的实现
要求请求URL的格式如下：
http://www.mydomain.com/index.php?r=post/save
r表示Route，斜杠前面的post表示Controller的名称，后面的save表示Action的名称。对HTTP请求的各种处理逻辑封装在新对象HttpRequest中：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 &amp;lt;?</description></item><item><title>PHP框架实战（二）：错误和异常的自动处理</title><link>http://0x3f.org/posts/flamework-error-auto-handling/</link><pubDate>Sat, 28 Dec 2013 13:40:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-error-auto-handling/</guid><description>目标 实现错误和异常的自动捕获和处理。
获取代码 1 git checkout v0.2 设计与实现 使用set_error_handler()和set_exception_handler()两个函数注册错误和异常的处理方法，并在两个处理方法中先调用用户自定义的错误和异常处理逻辑，如果自定义逻辑不存在或者返回false，继续调用框架缺省的处理逻辑，输出错误信息到页面。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 &amp;lt;?</description></item><item><title>PHP框架实战（一）：框架入口与类的自动加载</title><link>http://0x3f.org/posts/flamework-entry/</link><pubDate>Sat, 28 Dec 2013 01:56:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-entry/</guid><description>目标 实现框架入口和类的自动加载。
获取代码 1 git checkout v0.1 设计与实现 通过两个类实现本次目标。
静态类Flame作为整个框架的入口，实现一系列框架级公用静态方法（例如创建应用实例和自动加载类）。
WebApplication是应用的抽象层，实现应用的入口和其它应用级（即运行时）公用方法（例如读取配置文件）。
程序入口
1 2 3 4 &amp;lt;?php // ... Flame::createApplication($config)-&amp;gt;run(); ?&amp;gt; 此处传入的$config是应用配置文件的路径，该配置文件内容格式如下：
1 2 3 4 5 6 &amp;lt;?php return array( &amp;#39;opt1&amp;#39; =&amp;gt; &amp;#39;val1&amp;#39;, // ... ); ?&amp;gt; 在文件中直接return一个关联数组的好处是，加载该文件时，include()函数的返回值就是该数组，代码更简洁，效率比解析其它格式配置文件高。
类的自动加载
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 &amp;lt;?php // ... class Flame { // .</description></item><item><title>PHP框架实战（零）：代码规范</title><link>http://0x3f.org/posts/flamework-code-spec/</link><pubDate>Thu, 26 Dec 2013 22:07:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-code-spec/</guid><description>类C语言语法风格最大的问题就是用花括号区分代码块，这导致源码排版容易混乱，对于我这种有代码洁癖的人来说非常痛苦，所以我最喜欢的语法风格是Python的，用缩进区分代码块，排版不规范直接判处语法错误。
命名规范 所有命名使用驼峰风格。
源码开头定义命名空间，Flamework框架入口类的命名空间为“org\x3f\flamework”，其余类的命名空间应在此基础上追加与所在目录路径匹配的内容。例如，框架源码目录下一级子目录“base”中的类文件的命名空间均为“org\x3f\flamework\base”。
类名必须是名词，不允许添加任何无意义的前缀或后缀，只允许使用大小写英文字母且首字母大写。
方法名必须是“动词+名词”的形式（如果动词意义明确且不需要宾语，可省略后者），只允许使用大小写英文字母及阿拉伯数字和下划线，首字母小写。
属性名分两种情况，对于存储普通数据的属性，名称必须是名词；对于布尔型属性，名称必须是“动词+名词”的形式。只允许使用大小写英文字母及阿拉伯数字和下划线，首字母小写。
源码文件名必须与类名相同，后缀统一使用“.php”。
注释规范 统一使用phpDocumenter的注释规范。
类注释必须注明@author、@since。
属性和方法的作者如果和类的创建者不同，必须注明@author，此外必须注明@since。
文件格式 所有文本文件统一使用UNIX格式和UTF-8编码。
严禁使用制表符缩进代码，必须使用4个空格替代制表符。
类、属性、方法、方法内部代码块都必须严格按照层级缩进。</description></item><item><title>PHP框架实战：Flamework</title><link>http://0x3f.org/posts/flamework/</link><pubDate>Thu, 26 Dec 2013 20:24:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework/</guid><description>从今天开始，逐步实现一个PHP的MVC框架，以践行平时对这方面的一些想法。
项目信息 名称：Flamework (Flame Framework) 源码：https://github.com/xbot/flamework 框架特性 激进
用PHP高版本引入的新特性，不考虑向前兼容问题，没有历史包袱。
命名空间
PHP 5.3引入的命名空间可以有效避免类命名冲突，这样可以使类名看起来更自然，不用再在类名前面加难看的前缀了。
类的自动加载
手动include会增加维护的难度，因为经常会出现一个类被从源码中移除而它的include行还在的问题，这会拖慢程序执行速度、增加内存占用。
实现类的自动加载可以在类被引用时自动include相应的源码。
异常的自动处理
在设计程序时，一般应该把用户级的错误返回给页面显示，或者对一些HTTP错误显示个性化的页面（例如人民群众喜闻乐见的404页面），所以在业务逻辑、数据操作这些层一般应该逐级向上抛异常，然后在Controller里捕获并加工成页面可识别的格式（例如JSON）。这样做的缺点是Controller里每个Action都包含重复的try&amp;hellip;catch块。
异常的自动处理允许开发者指定自定义的异常处理逻辑，将异常处理与普通逻辑解耦，这样每个Action只需实现它所关注的功能即可。
过滤器
过滤器允许面向切面编程，是将横向逻辑与纵向逻辑解耦的重要工具。Flamework要实现针对Controller和Action两个级别的过滤器链，过滤器可在该级别逻辑前后执行，并能停止该级别逻辑及后续过滤器的执行。
懒加载
对尽可能多的资源实现懒加载，例如数据库连接、类、组件等，目的是提高效率、节约资源。
参数绑定
自动将请求中的参数与Action方法的参数绑定，从而避免在Action里出现通过$_POST、$_GET这些数组取参数的脏代码，也可以自动实现参数的校验和错误处理。
ActiveRecord
ORM是对关系模型和对象模型的阻抗不匹配问题的解决方案，ActiveRecord是目前最流行的一种ORM的实现方式。通过AR，可以以更对象化的方式操作关系数据库的数据。
依赖注入
依赖注入是个很好的解耦方法，也可以很优雅地实现懒加载。
目录 零：代码规范 一：框架入口与类的自动加载 二：错误和异常的自动处理 三：实现Controller和Filter 四：视图的模板与渲染 五：ORM与ActiveRecord 六：依赖注入 ∝：烈焰之终章</description></item><item><title>用 Dojo 实现拖放操作的最佳实践</title><link>http://0x3f.org/posts/practical-drag-and-drop-implementation-with-dojo/</link><pubDate>Tue, 05 Nov 2013 16:58:00 +0000</pubDate><guid>http://0x3f.org/posts/practical-drag-and-drop-implementation-with-dojo/</guid><description>在研究 Dojo 实现拖放操作时，我花了很多时间处理一些细节问题，比如创建自定义样式的拖拽物件以及将光标放置在拖拽开始位置等。这些细节在实现个性化的拖放操作时非常重要，但是我几乎没有找到直接相关的资料可供参考。
创建自定义样式的拖拽物件 Dojo 缺省的拖拽物件样式很丑，通过覆盖官方文档里列出的几个 CSS 的 class 可以有限地调整部分样式，如果需要更多个性化，就需要使用自定义的物件模板。
通过重载 Source 对象的 creator 方法可以实现这一点。这个方法会在创建拖拽物件的时候被调用，如果 hint 参数的值为“avatar”就表示将被创建的是被拖拽物件，此时可以使用预先定义好的模板 avatarTmpl 创建物件的 node 。
1 2 3 4 5 6 7 8 9 10 11 this.dndSrc = new Source(this.itemList.domNode, { copyOnly:true, selfAccept:true, creator: function(item, hint) { var n; if (hint == &amp;#39;avatar&amp;#39;) { n = domConstruct.toDom(lang.replace(avatarTmpl, item)); } return {node:n, data:item, type:[&amp;#39;text&amp;#39;]}; } }); 置光标位置于拖拽起始处 在拖拽开始后，Dojo 默认将光标置于被拖拽物件的左上角，而一般把光标置于拖拽开始时相对于物件的位置处显得比较自然。
实现方式是先记录拖拽开始时光标的位置，然后设置 dojo.dnd.Manager 的两个位移属性。
1 2 3 4 5 6 7 8 9 10 on(this.</description></item><item><title>Dojo DnD: Cannot read property 'type' of undefined</title><link>http://0x3f.org/posts/dojo-dnd-cannot-read-property-type-of-undefined/</link><pubDate>Thu, 11 Jul 2013 22:44:00 +0000</pubDate><guid>http://0x3f.org/posts/dojo-dnd-cannot-read-property-type-of-undefined/</guid><description>场景如下：
假设有两个Widget：ItemListWidget和ItemWidget，后者要被创建多份并追加到前者内部，同时ItemListWidget要作为dojo/dnd/Source，每个ItemWidget作为一个单元可被拖拽到另外一个dojo/dnd/Target容器中。
问题是，当Source被创建后，再添加到ItemListWidget的ItemWidget实例在被拖拽时会报如下错误：
Uncaught TypeError: Cannot read property &amp;rsquo;type&amp;rsquo; of undefined
在Chrome开发工具中点开这个错误，显示以下内容：
从方法的注释或API中可以看到，checkAcceptance()是用来判断当前拖拽对象是否在这个target接受的范围之内，接受规则用Source和Target的构造参数中的“accept”定义。在这个方法里通过Source.getItem()方法拿到的对象是null，上述错误就是从这儿报出来的。
接合API和Reference Guide发现，每个Source中的可拖拽项目在Source中都要有一个对应的对象，这个对象至少包括两个属性：“data”和“type”。在Reference Guide中，对这两个属性有详细说明，简言之，data是向Target传递的数据，type是被Target用来判断拖拽个体是否属于接受范围的依据。
当Source实例被创建时，已经存在于ItemListWidget中的ItemWidget实例会被自动创建对应的上述对象，但之后加入的不会。解决的办法是调用Source.setItem()方法为每一个新加入的ItemWidget关联相应的对象，或在ItemWidget中添加一个构造参数，用于指定Source，并在postCreate()方法中为当前ItemWidget实例关联相应的对象:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 define([ &amp;#34;dojo/_base/declare&amp;#34;, &amp;#34;dijit/_WidgetBase&amp;#34;, ], function(declare, _WidgetBase){ return declare(&amp;#34;ItemWidget&amp;#34;, [_WidgetBase], { // 本Widget实例所属的Source实例 dndSrc: null, postCreate: function() { this.inherited(arguments); // 不需要传递数据时，可忽略data参数 if (this.dndSrc !== null) this.dndSrc.setItem(this.id, {type:[&amp;#34;text&amp;#34;]}); } }); });</description></item><item><title>PySide: How to Get the Position of a Widget-Value-Changed Cell in QTableWidget</title><link>http://0x3f.org/posts/get-position-in-qtablewidget-for-changed-cellwidgets/</link><pubDate>Mon, 01 Jul 2013 00:57:00 +0000</pubDate><guid>http://0x3f.org/posts/get-position-in-qtablewidget-for-changed-cellwidgets/</guid><description>Assume we have created an instance of QTableWidget, in which cells are filled with widgets like QComboBox, QCheckBox, etc. When values are changed, we need to get the row and column indexes of the cells. But the QTableWidget.cellChanged() and QTableWidget.itemChanged() signals are only effective for cells containing QTableWidgetItem instances, for those in which widgets are filled in with QTableWidget.setCellWidget(), this doesn&amp;rsquo;t work.
This problem nearly made me crazy last weekend. So how can I make it ?</description></item><item><title>怎样为红帽系Linux发行版写系统服务脚本</title><link>http://0x3f.org/posts/how-to-write-service-scripts-for-redhat-distros/</link><pubDate>Tue, 19 Jun 2012 00:14:00 +0000</pubDate><guid>http://0x3f.org/posts/how-to-write-service-scripts-for-redhat-distros/</guid><description>##阅读说明
阅读本文要求有基本的Linux系统使用经验和Bash脚本编程能力。
本文所述的内容适用于RHEL、CentOS等红帽系Linux发行版。
##系统服务简介
###常用命令
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 启动MySQL service mysqld start # 关闭MySQL service mysqld stop # 重启MySQL service mysqld restart # 查看MySQL服务运行状态 service mysqld status # 查看MySQL服务是否开机自动运行 chkconfig --list mysqld # 设置MySQL服务开机自动运行 chkconfig --level 345 mysqld on # 取消MySQL服务开机自动运行 chkconfig --level 345 mysqld off ###运行级别
泛UNIX派系操作系统使用运行级别标识使用何种模式初始化。理论上，不同的发行版各级别代表的意义不同。红帽系发行版使用以下七个运行级别：
0：关机 1：单用户模式 2：多用户模式，无网络服务 3：多用户模式，有网络服务 4：未使用/用户自定义 5：带图形界面的多用户模式 6：重启 最常用的是0、3、5、6四种模式。其中，0和6表示关闭和重启操作系统，所以，执行命令init 0和shutdown是一个效果，同样，执行命令init 6和reboot是一个效果。模式3即普通的命令行用户界面，模式5即普通的图形界面用户界面。</description></item><item><title>UltraBlog.vim v3.5.0: 内建浏览器</title><link>http://0x3f.org/posts/ultrablog-v350-released/</link><pubDate>Mon, 30 Apr 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v350-released/</guid><description>此前预览文章是通过调用系统默认的网络浏览器实现的，缺点是这些功能完备的浏览器启动速度不甚理想，尤其是火狐，谁用谁知道。
前两天看了TuxRadar的一个Podcast，几分钟内就可以用pywebkitgtk拼装出一个五脏俱全的网络浏览器，pywebkitgtk这个东西实在是非常的好用。不过我实测后发现这东西加载页面的速度比较慢，而且貌似是单线程的，因为图片都是放在最后才加载，不知道是这个绑定本身的问题，还是有API可以实现的。于是突然想到拿这个东西实现一个简单的浏览器，很适合在UB里预览文章。
增加了一个选项“ub_use_ubviewer”，默认值是1，即默认使用这个内建的浏览器预览文章。当这个选项的值被设为0时，仍然使用系统的默认浏览器，并且在Vim启动时不会加载内建的浏览器。这样做一是为了多一种选择，再一个也可以避开烦人的GTK警告：
** (gvim:13629): WARNING **: Trying to register gtype 'GMountMountFlags' as enum when in fact it is of type 'GFlags'
** (gvim:13629): WARNING **: Trying to register gtype 'GDriveStartFlags' as enum when in fact it is of type 'GFlags'
** (gvim:13629): WARNING **: Trying to register gtype 'GSocketMsgFlags' as enum when in fact it is of type 'GFlags'
这些警告是GTK或其它一些程序库的Bug造成的，虽然只在虚拟终端中启动Vim时会显示并且不影响使用，但总会有警告恐惧症患者会觉得这种东西很闹心。如果这样，就把这个选项的值设成0，用回巨型浏览器好了。
本次更新的全部内容如下：
Feature: Add a tiny web browser to do previewing, which starts much faster than full-functional browsers like firefox and chromium.</description></item><item><title>UltraBlog.vim v3.4.0: 正则表达式、批量替换和调试模式</title><link>http://0x3f.org/posts/ultrablog-v340-released/</link><pubDate>Sun, 29 Apr 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v340-released/</guid><description>这次的更新主要引入了支持正则表达式的全文检索、批量替换和调试模式。
正则表达式 我一直觉得原来的全文检索有一个遗憾，虽然可以通过多个关键词实现较为精确的查询，但还是不如正则表达式灵活和精确。
这是个蓄谋已久的需求，但直到真正做起来，才发现很多有意思的东西。虽然SQLite3提供支持正则表达式查询的“REGEX”关键词，但并没有实际实现这个功能，而是需要写程序实现并在数据库接口中注册这个函数：
```python import sqlite3 conn = sqlite3.connect('/tmp/your-database-file.db') # 使用正则表达式匹配给定内容的函数，返回布尔类型 def regexp_search(expr, item): """Check if the item has a sub-string which matches the expr""" reg = re.compile(expr) return reg.search(item) is not None # 在数据库中注册这个函数 conn.create_function('REGEXP', 2, regexp_search) cur = conn.execute('select id,title from post where content REGEXP ?', '\babc\b') row = cur.fetchone() print row conn.close() ``` 在SQLAlchemy中具体的实现方式是：
```python # 注册函数 dbe = sqlalchemy.create_engine("sqlite:///tmp/your-database-file.db") conn = dbe.connect() conn.connection.create_function('REGEXP', 2, regexp_search) # 在SQL Expression Language中创建查询条件 tbl = Post.</description></item><item><title>PHP大量常量应集中使用APC定义</title><link>http://0x3f.org/posts/define-massive-constants-using-apc/</link><pubDate>Tue, 24 Apr 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/define-massive-constants-using-apc/</guid><description>用xdebug跟踪程序性能时，发现一个定义了约七百个常量的文件，include_once()时消耗约六十毫秒的时间。事实上define()的效率比较低，如果需要定义大量常量，使用APC扩展提供的apc_define_constants()效果会好得多。
下面是对这个文件改造前后效率跟踪结果的对比：
define()方案（ms） apc_define_constants()方案（ms） 启动Web服务和PHP，第一次运行 58 4 不重启Web服务和PHP，第二次运行 65 1 不重启Web服务和PHP，第三次运行 66 1 由此可见，apc_define_constants()不但在初次调用时效能就超过define()，而且由于APC自身的缓存功能，在后续调用时效率会有进一步的提高，而define()基本没有变化。
以下是apc_define_constants()的代码示例：
```php &lt;?php if(!apc_load_constants('my_constants')) { $constants = array( 'ONE' => 1, 'TWO' => 2, 'THREE' => 3, ); apc_define_constants('my_constants', $constants); } ?> ``` Posted via UltraBlog.vim.</description></item><item><title>慎用PHP的fsockopen()连接localhost</title><link>http://0x3f.org/posts/fsockopen-fails-connecting-localhost/</link><pubDate>Tue, 24 Apr 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/fsockopen-fails-connecting-localhost/</guid><description>使用xdebug跟踪程序性能时发现fsockopen()函数耗时一秒，单步调试发现实际在这里超时了，而超时时间设置的就是一秒。
如果把目标地址由原来的“localhost”换成“127.0.0.1”，马上就可以连上。在PHP的Bug跟踪系统中找到这个问题：
https://bugs.php.net/bug.php?id=50953
看起来像是在5.2.12以后已修改，但我发现在5.2.17中仍存在这个问题。另有说法在5.3中不存在这个问题，我没有测试。
Posted via UltraBlog.vim.</description></item><item><title>UltraBlog.vim v3.3.0：I18N、超时时间和其它</title><link>http://0x3f.org/posts/ultrablog-v330-released/</link><pubDate>Sun, 15 Apr 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v330-released/</guid><description>UB一岁了，这算是个周年纪念版吧。
在这一年里，因为各种原因，博客写得没有以前多了，但每篇都是用这个插件写的，我觉得很好用。断断续续地做了一些修改，因为一切都是一个人在做，所以大的变化不多。这次这个版本里有些改动还是要感谢荒野无灯童鞋，他的建议很大程度上催生了这个新版本：比如加入保存命令的热键映射选项，这样可以使用保存普通文件的热键保存UB中的内容，我自己以前也经常习惯性地用错热键；还有socket超时时间的选项，最近我这里也经常性地在UB操作博客时报超时的异常，荒童鞋关于自定义socket超时时间的建议一语惊醒了梦中人。
此外，似乎与近期Vim的一次升级有关，在Vim中调用Python接口打印任何内容到标准IO都会导致Vim崩溃，所以这次把所有的输出都改成了调用Vim的输出命令来做。
本次修改的内容中，还有一项比较重要的内容就是实现了国际化，目前只提供英文和简体中文两种语言，由于Vimball不能处理二进制文件，所以从此以后UB改用zip格式压缩包打包。
以下是本次更新的详细内容：
Feature: Add i18n support ! Feature: Add a new option ub_hotkey_save_current_item, users can define their own hotkey for :UBSave. Feature: Add a new option ub_socket_timeout, users can customize the timeout period in seconds, useful for slow networks. Bugfix: Exception raised when one event is processed by more than one event handlers. Change: Echoing messages now uses the command :echoerr instead of python's sys.stderr, because Vim crashes on this due to an upgrade recently.</description></item><item><title>TurboCRM Cluster Express v1.0 释出</title><link>http://0x3f.org/posts/turbocrm-cluster-express-v1-released/</link><pubDate>Sun, 08 Apr 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/turbocrm-cluster-express-v1-released/</guid><description>TurboCRM Cluster Express是TurboCRM的集群实施工具。
去年我曾经写过一个配置集群的Bash脚本“cluster.sh”，TCE是对这个脚本的图形界面封装，通过可视化的操作简化集群的实施工作。
TCE的最新版本和使用说明可以在这里找到。
Posted via UltraBlog.vim.</description></item><item><title>禁止屏幕在播放视频时自动关闭</title><link>http://0x3f.org/posts/how-to-keep-monitor-active-while-watching-flv/</link><pubDate>Wed, 04 Apr 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/how-to-keep-monitor-active-while-watching-flv/</guid><description>貌似Lose系统下看在线视频的时候不会超时自动关闭屏幕，但是我在Arch下就一直晃鼠标、按键盘来著，这严重违反了DRY原则。于是昨天终于写了这个脚本，当全屏播放视频的时候，关闭屏保和显示器的节能特性，否则则激活它们。由于是在X的级别实现，理论上应当适合所有桌面环境。
```bash #!/bin/bash # Baby-sitter of the monitor's DPMS idle_period=60 ss_switch_off=0 ss_is_off=0 while true; do # Read DPMS state xset -q|grep "DPMS is Disabled" > /dev/null &amp;&amp; ss_is_off=1 || ss_is_off=0 # Get pid of the current window active_window_id=`xprop -root | grep "_NET_ACTIVE_WINDOW(WINDOW)" | cut -d" " -f5` decimal_id=`xprop -id $active_window_id | grep PID | cut -d" " -f3` # Traverse all libflashplayer.so for pid in `ps -ef|grep -v grep|grep libflashplayer.so|awk '{print $2}'`; do # If the current window is libflashplayer.</description></item><item><title>关于PyGTK.CellRenderer的回调方法中聚焦异常的问题</title><link>http://0x3f.org/posts/the-focus-issue-of-pygtk-cellrenderer/</link><pubDate>Sun, 25 Mar 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/the-focus-issue-of-pygtk-cellrenderer/</guid><description>遇到这样一个问题：
在pygtk.TreeView中，需要在一个Cell的值被修改后做一个校验，如果不合法，则重新聚焦该Cell并选中其中的内容。
示意代码如下：
```python # pygtk.CellRenderer的edited事件的回调方法 def onCellEdited(self, cell, path, newText, userData): store,colNum = userData # 使用事件驱动的设计理念，创建一个自定义的事件 evt = ServerTypeChangedEvent(self, cell, usrData) # 事件入队列 EventQueue.fireEvent(evt) # 处理事件队列，如果截获异常，提示并重新聚焦Cell try: EventQueue.processEvents() except Exception,e: self.alert(e.message) col = self.treeView.get_column(colNum-1) # 聚焦Cell，并选中Cell中的内容 self.treeView.set_cursor_on_cell(path, col, cell, True) ``` 关键的代码在最后一行，通过调用TreeView的set_cursor_on_cell方法聚焦Cell并选中其内容。但就是这一步出了问题，报如下警告：
GtkWarning: _gtk_tree_view_column_start_editing: assertion `tree_column->editable_widget == NULL' failed
此后整个TreeView的行为表现不正常，表现为可直接修改其它Cell的内容，且原Cell一直处于聚焦状态。
此问题的原因是：edited事件在Cell的输入控件被销毁前就发出了，这时在事件的回调方法中重新聚焦该Cell就导致了这个问题（详见这里）。
解决方法是借助glib.idle_add函数，在PyGTK空闲的时候再调用set_cursor_on_cell方法，由于此时原控件已被销毁，所以不会有问题。
修改后的代码如下：
```python def onCellEdited(self, cell, path, newText, userData): store,colNum = userData evt = ServerTypeChangedEvent(self, cell, usrData) EventQueue.fireEvent(evt) try: EventQueue.</description></item><item><title>YYeTs.py：人人影视BT种子下载辅助脚本</title><link>http://0x3f.org/posts/yyets-torrents-download-script/</link><pubDate>Mon, 14 Nov 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/yyets-torrents-download-script/</guid><description>这是最好的时代，这是最坏的时代。现在还有像人人影视的BT种子FTP这样的站点，实在不容易。但是所有种子列在一块，想看看最近几天都更新了甚么都很困难，于是早想写个脚本省时省力。这周末终于实现了这个想法。
主要功能 按关键词查询种子 限制查询范围为最近几天新增的 下载符合查询条件的种子，允许下载前编辑任务列表 使用说明 环境 Python 2.7，不支持Python3 Mac OS X Lion，Archlinux测试通过，理论上支持Windows 配置 如果需要编辑下载任务列表（即使用-s选项），应事先配置环境变量YYETS_EDITOR，将值设定为一个文本编辑器的路径，或者修改脚本的私有属性__editor__也一样。如果这两个位置都没有设置，则使用环境变量EDITOR。否则，将报“Command not found”的错误。
有一点提示，如果使用GVim或MacVim，需要加上选项-f，以阻塞的方式启动它，否则会导致下载结果不能达到预期。例如对于MacVim，可配置YYETS_EDITOR为：
mvim -f
使用举例 ```bash # 列出所有种子 ./yyets.py # 搜索关键词 ./yyets.py 猩球崛起 1080p # 搜索最近三天新增的种子 ./yyets.py --past=3 # 搜索最近七天内新增的、满足关键词条件的种子 ./yyets.py --past=7 蓝精灵 # 下载满足查询条件的种子 ./yyets.py -d --past=30 1080p # 下载满足查询条件的种子，下载前编辑任务列表 ./yyets.py -d -p --past=30 1080p # 更多详细信息，参阅帮助 ./yyets.py -h ./yyets.py --help ``` 下载 移步GitHub获取最新版本：
https://github.com/xbot/shell
Posted via UltraBlog.vim.</description></item><item><title>UltraBlog.vim v3.1释出：代码重构与MacVim支持</title><link>http://0x3f.org/posts/ultrablog-v310-released/</link><pubDate>Sat, 05 Nov 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v310-released/</guid><description>距离上一个版本的释出已经有三个月了，这次新版并没有增加多少功能性的内容，主要是代码的重构和对在MacVim下稳定性的改进。
对依赖关系检查的不细致导致了一些麻烦，抛出的错误信息有时与实际原因相距甚远。由于开始时是以实现功能为主，所以都是直接用函数实现的，之后修修补补，代码冗余而且维护麻烦。于是著手重构主要功能的源码，面向对象，把所有检查逻辑放到父类中去实现，子类只关注自身逻辑，最后新版减少了二百多行的代码量。
在重构的过程中偶然发现，在MacVim中，程序抛出任何异常，即便是有捕获逻辑，也会导致编辑器崩溃。在这里简略地提到：
the failure was actual a crash, through some strange combination of threading, matplotlib pyplot backend, and ssh X11 forwarding, sys.stderr had somehow been assigned to something which python complained wasn't a file-like object
于是将所有标准输出与标准错误输出语句换成另一种形式：
```python # 原形式 sys.stdout.write('xxx') sys.stderr.write('xxx') # 新形式 print >> sys.stdout, 'xxx' print >> sys.stderr, 'xxx' ``` 以上是新版主要变更的内容，此外，也顺便解决了开发过程中发现的个别Bug和做了其它一些改动：
Change: The key "xmlrpc" of the settings list is dropped, a new one with the name "</description></item><item><title>Enable Code Snippet Highlighting For UltraBlog.vim Templates</title><link>http://0x3f.org/posts/enable-code-snippet-highlighting-for-ultrablog-vim-templates/</link><pubDate>Sat, 27 Aug 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/enable-code-snippet-highlighting-for-ultrablog-vim-templates/</guid><description>Templates make it possible for users previewing posts in custom formats in UltraBlog.vim. However, there is more you can do with our highly customizable templates. This article discusses how to highlight code snippets in posts by the use of some third-party open-source tools.
Before setting out to work, let me introduce the tools we are about to use:
highlight.js: A javascript library which highlights code blocks in web pages automatically. jquery: The famous RIA development javascript library.</description></item><item><title>UltraBlog.vim v3.0释出：全文检索与事件驱动</title><link>http://0x3f.org/posts/ultrablog-v300-released/</link><pubDate>Mon, 25 Jul 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v300-released/</guid><description>用了一周的业余时间，昨天我释出了UltraBlog.vim的3.0版。新版本主要加入了全文检索的功能，并引入事件驱动的模式。
全文检索是我蓄谋已久的功能，一个不能搜索的博客客户端的管理功能是大打折扣的。得益于SQLite数据库和SQLAlchemy框架，全文检索的实现是很简单的，新增加的:UBFind命令将在所有文章和页面的标题与内容中查询，并将搜索结果显示在一个可分页的列表中。这个命令支持任意多个关键词，各关键词之间遵循与的关系。此外，检索结果中，所有的关键词将被自动标记为高亮。
事件驱动模式的引入是我悍然将版本号跳跃到3.x的主要原因。
在前几个版本中，我实现了对多窗口的支持，它使得用户可以在新窗口中打开列表中的文章。但UltraBlog.vim最初开发的时候并没有考虑到多窗口的问题，所有命令都只针对当前窗口进行操作。这就有了缓冲区内容同步的问题，假如在一个新的缓冲区中打开了和另一个缓冲区相同的文章，则一个缓冲区内容的改变不会同步到另外一个中，这多少是有些隐患的。
最直接的做法是在所有可能改变缓冲区内容的功能中加入对其它缓冲区的处理，但这样做有不少问题：
代码耦合度太高，违反K.I.S.S原则，不利于今后的开发和维护 函数体过长，我讨厌难看的代码 代码冗余，重复劳动 事件驱动模式可以很好的解决以上问题，一个函数只干一件事，做完后一个事件抛出去，至于连带著要做什么，谁监听这个事件谁去处理，代码的耦合度很低，复用度很高，易于维护和阅读。
UltraBlog.vim引入事件驱动模式处理缓冲区同步的问题。不同的操作抛出不同的事件，所有的事件继承自父类UBEvent：
```python class UBEvent: def __init__(self, srcObj): self.srcObj = srcObj class UBDebugEvent(UBEvent): pass class UBTmplDelEvent(UBEvent): pass class UBTmplSaveEvent(UBEvent): pass class UBLocalPostDelEvent(UBEvent): pass class UBRemotePostDelEvent(UBEvent): pass class UBPostSendEvent(UBEvent): pass class UBPostSaveEvent(UBEvent): pass ``` 一个可能改变缓冲区内容的操作执行完后，创建一个特定的事件并将其加入到事件队列中。事件队列类中存放两个列表，一是事件队列，二是事件监听器列表；提供三个方法，分别用来注册事件监听器、对事件执行入队列操作和处理队列中所有事件：
```python class UBEventQueue: queue = [] listeners = [] @classmethod def fireEvent(cls, evt): cls.queue.append(evt) @classmethod def processEvents(cls): for evt in cls.queue: for listener in cls.listeners: if listener.isTarget(evt): cls.queue.remove(evt) listener.</description></item><item><title>APC、文件和Memcached效率对比</title><link>http://0x3f.org/posts/comparison-of-efficiency-for-apc-file-memcached/</link><pubDate>Wed, 13 Jul 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/comparison-of-efficiency-for-apc-file-memcached/</guid><description>对一个保存了100个对象实例的数组进行300次读写，该数组序列化后大小为232KB。
测试环境 网络服务器 PHP版本 操作系统 硬件配置 NGINX v1.0.4 PHP-FPM v5.3.6
APC启用 Archlinux 32bit Intel(R) Core(TM)2 Duo CPU T9400 @ 2.53GHz
Mem: 3G DDR3
Disk: 5400r/s 测试脚本 测试数据：
```php &lt;?php /* * @file data.php */ class XTest { var $x0; var $x1; var $x2; var $x3; var $x4; var $x5; var $x6; var $x7; var $x8; var $x9; var $x10; var $x11; var $x12; var $x13; var $x14; var $x15; var $x16; var $x17; var $x18; var $x19; var $x20; var $x21; var $x22; var $x23; var $x24; var $x25; var $x26; var $x27; var $x28; var $x29; var $x30; var $x31; var $x32; var $x33; var $x34; var $x35; var $x36; var $x37; var $x38; var $x39; var $x40; var $x41; var $x42; var $x43; var $x44; var $x45; var $x46; var $x47; var $x48; var $x49; var $x50; var $x51; var $x52; var $x53; var $x54; var $x55; var $x56; var $x57; var $x58; var $x59; var $x60; var $x61; var $x62; var $x63; var $x64; var $x65; var $x66; var $x67; var $x68; var $x69; var $x70; var $x71; var $x72; var $x73; var $x74; var $x75; var $x76; var $x77; var $x78; var $x79; var $x80; var $x81; var $x82; var $x83; var $x84; var $x85; var $x86; var $x87; var $x88; var $x89; var $x90; var $x91; var $x92; var $x93; var $x94; var $x95; var $x96; var $x97; var $x98; var $x99; function __construct() { $this->x0 = 1234567890; $this->x1 = 1234567890; $this->x2 = 1234567890; $this->x3 = 1234567890; $this->x4 = 1234567890; $this->x5 = 1234567890; $this->x6 = 1234567890; $this->x7 = 1234567890; $this->x8 = 1234567890; $this->x9 = 1234567890; $this->x10 = 1234567890; $this->x11 = 1234567890; $this->x12 = 1234567890; $this->x13 = 1234567890; $this->x14 = 1234567890; $this->x15 = 1234567890; $this->x16 = 1234567890; $this->x17 = 1234567890; $this->x18 = 1234567890; $this->x19 = 1234567890; $this->x20 = 1234567890; $this->x21 = 1234567890; $this->x22 = 1234567890; $this->x23 = 1234567890; $this->x24 = 1234567890; $this->x25 = 1234567890; $this->x26 = 1234567890; $this->x27 = 1234567890; $this->x28 = 1234567890; $this->x29 = 1234567890; $this->x30 = 1234567890; $this->x31 = 1234567890; $this->x32 = 1234567890; $this->x33 = 1234567890; $this->x34 = 1234567890; $this->x35 = 1234567890; $this->x36 = 1234567890; $this->x37 = 1234567890; $this->x38 = 1234567890; $this->x39 = 1234567890; $this->x40 = 1234567890; $this->x41 = 1234567890; $this->x42 = 1234567890; $this->x43 = 1234567890; $this->x44 = 1234567890; $this->x45 = 1234567890; $this->x46 = 1234567890; $this->x47 = 1234567890; $this->x48 = 1234567890; $this->x49 = 1234567890; $this->x50 = 1234567890; $this->x51 = 1234567890; $this->x52 = 1234567890; $this->x53 = 1234567890; $this->x54 = 1234567890; $this->x55 = 1234567890; $this->x56 = 1234567890; $this->x57 = 1234567890; $this->x58 = 1234567890; $this->x59 = 1234567890; $this->x60 = 1234567890; $this->x61 = 1234567890; $this->x62 = 1234567890; $this->x63 = 1234567890; $this->x64 = 1234567890; $this->x65 = 1234567890; $this->x66 = 1234567890; $this->x67 = 1234567890; $this->x68 = 1234567890; $this->x69 = 1234567890; $this->x70 = 1234567890; $this->x71 = 1234567890; $this->x72 = 1234567890; $this->x73 = 1234567890; $this->x74 = 1234567890; $this->x75 = 1234567890; $this->x76 = 1234567890; $this->x77 = 1234567890; $this->x78 = 1234567890; $this->x79 = 1234567890; $this->x80 = 1234567890; $this->x81 = 1234567890; $this->x82 = 1234567890; $this->x83 = 1234567890; $this->x84 = 1234567890; $this->x85 = 1234567890; $this->x86 = 1234567890; $this->x87 = 1234567890; $this->x88 = 1234567890; $this->x89 = 1234567890; $this->x90 = 1234567890; $this->x91 = 1234567890; $this->x92 = 1234567890; $this->x93 = 1234567890; $this->x94 = 1234567890; $this->x95 = 1234567890; $this->x96 = 1234567890; $this->x97 = 1234567890; $this->x98 = 1234567890; $this->x99 = 1234567890; } } $repeat = 300; $arr = array(); for ($i = 0; $i &lt; 100; $i++) { $arr[] = new XTest; } ?</description></item><item><title>隐藏InstallShield对话框控件的方法</title><link>http://0x3f.org/posts/how-to-hide-dialog-in-installshield/</link><pubDate>Wed, 22 Jun 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/how-to-hide-dialog-in-installshield/</guid><description>SQLServerSelectLogin对话框中如果选择Windows身份验证，在附加数据库时会因权限不够而失败，所以应该隐藏这个选项，从而要求用户只执行SQL身份验证。
但是如果在定制对话框布局时直接删除两个单选框，会导致用户输入的用户名和密码不能被安装程序获取，并且InstallShield也没有提供隐藏这些控件的属性。解决方法是修改控件的定位属性，将其定位到对话框的大小范围之外：
要达到的目标：
修改Top属性，将指定的控件定位在对话框之外：
最终效果：
Posted via UltraBlog.vim.</description></item><item><title>UltraBlog.vim v2.3.0 Released With Templates</title><link>http://0x3f.org/posts/ultrablog-v230-released/</link><pubDate>Mon, 13 Jun 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-v230-released/</guid><description>I released the new version 2.3.0 of UltraBlog.vim last week. The main improvement in this version is that templates are introduced in.
Templates are simply HTML strings, they are used to preview posts/pages in the browser locally. This feature is a reparation for the remote previewing, due to the limit of the API, users cannot send a post to Wordpress as draft and preview it without affecting the post status if the post has been published.</description></item><item><title>Vim自定义命令的参数自动补全</title><link>http://0x3f.org/posts/how-to-define-auto-completion-for-vim-commands/</link><pubDate>Sat, 11 Jun 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/how-to-define-auto-completion-for-vim-commands/</guid><description>UltraBlog.vim起初的几个版本采用增加命令个数的方式减少每个命令的参数个数，目的是降低命令格式记忆的难度。从2.3.0版本起，开始采用Vim自定义命令的一些高级特性，精简命令个数，虽然参数个数增加了，但由于实现了参数补全，反而更加直观。
Vim对自定义命令提供了多种补全参数的方式，详见:h command-complete。其中，最常用的当属custom：
```vim command! -nargs=? -complete=custom,StatusCmpl UBSend exec('py ub_send_item()') ``` 以上代码定义了一个自定义命令UBSend，它可以获得一个或零个参数（-nargs=?），如果指定参数，则补全方式采用custom，该方式调用一个名为StatusCmpl的函数并以其返回值作为补全的值域：
```vim function! StatusCmpl(ArgLead, CmdLine, CursorPos) return "draft\npublish\nprivate\npending\n" endfunction ``` 从以上代码可以看出，该函数需要接受三个参数，返回值应该是一个用换行符“\n”分割的字符串，在执行补全时，Vim自动使用正则表达式匹配备选项。对于只有一个参数的情况，这种实现方式简单高效。
对于参数较多的情况，customlist补全方式最为适用：
```vim command! -nargs=* -complete=customlist,UBNewCmpl UBNew exec('py ub_new_item()') ``` 以上代码定义了命令UBNew，customlist补全方式调用函数UBNewCmpl获取补全的值域：
```vim function! UBNewCmpl(ArgLead, CmdLine, CursorPos) let lst = split(a:CmdLine) if len(a:ArgLead)>0 let lst = lst[0:-2] endif let results = [] " For the first argument, complete the object type if len(lst)==1 let objects = ['post','page','tmpl'] for obj in objects if stridx(obj,a:ArgLead)==0 call add(results,obj) endif endfor "</description></item><item><title>人性化Vim的预览窗口</title><link>http://0x3f.org/posts/humanize-preview-window-in-vim/</link><pubDate>Sun, 29 May 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/humanize-preview-window-in-vim/</guid><description>Vim的预览窗口由 :ptag 等命令触发，可用于预览函数定义。但在缺省情况下，预览窗口的高度是固定的，对于注释信息较多的函数，往往不能完全显示注释，而对于注释较少的函数，又会有多余的行浪费屏幕空间。
下面的函数用于解决这个问题：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 &amp;#34; 调用:ptag命令预览光标所在&amp;lt;word&amp;gt;的定义 &amp;#34; 对类C语言风格的函数/方法定义和注释有效，对其余情况仍沿用:ptag的原有效果 function! PTagIt() exec &amp;#34;ptag &amp;#34;.expand(&amp;#34;&amp;lt;cword&amp;gt;&amp;#34;) let cwin = winnr() silent! wincmd P let lnr = line(&amp;#39;.&amp;#39;) if lnr &amp;lt; 3 return endif if foldlevel(&amp;#39;.</description></item><item><title>PHP序列化方案效率比较</title><link>http://0x3f.org/posts/comparison-of-serialization-methods-of-php/</link><pubDate>Sun, 17 Apr 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/comparison-of-serialization-methods-of-php/</guid><description>同时对以下几种PHP的序列化方案进行了测试：
serialize() and unserialize() json_encode() and json_decode() msgpack_serialize() and msgpack_unserialize() igbinary_serialize() and igbinary_unserialize() 测试环境：
OS: Archlinux 32-bit CPU: CORE 2 DUO T9400, 2.53GHz Mem: DDR3, 3G Server: nginx v1.0.0 PHP: php v5.3.6 + php-fpm Profiler: xhprof v0.9.2 测试代码块：
```php &lt;?php class Test{ function __construct(){ $this->value = str_repeat('a', 1000); } } function produce($num) { $arr = array(); for ($i = 0; $i &lt; $num; $i++) { $arr[] = new Test(); } $data = serialize($arr); $arr = unserialize($data); $data = json_encode($arr); $arr = json_decode($data); $data = msgpack_serialize($arr); $arr = msgpack_unserialize($data); $data = igbinary_serialize($arr); $arr = igbinary_unserialize($data); } produce(10000); ?</description></item><item><title>UltraBlog.vim开发手记</title><link>http://0x3f.org/posts/ultrablog-development-note/</link><pubDate>Mon, 11 Apr 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-development-note/</guid><description>对于博客已死的说法，我一点都不感到奇怪。早在几年前博客还比较火的时候我就表达过对博客泡沫的看法。
经历了短暂的tumblog的风头，微博成为现在最火的媒介。说博客已死，无非就是说微博将成为个人信息传播的主流。好吧，现在我知道那时候我所说的不懂什么是博客的人都去干什么了。
但是博客还是会继续发展，微博的兴起只会减少滥竽充数。因为微博突出的是时效性，最缺乏的是系统性和可重复更新的能力。微博的短处，正是博客的长处。这让我对博客有了一个新的、迟到了很久的认识──一个好的博客，它的文章不应该是写掉就忘的，而应该是不断地更新著的。
UltraBlog.vim就是出于这个需要而写的。
我对博客客户端的使用大概可以追溯到四五年前，那时候博客正火，在比较了几个BSP后选择了中国博客网，就是因为他们提供桌面客户端。后来独博之后也试用过几个通用的客户端，但都没坚持多久，最根本的原因是它们几乎无一例外地都是WYSIWYG。而WYSIWYG的编辑器生成的HTML源码几乎都使用inline的样式，这就导致文章的排版布局很难控制，我对WYSIWYG其实是很抵触的，至今都不怎么用Office这类东西。
后来我意识到，我所需要的是样式与内容分离，于是准备自己写一个客户端，后来由于工作的原因不了了之。与此同时，我自定义了一套文章格式并用Java写了一个转换文章到HTML的工具，直到后来发现Markdown，我才知道我其实是需要一个轻量标记语言。
使用Markdown之后，写博客开始变得轻松愉快。我一度用过一段时间SciTE，还用Lua写了个辅助脚本。但是我需要一个完整的客户端来管理文章，而这是一个编辑器所不能胜任的，所以就著手实现一个支持Markdown的客户端。这一次走得比较远，ForeverFantasy最终达到了可用的程度，我一度用它写过一段时间的博客。但是作为一个Vim重症患者，wxPython的编辑器部件是远远达不到我需要的水平的。虽然后来还实现了调用外部程序处理文章内容（当然也可以调用Vim），但总归觉得不舒服，至今已经一年没更新了。
直到前段时间试用了一下VimRepress，在修改这个插件的时候突然受到启发，我这几年的需求原来是可以这么简单地解决的。
其实在几年前vimpress刚刚发布的时候我就了解过这个东西，包括此后接连发布的几个Vim写博客的插件，它们和我原来写的SciTE的那个辅助脚本没有本质的区别，都是博客编辑器。与完整的客户端相比，编辑器缺少对本地文章源码的管理，而且它们不记录文章源码和发布的文章的关联关系，简单地说是无状态的。这不符合博客文章持续更新的观点。
UltraBlog.vim使用SQLAlchemy做数据库抽象层，将所有文章的源码及其状态保存在本地的一个SQLite数据库中，并且以此为基础，通过XMLRPC接口实现对博客文章、页面的CRUD操作。同时利用Vim分模式的特点实现了可分页的文章列表和文章编辑视图。
UltraBlog.vim目前支持Markdown和HTML两种格式的文章，它最大的特点是在Markdown格式的源码和发布到博客中的文章之间建立联系，你可以随时修改本地数据库中的Markdown源码并更新博客中对应的文章。
新的功能还会不断地加入。
Posted via UltraBlog.vim.</description></item><item><title>UltraBlog.vim: Ultimate Vim Blogging Plugin</title><link>http://0x3f.org/posts/ultrablog-as-an-ultimate-vim-blogging-plugin/</link><pubDate>Sat, 02 Apr 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/ultrablog-as-an-ultimate-vim-blogging-plugin/</guid><description>Introduction UltraBlog.vim is yet another Vim blogging script for Wordpress.
The biggest difference between UB and other similar scripts is that UB is an ultimate client, which stores posts locally in an SQLite database, while others just operate remotely. In this way, many things can be done easily by the advantage of local storage and many other utilities, for example, you can search for posts stored in the database with a few keywords by typing a simple command, also you can preview drafts with any of your favorite templates as soon as you want to.</description></item><item><title>Batch Cat v0.3 Released</title><link>http://0x3f.org/posts/batchcat-v03-released/</link><pubDate>Sun, 20 Mar 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/batchcat-v03-released/</guid><description>Change Log 2011-03-20 Sunday Solve the compatibility problem under Wordpress 3.1, thanks to wongkediri. Check the plugin&amp;rsquo;s page for more information.</description></item><item><title>使用Vim写博客</title><link>http://0x3f.org/posts/blogging-with-vim/</link><pubDate>Sat, 19 Mar 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/blogging-with-vim/</guid><description>VimRepress是Vim写博客的插件中较新的一个，是久未更新的Vimpress的一个衍生版。
虽然不是所有此类插件中功能最多的一个，但VimRepress非常实用，除包含最常用的几个功能外，还支持Markdown。但是当前版本的VimRepress在转换Markdown格式的字符串到HTML时，是通过直接调用外部命令markdown来实现的，这显然只是针对Linux（及其它类UNIX）系统设计的。
为了使VimRepress支持在Windows下使用Markdown写文章，可以对它做一些改进。
修改VimRepress的源文件blog.vim，在if __name__ == "__main__":这一行的上方加入如下两个函数：
```python def markdown_preview2(): import sys reload(sys) sys.setdefaultencoding('utf-8') import markdown2 as mkd global vimpress_temp_dir if vimpress_temp_dir == '': vimpress_temp_dir = tempfile.mkdtemp(suffix="vimpress") temp_htm = os.path.join(vimpress_temp_dir, "vimpress_temp.htm") html_heads = \ """&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> """ tmp_file = open(temp_htm, 'w') tmp_file.write(html_heads) txt = "\n".join(vim.current.buffer[:]) #txt = unicode(txt,'cp936') tmp_file.write(mkd.markdown(txt)) #tmp_file.write(mkd.markdown("\n".join(vim.current.buffer[:]))) tmp_file.close() webbrowser.open("file://%s" % temp_htm) def markdown_newpost2(): import sys reload(sys) sys.setdefaultencoding('utf-8') import markdown2 as mkd global vimpress_temp_dir if vimpress_temp_dir == '': vimpress_temp_dir = tempfile.</description></item><item><title>Dumperor v1.0.0 Released</title><link>http://0x3f.org/posts/dumperor-v100-released/</link><pubDate>Tue, 15 Mar 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/dumperor-v100-released/</guid><description>Changelog 2011-03-14 Now Dumperor is stable enough. Add the abillity to export table structures or data to a human readable format, which is suit for comparing. Add the abillity to manage multiple configurations. Add a desktop application to sort the human readable output file of table structures, written in python and tk. Check the main page for more information.</description></item><item><title>Anti Artificial Spam v0.2 Released</title><link>http://0x3f.org/posts/anti-artificial-spam-v02-released/</link><pubDate>Thu, 24 Feb 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/anti-artificial-spam-v02-released/</guid><description>Change Log 2011-02-23 Wednesday 22:24:12 Rename anti-manpower-spam to anti-artificial-spam. Don't just test if the URL is in the banned ones, but also test if it is a substring of one of them. Optimize the speed of matching. Check the plugin&amp;rsquo;s page for more information.</description></item><item><title>Oracle中对LOB字段的操作方法</title><link>http://0x3f.org/posts/oracle-lob-operations/</link><pubDate>Fri, 07 Jan 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/oracle-lob-operations/</guid><description>在Oracle中插入或更新LOB字段时，可以将字符串以如下方式写入SQL语句：
1 insert tbl_lob (fld_lob) values (utl_raw.cast_to_raw(&amp;#39;hello world&amp;#39;)); 这样做的限制是：
Oracle中单条SQL语句有长度限制 cast_to_raw()对字符串有长度限制 因此如果要插入或更新的字符串过长，会导致执行失败。此时应该使用dbms_lob处理LOB相关字段。下面是利用dbms_lob更新一个BLOB字段的存储过程，对CLOB的操作同理：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 create or replace procedure updateblob( ctbl in varchar2, cfld in varchar2, cstr in varchar2, ccond in varchar2 ) is vqry varchar2(1000); vblob blob; vbatch varchar2(2000); vstrlen number; voffset number :=1; vamt number :=2000; begin vstrlen := length(cstr); vqry := &amp;#39;update &amp;#39;||ctbl||&amp;#39; set &amp;#39;||cfld||&amp;#39;=empty_blob() where &amp;#39;||ccond; execute immediate vqry; vqry := &amp;#39;select &amp;#39;||cfld||&amp;#39; from &amp;#39;||ctbl||&amp;#39; where &amp;#39;||ccond||&amp;#39; for update&amp;#39;; execute immediate vqry into vblob; if vstrlen&amp;gt;vamt then while vstrlen&amp;gt;voffset loop vbatch := substr(cstr, voffset, vamt); voffset := voffset+vamt; dbms_lob.</description></item><item><title>Batch Cat v0.2 Released</title><link>http://0x3f.org/posts/batchcat-v02-released/</link><pubDate>Sun, 12 Dec 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/batchcat-v02-released/</guid><description>Change Log 2010-12-12 Sunday Add the ability to append the selected categories to posts Add the ability to delete the selected categories from posts Check the plugin&amp;rsquo;s page for more information.</description></item><item><title>DonkeyBuddy: A Chrome Extension for MLDonkey</title><link>http://0x3f.org/posts/donkeybuddy-a-chrome-extension-for-mldonkey/</link><pubDate>Fri, 24 Sep 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/donkeybuddy-a-chrome-extension-for-mldonkey/</guid><description>DonkeyBuddy is an extension for Google Chrome Browser. It's intended to make life easier when you add downloading tasks to MLDonkey.
Features Users can choose how to interact with MLDonkey, either by AJAX or popup windows. The AJAX mode interacts with MLDonkey by AJAX requests and uses desktop notifications to show the results, so it won't bother you by popping up windows and forcing you to close them. The popup-window mode interacts with MLDonkey by popping up a window and displays results in it, this is always a reliable way to add downloads but annoying.</description></item><item><title>Dumperor: Multi-Database Dumping Toolkit</title><link>http://0x3f.org/posts/dumperor-as-a-multidb-dumping-tool/</link><pubDate>Thu, 23 Sep 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/dumperor-as-a-multidb-dumping-tool/</guid><description>Dumperor is a multi-database dumping toolkit. It dumps table structures and data from databases, and generates CREATE-TABLE SQL statements for table structures or INSERT SQL statements for data.
Part of the original intention for developing Dumperor is to check whether a migration of SQL scripts from one database to another is successful, you know, by comparing the differences between two files, one dumped before executing scripts and the other after.</description></item><item><title>WordPress Plugin: Batch Cat</title><link>http://0x3f.org/posts/wp-batchcat/</link><pubDate>Sat, 04 Sep 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/wp-batchcat/</guid><description>Introduction Batch Cat is intended to help users change categories of posts in bulk.
The main features are:
Assign the selected categories to posts. Append the selected categories to posts. Delete the selected categories from posts. Intuitionistic operating manners which come up with people's common practice. Configurable number of posts listed in one page. Slimming but enough searching and sorting options. More in the future. Screenshot Installation &amp; Usage As usual, upload the folder of Batch Cat to the wordpress plugin directory, activate it then.</description></item><item><title>批量下载视频的BASH脚本</title><link>http://0x3f.org/posts/a-bash-script-downloading-videos-in-batch/</link><pubDate>Sat, 28 Aug 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/a-bash-script-downloading-videos-in-batch/</guid><description>两周前为了批量下载某视频网站中的电视剧，写了个BASH脚本。将电视剧列表页面的URL地址作为唯一参数传给脚本，然后就会把所有视频下载到当前目录下，并自动重命名，同时生成一个M3U格式的播放列表。
由于在线视频不支持断点续传，所以对于单个视频来说无法实现。但对于整个批量下载任务来说，实现了宏观上的断点续传，已经下载的视频不会被重复下载。由于有些视频网站会在午夜更改视频地址，所以这一点很有用。
主流视频网站应该是都支持的，我只测试了我下载电视剧的网站，不支持的都是非主流的！
唯一可能需要注意的依赖是PHP，必须安装后才能使用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #!</description></item><item><title>InstallShield在MySQL和Oracle中执行SQL脚本的方法</title><link>http://0x3f.org/posts/howto-run-sql-scripts-in-mysql-oracle-within-installshield/</link><pubDate>Tue, 24 Aug 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/howto-run-sql-scripts-in-mysql-oracle-within-installshield/</guid><description>简述 InstallShield已经内建了对MySQL和Oracle的支持。但是这个功能是通过ODBC实现的，它对SQL脚本的格式要求非常严格，因此已经通过官方客户端测试的脚本在IS中执行时往往就会报错。
一般来说，数据库脚本只保证通过官方客户端测试即可，同时维护一份供IS执行的脚本费时费力。因此，考虑安装程序对两数据库的支持通过官方客户端实现。
MySQL
function InstallMySQLComponent(szComponent) NUMBER nResult; STRING szServer,szDB,szUser,szPassword,sCMD,sOPT,sResult1,sResult2,svLine,sMsg,sPath; NUMBER nvFileHandle,nvCount; LIST listStatus; begin sMsg = &amp;#39;安装&amp;#39;+szComponent+&amp;#39; ...&amp;#39;; SdShowMsg(sMsg, TRUE); // source命令不认识windows路径中的反斜杠，故将SRCDIR中的反斜杠替换成斜杠 sPath = SRCDIR; StrReplace(sPath, &amp;#39;\\&amp;#39;, &amp;#39;/&amp;#39;, 0); // Fetch database connection information SQLRTGetConnectionInfo( &amp;#39;mysql&amp;#39;, szServer, szDB, szUser, szPassword ); sCMD = WINSYSDIR^&amp;#39;cmd.exe&amp;#39;; sOPT = &amp;#39; /c &amp;#39;+SRCDIR^&amp;#39;mysql.exe -h&amp;#39;+szServer+&amp;#39; -u&amp;#39;+szUser+&amp;#39; -p&amp;#39;+szPassword+&amp;#39; -D&amp;#39;+szDB; sOPT = sOPT+&amp;#39; -e &amp;#34;source &amp;#39;+sPath^szComponent+&amp;#39;.sql&amp;#34; &amp;gt; &amp;#39;+SRCDIR^&amp;#39;dbstatus.txt 2&amp;gt;&amp;amp;1&amp;#39;; // Execute the script associated with the given component in database nResult=LaunchAppAndWait(sCMD, sOPT, WAIT|LAAW_OPTION_HIDDEN); if (nResult &amp;lt; 0) then MessageBox(&amp;#39;Failed installing &amp;#39;+szComponent+&amp;#39; !</description></item><item><title>用JavaScript实现分页打印</title><link>http://0x3f.org/posts/howto-do-paged-printing-using-javascript/</link><pubDate>Sat, 19 Jun 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/howto-do-paged-printing-using-javascript/</guid><description>最近客户提的一个需求，要实现分页打印功能。公司产品对打印功能实现得不够好，排版全由程序生成，耦合度高，且不支持分页，需要用笨拙的方法变通。
于是我对如何更好地实现分页打印产生了兴趣，Google了一下，整理了一个Demo：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html;charset=utf-8&amp;#34;/&amp;gt; &amp;lt;style media=print&amp;gt; .Noprint{display:none;} .PageNext{page-break-after: always;} &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;OBJECT id=WebBrowser classid=CLSID:8856F961-340A-11D0-A96B-00C04FD705A2 height=0 width=0 VIEWASTEXT&amp;gt; &amp;lt;/OBJECT&amp;gt; &amp;lt;div class=&amp;#34;Noprint&amp;#34;&amp;gt; &amp;lt;input onclick=document.all.WebBrowser.ExecWB(6,1) type=button value=打印 name=Button&amp;gt; &amp;lt;input onclick=document.all.WebBrowser.ExecWB(7,1) type=button value=打印预览 name=Button&amp;gt; &amp;lt;input onclick=document.all.WebBrowser.ExecWB(8,1) type=button value=页面设置 name=Button4&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;PageNext&amp;#34;&amp;gt; &amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;雅游&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt; &amp;lt;p&amp;gt;旧院人称曲中，前门对武定桥，后门在钞库街。妓家鳞次，比屋而居。屋宇精洁，花木萧疏，迥非尘境。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;到门则铜环半启，珠箔低垂;升阶则猧儿吠客，鹦哥唤茶；登堂则假母肃迎，分宾抗礼；&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;进轩则丫鬟毕妆，捧艳而出；坐久则水陆备至，丝肉竞陈；定情则目眺心挑，绸缪宛转。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;纨绔少年，绣肠才子，无不魂迷色阵，气尽雌风矣。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;妓家，仆婢称之曰娘，外人呼之曰小娘，假母称之曰娘儿。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;有客称客曰姐夫，客称假母曰外婆。&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;PageNext&amp;#34;&amp;gt; &amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;木兰花令·拟古决绝词&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt; &amp;lt;center&amp;gt;&amp;lt;h3&amp;gt;清·纳兰容若&amp;lt;/h3&amp;gt;&amp;lt;/center&amp;gt; &amp;lt;p&amp;gt;人生若只如初见，何事秋风悲画扇。等闲变却故人心，却道故人心易变!</description></item><item><title>中转feedburner订阅数图标</title><link>http://0x3f.org/posts/howto-display-feedburner-subscription-image/</link><pubDate>Mon, 14 Jun 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/howto-display-feedburner-subscription-image/</guid><description>利用国外服务器中转feedburner的图标：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &amp;lt;?php /* * 将$fburl替换为自己的feedburner订阅数图片地址，然后将博客中的图片地址换成此脚本的URL即可 */ $fburl = &amp;#39;http://feeds.feedburner.com/~fc/leninlee?bg=99CCFF&amp;amp;amp;fg=444444&amp;amp;amp;anim=0&amp;#39;; $fbfl = &amp;#39;fb.gif&amp;#39;; $fp = fopen($fburl, &amp;#39;rb&amp;#39;); if ($fp) { $fp_local = fopen($fbfl, &amp;#39;wb&amp;#39;); if ($fp_local) { while (!feof($fp)) { fwrite($fp_local, fread($fp, 1024*8), 1024*8); } fclose($fp_local); } fclose($fp); } header(&amp;#39;Location: &amp;#39;.$fbfl); ?&amp;gt; 或者：
1 2 3 4 &amp;lt;?php header(&amp;#39;Content-Type: image/gif&amp;#39;); readfile(&amp;#39;http://feeds.feedburner.com/~fc/leninlee?bg=99CCFF&amp;amp;fg=444444&amp;amp;anim=0&amp;#39;); ?&amp;gt;</description></item><item><title>Inno Setup执行SQL脚本的方法</title><link>http://0x3f.org/posts/howto-execute-sql-scripts-in-inno-setup/</link><pubDate>Mon, 17 May 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/howto-execute-sql-scripts-in-inno-setup/</guid><description>作为和NSIS并立的、两个最流行的免费Windows应用程序安装包制作工具之一，Inno在学习难度上相对要低一些，非常适合对一些简单的桌面程序打包。但对于较复杂的安装过程，或者Web应用程序来说，我个人觉得不是Inno的强项。当然，既然Inno内嵌了Pascal语言用以扩展功能，理论上不是不可以应付复杂的安装过程，但实现起来要复杂一些。
比如对于在安装过程中连接数据库并执行SQL脚本这样的需求，使用InstallShield应该会简单地多，而Inno却不支持直接操作数据库，并且相关的资料说明少之又少，还不如NSIS丰富，以至于我踏破铁鞋无觅处，最终却在NSIS的资料中找到了思路。
主要的思路是，在安装过程中，调用数据库客户端连接数据库并执行SQL脚本，然后将执行结果或错误信息输出到文件中，最后通过分析这个文件来判断命令执行的结果。但是，既然是调用特定的客户端，那么对不同数据库的操作自然就有所区别，具体情况如下所述。
首先在打包脚本的[Files]段将必需的文件包含进来：
```ini [Files] Source: "D:\Development\MyDemoApp\code\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs Source: "D:\Development\MyDemoApp\sqlcmd.exe"; Flags: dontcopy Source: "D:\Development\MyDemoApp\sqlcmd.rll"; Flags: dontcopy Source: "D:\Development\MyDemoApp\mysql.exe"; Flags: dontcopy Source: "D:\Development\MyDemoApp\script_mssql.sql"; Flags: dontcopy Source: "D:\Development\MyDemoApp\script_mysql.sql"; Flags: dontcopy Source: "D:\Development\MyDemoApp\script_oracle.sql"; Flags: dontcopy ``` 在SQL Server中执行脚本的代码片断：
```pascal function ExecScriptInMSSQL(DBHost, DBLogin, DBPass, DBName: String): Boolean; var ConnectExe: String; ConnectParam: String; begin {解压临时文件} ExtractTemporaryFile('sqlcmd.exe'); ExtractTemporaryFile('sqlcmd.rll'); ExtractTemporaryFile('script_mssql.sql'); {构造数据库连接字符串} ConnectExe := ExpandConstant('{tmp}') + '\sqlcmd.exe'; ConnectParam := ' -S ' + DBHost + ' -U ' + DBLogin + ' -P ' + DBPass + ' -d ' + DBName + ' -i script_mssql.</description></item><item><title>强大的工具函数库：php.js</title><link>http://0x3f.org/posts/phpjs/</link><pubDate>Sat, 24 Apr 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/phpjs/</guid><description>PHP最大的特点在于它拥有一个丰富、灵活、强大的函数库，因此得以机动灵活成为软件开发语言中的轻骑兵。
php.js是一个用Javascript实现的函数库，它试图用Javascript最大程度地重写PHP的函数库。相对于JQuery、ExtJS这些Javascript库，php.js不并致力于为AJAX、DOM和界面开发提供一揽子解决方案，它只是将PHP函数的强大和简便带到前端开发中来，由于JQuery这样的库并不旨在提供完全的Javascript开发标准和手段，实际上，它弥补了这些高端的工具库与低端的Javascript开发之间的一个空白。
对于熟悉PHP的人尤其是PHP程序员来说，使用php.js是几乎不需要切换思维方式的。
这是使用php实现的日期格式校验函数：
```php function IsValidDate($strDate, $strFormat='Y-m-d') { $strDate = trim($strDate); $unixTime = strtotime($strDate); $strNewDate = date($strFormat, $unixTime); return $strDate == $strNewDate; } ``` 这是使用php.js实现的日期格式校验函数：
```javascript function IsValidDate(strDate, strFormat) { strDate = trim(strDate); var unixTime = strtotime(strDate); var strNewDate = date(strFormat, unixTime); return strDate == strNewDate; } ```</description></item><item><title>使用cx_Freeze的distutils脚本打包Python程序</title><link>http://0x3f.org/posts/cx-freeze/</link><pubDate>Fri, 26 Mar 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/cx-freeze/</guid><description>cx_Freeze打包Python程序的命令基本格式如下：
```python cxfreeze main.py --target-dir appdir ``` 它表示把脚本main.py或以main.py为程序入口的程序打包并导出到当前路径中名为appdir的目录中。
对于Windows下的GUI应用程序，以上面的命令导出后，运行时会弹出cmd命令行的黑窗口，须加上如下命令中的参数：
```python cxfreeze main.py --target-dir appdir --base-name=win32gui ``` 对于比较复杂的程序，cx_Freeze支持distutils格式的打包脚本，当然，彼此之间在引入的模块和支持的参数上还是有差别的。
cx_Freeze的文档中有其支持的全部命令参数及说明，写到setup.py脚本中时，所有参数中的-符号应换成下划线。
我的setup.py内容大致如下：
```python #!/usr/bin/python # -*- coding: utf-8 -*- from cx_Freeze import setup,Executable includefiles = [('settings.ini.jctest','settings.ini') ,'README.mkd'] includes = [] excludes = ['Tkinter'] packages = ['sqlalchemy.engine', 'sqlalchemy.orm', 'sqlalchemy.dialects.mssql'] setup( name = 'pyutil', version = '0.1', description = 'A general enhancement utility for XXX', author = 'Lenin Lee', author_email = 'lenin.lee@xxx.com', options = {'build_exe':{'excludes':excludes,'packages':packages,'include_files':includefiles}}, executables = [Executable('jcitk.</description></item><item><title>SQL Server的自定义函数：统计两日期之间工作日的数量</title><link>http://0x3f.org/posts/counting-days-between-dates-in-sqlserver/</link><pubDate>Sat, 13 Mar 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/counting-days-between-dates-in-sqlserver/</guid><description>前段时间工作中遇到的一个需求，要求计算两个日期之间工作日的数量，即排除期间所有的周六和周日之后的天数。
在网上找到一个自定义函数，原函数有些小问题，例如如果传入的截止日期如果有时间且足够大，则计算结果可能出错，修正后代码如下：
```sql --函数：类似datediff，不统计期间所有的周六和周日 if exists (select * from dbo.sysobjects where id=object_id(N'[dbo].[f_WorkDay]') and xtype in (N'FN',N'IF',N'TF')) drop function [dbo].[f_WorkDay] GO CREATE FUNCTION f_WorkDay( @dt_begin datetime, @dt_end datetime )RETURNS int AS BEGIN DECLARE @workday int,@i int,@bz bit,@dt datetime set @dt_begin = convert(datetime, convert(nvarchar(32), @dt_begin, 23)) set @dt_end = convert(datetime, convert(nvarchar(32), @dt_end, 23)) IF @dt_begin>@dt_end SELECT @bz=1,@dt=@dt_begin,@dt_begin=@dt_end,@dt_end=@dt ELSE SET @bz=0 SELECT @i=DATEDIFF(Day,@dt_begin,@dt_end),@workday=@i/7*5,@dt_begin=DATEADD(Day,@i/7*7,@dt_begin) WHILE @dt_begin&lt;@dt_end BEGIN SELECT @workday=CASE WHEN (@@DATEFIRST+DATEPART(Weekday,@dt_begin)-1)%7 BETWEEN 1 AND 5 THEN @workday+1 ELSE @workday END,@dt_begin=@dt_begin+1 END RETURN(CASE WHEN @bz=1 THEN -@workday ELSE @workday END) END GO ``` 此函数的原理是，使用datediff计算两日期之间的差值A，然后取A与7的商，即计算期间内有几个整周。然后使用这个商与5相乘，得到所有整周内的工作日天数B。接着，使用A除以7再乘以7得到C，这就约去了A中最后不到一个整周的天数。再在起始日期的基础上加上C，得到一个新的起始日期，然后从这个新的起始日期开始遍历至截止日期的每一天，每增加一天，判断若此日期是工作日，则在C的基础上累加一。判断一个日期（假设使用@dt_begin表示）是否是工作日的方法是：(@@datefirst+datepart(Weekday, @dt_begin)-1)%7的值在1和5之间。</description></item><item><title>Python控制外部进程的灵异事件</title><link>http://0x3f.org/posts/supernatural-phenomenon-of-controlling-external-processes-in-python/</link><pubDate>Mon, 08 Mar 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/supernatural-phenomenon-of-controlling-external-processes-in-python/</guid><description>春节前的一段时间，重新拾起近一年没动过的ForeverFantasy。
虽然一年内没什么更新，但是我却一直都在用，基本上只限于将用Vim写好的Markdown格式的文档转换成HTML。
重写了相当一部分代码，较大程度地改变了界面布局，突然发现经过一年的沉淀，对wxPython的理解增进了不少，开发起来比起去年这个时候清楚了很多。
这些天来一直坚持着每天或多或少的做一些，如果说有什么主要的进展的话，那就是界面的重构，以及昨天实现了调用Vim编辑文档并回收文档内容的功能。
ForeverFantasy和Vim协同的一个最大的问题就是如何判断Vim已经退出。Python调用外部程序的方法有很多，比如传统的commands模块、os.system()等，subprocess是致力于替代这些旧有的方式的一个模块，它的一个特点是可以在启动一个外部程序作为子进程后还能监控这个进程的运行状态。这为ForeverFantasy在Vim退出后回收文档内容提供了更简捷的途径。
下面的代码可以说明如何使用subprocess运行外部程序并监控运行状态：
```python import subprocess process = subprocess.Popen('gvim', shell=True) status = process.poll() if 0 == status: print 'The external program exited.' if status is None: print 'The external program is still running.' ``` 理论上，可以拿实例process的poll()方法监视进程的运行状态，而且这一点在Windows上也确实可以做到，但是到了Linux下，诡异的事出现了，即使刚刚打开gvim，poll()方法也会马上返回一个0，同时process.pid的值总是和实际在运行的那个gvim进程的pid的值差3，而且在虚拟终端中输入gvim命令也不会阻塞终端，就像别的命令加上“&amp;amp;”符号的效果一样。尝试用strace跟踪gvim的运行，试图找到问题原因，无果。我猜想可能/usr/bin/gvim是一个跳板，它启动后会启动一个新的gvim进程。总之，这个方法在Linux下是行不通的。
因此我觉得只能另寻出路了，既然不能监控gvim进程，那就监控gvim进程所编辑的文件，只要这个文件不被任何进程占用，就可以判定gvim已退出。这一点，在Linux下易如反掌，不用说，lsof当仁不让。
用commands.getstatusoutput('lsof file.txt')测试发现，如果文件file.txt被某进程占用，则返回的状态值为0，反之，返回256。
最终，我在程序中使用了两种判断方式，在Windows平台使用subprocess跟踪gvim.exe进程，而在Linux及Unix平台使用lsof检查文档占用情况。
剩下的就是进行这个判断的时间问题了。
很显然，如果在子进程被启动后马上使用while循环不停的检查，一来必须使用多线程，二来系统资源占用也会很高。这时就需要利用wxPython的事件机制了，当ForeverFantasy启动Gvim时，主窗口失去焦点，而当Gvim退出时，ForeverFantasy又会获得焦点，只要能在ForeverFantasy窗口获得焦点时做一次检查即可。不过，在选择最合适的事件的问题上，又是一波三折。
在wxPython的API文档中没有找到事件列表，倒是在Wiki中找到了。顾名思义，觉得wx.EVT_SET_FOCUS比较靠谱，但试用失败，看API中关于FocusEvent的说明，这个事件适用于窗口控件；然后又试了wx.EVT_CHILD_FOCUS，只有在窗口包含的控件中有获得焦点的情况才会触发；最后才发现wx.EVT_ACTIVATE，这个事件会在窗口失去焦点和获得焦点时各触发一次，使用GetActive()方法可以判断是获得焦点还是失去焦点。
完成与Vim的协同使ForeverFantasy在我手上由原来单纯的格式转换工具进化为基本可用的文档编辑器，就算是Milestone 2吧。
此外，还有一些小的经验：
1. 调用非环境变量下的程序，即命令中必须带程序所在的路径时，应当将程序所在目录的完整路径以自然字符串的形式传递给subprocess.Popen类的构造方法的cwd参数，即如下所示：
```python process = subprocess.Popen('gvim.exe', cwd=r'C:\program files\vim\vim72', shell=True) ``` 这样可以有效避免路径中的空格和特殊字符对命令执行的影响。
2. Vim编辑一个文档时，实际操作的是一个临时文件，而不是原文件，这个临时文件与原文件同路径，名称为在原文件名的基础上，前面加一个句点，后面加后缀“.swp”。应该用lsof监控这个临时文件，才可以判断出编辑该文档的Vim进程的运行状态。由于对于不存在的文件使用lsof命令的返回值也是256，故可以同时判断临时文件和原文件的占用情况，这样就为对其它编辑器的支持奠定了基础。
2010-03-10 Wednesday 22:52:13 更新
感谢KL童鞋和依云童鞋指教，果然加上-f参数就可以了。</description></item><item><title>SQLAlchemy操作SQL Server的中文问题</title><link>http://0x3f.org/posts/chinese-problem-of-sqlalchemy-with-sqlserver/</link><pubDate>Wed, 24 Feb 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/chinese-problem-of-sqlalchemy-with-sqlserver/</guid><description>最初将脚本的文件编码和coding行都设定为UTF-8，在windows下执行时，中文无法保存，报编码错误。将上述两个编码改为GBK后，保存正常，但查询时报错。
Traceback内容如下：
``` Traceback (most recent call last): File "test.py", line 36, in &amp;lt;module&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for obj in session.query(User): File "C:\Python26\lib\site-packages\sqlalchemy-0.6beta1-py2.6.egg\sqlalchemy\orm\query.py", line 1411, in instances &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rows = [process[0](row, None) for row in fetch] File "C:\Python26\lib\site-packages\sqlalchemy-0.6beta1-py2.6.egg\sqlalchemy\orm\mapper.py", line 1788, in _instance &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;populate_state(state, dict_, row, isnew, only_load_props) File "C:\Python26\lib\site-packages\sqlalchemy-0.6beta1-py2.6.egg\sqlalchemy\orm\mapper.py", line 1677, in populate_state &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;populator(state, dict_, row, isnew=isnew, **flags) File "C:\Python26\lib\site-packages\sqlalchemy-0.6beta1-py2.6.egg\sqlalchemy\orm\strategies.py", line 118, in new_execute &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dict_[key] = row[col] File "C:\Python26\lib\site-packages\sqlalchemy-0.6beta1-py2.6.egg\sqlalchemy\engine\base.py", line 1634, in __getitem__ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return self.</description></item><item><title>PHP后台echo过多会导致进程崩溃</title><link>http://0x3f.org/posts/too-many-echoes-may-crash-php/</link><pubDate>Sun, 31 Jan 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/too-many-echoes-may-crash-php/</guid><description>这是去年晚些时侯发现的一个问题。
公司产品的后台定时任务应该是用独立的PHP进程驱动的。在做一个项目的时候，为了便于手工调试，我在定时任务中使用了大量的echo输出信息并在浏览器中手工执行此任务的脚本。
手工执行通过，输出信息完全没有问题。但在实际运行的过程中，一个很诡异的事情发生了：即使我将实际处理数据的代码全部注释掉，只对原始数据做简单的查询，此定时任务仍然极其健壮地中途退出。最要命的是无论程序日志还是PHP的错误日志，都没有任何相关信息。直到后来我把所有echo输出都取消，问题才解决。
事后模糊地记得很久以前似乎在哪本书上看到过在无输出设备的情况下echo过多数据会导致PHP进程崩溃的内容，但原因已想不起来了。</description></item><item><title>欧拉工程第十一解</title><link>http://0x3f.org/posts/project-euler-11/</link><pubDate>Tue, 12 May 2009 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-11/</guid><description>In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48</description></item><item><title>欧拉工程第十解</title><link>http://0x3f.org/posts/project-euler-10/</link><pubDate>Tue, 18 Nov 2008 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-10/</guid><description>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
Find the sum of all the primes below two million.
题目越来越变态，开始好玩儿了。
第七解里的算法在这里算是废了，一万个素数都算得那么费劲，两百万以下的素数有十几万个，不得不用筛选法了。
普通的筛选效率也不行，当初就是因为这个原因才没用它。不过优化过的筛选法就很奇妙了，下面是Lua的实现：
```lua require('math') local limit = 2000000 local primes = {} for i=1,limit do table.insert(primes,true) end primes[0] = false primes[1] = false for i=0,math.floor(math.sqrt(limit)) do if primes[i] then for j=math.pow(i,2),limit,i do primes[j] = false end end end local sumVal = 0 for i,j in ipairs(primes) do if j then sumVal = sumVal + i end end print(sumVal) ``` 在我这里两秒半就出结果了，Python的表现也不错，四秒半出结果：</description></item><item><title>欧拉工程第九解</title><link>http://0x3f.org/posts/project-euler-9/</link><pubDate>Mon, 10 Nov 2008 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-9/</guid><description> A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which,
a2 + b2 = c2
For example, 32 + 42 = 9 + 16 = 25 = 52.
There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc. 解：
```python flag = False for a in range(1,1000): for b in range(1,1000): if a ** 2 + b ** 2 == (1000 - a - b) ** 2: print a,b,(1000 - a - b) print a * b * (1000 - a - b) flag = True break if flag: break ```</description></item><item><title>欧拉工程第八解</title><link>http://0x3f.org/posts/project-euler-8/</link><pubDate>Sun, 09 Nov 2008 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-8/</guid><description>Find the greatest product of five consecutive digits in the 1000-digit number.
73167176531330624919225119674426574742355349194934 96983520312774506326239578318016984801869478851843 85861560789112949495459501737958331952853208805511 12540698747158523863050715693290963295227443043557 66896648950445244523161731856403098711121722383113 62229893423380308135336276614282806444486645238749 30358907296290491560440772390713810515859307960866 70172427121883998797908792274921901699720888093776 65727333001053367881220235421809751254540594752243 52584907711670556013604839586446706324415722155397 53697817977846174064955149290862569321978468622482 83972241375657056057490261407972968652414535100474 82166370484403199890008895243450658541227588666881 16427171479924442928230863465674813919123162824586 17866458359124566529476545682848912883142607690042 24219022671055626321111109370544217506941658960408 07198403850962455444362981230987879927244284909188 84580156166097919133875499200524063689912560717606 05886116467109405077541002256983155200055935729725 71636269561882670428252483600823257530420752963450
穷举，解：
```python def MakeProduct(strNum): prod = 1 for char in strNum: prod = prod * int(char) return prod def GetTheFirstProduct(strNum): if len(strNum) &lt; 5: return 0,0 return MakeProduct(strNum[:5]),strNum[1:] num = '7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450' largestProduct = 0 while len(num) >= 5: tmp = GetTheFirstProduct(num) if tmp == (0,0): break num = tmp[1] if largestProduct &lt; tmp[0]: largestProduct = tmp[0] print largestProduct ``` 如果先找到下五个均不为零的连续整数，然后计算它们的积并以之参与比较，效率会更高：</description></item><item><title>欧拉工程第七解</title><link>http://0x3f.org/posts/project-euler-7/</link><pubDate>Fri, 31 Oct 2008 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-7/</guid><description>第七解：
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
What is the 10001st prime number?
穷举，并加以最大程度的优化：对大于2的素数，只判断奇数；判断一个奇数是否素数时，只拿已经找到的素数中小于第这个数平方根的数来相除，如果均不能整除，就是素数。Python的实现：
```python def IsPrimeNum(num,feed): from math import sqrt tmp = feed[:] while tmp[-1] > int(sqrt(num)): tmp.pop() for i in tmp: if num % i == 0: return False return True limit = 10001 feed = [2,3,5,7] temp = 7 counter = 4 while counter &lt; limit : temp += 2 if IsPrimeNum(temp,feed): feed.</description></item><item><title>欧拉工程第六解</title><link>http://0x3f.org/posts/project-euler-6/</link><pubDate>Wed, 29 Oct 2008 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-6/</guid><description>第六解：
The sum of the squares of the first ten natural numbers is, 12 + 22 + &amp;hellip; + 102 = 385
The square of the sum of the first ten natural numbers is, (1 + 2 + &amp;hellip; + 10)2 = 552 = 3025
Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 385 = 2640.</description></item><item><title>欧拉工程第五解</title><link>http://0x3f.org/posts/project-euler-5/</link><pubDate>Mon, 27 Oct 2008 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-5/</guid><description>第五解：
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest number that is evenly divisible by all of the numbers from 1 to 20?
解：
```python #为简洁明了，此处不作校验 def GetGreatestCommonDivisor(min,max): '''辗转相除法求最大公约数''' while min > 0: tmp = min min = max % min max = tmp return max def GetLeastCommonMultiple(a,b): if a > b: max = a min = b else: max = b min = a div = GetGreatestCommonDivisor(min,max) return min * max / div temp = 1 for i in range(1,21): temp = GetLeastCommonMultiple(i,temp) print temp ``` 本题旨在求最小公倍数。此算法有意思的是，它的精华在于如何求解两个正整数的最大公约数，有点围魏救赵的意思。</description></item><item><title>欧拉工程第四解</title><link>http://0x3f.org/posts/project-euler-4/</link><pubDate>Wed, 22 Oct 2008 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-4/</guid><description>第四解：
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99. Find the largest palindrome made from the product of two 3-digit numbers.
解：
```python largestPalindrome = 0 for i in range(100,1000): for j in range(100,1000): product = i * j if int(str(product)[::-1]) == product and product > largestPalindrome: largestPalindrome = product print largestPalindrome ``` 穷举，有没有效率高的办法？</description></item><item><title>欧拉工程第三解</title><link>http://0x3f.org/posts/project-euler-3/</link><pubDate>Tue, 21 Oct 2008 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-3/</guid><description>第三解：
The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ?
解：
```python feed = 600851475143 def GetFactor(feed,footmark): while footmark &lt; feed: footmark += 2 if feed % footmark == 0: print footmark GetFactor(feed / footmark,footmark) break GetFactor(feed,1) ```</description></item><item><title>欧拉工程第二解</title><link>http://0x3f.org/posts/project-euler-2/</link><pubDate>Sun, 19 Oct 2008 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-2/</guid><description>第二解：
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, &amp;hellip; Find the sum of all the even-valued terms in the sequence which do not exceed four million.
解：
```python i = 1 j = 2 sum = 0 while j &lt; 4000000 : if j % 2 == 0 : sum = sum + j t = i i = j j = t + j print sum ```</description></item><item><title>欧拉工程第一解</title><link>http://0x3f.org/posts/project-euler-1/</link><pubDate>Mon, 06 Oct 2008 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-1/</guid><description> “欧拉工程”是一个很有意思的网站，它每周会提供一道数学题，要求访问者使用任一种编程语言设计一个计算机程序求解。到现在为止已经出了二百一十一道题，当然，题的难度是依次递增的。几十个国家的程序员已参与了这个工程，截至目前，中国有四百多人参与，但是解决所有的二百多道题的只有一个人。 我觉得没事儿的时候做一道很有意思，下面是第一道，很简单： If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. 最容易想到的一算法就是依次取出一到一千的整数，只要是三或五的倍数，就累加起来，最终的和就是结果： ```python sum = 0 for num in range(1,1000): if not (num % 3 != 0 and num % 5 != 0): sum += num print sum ``` 但是我觉得这个算法太普通了，从一到一千要做一千次循环，时间复杂度会比较高。所以我设想只取出三和五的倍数，然后相加就行了，所需要考虑的只是怎么处理三和五的公倍数的问题。下面是我的算法，只有三百多次循环： ```python def SumMultiple(feed,limit): threeMultiple = 3 * feed fiveMultiple = 5 * feed if threeMultiple >= limit: return None if fiveMultiple >= limit: return threeMultiple if fiveMultiple % 3 == 0: return threeMultiple return threeMultiple + fiveMultiple sum = 0 for feed in range(1,500): if SumMultiple(feed,1000) == None: break; sum += SumMultiple(feed,1000) print sum ``` 不过事与愿违，通过测试，这个算法的效率要比上一种低，我想应该是SumMultiple()函数中运算和比较次数较多导致的。 不管怎样，第一个问题已经顺利解决了：</description></item></channel></rss>