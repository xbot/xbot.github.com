<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Laravel/Lumen - 标签 - 晴耕雨讀</title><link>http://0x3f.org/tags/laravel/lumen/</link><description>Laravel/Lumen - 标签 - 晴耕雨讀</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><atom:link href="http://0x3f.org/tags/laravel/lumen/" rel="self" type="application/rss+xml"/><item><title>关于Lumen的Facade不支持引用传递的看法</title><link>http://0x3f.org/post/lumen-facade-doesnot-support-pass-by-reference-param/</link><pubDate>Tue, 04 Feb 2020 17:40:34 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/lumen-facade-doesnot-support-pass-by-reference-param/</guid><description>&lt;p>今天遇到一个奇怪的问题，一次调用带引用传递形参的方法后，该形参对应的变量值没有按预期改变。&lt;/p></description></item><item><title>解决Laravel中makeWith()无法取到被mock的实例的问题</title><link>http://0x3f.org/post/mocking-objects-made-by-laravel-container-with-parameters/</link><pubDate>Fri, 16 Aug 2019 10:55:40 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/mocking-objects-made-by-laravel-container-with-parameters/</guid><description><![CDATA[<p>被测单元有一行实例化一个类的代码，而且该类的构造方法需要参数。基于面向单元测试编程的原则，通过容器的makeWith()方法实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php">$api = app()-&gt;makeWith(Api::class, [&#39;config&#39; =&gt; $config]);
</code></pre></td></tr></table>
</div>
</div><p>但是在执行单元测试时发现，虽然测试代码中已经mock了这个类且注入到容器，但在被测单元中取到的还是原类的实例。</p>]]></description></item><item><title>利用单元测试为开发提效</title><link>http://0x3f.org/post/use-unit-test-as-an-efficiency-tool/</link><pubDate>Tue, 13 Aug 2019 16:38:02 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/use-unit-test-as-an-efficiency-tool/</guid><description><![CDATA[<p>单元测试可以方便地伪造和回滚测试数据，这个特性决定了它其实是一个效率工具。</p>
<p>例如在开发退款单、发票的时候，由于这种后置的功能依赖订单、支付、库存等前置的数据，因此需要频繁地创建这些测试数据，这就导致开发的效率极低，有时甚至需要切换多个系统做诸如增加库存、下单、支付等操作。虽然在开发环境可以通过直接修改数据使之恢复可被测试的状态，但仍然存在效率很低、遗留垃圾数据和存在隐患等问题。</p>
<p>单元测试可以完美地解决这些问题。</p>]]></description></item><item><title>面向单元测试编程</title><link>http://0x3f.org/post/unit-test-oriented-programming/</link><pubDate>Tue, 13 Aug 2019 16:35:15 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/unit-test-oriented-programming/</guid><description>&lt;p>同一逻辑可以有多种实现方式，选择对单元测试友好的方式可以提高写测试代码的效率。&lt;/p></description></item><item><title>Lumen单元测试提示自定义校验规则不存在的问题</title><link>http://0x3f.org/post/unit-test-in-laravel-complains-validation-rule-not-exist/</link><pubDate>Fri, 02 Aug 2019 15:12:17 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/unit-test-in-laravel-complains-validation-rule-not-exist/</guid><description><![CDATA[<p>执行单元测试时遇到报错：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">BadMethodCallException: Method [validateIdList] does not exist.
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>对比Laravel Excel和Spout的读写性能</title><link>http://0x3f.org/post/performance-comparation-for-laravel-excel-and-spout/</link><pubDate>Sun, 07 Jul 2019 20:23:26 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/performance-comparation-for-laravel-excel-and-spout/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ./artisan excel:write --driver=spout --amount=100000 写入数据100000行。 用时：156秒。 最大使用内存：2750.5106964111 M。 ./artisan excel:write --driver=laravel-excel</description></item><item><title>基于Laravel的项目的单元测试规范</title><link>http://0x3f.org/post/unit-testing-standard-for-laravel-based-projects/</link><pubDate>Sun, 24 Mar 2019 22:42:08 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/unit-testing-standard-for-laravel-based-projects/</guid><description>&lt;p>单元测试是个好东西，解决了我很多问题，不论开发效率还是代码质量，都给我助益良多。最近想在团队内部推广，就拟了个规范草稿：&lt;/p></description></item><item><title>解决Laravel的Facade在被Mock时不自动注入依赖的一种方法</title><link>http://0x3f.org/post/manual-dependency-injection-with-laravel/</link><pubDate>Tue, 30 Jan 2018 15:41:16 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/manual-dependency-injection-with-laravel/</guid><description>由于集成了Mockery，Laravel的Facade对单元测试非常友好，只需要一行代码就能实现mocking。 例如，测试目标方法中调用了订</description></item><item><title>Laravel单元测试错误：1205 Lock wait timeout exceeded</title><link>http://0x3f.org/post/1205-lock-wait-timeout-exceeded/</link><pubDate>Fri, 22 Dec 2017 15:47:32 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/1205-lock-wait-timeout-exceeded/</guid><description>错误信息： 1205 Lock wait timeout exceeded; try restarting transaction 原因之一是测试用例里重写的tearDown()方法中没有调用父类的该方法。因为DatabaseTransactio</description></item><item><title>Mock Laravel的DB Facade的方法</title><link>http://0x3f.org/post/how-to-mock-the-db-facade-of-laravel/</link><pubDate>Mon, 14 Aug 2017 15:51:41 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/how-to-mock-the-db-facade-of-laravel/</guid><description>关于数据库操作是否应该mock的问题，我认为查询一般不应该mock，可以避免一些问题，但如果查询的结果可能影响到断言，就应该mock了。 La</description></item></channel></rss>