<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PHP on 晴耕雨讀</title><link>http://0x3f.org/tags/php/</link><description>Recent content in PHP on 晴耕雨讀</description><generator>Hugo</generator><language>zh-cn</language><copyright>© 淘气 2022</copyright><lastBuildDate>Sat, 06 Aug 2022 20:22:36 +0800</lastBuildDate><atom:link href="http://0x3f.org/tags/php/index.xml" rel="self" type="application/rss+xml"/><item><title>Laravel Horizon 简介</title><link>http://0x3f.org/posts/an-introduction-of-laravel-horizon/</link><pubDate>Sat, 06 Aug 2022 20:22:36 +0800</pubDate><guid>http://0x3f.org/posts/an-introduction-of-laravel-horizon/</guid><description>简介 Horizon 针对 Laravel 的 Redis 队列，增加了可视化、进程池等特性。
特性 可视化仪表板 Worker 进程池的维护和调度 词汇表 master supervisor: 主进程，通过 proc_open() 启动 supervisor 子进程。 environments: 可以按 APP_ENV 针对不同环境创建多套配置。 supervisors: Horizon 自己的进程池概念，与托管后台进程的软件 Supervisor 没有关系。 workers: 队列消费者进程，每个 supervisor 中包含多个 worker。 负载均衡策略 false 一个 supervisor 下的所有 worker 全部用于按队列名称的顺序逐个队列消费任务。
simple 一个 supervisor 下的所有 worker 被平均分配给每个队列。
auto 一个 supervisor 下空闲的 worker 会被优先分配给负载最高的队列。同时保证空闲队列有配置项 minProcesses 数量的 worker 待命。
超时提醒 如果一个队列执行任务的时间超过预先配置的时间限制，horizon 将终止该任务并可以通过短信、邮件或 Slack 发送通知。
Horizon 每分钟查询一次执行任务的时间超过配置值的队列：
每 5 分钟发送一次通知：
吞吐量和平均耗时统计 需要通过定时任务周期性执行 artisan horizon:snapshot 命令生成统计数据并存储到 Redis 中。</description></item><item><title>解决 PHPUnit 生成代码覆盖报告时抛出重复定义类的错误的办法</title><link>http://0x3f.org/posts/the-solution-of-class-redeclaration-error-raised-while-generating-php-code-coverage-report/</link><pubDate>Thu, 23 Jun 2022 14:42:34 +0800</pubDate><guid>http://0x3f.org/posts/the-solution-of-class-redeclaration-error-raised-while-generating-php-code-coverage-report/</guid><description>在生成 Cobertura 格式的代码覆盖报告时程序报了如下错误：
Generating code coverage report in Cobertura XML format &amp;hellip; PHP Fatal error: Cannot declare class App\FakeNamespace\GenericProvider, because the name is already in use in /builds/fake_project/app/FakeNamespace/GenericProvider.php on line 17
对应的代码和单元测试执行均无问题。
经排查，直接原因是使用了 Mockery 的 Instance Mocking 1特性 mock 代码中的硬依赖关系（Hard Dependency）。
该特性的实现利用了类的自动加载机制和依赖注入技术。对依赖关系 mock 的实例保存在 Mockery 的容器中，同时生成一个 stub 文件：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &amp;lt;?php namespace Mockery; class Mockery_App_FakeNamespace_GenericProvider { private Container $container; function doSomething($param) { // internal code check expectations return $this-&amp;gt;container-&amp;gt;get(&amp;#39;App\FakeNamespace\GenericProvider::doSomething&amp;#39;)-&amp;gt;expectations(); } } 当代码中实例化这个类的时候，Mockery 自动加载该文件，从而代替了对原类文件的加载。</description></item><item><title>Archlinux 下 PHP 不能读取 /tmp 下文件的问题</title><link>http://0x3f.org/posts/php-failed-to-open-stream-under-tmp-in-archlinux/</link><pubDate>Mon, 09 Aug 2021 15:27:58 +0800</pubDate><guid>http://0x3f.org/posts/php-failed-to-open-stream-under-tmp-in-archlinux/</guid><description>问题的场景是，以 http 用户运行的 FPM 进程访问 /tmp 下由普通用户运行的 CLI 进程创建的文件时，报如下错误：
Failed to open stream.
原因是 PHP-FPM 的 systemd 配置中默认对 FPM 进程单独挂载 /tmp 目录。
具体对应：
/usr/lib/systemd/system/php-fpm.service
中的：
PrivateTmp=true</description></item><item><title>解决Laravel中makeWith()无法取到被mock的实例的问题</title><link>http://0x3f.org/posts/mocking-objects-made-by-laravel-container-with-parameters/</link><pubDate>Fri, 16 Aug 2019 10:55:40 +0000</pubDate><guid>http://0x3f.org/posts/mocking-objects-made-by-laravel-container-with-parameters/</guid><description>&lt;p>被测单元有一行实例化一个类的代码，而且该类的构造方法需要参数。基于面向单元测试编程的原则，通过容器的makeWith()方法实现：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-php" data-lang="php">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">$api&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">app&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="na">makeWith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">Api&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;config&amp;#39;&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="nv">$config&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但是在执行单元测试时发现，虽然测试代码中已经mock了这个类且注入到容器，但在被测单元中取到的还是原类的实例。&lt;/p></description></item><item><title>利用单元测试为开发提效</title><link>http://0x3f.org/posts/use-unit-test-as-an-efficiency-tool/</link><pubDate>Tue, 13 Aug 2019 16:38:02 +0000</pubDate><guid>http://0x3f.org/posts/use-unit-test-as-an-efficiency-tool/</guid><description>&lt;p>单元测试可以方便地伪造和回滚测试数据，这个特性决定了它其实是一个效率工具。&lt;/p>
&lt;p>例如在开发退款单、发票的时候，由于这种后置的功能依赖订单、支付、库存等前置的数据，因此需要频繁地创建这些测试数据，这就导致开发的效率极低，有时甚至需要切换多个系统做诸如增加库存、下单、支付等操作。虽然在开发环境可以通过直接修改数据使之恢复可被测试的状态，但仍然存在效率很低、遗留垃圾数据和存在隐患等问题。&lt;/p>
&lt;p>单元测试可以完美地解决这些问题。&lt;/p></description></item><item><title>面向单元测试编程</title><link>http://0x3f.org/posts/unit-test-oriented-programming/</link><pubDate>Tue, 13 Aug 2019 16:35:15 +0000</pubDate><guid>http://0x3f.org/posts/unit-test-oriented-programming/</guid><description>&lt;p>同一逻辑可以有多种实现方式，选择对单元测试友好的方式可以提高写测试代码的效率。&lt;/p></description></item><item><title>PHP单元测试的技巧</title><link>http://0x3f.org/posts/phpunit-tips/</link><pubDate>Tue, 13 Aug 2019 14:21:48 +0000</pubDate><guid>http://0x3f.org/posts/phpunit-tips/</guid><description>&lt;p>以下是我平时写单元测试时总结的一些最佳实践，有些是和具体的框架强相关的。&lt;/p></description></item><item><title>Lumen单元测试提示自定义校验规则不存在的问题</title><link>http://0x3f.org/posts/unit-test-in-laravel-complains-validation-rule-not-exist/</link><pubDate>Fri, 02 Aug 2019 15:12:17 +0000</pubDate><guid>http://0x3f.org/posts/unit-test-in-laravel-complains-validation-rule-not-exist/</guid><description>&lt;p>执行单元测试时遇到报错：&lt;/p>
&lt;pre tabindex="0">&lt;code>BadMethodCallException: Method [validateIdList] does not exist.
&lt;/code>&lt;/pre></description></item><item><title>对比Laravel Excel和Spout的读写性能</title><link>http://0x3f.org/posts/performance-comparation-for-laravel-excel-and-spout/</link><pubDate>Sun, 07 Jul 2019 20:23:26 +0000</pubDate><guid>http://0x3f.org/posts/performance-comparation-for-laravel-excel-and-spout/</guid><description>./artisan excel:write --driver=spout --amount=100000 写入数据100000行。 用时：156秒。 最大使用内存：2750.5106964111 M。 ./artisan excel:write --driver=laravel-excel --amount=100000 写入数据100000行。 用时：305秒。 最大使用内存：1330.7370758057 M。 ./artisan excel:read ./storage/app/test.xlsx --driver=spout 读取数据100001行。 用时：576秒。 最大使用内存：122.15303039551 M。 ./artisan excel:read ./storage/app/test.xlsx --driver=laravel-excel 读取数据100001行。 用时：166秒。 最大使用内存：739.48976898193 M。 基本上，Laravel Excel写XLSX的性能是Spout的一半，但内存占用是对方的一半。而在读文件上，前者的性能是后者的约3倍多，而内存占用是后者的6倍。
测试环境：
MBP 3.1 GHz Intel Core i5 8G内存 PHP 7.1.30 Laravel 5.8.27 Laravel Excel 3.1.14 Spout 3.0.1</description></item><item><title>基于Laravel的项目的单元测试规范</title><link>http://0x3f.org/posts/unit-testing-standard-for-laravel-based-projects/</link><pubDate>Sun, 24 Mar 2019 22:42:08 +0000</pubDate><guid>http://0x3f.org/posts/unit-testing-standard-for-laravel-based-projects/</guid><description>&lt;p>单元测试是个好东西，解决了我很多问题，不论开发效率还是代码质量，都给我助益良多。最近想在团队内部推广，就拟了个规范草稿：&lt;/p></description></item><item><title>生成PDF的方案调研</title><link>http://0x3f.org/posts/pdf-creating-solutions/</link><pubDate>Wed, 16 May 2018 15:41:36 +0000</pubDate><guid>http://0x3f.org/posts/pdf-creating-solutions/</guid><description>结论 倾向于通过wkhtmltopdf+消息队列实现。
工作流程：
用户保存表单 推送生成pdf的任务到队列 同时页面显示「正在生成PDF文档，请稍候」并轮询后端接口 PDF生成后，页面显示下载按钮 后端 dompdf 纯PHP实现。工作原理是把HTML转换成PDF。
优点：
不需要PHP调用命令行，安全性高。 缺点：
HTML/CSS支持不完全，实测多个网页转换后排版错乱。 中文网页转换后，中文都是问号（网上说有解决办法1、2，未测试）。 CPU占用比较高（网上的说法，没有实测具体有多高）。 参考：
laravel-dompdf主页 mpdf 纯PHP实现。工作原理是把HTML转换成PDF。
优点：
不需要PHP调用命令行，安全性高。 缺点（未实测）：
HTML/CSS支持不完整。 生成PDF耗时长。 参考：
laravel-pdf主页 mpdf文档 mpdf主页 mpdf与fpdf的使用比较 PDFtk Server PDFtk Server是个命令行程序。工作原理是利用FDF表单替换PDF模板中的占位符。实现方案有：纯PHP实现FDF + PDFtk、FPDI + PDFtk。
优点：
直接替换PDF模板，实现成本低，最大程度保证生成的PDF的效果。 缺点：
需要允许PHP调用命令行，有安全隐患。 只能实现简单的字符串替换（例如公司名称），不能替换有格式文本。 参考：
FPDI PHP的FDF手册 PDFtk的使用方法 纯PHP实现FDF + PDFtk wkhtmltopdf wkhtmltopdf是个命令行程序。工作原理是转换HTML到PDF。实现方案是laravel-snappy。
优点：
由于内嵌webkit核心，HTML/CSS的支持没有问题。 缺点：
需要允许PHP调用命令行，有安全隐患。 wkhtmltopdf体积40M，并发较多时影响服务器性能和稳定性（需要考虑用队列辅助实现，异步执行，需要需求变更交互方式）。 参考：
laravel-snappy主页 CutyCapt 命令行程序。工作原理和wkhtmtopdf相同。
优缺点同wkhtmltopdf，但是最近的更新在13年。
参考：
CutyCapt主页 Prince 命令行程序。工作原理是转换HTML到PDF。
优点：
HTML/CSS的支持很好。 文档很全 缺点：</description></item><item><title>解决Laravel的Facade在被Mock时不自动注入依赖的一种方法</title><link>http://0x3f.org/posts/manual-dependency-injection-with-laravel/</link><pubDate>Tue, 30 Jan 2018 15:41:16 +0000</pubDate><guid>http://0x3f.org/posts/manual-dependency-injection-with-laravel/</guid><description>由于集成了Mockery，Laravel的Facade对单元测试非常友好，只需要一行代码就能实现mocking。
例如，测试目标方法中调用了订单工具类的一个方法，在使用依赖注入的方式时，需要用三行代码实现对这个方法的mocking：
1 2 3 $fakeOrderTool = m::mock(\App\Tool\Order::class); $fakeOrderTool-&amp;gt;shouldReceive(&amp;#39;getById&amp;#39;)-&amp;gt;once()-&amp;gt;with($id)-&amp;gt;andReturn($fakeOrder); $this-&amp;gt;app-&amp;gt;instance(\App\Tool\Order::class, $fakeOrderTool); 而用Facade是这样的：
1 OrderFacade::shouldReceive(&amp;#39;getById&amp;#39;)-&amp;gt;once()-&amp;gt;with($id)-&amp;gt;andReturn($fakeOrder); 当测试目标方法也属于订单工具类时，需要部分mock这个类，所以还要加上一行：
1 OrderFacade::makePartial(); 但如果订单工具类的构造方法里有需要注入的依赖关系，这里并不会被执行。所以我在工具类基类里封装了一个方法，用反射机制实现手工注入依赖关系：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * 注入依赖，用于单元测试 * * @return void * @author donieli * @since 5 * @version 5 */ public function injectDependencies() { $reflector = new \ReflectionClass(get_class($this)); $params = $reflector-&amp;gt;getConstructor()-&amp;gt;getParameters(); $args = []; foreach ($params as $param) { $paramClass = $param-&amp;gt;getClass(); if (empty($paramClass)) { throw new \Exception(&amp;#39;Dependency named &amp;#39;.</description></item><item><title>Laravel单元测试错误：1205 Lock wait timeout exceeded</title><link>http://0x3f.org/posts/1205-lock-wait-timeout-exceeded/</link><pubDate>Fri, 22 Dec 2017 15:47:32 +0000</pubDate><guid>http://0x3f.org/posts/1205-lock-wait-timeout-exceeded/</guid><description>错误信息：
1205 Lock wait timeout exceeded; try restarting transaction
原因之一是测试用例里重写的tearDown()方法中没有调用父类的该方法。因为DatabaseTransaction这个trait自动开启了事务，对应的回滚方法在测试用例基类的tearDown()中执行。</description></item><item><title>Mock Laravel的DB Facade的方法</title><link>http://0x3f.org/posts/how-to-mock-the-db-facade-of-laravel/</link><pubDate>Mon, 14 Aug 2017 15:51:41 +0000</pubDate><guid>http://0x3f.org/posts/how-to-mock-the-db-facade-of-laravel/</guid><description>关于数据库操作是否应该mock的问题，我认为查询一般不应该mock，可以避免一些问题，但如果查询的结果可能影响到断言，就应该mock了。
Laravel的DB facade完整的mock实例是这样的：</description></item><item><title>GraphQL：RESTful之外的接口实现方案</title><link>http://0x3f.org/posts/graphql-vs-restful/</link><pubDate>Tue, 01 Aug 2017 17:36:27 +0000</pubDate><guid>http://0x3f.org/posts/graphql-vs-restful/</guid><description>和RESTfull一样，GraphQL也是一种基于HTTP的接口实现方式。它区别于前者的主要有两点：数据格式的自定义和请求的合并。
本质上，GraphQL是为了解决RESTful中前后端在业务逻辑上的耦合关系。在RESTful中，接口是为前端具体的业务需求定制的，从实现什么样的功能，到返回哪些数据，都是既定的，所以很难被其它业务逻辑共用，即使可以共用，前端也必须发送多个请求到后端，因而造成资源浪费、效率下降。
GraphQL实现的是一套逻辑积木，每个封装好的业务逻辑都是原子的，前端可以自由选择使用哪些，也可以定制返回数据的格式。并且这一切，都可以通过一次请求实现。
当然，GraphQL也有一些短板。比如缓存，对于RESTfull接口，可以根据操作的幂等性实现负载均衡层面的缓存，而对于GraphQL，由于请求数据格式灵活且可能很大，请求会用POST方式发送，这样就必须改变缓存的实现方式。再一点是嵌套的层级问题，GraphQL的灵活性允许查询类型之间彼此嵌套，如果层级过多，可能导致严重的性能和可用性问题，因此需要注意限制嵌套的层级。还有就是GraphQL的实现复杂度比RESTful要高，需要权衡使用哪种实现方案。
GraphQL用schema管理接口，可以根据业务等因素划分schema，例如需要权限验证的和公开的。每个schema包含两类接口：query和mutation，分别用来查询和变更数据。
下面在Laravel中简单实现一个query接口。
先安装folklore/graphql库。
实现文章类型：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 namespace App\GraphQL\Type; use GraphQL\Type\Definition\Type; use Folklore\GraphQL\Support\Type as GraphQLType; class PostType extends GraphQLType { public function fields() { return [ &amp;#39;id&amp;#39; =&amp;gt; [ &amp;#39;type&amp;#39; =&amp;gt; Type::nonNull(Type::string()), &amp;#39;description&amp;#39; =&amp;gt; &amp;#39;The id of the post&amp;#39; ], &amp;#39;title&amp;#39; =&amp;gt; [ &amp;#39;type&amp;#39; =&amp;gt; Type::string(), &amp;#39;description&amp;#39; =&amp;gt; &amp;#39;Post title&amp;#39; ] ]; } protected function resolveTitleField($root, $args) { return $root-&amp;gt;post_title; } } 实现文章的查询逻辑：</description></item><item><title>怎样测试PHP的Private或Protected方法</title><link>http://0x3f.org/posts/how-to-test-private-or-protected-methods-in-php/</link><pubDate>Mon, 03 Jul 2017 13:17:30 +0000</pubDate><guid>http://0x3f.org/posts/how-to-test-private-or-protected-methods-in-php/</guid><description>利用闭包绑定：
1 2 3 4 5 6 7 $ctrlr = new UserController; $tester = function () use ($uid) { $this-&amp;gt;getUser($uid); }; $runner = $tester-&amp;gt;bindTo($ctrlr, $ctrlr); $runner();</description></item><item><title>PHPUnit代码覆盖率的统计方法</title><link>http://0x3f.org/posts/how-to-count-code-coverage-of-phpunit/</link><pubDate>Sun, 30 Apr 2017 14:20:41 +0000</pubDate><guid>http://0x3f.org/posts/how-to-count-code-coverage-of-phpunit/</guid><description>关于PHPUnit代码覆盖率的很多概念，官方文档中讲的十分清楚，本文仅就部分语焉不详的细节做些补充。
虽然phpunit.xml不是必需，但每次都输入完整的命令很不方便，所以一般都要生成这个配置文件。用phpunit --generate-configuration生成的phpunit.xml默认包含forceCoversAnnotation=&amp;quot;true&amp;quot;，它表示必须在测试方法头部的注释里显式使用@covers标签声明统计范围，例如：
1 2 3 4 5 6 7 8 9 10 /** * @covers Ox3f\LaravelUtils\Log\Log::&amp;lt;public&amp;gt; * @covers Ox3f\LaravelUtils\Log\Log::parseCallStack * @covers Ox3f\LaravelUtils\Log\Log::__construct * @covers Ox3f\LaravelUtils\Log\Log::__callStatic */ public function testAll() { // ... } 否则在执行统计代码覆盖率的命令时，会报risk：
There was 1 risky test:
Ox3f\LaravelUtils\Log\LogTest::testAll This test does not have a @covers annotation but is expected to have one 如果希望单元测试覆盖全部代码、且不用一一显式声明，可以将此选项的值改成 false。
之后即可使用明令phpunit —coverage-html ./report统计代码覆盖率，统计结果保存在report目录中。
参考 官方文档：第11章-代码覆盖率分析</description></item><item><title>利用依赖注入Mock PHP的内建函数</title><link>http://0x3f.org/posts/mock-php-built-in-functions-using-dependency-injection/</link><pubDate>Sun, 30 Apr 2017 09:57:50 +0000</pubDate><guid>http://0x3f.org/posts/mock-php-built-in-functions-using-dependency-injection/</guid><description>简述 上篇文章讨论了如何利用命名空间实现对PHP内建函数的mocking，本文介绍另一种实现方法——依赖注入。
出于编写可测试代码的需要，依赖注入是经常使用的一种技术。通过把代码中依赖的其它数据获取服务提取出来、和原有逻辑解耦，提高代码的可测试性。只需mock这些依赖并注入到测试对象中即可。
实现 对原有代码的重构 先把原有代码用依赖注入的方式重构（为突出重点，省略了和上篇文章中重复的部分）：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // ... use Ox3f\LaravelUtils\Services\Builtins; /** * Class Log * @author donie */ class Log { // ... private $builtins; // Builtin functions private function __construct() { $this-&amp;gt;builtins = new Builtins(); // .</description></item><item><title>利用命名空间Mock PHP的内建函数</title><link>http://0x3f.org/posts/mock-php-built-in-functions-using-namespace/</link><pubDate>Sun, 30 Apr 2017 09:06:17 +0000</pubDate><guid>http://0x3f.org/posts/mock-php-built-in-functions-using-namespace/</guid><description>简述 Mock PHP的内建函数一般有两种方法：命名空间法和依赖注入法。
命名空间法是利用PHP优先使用同命名空间内函数的特性，在测试对象的命名空间内重载内建函数来实现。前提是内建函数在被调用时没有使用命名空间，例如：\debug_backtrace()是不能使用本方法的。
上篇文章《接口编程中记录日志的最佳实践》中实现的日志类中，核心部分调用了debug_backtrace()函数获取方法调用堆栈。下面讨论下如何利用命名空间法实现对此函数的mock。
实现 先看代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 &amp;lt;?</description></item><item><title>Swoole与PHP-FPM性能对比</title><link>http://0x3f.org/posts/swoole-vs-php-fpm/</link><pubDate>Tue, 14 Jul 2015 16:40:00 +0000</pubDate><guid>http://0x3f.org/posts/swoole-vs-php-fpm/</guid><description>测试环境：
CPU: Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz MEM: 4G OS: Archlinux 64bit 测试命令：
1 ab -c 200 -n 200000 -k http://127.0.0.1/test NGINX + PHP-FPM Requests per second: 16240.50 [#/sec] (mean)
Time per request: 12.315 [ms] (mean)
NGINX + Swoole Requests per second: 31284.57 [#/sec] (mean)
Time per request: 6.393 [ms] (mean)
Swoole Requests per second: 99926.55 [#/sec] (mean)
Time per request: 2.001 [ms] (mean)
结论 对一个最简单的PHP脚本做测试，排除业务逻辑的消耗的影响。Swoole威武。</description></item><item><title>PHP扩展框架的创建</title><link>http://0x3f.org/posts/create-php-extension-skeleton/</link><pubDate>Thu, 18 Jun 2015 14:15:00 +0000</pubDate><guid>http://0x3f.org/posts/create-php-extension-skeleton/</guid><description>创建项目 在PHP源码目录下的ext目录下执行：
1 ./ext_skel --extname=foobar 修改foobar/config.m4，移除以下三行前的dnl：
dnl PHP_ARG_WITH(foobar, for foobar support,
dnl Make sure that the comment is aligned:
dnl [ &amp;ndash;with-foobar Include foobar support])
编译与安装 在foobar目录下执行以下命令，生成configure脚本：
1 /usr/bin/phpize 执行configure：
1 ./configure --with-php-config=/usr/bin/php-config 编译安装：
1 sudo make install 修改php.ini，启用扩展：
1 extension=foobar.so</description></item><item><title>PHP流的上下文和过滤器的实现</title><link>http://0x3f.org/posts/contexts-and-filters-implementation-of-php/</link><pubDate>Mon, 15 Jun 2015 19:15:00 +0000</pubDate><guid>http://0x3f.org/posts/contexts-and-filters-implementation-of-php/</guid><description>上下文的实现和应用 上下文包含流的选项和流的参数两部分内容。
1 php_stream_context *php_stream_context_alloc(void); 流的选项是一系列键值对。
1 2 3 int php_stream_context_set_option(php_stream_context *context, const char *wrappername, const char *optionname, zval *optionvalue); int php_stream_context_get_option(php_stream_context *context, const char *wrappername, const char *optionname, zval ***optionvalue); 流的参数目前只实现对流的事件的回调，php_stream_context-&amp;gt;notifier存储如下结构：
1 2 3 4 5 6 7 typedef struct { php_stream_notification_func func; void (*dtor)(php_stream_notifier *notifier); void *ptr; int mask; size_t progress, progress_max; } php_stream_notifier; 回调函数的原型为：
1 2 3 4 5 typedef void (*php_stream_notification_func)(php_stream_context *context, int notifycode, int severity, char *xmsg, int xcode, size_t bytes_sofar, size_t bytes_max, void * ptr TSRMLS_DC); notifycode包含如下：</description></item><item><title>PHP流的操作</title><link>http://0x3f.org/posts/stream-operations-of-php/</link><pubDate>Mon, 01 Jun 2015 15:33:00 +0000</pubDate><guid>http://0x3f.org/posts/stream-operations-of-php/</guid><description>实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* reimplement fopen using stream */ ZEND_FUNCTION(donie_stream_fopen) { php_stream *stream; char *path, *mode; int path_len, mode_len; int options = ENFORCE_SAFE_MODE|REPORT_ERRORS; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &amp;#34;ss&amp;#34;, &amp;amp;path, &amp;amp;path_len, &amp;amp;mode, &amp;amp;mode_len) == FAILURE) { return; } stream = php_stream_open_wrapper(path, mode, options, NULL); if (!stream) { RETURN_FALSE; } php_stream_to_zval(stream, return_value); } php_stream_open_wrapper()是对文件类型资源创建流的方法，此外还有基于socket的流、目录流和特殊流三种。php_stream_to_zval()用于把流实例转换成zval结构。</description></item><item><title>PHP流的实现</title><link>http://0x3f.org/posts/stream-implementation-in-php/</link><pubDate>Fri, 29 May 2015 17:33:00 +0000</pubDate><guid>http://0x3f.org/posts/stream-implementation-in-php/</guid><description>流的概念 流是一系列概念的集合，包括流包装器、流资源、流操作、上下文等内容。流是对不同资源进行操作的抽象，允许线性地从指定位置读取或写入数据，通过一套统一的API简化对资源操作的实现。
流由scheme://target指代，scheme是包装器（Wrapper）的名字，target是流的目标地址。
PHP的流的实现较Java简单，后者可以通过嵌套实现更灵活的应用。
流的实现 存储结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 struct _php_stream { php_stream_ops *ops; void *abstract;	/* convenience pointer for abstraction */ php_stream_filter_chain readfilters, writefilters; php_stream_wrapper *wrapper; /* which wrapper was used to open the stream */ void *wrapperthis;	/* convenience pointer for a instance of a wrapper */ zval *wrapperdata;	/* fgetwrapperdata retrieves this */ int fgetss_state;	/* for fgetss to handle multiline tags */ int is_persistent; char mode[16];	/* &amp;#34;rwb&amp;#34; etc.</description></item><item><title>PHP全局变量的实现和操作</title><link>http://0x3f.org/posts/globals-implementation-in-php/</link><pubDate>Fri, 08 May 2015 17:23:00 +0000</pubDate><guid>http://0x3f.org/posts/globals-implementation-in-php/</guid><description>扩展内部的全局变量 1 2 3 4 ZEND_BEGIN_MODULE_GLOBALS(donie) unsigned long global_long; char *global_string; ZEND_END_MODULE_GLOBALS(donie) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ZEND_DECLARE_MODULE_GLOBALS(donie); static void php_donie_init_globals(zend_donie_globals *donie_globals) { donie_globals-&amp;gt;global_long = 2015; donie_globals-&amp;gt;global_string = &amp;#34;Long live Donie Leigh !&amp;#34;; } static void php_donie_globals_dtor(zend_donie_globals *donie_globals) { php_printf(&amp;#34;php_donie_globals_dtor triggered.&amp;#34;); } PHP_MINIT_FUNCTION(donie) { /* init extension globals */ ZEND_INIT_MODULE_GLOBALS(donie, php_donie_init_globals, php_donie_globals_dtor); return SUCCESS; } PHP_RSHUTDOWN_FUNCTION(donie) { #ifndef ZTS php_donie_globals_dtor(&amp;amp;donie_globals); #endif return SUCCESS; } ZEND_FUNCTION(donie_test_ext_globals) { php_printf(&amp;#34;%s&amp;#34;, DONIE_G(global_string)); } 声明 ZEND_BEGIN_MODULE_GLOBALS和ZEND_END_MODULE_GLOBALS及其间的内容实际上声明了一个结构体zend_donie_globals。</description></item><item><title>PHP常量的实现和操作</title><link>http://0x3f.org/posts/constant-implementation-in-php/</link><pubDate>Thu, 07 May 2015 16:29:00 +0000</pubDate><guid>http://0x3f.org/posts/constant-implementation-in-php/</guid><description>存储结构 常量存储在哈希表EG(zend_constants)中。
常量的结构定义为：
1 2 3 4 5 6 7 typedef struct _zend_constant { zval value; int flags; char *name; uint name_len; int module_number; } zend_constant; value是常量的值，是一个zval。name是常量名。module_number是模块被加载时，PHP内核在MINIT和RINIT方法的原型里默认传递的一个值，作为模块清理时的线索，在注册常量的接口里直接传递即可。
flags是常量的标识或标识组合：
CONST_CS CONST_PERSISTENT CONST_CT_SUBST CONST_CS表示常量名对大小写敏感，对应PHP函数define()的第三个参数，TRUE、FALSE、NULL这些常量名对大小写是不敏感的。CONST_PERSISTENT表示常量在请求结束后被保存，只在PHP进程结束时才销毁，一般在MINIT中定义的常量应该指定此参数，RINIT中定义的不指定。CONST_CT_SUBST表示在编译时可替换，TRUE、FALSE、NULL、ZEND_THREAD_SAFE、ZEND_DEBUG_BUILD属于此类。
常量的声明 常量的声明方法有两种，简单的使用宏函数族REGISTER_*_CONSTANT()：
REGISTER_NULL_CONSTANT(name, flags) REGISTER_BOOL_CONSTANT(name, bval, flags) REGISTER_LONG_CONSTANT(name, lval, flags) REGISTER_DOUBLE_CONSTANT(name, dval, flags) REGISTER_STRING_CONSTANT(name, str, flags) REGISTER_STRINGL_CONSTANT(name, str, len, flags)
由于不需指定常量名长度，所以name参数应直接使用字符串，而不是char*。
如需使用变量作为name参数，使用zend_register_*_constant()函数族，并指定变量名长度（sizeof(name)）。上面的宏函数其实是对这族函数的封装。
void zend_register_long_constant(char *name, uint name_len, long lval, int flags, int module_number TSRMLS_DC) void zend_register_double_constant(char *name, uint name_len, double dval, int flags, int module_number TSRMLS_DC) void zend_register_bool_constant(const char *name, uint name_len, zend_bool bval, int flags, int module_number TSRMLS_DC) void zend_register_string_constant(char *name, uint name_len, char *strval, int flags, int module_number TSRMLS_DC) void zend_register_stringl_constant(char *name, uint name_len, char *strval, uint strlen, int flags, int module_number TSRMLS_DC)</description></item><item><title>PHP资源的实现和操作</title><link>http://0x3f.org/posts/resource-implementation-in-php/</link><pubDate>Tue, 05 May 2015 18:53:00 +0000</pubDate><guid>http://0x3f.org/posts/resource-implementation-in-php/</guid><description>存储结构 资源变量也是一个zval结构，zval-&amp;gt;type == IS_RESOURCE，zval-&amp;gt;value-&amp;gt;lval存储一个整数，此整数为资源数据在存储资源的哈希表中的索引。
资源数据的结构为：
1 2 3 4 5 6 typedef struct _zend_rsrc_list_entry { void *ptr; int type; int refcount; }zend_rsrc_list_entry; 常规资源与持久资源 有两个存储资源数据的哈希表。EG(regular_list)存储常规资源，EG(persistent_list)存储持久资源。
常规资源对应的变量在作用域结束后会被内核回收，对应的资源数据也会被销毁。持久资源可以保持并被多次请求使用。持久资源的自动析构发生在PHP进程退出时。
实现 重新实现基本的文件句柄和相关操作。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 // 资源名称 #define PHP_DONIE_RES_NAME_FILE &amp;#34;Donie&amp;#39;s File Descriptor&amp;#34; // 资源类型 static int le_donie_file_descriptor; static int le_donie_file_descriptor_persist; // 资源析构函数 static void php_donie_file_descriptor_dtor(zend_rsrc_list_entry *rsrc TSRMLS_CC) { FILE *fp = (FILE*)rsrc-&amp;gt;ptr; fclose(fp); } // 在扩展的MINIT方法里创建资源类型 PHP_MINIT_FUNCTION(donie) { /* create a new resource type */ le_donie_file_descriptor = zend_register_list_destructors_ex( php_donie_file_descriptor_dtor, NULL, PHP_DONIE_RES_NAME_FILE, module_number ); /* create a persistent resource type */ le_donie_file_descriptor_persist = zend_register_list_destructors_ex( NULL, php_donie_file_descriptor_dtor, PHP_DONIE_RES_NAME_FILE, module_number ); return SUCCESS; } // 文件打开操作 PHP_FUNCTION(donie_fopen) { FILE *fp; char *filename, *mode; int filename_len, mode_len; zend_bool persist = 0; char *hash_key; int hash_key_len; list_entry *persist_file; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &amp;#34;ss|b&amp;#34;, &amp;amp;filename, &amp;amp;filename_len, &amp;amp;mode, &amp;amp;mode_len, &amp;amp;persist) == FAILURE) { RETURN_NULL(); } if (!</description></item><item><title>PHP对象的实现和操作</title><link>http://0x3f.org/posts/object-implementation-in-php/</link><pubDate>Wed, 29 Apr 2015 23:00:00 +0000</pubDate><guid>http://0x3f.org/posts/object-implementation-in-php/</guid><description>Object的存储结构 对象实例用zval存储。zval-&amp;gt;type == IS_OBJECT，zval-&amp;gt;value-&amp;gt;obj存储zend_object_value类型的结构体变量。
1 2 3 4 typedef struct _zend_object_value { zend_object_handle handle; const zend_object_handlers *handlers; } zend_object_value; zend_object_handle是一个unsigned int，是对象的ID。zend_object_handlers存储对象所有的行为。
Object的实例化过程 Object的初始化用以下几个宏函数：
object_init(zval *arg) object_init_ex(zval *arg, zend_class_entry *class_type) object_and_properties_init(zval *arg, zend_class_entry *class_type, HashTable *properties) 底层都是调用_object_and_properties_init(zval *arg, zend_class_entry *class_type, HashTable *properties)实现。这个函数做以下几件事：
检查类是否可实例化（例如接口、抽象类等不允许初始化） 处理类常量 检查类是否存在自定义实例化逻辑 若存在，调用自定义实例化逻辑 若不存在，调用缺省的函数zend_objects_new(zend_object **object, zend_class_entry *class_type) 把实例化的zend_object类型的数据存入zval中 zend_objects_new()做这些事：
分配一个zend_object类型的内存空间 初始化zend_object类型数据 把zend_object类型数据存入对象仓库（Objects Store） zend_objects_store_put(void *object, zend_objects_store_dtor_t dtor, zend_objects_free_object_storage_t free_storage, zend_objects_store_clone_t clone） zend_object的存储结构 1 2 3 4 5 6 typedef struct _zend_object { zend_class_entry *ce; HashTable *properties; zval **properties_table; HashTable *guards; /* protects from __get/__set .</description></item><item><title>PHP类和接口的实现</title><link>http://0x3f.org/posts/class-interface-implementation-in-php/</link><pubDate>Tue, 28 Apr 2015 18:38:00 +0000</pubDate><guid>http://0x3f.org/posts/class-interface-implementation-in-php/</guid><description>Class的实现 类的注册是在扩展的MINIT方法里。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 /* * this pointer should be put into the header file, * so other modules can access this class.</description></item><item><title>PHP数组的实现与操作</title><link>http://0x3f.org/posts/array-implementation-in-php/</link><pubDate>Fri, 24 Apr 2015 12:09:00 +0000</pubDate><guid>http://0x3f.org/posts/array-implementation-in-php/</guid><description>存储结构 和其它变量一样，PHP的数组也是一个zval。存储数据的哈希表存放在zval-&amp;gt;value-&amp;gt;ht中。
符号表操作 为实现可转换成整数的字符串键与整数键指向同一个元素，在哈希表操作的基础上封装了一层，对可转换成整数的字符串键转换成整数，然后调用zend_hash_index_*操作，否则调用zend_hash_*操作。这就是符号表操作。
用ZEND_HANDLE_NUMERIC处理整数字符串键：
1 2 3 4 5 6 static inline int zend_symtable_find( HashTable *ht, const char *arKey, uint nKeyLength, void **pData ) { ZEND_HANDLE_NUMERIC(arKey, nKeyLength, zend_hash_index_find(ht, idx, pData)); return zend_hash_find(ht, arKey, nKeyLength, pData); } 其它符号表操作函数：
1 2 3 4 5 6 7 8 static inline int zend_symtable_exists(HashTable *ht, const char *arKey, uint nKeyLength); static inline int zend_symtable_del(HashTable *ht, const char *arKey, uint nKeyLength); static inline int zend_symtable_update( HashTable *ht, const char *arKey, uint nKeyLength, void *pData, uint nDataSize, void **pDest ); static inline int zend_symtable_update_current_key_ex( HashTable *ht, const char *arKey, uint nKeyLength, int mode, HashPosition *pos ); 数组操作 初始化 1 2 3 4 5 6 7 8 9 // 初始化数组 zval *zv1; array_init(zv1); // 初始化数组并指定哈希表nTableSize的值 array_init_size(zv1, 100); // 在函数中返回数组：把返回值初始化为数组 array_init(return_value); 插入和更新 1 2 3 4 5 6 7 8 /* Insert at next index */ int add_next_index_*(zval *arg, .</description></item><item><title>PHP哈希表的实现与操作</title><link>http://0x3f.org/posts/hashtable-implementation-of-php/</link><pubDate>Thu, 23 Apr 2015 15:56:00 +0000</pubDate><guid>http://0x3f.org/posts/hashtable-implementation-of-php/</guid><description>结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 哈希表结构 typedef struct _hashtable { uint nTableSize; uint nTableMask; uint nNumOfElements; // 全部元素数 ulong nNextFreeElement; // 下一个可用的整数键 Bucket *pInternalPointer; // 枚举操作时使用，指向当前Bucket Bucket *pListHead; Bucket *pListTail; Bucket **arBuckets; dtor_func_t pDestructor; // 元素的析构函数 zend_bool persistent; // 是否在本次请求结束后保留哈希表 unsigned char nApplyCount; // 循环级别，防止循环引用导致遍历哈希表时死循环 zend_bool bApplyProtection; // 是否防止死循环 #if ZEND_DEBUG int inconsistent; #endif } HashTable; // Bucket结构 typedef struct bucket { ulong h; uint nKeyLength; void *pData; void *pDataPtr; struct bucket *pListNext; struct bucket *pListLast; struct bucket *pNext; struct bucket *pLast; char *arKey; } Bucket; 哈希冲突处理 哈希表通过计算键值的哈希值，将对应的数据映射到对应的槽上。理论上会存在不同的键的哈希值相同的情况。</description></item><item><title>运行时可装卸的Mixin的PHP实现</title><link>http://0x3f.org/posts/php-implementation-of-runtime-mixin/</link><pubDate>Thu, 04 Dec 2014 11:52:00 +0000</pubDate><guid>http://0x3f.org/posts/php-implementation-of-runtime-mixin/</guid><description>PHP的Trait可以实现加载时（load time）的混入（mixin）。作为元编程的一部分，运行时（run time）的混入拥有更大的灵活性。下面利用PHP的魔术方法实现运行时的混入。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 &amp;lt;?</description></item><item><title>Phalcon项目中PHPUnit的初始化</title><link>http://0x3f.org/posts/testing-with-phpunit-in-phalcon/</link><pubDate>Sat, 29 Nov 2014 09:58:00 +0000</pubDate><guid>http://0x3f.org/posts/testing-with-phpunit-in-phalcon/</guid><description>参考官方文档，稍作修改。
在项目下创建目录 unittests ，进入目录执行：
1 composer require phpunit/phpunit 创建 tests 目录并在其中创建文件 Bootstrap.php ：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 &amp;lt;?php use Phalcon\DI, Phalcon\DI\FactoryDefault; ini_set(&amp;#39;display_errors&amp;#39;,1); error_reporting(E_ALL); define(&amp;#39;ROOT_PATH&amp;#39;, __DIR__); define(&amp;#39;PROJECT_DIR&amp;#39;, &amp;#39;/home/taoqi/workspace&amp;#39;); set_include_path( ROOT_PATH . PATH_SEPARATOR . get_include_path() ); // required for phalcon/incubator include __DIR__ . &amp;#34;/../vendor/autoload.php&amp;#34;; // 加载项目文件 $config = require_once PROJECT_DIR.</description></item><item><title>Vim强制在PHP中使用HTML注释的方法</title><link>http://0x3f.org/posts/force-commenting-html-in-php-files-in-vim/</link><pubDate>Thu, 13 Nov 2014 21:45:00 +0000</pubDate><guid>http://0x3f.org/posts/force-commenting-html-in-php-files-in-vim/</guid><description>对PHP页面模板中的HTML做注释，NERDCommenter是根据文件类型处理的，所以必须临时转换文件类型：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 &amp;#34; 强制使用HTML的注释 function! ForceHTMLComment(mode, type) range set ft=html if a:mode == &amp;#34;x&amp;#34; execute a:firstline.&amp;#34;,&amp;#34;.a:lastline.&amp;#34;call NERDComment(\&amp;#34;x\&amp;#34;, \&amp;#34;&amp;#34;.a:type.&amp;#34;\&amp;#34;)&amp;#34; else if a:type == &amp;#34;Sexy&amp;#34; normal ,cs else normal ,cc endif endif set ft=php endfunction au FileType php nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;fhcc :call ForceHTMLComment(&amp;#34;n&amp;#34;, &amp;#34;Comment&amp;#34;)&amp;lt;CR&amp;gt; au FileType php vmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;fhcc :call ForceHTMLComment(&amp;#34;x&amp;#34;, &amp;#34;Comment&amp;#34;)&amp;lt;CR&amp;gt; au FileType php nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;fhcs :call ForceHTMLComment(&amp;#34;n&amp;#34;, &amp;#34;Sexy&amp;#34;)&amp;lt;CR&amp;gt; au FileType php vmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;fhcs :call ForceHTMLComment(&amp;#34;x&amp;#34;, &amp;#34;Sexy&amp;#34;)&amp;lt;CR&amp;gt; au FileType php nmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;fhcu :call ForceHTMLComment(&amp;#34;n&amp;#34;, &amp;#34;Uncomment&amp;#34;)&amp;lt;CR&amp;gt; au FileType php vmap &amp;lt;buffer&amp;gt; &amp;lt;leader&amp;gt;fhcu :call ForceHTMLComment(&amp;#34;x&amp;#34;, &amp;#34;Uncomment&amp;#34;)&amp;lt;CR&amp;gt; 有日子没写vimscript了，手都生了。</description></item><item><title>接管PHP致命错误的方法</title><link>http://0x3f.org/posts/how-to-take-over-php-fatal-error-handling/</link><pubDate>Wed, 12 Nov 2014 00:47:00 +0000</pubDate><guid>http://0x3f.org/posts/how-to-take-over-php-fatal-error-handling/</guid><description>Yii 2.0引入了一项新特性，可以接管PHP的致命错误。在此之前，如果PHP源码有语法错误，框架本身是不会处理的。
实现的思路如下：
禁止显示错误 注册自定义的shutdown回调函数 在回调函数中获取最近的错误 若错误是致命错误，调用相应的处理逻辑 代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &amp;lt;?php // ... ini_set(&amp;#39;display_errors&amp;#39;, false); register_shutdown_function(function(){ $error = error_get_last(); if (isset($error[&amp;#39;type&amp;#39;]) &amp;amp;&amp;amp; in_array($error[&amp;#39;type&amp;#39;], [E_ERROR, E_PARSE, E_CORE_ERROR, E_CORE_WARNING, E_COMPILE_ERROR, E_COMPILE_WARNING])) { ob_clean(); echo &amp;#39;&amp;lt;pre&amp;gt;&amp;#39;; var_dump($error); echo &amp;#39;&amp;lt;/pre&amp;gt;&amp;#39;; exit(1); } }); // ... ?&amp;gt;</description></item><item><title>Project Euler Problem 24 Solved</title><link>http://0x3f.org/posts/project-euler-24/</link><pubDate>Sun, 27 Apr 2014 21:17:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-24/</guid><description>Lexicographic permutations A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:
012 021 102 120 201 210
What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?</description></item><item><title>Project Euler Problem 22 Solved</title><link>http://0x3f.org/posts/project-euler-22/</link><pubDate>Sun, 20 Apr 2014 08:03:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-22/</guid><description>Names scores Using names.txt (right click and &amp;lsquo;Save Link/Target As&amp;hellip;&amp;rsquo;), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.
For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list.</description></item><item><title>PHP框架实战（六）：依赖注入</title><link>http://0x3f.org/posts/flamework-dependency-injection/</link><pubDate>Sun, 30 Mar 2014 10:00:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-dependency-injection/</guid><description>简述 依赖注入是个很好的解耦方法，也可以优雅的实现懒加载。
以数据库连接为例，当一个组件用到数据库时，最简单粗暴的办法是在使用前创建连接：
1 2 3 4 5 6 7 8 9 10 11 &amp;lt;?php class Component { public function doSth() { // ... $db = new DatabaseConnection($schema, $host, $port, $login, $password); // ... } } ?&amp;gt; 这样做的缺点是代码一旦执行，Component行为将不可更改，有时我们需要在程序执行的过程中决定其行为。很直接地，可以想到给Component添加一个Setter方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &amp;lt;?php class Component { private $__db; public function doSth() { // ... if ($this-&amp;gt;__db !</description></item><item><title>PHP框架实战（∝）：烈焰之终章</title><link>http://0x3f.org/posts/flamework-summary/</link><pubDate>Thu, 02 Jan 2014 15:15:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-summary/</guid><description>写“烈焰”（Flame）用了一周的业余时间，主要是对平时一些想法的总结和验证。实现了比较完整的控制器层和视图层，对模型层的ActiveRecord实现思路做了一下梳理。
当然，一个可实用的框架需要包含的东西远不止这些。比如框架中用到代码动态调用的地方，一定要做好语言安全子集的过滤，否则就是很大的安全漏洞。再比如需要支持依赖反转的缓存机制，实现对多种缓存方式的平滑支持。此外，像URI路由、可扩展、多模板方案支持也都是现代框架的标配。这些留待以后有时间再讨论。然而在这次练习的过程中，我突然想到一个问题——PHP是不是适合实现一个完备的框架。
曾见过一句话，说PHP本身就是一个框架，后来明白，这才是微言大义。PHP有很多高级选项、高级函数和扩展，用得好事半功倍，用不好就是魔鬼。
PHP本身有很多问题，协议不统一、函数命名混乱、命名空间语法怪异而且鸡肋等等都是老生常谈。在运行模式上，无论是Apache+PHP模块，还是NGINX+FastCGI，都只能实现在纵向层面上对一次请求的处理，由于缺乏在内存中持续运行程序的机制，凡是对程序全局共享并持续占有的东西都不能实现，比如数据库连接池等，以至于很多初始化的工作对于每次请求都要重新执行一次，这意味著面向对象越彻底、封装越多，系统资源的重复消耗越厉害，所以PHP的程序在性能和内存占用上与Java相比有一定缺陷。因此PHP更适合短平快的应用场景，不适合实现复杂的业务逻辑。
基于这个观点，我认同混合编程。没有哪种语言是完美的，用对的工具做对的事是最理想的。用PHP实现一个完备的框架也许不是个明智的选择，从短平快的角度出发，它更适合用来实现微框架。
现在微框架是个比较热门的话题，我最早接触的是Python的Bottle和Flask，短小精悍，非常容易上手。微框架主要实现控制器层和视图层，一般不包括模型层。为了以最快的速度将请求路由到处理逻辑，一般以最直接的方式建立URI模板和回调物件之间的映射，控制器层可以以极简的方式实现，例如只做一个像本文后面例子中那样简单的约定。微框架应该尽可能少地包含配置，大部分时候并不需要像Java的S.S.H那样滥用配置，CoC原则就持这样的观点，约定可以解决的问题就不要用配置去做。
下面只使用两个函数和五条约定实现一个微框架：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 &amp;lt;?php /** * 路由定义与应用 * @param string $route 用作定义路由规则时，此参数为模板字符串， * 使用冒号加参数名作为参数占位符，例如： * on(&amp;#39;/post/edit/:id&amp;#39;, function($id){}); * 用做应用路由规则时，此参数为URI，例如： * on($_SERVER[&amp;#39;REQUEST_URI&amp;#39;]); * @param callable $callback 路由规则的回调逻辑，如果路由规则中 * 含有参数占位符，回调中需存在同名的参数；当函数作为应用路 * 由规则使用时，此参数不指定 * @return void * @since 1.</description></item><item><title>PHP框架实战（五）：ORM与ActiveRecord</title><link>http://0x3f.org/posts/flamework-active-record/</link><pubDate>Wed, 01 Jan 2014 20:45:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-active-record/</guid><description>简述 Model是MVC框架中最复杂的部分，它要提供与业务逻辑相关的数据及数据处理方法的封装，一般要提供数据对象、数据库连接、事务管理、SQL语句构造、数据CRUD、高级通用业务逻辑等一系列功能。由于Model与Controller和View是解耦的，并且本身具备很高的通用性和复杂性，所以有很多独立的实现。本文希望能通过开发一个简单的ActiveRecord，验证这种Model实现方案的原理和过程。
ORM：对象关系映射 ORM的全称是Object Relational Mapping，即对象关系映射。它是为了解决关系数据库的数学模型和编程语言的对象模型之间的阻抗不匹配问题而提出的解决方案。
阻抗不匹配是个逼格很高的词。
阻抗是指电路中的电容、电感、电阻对交流电的障碍作用，就像电阻对直流电的障碍作用。两个系统传递信号可以形象地看成电压的传递，公式为：
U(out) * Z(in)
U(in) = &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
Z(in) + Z(out)
即输入电压等于输出电压与输入阻抗的积除以输入阻抗与输出阻抗的和。
理想情况肯定是输入电压等于输出电压，这时信号是没有失真的，也就是要求Z(in)与Z(in)+Z(out)之商无限逼近1，这个过程就叫阻抗匹配。关系型数据库是建立在数学模型的基础上，而编程语言中的对象是建立在人对客观世界认知的具象模型上。说白了，阻抗不匹配问题就是说因这两种模型不一致而导致的问题。
ORM通过建立表与对象、列与属性（这只是一般情况）之间的映射关系而解决问题，这可以实现像操作对象一样对数据库中的数据进行增删改查，简化了开发过程。不过ORM的缺点是不能很好地处理复杂数据关系，会出现效率低下的问题，因此必要时仍然需要直接使用SQL。
ActiveRecord ActiveRecord是Ruby on Rails提出的一个概念，其实就是ORM的一种实现，它是对象类型、数据、CRUD方法的合体，使对数据的操作以更具象化的方式实现。下面介绍在Flamework中实现一个简单的ActiveRecord的过程。
首先实现数据库的接口，提供数据库连接、查询、执行SQL语句、事务管理等基本功能。这里使用PDO实现：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 &amp;lt;?</description></item><item><title>PHP框架实战（四）：View的模板与渲染</title><link>http://0x3f.org/posts/flamework-view-rendering/</link><pubDate>Mon, 30 Dec 2013 21:05:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-view-rendering/</guid><description>目标 实现MVC模型的View层，Controller的Action中应可以将从Model层获取的数据填充到View模板中，并将渲染结果返回给访问者。本文并不志在实现一个完备的模板框架，相应的需求可借助Smarty这样现有的实现。
获取代码 1 git checkout v0.4 设计与实现 View的模板是最好实现的，因为PHP本身就是一个模板语言，所以这里实现的模板主要是指几条约定：
模板文件本身是一个普通PHP文件，文件名后缀是“.php”； 模板文件应存储在项目指定的模板基础目录中； 模板名称指模板文件相对于项目的模板基础目录的路径，并且去掉文件后缀； 模板本身的实际效果等同于在Controller的Action中执行的代码，故可以调用Controller的所有方法以及Flame对象的方法等内容； 所有要填充到模板中的数据以键值对的形式存储在一个关联数组中，并传递给渲染模板的方法，在模板中使用与键名相同的变量调用数据； View的渲染方法
添加Controller::render()方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 &amp;lt;?php // ... /** * Render the view template with data * @param string $view View template relative path to base path of the templates * For example, &amp;#39;post/list&amp;#39; point to file /srv/http/mysite/protected/view/post/list.</description></item><item><title>PHP框架实战（三）：实现Controller和Filter</title><link>http://0x3f.org/posts/flamework-controller-and-filter/</link><pubDate>Sun, 29 Dec 2013 20:40:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-controller-and-filter/</guid><description>目标 实现Controller和Filter，程序可以从HTTP请求中解析Controller和Action，并在这两个切面级别实现Filter链。此外，在Controller中，可以使用Action的参数直接访问HTTP请求中的同名参数。
获取代码 项目目录结构做了调整，framework目录存放Flamework框架源码，demo目录存放示例项目。
1 git checkout v0.3 设计与实现 Controller的实现
要求请求URL的格式如下：
http://www.mydomain.com/index.php?r=post/save
r表示Route，斜杠前面的post表示Controller的名称，后面的save表示Action的名称。对HTTP请求的各种处理逻辑封装在新对象HttpRequest中：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 &amp;lt;?</description></item><item><title>PHP框架实战（二）：错误和异常的自动处理</title><link>http://0x3f.org/posts/flamework-error-auto-handling/</link><pubDate>Sat, 28 Dec 2013 13:40:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-error-auto-handling/</guid><description>目标 实现错误和异常的自动捕获和处理。
获取代码 1 git checkout v0.2 设计与实现 使用set_error_handler()和set_exception_handler()两个函数注册错误和异常的处理方法，并在两个处理方法中先调用用户自定义的错误和异常处理逻辑，如果自定义逻辑不存在或者返回false，继续调用框架缺省的处理逻辑，输出错误信息到页面。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 &amp;lt;?</description></item><item><title>PHP框架实战（一）：框架入口与类的自动加载</title><link>http://0x3f.org/posts/flamework-entry/</link><pubDate>Sat, 28 Dec 2013 01:56:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-entry/</guid><description>目标 实现框架入口和类的自动加载。
获取代码 1 git checkout v0.1 设计与实现 通过两个类实现本次目标。
静态类Flame作为整个框架的入口，实现一系列框架级公用静态方法（例如创建应用实例和自动加载类）。
WebApplication是应用的抽象层，实现应用的入口和其它应用级（即运行时）公用方法（例如读取配置文件）。
程序入口
1 2 3 4 &amp;lt;?php // ... Flame::createApplication($config)-&amp;gt;run(); ?&amp;gt; 此处传入的$config是应用配置文件的路径，该配置文件内容格式如下：
1 2 3 4 5 6 &amp;lt;?php return array( &amp;#39;opt1&amp;#39; =&amp;gt; &amp;#39;val1&amp;#39;, // ... ); ?&amp;gt; 在文件中直接return一个关联数组的好处是，加载该文件时，include()函数的返回值就是该数组，代码更简洁，效率比解析其它格式配置文件高。
类的自动加载
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 &amp;lt;?php // ... class Flame { // .</description></item><item><title>PHP框架实战（零）：代码规范</title><link>http://0x3f.org/posts/flamework-code-spec/</link><pubDate>Thu, 26 Dec 2013 22:07:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework-code-spec/</guid><description>类C语言语法风格最大的问题就是用花括号区分代码块，这导致源码排版容易混乱，对于我这种有代码洁癖的人来说非常痛苦，所以我最喜欢的语法风格是Python的，用缩进区分代码块，排版不规范直接判处语法错误。
命名规范 所有命名使用驼峰风格。
源码开头定义命名空间，Flamework框架入口类的命名空间为“org\x3f\flamework”，其余类的命名空间应在此基础上追加与所在目录路径匹配的内容。例如，框架源码目录下一级子目录“base”中的类文件的命名空间均为“org\x3f\flamework\base”。
类名必须是名词，不允许添加任何无意义的前缀或后缀，只允许使用大小写英文字母且首字母大写。
方法名必须是“动词+名词”的形式（如果动词意义明确且不需要宾语，可省略后者），只允许使用大小写英文字母及阿拉伯数字和下划线，首字母小写。
属性名分两种情况，对于存储普通数据的属性，名称必须是名词；对于布尔型属性，名称必须是“动词+名词”的形式。只允许使用大小写英文字母及阿拉伯数字和下划线，首字母小写。
源码文件名必须与类名相同，后缀统一使用“.php”。
注释规范 统一使用phpDocumenter的注释规范。
类注释必须注明@author、@since。
属性和方法的作者如果和类的创建者不同，必须注明@author，此外必须注明@since。
文件格式 所有文本文件统一使用UNIX格式和UTF-8编码。
严禁使用制表符缩进代码，必须使用4个空格替代制表符。
类、属性、方法、方法内部代码块都必须严格按照层级缩进。</description></item><item><title>PHP框架实战：Flamework</title><link>http://0x3f.org/posts/flamework/</link><pubDate>Thu, 26 Dec 2013 20:24:00 +0000</pubDate><guid>http://0x3f.org/posts/flamework/</guid><description>从今天开始，逐步实现一个PHP的MVC框架，以践行平时对这方面的一些想法。
项目信息 名称：Flamework (Flame Framework) 源码：https://github.com/xbot/flamework 框架特性 激进
用PHP高版本引入的新特性，不考虑向前兼容问题，没有历史包袱。
命名空间
PHP 5.3引入的命名空间可以有效避免类命名冲突，这样可以使类名看起来更自然，不用再在类名前面加难看的前缀了。
类的自动加载
手动include会增加维护的难度，因为经常会出现一个类被从源码中移除而它的include行还在的问题，这会拖慢程序执行速度、增加内存占用。
实现类的自动加载可以在类被引用时自动include相应的源码。
异常的自动处理
在设计程序时，一般应该把用户级的错误返回给页面显示，或者对一些HTTP错误显示个性化的页面（例如人民群众喜闻乐见的404页面），所以在业务逻辑、数据操作这些层一般应该逐级向上抛异常，然后在Controller里捕获并加工成页面可识别的格式（例如JSON）。这样做的缺点是Controller里每个Action都包含重复的try&amp;hellip;catch块。
异常的自动处理允许开发者指定自定义的异常处理逻辑，将异常处理与普通逻辑解耦，这样每个Action只需实现它所关注的功能即可。
过滤器
过滤器允许面向切面编程，是将横向逻辑与纵向逻辑解耦的重要工具。Flamework要实现针对Controller和Action两个级别的过滤器链，过滤器可在该级别逻辑前后执行，并能停止该级别逻辑及后续过滤器的执行。
懒加载
对尽可能多的资源实现懒加载，例如数据库连接、类、组件等，目的是提高效率、节约资源。
参数绑定
自动将请求中的参数与Action方法的参数绑定，从而避免在Action里出现通过$_POST、$_GET这些数组取参数的脏代码，也可以自动实现参数的校验和错误处理。
ActiveRecord
ORM是对关系模型和对象模型的阻抗不匹配问题的解决方案，ActiveRecord是目前最流行的一种ORM的实现方式。通过AR，可以以更对象化的方式操作关系数据库的数据。
依赖注入
依赖注入是个很好的解耦方法，也可以很优雅地实现懒加载。
目录 零：代码规范 一：框架入口与类的自动加载 二：错误和异常的自动处理 三：实现Controller和Filter 四：视图的模板与渲染 五：ORM与ActiveRecord 六：依赖注入 ∝：烈焰之终章</description></item><item><title>PHP大量常量应集中使用APC定义</title><link>http://0x3f.org/posts/define-massive-constants-using-apc/</link><pubDate>Tue, 24 Apr 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/define-massive-constants-using-apc/</guid><description>用xdebug跟踪程序性能时，发现一个定义了约七百个常量的文件，include_once()时消耗约六十毫秒的时间。事实上define()的效率比较低，如果需要定义大量常量，使用APC扩展提供的apc_define_constants()效果会好得多。
下面是对这个文件改造前后效率跟踪结果的对比：
define()方案（ms） apc_define_constants()方案（ms） 启动Web服务和PHP，第一次运行 58 4 不重启Web服务和PHP，第二次运行 65 1 不重启Web服务和PHP，第三次运行 66 1 由此可见，apc_define_constants()不但在初次调用时效能就超过define()，而且由于APC自身的缓存功能，在后续调用时效率会有进一步的提高，而define()基本没有变化。
以下是apc_define_constants()的代码示例：
```php &lt;?php if(!apc_load_constants('my_constants')) { $constants = array( 'ONE' => 1, 'TWO' => 2, 'THREE' => 3, ); apc_define_constants('my_constants', $constants); } ?> ``` Posted via UltraBlog.vim.</description></item><item><title>慎用PHP的fsockopen()连接localhost</title><link>http://0x3f.org/posts/fsockopen-fails-connecting-localhost/</link><pubDate>Tue, 24 Apr 2012 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/fsockopen-fails-connecting-localhost/</guid><description>使用xdebug跟踪程序性能时发现fsockopen()函数耗时一秒，单步调试发现实际在这里超时了，而超时时间设置的就是一秒。
如果把目标地址由原来的“localhost”换成“127.0.0.1”，马上就可以连上。在PHP的Bug跟踪系统中找到这个问题：
https://bugs.php.net/bug.php?id=50953
看起来像是在5.2.12以后已修改，但我发现在5.2.17中仍存在这个问题。另有说法在5.3中不存在这个问题，我没有测试。
Posted via UltraBlog.vim.</description></item><item><title>APC、文件和Memcached效率对比</title><link>http://0x3f.org/posts/comparison-of-efficiency-for-apc-file-memcached/</link><pubDate>Wed, 13 Jul 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/comparison-of-efficiency-for-apc-file-memcached/</guid><description>对一个保存了100个对象实例的数组进行300次读写，该数组序列化后大小为232KB。
测试环境 网络服务器 PHP版本 操作系统 硬件配置 NGINX v1.0.4 PHP-FPM v5.3.6
APC启用 Archlinux 32bit Intel(R) Core(TM)2 Duo CPU T9400 @ 2.53GHz
Mem: 3G DDR3
Disk: 5400r/s 测试脚本 测试数据：
```php &lt;?php /* * @file data.php */ class XTest { var $x0; var $x1; var $x2; var $x3; var $x4; var $x5; var $x6; var $x7; var $x8; var $x9; var $x10; var $x11; var $x12; var $x13; var $x14; var $x15; var $x16; var $x17; var $x18; var $x19; var $x20; var $x21; var $x22; var $x23; var $x24; var $x25; var $x26; var $x27; var $x28; var $x29; var $x30; var $x31; var $x32; var $x33; var $x34; var $x35; var $x36; var $x37; var $x38; var $x39; var $x40; var $x41; var $x42; var $x43; var $x44; var $x45; var $x46; var $x47; var $x48; var $x49; var $x50; var $x51; var $x52; var $x53; var $x54; var $x55; var $x56; var $x57; var $x58; var $x59; var $x60; var $x61; var $x62; var $x63; var $x64; var $x65; var $x66; var $x67; var $x68; var $x69; var $x70; var $x71; var $x72; var $x73; var $x74; var $x75; var $x76; var $x77; var $x78; var $x79; var $x80; var $x81; var $x82; var $x83; var $x84; var $x85; var $x86; var $x87; var $x88; var $x89; var $x90; var $x91; var $x92; var $x93; var $x94; var $x95; var $x96; var $x97; var $x98; var $x99; function __construct() { $this->x0 = 1234567890; $this->x1 = 1234567890; $this->x2 = 1234567890; $this->x3 = 1234567890; $this->x4 = 1234567890; $this->x5 = 1234567890; $this->x6 = 1234567890; $this->x7 = 1234567890; $this->x8 = 1234567890; $this->x9 = 1234567890; $this->x10 = 1234567890; $this->x11 = 1234567890; $this->x12 = 1234567890; $this->x13 = 1234567890; $this->x14 = 1234567890; $this->x15 = 1234567890; $this->x16 = 1234567890; $this->x17 = 1234567890; $this->x18 = 1234567890; $this->x19 = 1234567890; $this->x20 = 1234567890; $this->x21 = 1234567890; $this->x22 = 1234567890; $this->x23 = 1234567890; $this->x24 = 1234567890; $this->x25 = 1234567890; $this->x26 = 1234567890; $this->x27 = 1234567890; $this->x28 = 1234567890; $this->x29 = 1234567890; $this->x30 = 1234567890; $this->x31 = 1234567890; $this->x32 = 1234567890; $this->x33 = 1234567890; $this->x34 = 1234567890; $this->x35 = 1234567890; $this->x36 = 1234567890; $this->x37 = 1234567890; $this->x38 = 1234567890; $this->x39 = 1234567890; $this->x40 = 1234567890; $this->x41 = 1234567890; $this->x42 = 1234567890; $this->x43 = 1234567890; $this->x44 = 1234567890; $this->x45 = 1234567890; $this->x46 = 1234567890; $this->x47 = 1234567890; $this->x48 = 1234567890; $this->x49 = 1234567890; $this->x50 = 1234567890; $this->x51 = 1234567890; $this->x52 = 1234567890; $this->x53 = 1234567890; $this->x54 = 1234567890; $this->x55 = 1234567890; $this->x56 = 1234567890; $this->x57 = 1234567890; $this->x58 = 1234567890; $this->x59 = 1234567890; $this->x60 = 1234567890; $this->x61 = 1234567890; $this->x62 = 1234567890; $this->x63 = 1234567890; $this->x64 = 1234567890; $this->x65 = 1234567890; $this->x66 = 1234567890; $this->x67 = 1234567890; $this->x68 = 1234567890; $this->x69 = 1234567890; $this->x70 = 1234567890; $this->x71 = 1234567890; $this->x72 = 1234567890; $this->x73 = 1234567890; $this->x74 = 1234567890; $this->x75 = 1234567890; $this->x76 = 1234567890; $this->x77 = 1234567890; $this->x78 = 1234567890; $this->x79 = 1234567890; $this->x80 = 1234567890; $this->x81 = 1234567890; $this->x82 = 1234567890; $this->x83 = 1234567890; $this->x84 = 1234567890; $this->x85 = 1234567890; $this->x86 = 1234567890; $this->x87 = 1234567890; $this->x88 = 1234567890; $this->x89 = 1234567890; $this->x90 = 1234567890; $this->x91 = 1234567890; $this->x92 = 1234567890; $this->x93 = 1234567890; $this->x94 = 1234567890; $this->x95 = 1234567890; $this->x96 = 1234567890; $this->x97 = 1234567890; $this->x98 = 1234567890; $this->x99 = 1234567890; } } $repeat = 300; $arr = array(); for ($i = 0; $i &lt; 100; $i++) { $arr[] = new XTest; } ?</description></item><item><title>PHP序列化方案效率比较</title><link>http://0x3f.org/posts/comparison-of-serialization-methods-of-php/</link><pubDate>Sun, 17 Apr 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/comparison-of-serialization-methods-of-php/</guid><description>同时对以下几种PHP的序列化方案进行了测试：
serialize() and unserialize() json_encode() and json_decode() msgpack_serialize() and msgpack_unserialize() igbinary_serialize() and igbinary_unserialize() 测试环境：
OS: Archlinux 32-bit CPU: CORE 2 DUO T9400, 2.53GHz Mem: DDR3, 3G Server: nginx v1.0.0 PHP: php v5.3.6 + php-fpm Profiler: xhprof v0.9.2 测试代码块：
```php &lt;?php class Test{ function __construct(){ $this->value = str_repeat('a', 1000); } } function produce($num) { $arr = array(); for ($i = 0; $i &lt; $num; $i++) { $arr[] = new Test(); } $data = serialize($arr); $arr = unserialize($data); $data = json_encode($arr); $arr = json_decode($data); $data = msgpack_serialize($arr); $arr = msgpack_unserialize($data); $data = igbinary_serialize($arr); $arr = igbinary_unserialize($data); } produce(10000); ?</description></item><item><title>Dumperor v1.0.0 Released</title><link>http://0x3f.org/posts/dumperor-v100-released/</link><pubDate>Tue, 15 Mar 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/dumperor-v100-released/</guid><description>Changelog 2011-03-14 Now Dumperor is stable enough. Add the abillity to export table structures or data to a human readable format, which is suit for comparing. Add the abillity to manage multiple configurations. Add a desktop application to sort the human readable output file of table structures, written in python and tk. Check the main page for more information.</description></item><item><title>读完Agile Web Application Development with Yii1.1 and PHP5</title><link>http://0x3f.org/posts/after-reading-agile-web-application-development-with-yii11-and-php5/</link><pubDate>Mon, 24 Jan 2011 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/after-reading-agile-web-application-development-with-yii11-and-php5/</guid><description>花了两个周末，读完了Agile Web Application Development with Yii1.1 and PHP5，边读边做，受益匪浅。
这本书从零开始细致地讲解了用Yii开发一个项目管理系统TrackStar的全过程，涉及到Yii的大部分主要特性。全书风格简洁凝练，没有过多的占用篇幅的截图，但讲解浅显易懂，可操作性很强，是我看过的Tutorial类的书里面最好的一本。
从这段时间学习Yii的体会中，我觉得在目前的条件下，对于有PHP程序开发基础的人，学习路线应该是：
Yii权威指南→The Yii Blog Tutorial→Agile Web Application Development with Yii1.1 and PHP5</description></item><item><title>Vim中设置关键词识别规则的方法</title><link>http://0x3f.org/posts/howto-set-keyword-identification-in-vim/</link><pubDate>Wed, 22 Dec 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/howto-set-keyword-identification-in-vim/</guid><description>在Vim中，关键词是一个至关重要的概念。合理地利用关键词，可以快速地对光标下有特殊含义的字符串进行一系列的操作，例如通过快捷键复制关键词、查询函数定义或文档、在项目中查询所有引用当前函数的地方等等。这对工作效率的提升有极大的帮助。
但我的Vim对PHP文件的关键词识别有问题，在选择函数名的时候总是将函数名后的小括弧一起选入。
Vim使用选项iskeyword设定关键词的匹配规则，使用如下命令查看当前文件类型的关键词规则：
1 set iskeyword 我这里查看PHP文件的规则结果如下：
iskeyword=@,48-57,_,192-255,$,( 不明白为什么缺省设置中会有左括弧，在vimrc中加入如下配置取消之：
1 au FileType php set iskeyword-=(</description></item><item><title>Dumperor: Multi-Database Dumping Toolkit</title><link>http://0x3f.org/posts/dumperor-as-a-multidb-dumping-tool/</link><pubDate>Thu, 23 Sep 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/dumperor-as-a-multidb-dumping-tool/</guid><description>Dumperor is a multi-database dumping toolkit. It dumps table structures and data from databases, and generates CREATE-TABLE SQL statements for table structures or INSERT SQL statements for data.
Part of the original intention for developing Dumperor is to check whether a migration of SQL scripts from one database to another is successful, you know, by comparing the differences between two files, one dumped before executing scripts and the other after.</description></item><item><title>中转feedburner订阅数图标</title><link>http://0x3f.org/posts/howto-display-feedburner-subscription-image/</link><pubDate>Mon, 14 Jun 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/howto-display-feedburner-subscription-image/</guid><description>利用国外服务器中转feedburner的图标：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &amp;lt;?php /* * 将$fburl替换为自己的feedburner订阅数图片地址，然后将博客中的图片地址换成此脚本的URL即可 */ $fburl = &amp;#39;http://feeds.feedburner.com/~fc/leninlee?bg=99CCFF&amp;amp;amp;fg=444444&amp;amp;amp;anim=0&amp;#39;; $fbfl = &amp;#39;fb.gif&amp;#39;; $fp = fopen($fburl, &amp;#39;rb&amp;#39;); if ($fp) { $fp_local = fopen($fbfl, &amp;#39;wb&amp;#39;); if ($fp_local) { while (!feof($fp)) { fwrite($fp_local, fread($fp, 1024*8), 1024*8); } fclose($fp_local); } fclose($fp); } header(&amp;#39;Location: &amp;#39;.$fbfl); ?&amp;gt; 或者：
1 2 3 4 &amp;lt;?php header(&amp;#39;Content-Type: image/gif&amp;#39;); readfile(&amp;#39;http://feeds.feedburner.com/~fc/leninlee?bg=99CCFF&amp;amp;fg=444444&amp;amp;anim=0&amp;#39;); ?&amp;gt;</description></item><item><title>强大的工具函数库：php.js</title><link>http://0x3f.org/posts/phpjs/</link><pubDate>Sat, 24 Apr 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/phpjs/</guid><description>PHP最大的特点在于它拥有一个丰富、灵活、强大的函数库，因此得以机动灵活成为软件开发语言中的轻骑兵。
php.js是一个用Javascript实现的函数库，它试图用Javascript最大程度地重写PHP的函数库。相对于JQuery、ExtJS这些Javascript库，php.js不并致力于为AJAX、DOM和界面开发提供一揽子解决方案，它只是将PHP函数的强大和简便带到前端开发中来，由于JQuery这样的库并不旨在提供完全的Javascript开发标准和手段，实际上，它弥补了这些高端的工具库与低端的Javascript开发之间的一个空白。
对于熟悉PHP的人尤其是PHP程序员来说，使用php.js是几乎不需要切换思维方式的。
这是使用php实现的日期格式校验函数：
```php function IsValidDate($strDate, $strFormat='Y-m-d') { $strDate = trim($strDate); $unixTime = strtotime($strDate); $strNewDate = date($strFormat, $unixTime); return $strDate == $strNewDate; } ``` 这是使用php.js实现的日期格式校验函数：
```javascript function IsValidDate(strDate, strFormat) { strDate = trim(strDate); var unixTime = strtotime(strDate); var strNewDate = date(strFormat, unixTime); return strDate == strNewDate; } ```</description></item><item><title>在Vim中检查语法和执行代码</title><link>http://0x3f.org/posts/syntax-checking-and-code-executing-in-vim/</link><pubDate>Sat, 17 Apr 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/syntax-checking-and-code-executing-in-vim/</guid><description>《The Pragmatic Programmer》是本好书，虽然中文译名极为恶俗。为践行书中提到的DRY原则，我开始反思平时编码时总是重复出现的问题，其中之一就是很低级的语法错误，有时忘了语句最后的分号，有时忘了声明变量，凡此种种，不一而足。
相对于IDE，我更喜欢Vim，这也是语法错误没有检查出来的原因。因此就产生了给Vim添加语法检查功能的需求。下面是检查PHP代码的vimrc内容：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &amp;#34; Check the syntax of a PHP file function! CheckPHPSyntax() if &amp;amp;filetype != &amp;#39;php&amp;#39; echohl WarningMsg | echo &amp;#39;This is not a PHP file !&amp;#39; | echohl None return endif setlocal makeprg=php\ -l\ -n\ -d\ html_errors=off\ % setlocal errorformat=%m\ in\ %f\ on\ line\ %l echohl WarningMsg | echo &amp;#39;Syntax checking output:&amp;#39; | echohl None if &amp;amp;modified == 1 silent write endif silent make clist endfunction au filetype php map &amp;lt;F5&amp;gt; :call CheckPHPSyntax()&amp;lt;CR&amp;gt; au filetype php imap &amp;lt;F5&amp;gt; &amp;lt;ESC&amp;gt;:call CheckPHPSyntax()&amp;lt;CR&amp;gt; 以上脚本为Vim添加了一个检查PHP语法错误的函数和两个快捷键映射，此后可按F5键即时检查当前Buffer中的PHP当面的语法。和网上其它同类的函数相比，这个函数的优点在于改进了检查结果的显示，使用silent命令隐藏了所有不必要的输出。</description></item><item><title>phpsh：PHP的交互式解释器</title><link>http://0x3f.org/posts/phpsh/</link><pubDate>Mon, 29 Mar 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/phpsh/</guid><description>时常需要测试一些简短的代码是否能得到需要的结果，如果去写测试脚本再执行，显然太麻烦。虽然PHP自身也支持通过-a参数启动交互模式，但功能较为局限。如果PHP有像bpython那样的交互式解释器，就太好了。
phpsh就是这样一个工具，它是由facebook的开发者用Python实现的PHP的交互式解释器，并具备以下特性：
命令行历史回溯 tab键自动补全 快速文档索引</description></item><item><title>PHP后台echo过多会导致进程崩溃</title><link>http://0x3f.org/posts/too-many-echoes-may-crash-php/</link><pubDate>Sun, 31 Jan 2010 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/too-many-echoes-may-crash-php/</guid><description>这是去年晚些时侯发现的一个问题。
公司产品的后台定时任务应该是用独立的PHP进程驱动的。在做一个项目的时候，为了便于手工调试，我在定时任务中使用了大量的echo输出信息并在浏览器中手工执行此任务的脚本。
手工执行通过，输出信息完全没有问题。但在实际运行的过程中，一个很诡异的事情发生了：即使我将实际处理数据的代码全部注释掉，只对原始数据做简单的查询，此定时任务仍然极其健壮地中途退出。最要命的是无论程序日志还是PHP的错误日志，都没有任何相关信息。直到后来我把所有echo输出都取消，问题才解决。
事后模糊地记得很久以前似乎在哪本书上看到过在无输出设备的情况下echo过多数据会导致PHP进程崩溃的内容，但原因已想不起来了。</description></item><item><title>欧拉工程第七解</title><link>http://0x3f.org/posts/project-euler-7/</link><pubDate>Fri, 31 Oct 2008 00:00:00 +0000</pubDate><guid>http://0x3f.org/posts/project-euler-7/</guid><description>第七解：
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
What is the 10001st prime number?
穷举，并加以最大程度的优化：对大于2的素数，只判断奇数；判断一个奇数是否素数时，只拿已经找到的素数中小于第这个数平方根的数来相除，如果均不能整除，就是素数。Python的实现：
```python def IsPrimeNum(num,feed): from math import sqrt tmp = feed[:] while tmp[-1] > int(sqrt(num)): tmp.pop() for i in tmp: if num % i == 0: return False return True limit = 10001 feed = [2,3,5,7] temp = 7 counter = 4 while counter &lt; limit : temp += 2 if IsPrimeNum(temp,feed): feed.</description></item></channel></rss>