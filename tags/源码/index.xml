<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码 on 晴耕雨讀</title><link>http://0x3f.org/tags/%E6%BA%90%E7%A0%81/</link><description>Recent content in 源码 on 晴耕雨讀</description><generator>Hugo</generator><language>zh-cn</language><copyright>© 淘气 2022</copyright><lastBuildDate>Thu, 18 Jun 2015 14:15:00 +0000</lastBuildDate><atom:link href="http://0x3f.org/tags/%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml"/><item><title>PHP扩展框架的创建</title><link>http://0x3f.org/posts/create-php-extension-skeleton/</link><pubDate>Thu, 18 Jun 2015 14:15:00 +0000</pubDate><guid>http://0x3f.org/posts/create-php-extension-skeleton/</guid><description>创建项目 在PHP源码目录下的ext目录下执行：
1 ./ext_skel --extname=foobar 修改foobar/config.m4，移除以下三行前的dnl：
dnl PHP_ARG_WITH(foobar, for foobar support,
dnl Make sure that the comment is aligned:
dnl [ &amp;ndash;with-foobar Include foobar support])
编译与安装 在foobar目录下执行以下命令，生成configure脚本：
1 /usr/bin/phpize 执行configure：
1 ./configure --with-php-config=/usr/bin/php-config 编译安装：
1 sudo make install 修改php.ini，启用扩展：
1 extension=foobar.so</description></item><item><title>PHP流的上下文和过滤器的实现</title><link>http://0x3f.org/posts/contexts-and-filters-implementation-of-php/</link><pubDate>Mon, 15 Jun 2015 19:15:00 +0000</pubDate><guid>http://0x3f.org/posts/contexts-and-filters-implementation-of-php/</guid><description>上下文的实现和应用 上下文包含流的选项和流的参数两部分内容。
1 php_stream_context *php_stream_context_alloc(void); 流的选项是一系列键值对。
1 2 3 int php_stream_context_set_option(php_stream_context *context, const char *wrappername, const char *optionname, zval *optionvalue); int php_stream_context_get_option(php_stream_context *context, const char *wrappername, const char *optionname, zval ***optionvalue); 流的参数目前只实现对流的事件的回调，php_stream_context-&amp;gt;notifier存储如下结构：
1 2 3 4 5 6 7 typedef struct { php_stream_notification_func func; void (*dtor)(php_stream_notifier *notifier); void *ptr; int mask; size_t progress, progress_max; } php_stream_notifier; 回调函数的原型为：
1 2 3 4 5 typedef void (*php_stream_notification_func)(php_stream_context *context, int notifycode, int severity, char *xmsg, int xcode, size_t bytes_sofar, size_t bytes_max, void * ptr TSRMLS_DC); notifycode包含如下：</description></item><item><title>PHP流的操作</title><link>http://0x3f.org/posts/stream-operations-of-php/</link><pubDate>Mon, 01 Jun 2015 15:33:00 +0000</pubDate><guid>http://0x3f.org/posts/stream-operations-of-php/</guid><description>实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* reimplement fopen using stream */ ZEND_FUNCTION(donie_stream_fopen) { php_stream *stream; char *path, *mode; int path_len, mode_len; int options = ENFORCE_SAFE_MODE|REPORT_ERRORS; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &amp;#34;ss&amp;#34;, &amp;amp;path, &amp;amp;path_len, &amp;amp;mode, &amp;amp;mode_len) == FAILURE) { return; } stream = php_stream_open_wrapper(path, mode, options, NULL); if (!stream) { RETURN_FALSE; } php_stream_to_zval(stream, return_value); } php_stream_open_wrapper()是对文件类型资源创建流的方法，此外还有基于socket的流、目录流和特殊流三种。php_stream_to_zval()用于把流实例转换成zval结构。</description></item><item><title>PHP流的实现</title><link>http://0x3f.org/posts/stream-implementation-in-php/</link><pubDate>Fri, 29 May 2015 17:33:00 +0000</pubDate><guid>http://0x3f.org/posts/stream-implementation-in-php/</guid><description>流的概念 流是一系列概念的集合，包括流包装器、流资源、流操作、上下文等内容。流是对不同资源进行操作的抽象，允许线性地从指定位置读取或写入数据，通过一套统一的API简化对资源操作的实现。
流由scheme://target指代，scheme是包装器（Wrapper）的名字，target是流的目标地址。
PHP的流的实现较Java简单，后者可以通过嵌套实现更灵活的应用。
流的实现 存储结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 struct _php_stream { php_stream_ops *ops; void *abstract;	/* convenience pointer for abstraction */ php_stream_filter_chain readfilters, writefilters; php_stream_wrapper *wrapper; /* which wrapper was used to open the stream */ void *wrapperthis;	/* convenience pointer for a instance of a wrapper */ zval *wrapperdata;	/* fgetwrapperdata retrieves this */ int fgetss_state;	/* for fgetss to handle multiline tags */ int is_persistent; char mode[16];	/* &amp;#34;rwb&amp;#34; etc.</description></item><item><title>PHP全局变量的实现和操作</title><link>http://0x3f.org/posts/globals-implementation-in-php/</link><pubDate>Fri, 08 May 2015 17:23:00 +0000</pubDate><guid>http://0x3f.org/posts/globals-implementation-in-php/</guid><description>扩展内部的全局变量 1 2 3 4 ZEND_BEGIN_MODULE_GLOBALS(donie) unsigned long global_long; char *global_string; ZEND_END_MODULE_GLOBALS(donie) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ZEND_DECLARE_MODULE_GLOBALS(donie); static void php_donie_init_globals(zend_donie_globals *donie_globals) { donie_globals-&amp;gt;global_long = 2015; donie_globals-&amp;gt;global_string = &amp;#34;Long live Donie Leigh !&amp;#34;; } static void php_donie_globals_dtor(zend_donie_globals *donie_globals) { php_printf(&amp;#34;php_donie_globals_dtor triggered.&amp;#34;); } PHP_MINIT_FUNCTION(donie) { /* init extension globals */ ZEND_INIT_MODULE_GLOBALS(donie, php_donie_init_globals, php_donie_globals_dtor); return SUCCESS; } PHP_RSHUTDOWN_FUNCTION(donie) { #ifndef ZTS php_donie_globals_dtor(&amp;amp;donie_globals); #endif return SUCCESS; } ZEND_FUNCTION(donie_test_ext_globals) { php_printf(&amp;#34;%s&amp;#34;, DONIE_G(global_string)); } 声明 ZEND_BEGIN_MODULE_GLOBALS和ZEND_END_MODULE_GLOBALS及其间的内容实际上声明了一个结构体zend_donie_globals。</description></item><item><title>PHP常量的实现和操作</title><link>http://0x3f.org/posts/constant-implementation-in-php/</link><pubDate>Thu, 07 May 2015 16:29:00 +0000</pubDate><guid>http://0x3f.org/posts/constant-implementation-in-php/</guid><description>存储结构 常量存储在哈希表EG(zend_constants)中。
常量的结构定义为：
1 2 3 4 5 6 7 typedef struct _zend_constant { zval value; int flags; char *name; uint name_len; int module_number; } zend_constant; value是常量的值，是一个zval。name是常量名。module_number是模块被加载时，PHP内核在MINIT和RINIT方法的原型里默认传递的一个值，作为模块清理时的线索，在注册常量的接口里直接传递即可。
flags是常量的标识或标识组合：
CONST_CS CONST_PERSISTENT CONST_CT_SUBST CONST_CS表示常量名对大小写敏感，对应PHP函数define()的第三个参数，TRUE、FALSE、NULL这些常量名对大小写是不敏感的。CONST_PERSISTENT表示常量在请求结束后被保存，只在PHP进程结束时才销毁，一般在MINIT中定义的常量应该指定此参数，RINIT中定义的不指定。CONST_CT_SUBST表示在编译时可替换，TRUE、FALSE、NULL、ZEND_THREAD_SAFE、ZEND_DEBUG_BUILD属于此类。
常量的声明 常量的声明方法有两种，简单的使用宏函数族REGISTER_*_CONSTANT()：
REGISTER_NULL_CONSTANT(name, flags) REGISTER_BOOL_CONSTANT(name, bval, flags) REGISTER_LONG_CONSTANT(name, lval, flags) REGISTER_DOUBLE_CONSTANT(name, dval, flags) REGISTER_STRING_CONSTANT(name, str, flags) REGISTER_STRINGL_CONSTANT(name, str, len, flags)
由于不需指定常量名长度，所以name参数应直接使用字符串，而不是char*。
如需使用变量作为name参数，使用zend_register_*_constant()函数族，并指定变量名长度（sizeof(name)）。上面的宏函数其实是对这族函数的封装。
void zend_register_long_constant(char *name, uint name_len, long lval, int flags, int module_number TSRMLS_DC) void zend_register_double_constant(char *name, uint name_len, double dval, int flags, int module_number TSRMLS_DC) void zend_register_bool_constant(const char *name, uint name_len, zend_bool bval, int flags, int module_number TSRMLS_DC) void zend_register_string_constant(char *name, uint name_len, char *strval, int flags, int module_number TSRMLS_DC) void zend_register_stringl_constant(char *name, uint name_len, char *strval, uint strlen, int flags, int module_number TSRMLS_DC)</description></item><item><title>PHP资源的实现和操作</title><link>http://0x3f.org/posts/resource-implementation-in-php/</link><pubDate>Tue, 05 May 2015 18:53:00 +0000</pubDate><guid>http://0x3f.org/posts/resource-implementation-in-php/</guid><description>存储结构 资源变量也是一个zval结构，zval-&amp;gt;type == IS_RESOURCE，zval-&amp;gt;value-&amp;gt;lval存储一个整数，此整数为资源数据在存储资源的哈希表中的索引。
资源数据的结构为：
1 2 3 4 5 6 typedef struct _zend_rsrc_list_entry { void *ptr; int type; int refcount; }zend_rsrc_list_entry; 常规资源与持久资源 有两个存储资源数据的哈希表。EG(regular_list)存储常规资源，EG(persistent_list)存储持久资源。
常规资源对应的变量在作用域结束后会被内核回收，对应的资源数据也会被销毁。持久资源可以保持并被多次请求使用。持久资源的自动析构发生在PHP进程退出时。
实现 重新实现基本的文件句柄和相关操作。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 // 资源名称 #define PHP_DONIE_RES_NAME_FILE &amp;#34;Donie&amp;#39;s File Descriptor&amp;#34; // 资源类型 static int le_donie_file_descriptor; static int le_donie_file_descriptor_persist; // 资源析构函数 static void php_donie_file_descriptor_dtor(zend_rsrc_list_entry *rsrc TSRMLS_CC) { FILE *fp = (FILE*)rsrc-&amp;gt;ptr; fclose(fp); } // 在扩展的MINIT方法里创建资源类型 PHP_MINIT_FUNCTION(donie) { /* create a new resource type */ le_donie_file_descriptor = zend_register_list_destructors_ex( php_donie_file_descriptor_dtor, NULL, PHP_DONIE_RES_NAME_FILE, module_number ); /* create a persistent resource type */ le_donie_file_descriptor_persist = zend_register_list_destructors_ex( NULL, php_donie_file_descriptor_dtor, PHP_DONIE_RES_NAME_FILE, module_number ); return SUCCESS; } // 文件打开操作 PHP_FUNCTION(donie_fopen) { FILE *fp; char *filename, *mode; int filename_len, mode_len; zend_bool persist = 0; char *hash_key; int hash_key_len; list_entry *persist_file; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &amp;#34;ss|b&amp;#34;, &amp;amp;filename, &amp;amp;filename_len, &amp;amp;mode, &amp;amp;mode_len, &amp;amp;persist) == FAILURE) { RETURN_NULL(); } if (!</description></item><item><title>PHP对象的实现和操作</title><link>http://0x3f.org/posts/object-implementation-in-php/</link><pubDate>Wed, 29 Apr 2015 23:00:00 +0000</pubDate><guid>http://0x3f.org/posts/object-implementation-in-php/</guid><description>Object的存储结构 对象实例用zval存储。zval-&amp;gt;type == IS_OBJECT，zval-&amp;gt;value-&amp;gt;obj存储zend_object_value类型的结构体变量。
1 2 3 4 typedef struct _zend_object_value { zend_object_handle handle; const zend_object_handlers *handlers; } zend_object_value; zend_object_handle是一个unsigned int，是对象的ID。zend_object_handlers存储对象所有的行为。
Object的实例化过程 Object的初始化用以下几个宏函数：
object_init(zval *arg) object_init_ex(zval *arg, zend_class_entry *class_type) object_and_properties_init(zval *arg, zend_class_entry *class_type, HashTable *properties) 底层都是调用_object_and_properties_init(zval *arg, zend_class_entry *class_type, HashTable *properties)实现。这个函数做以下几件事：
检查类是否可实例化（例如接口、抽象类等不允许初始化） 处理类常量 检查类是否存在自定义实例化逻辑 若存在，调用自定义实例化逻辑 若不存在，调用缺省的函数zend_objects_new(zend_object **object, zend_class_entry *class_type) 把实例化的zend_object类型的数据存入zval中 zend_objects_new()做这些事：
分配一个zend_object类型的内存空间 初始化zend_object类型数据 把zend_object类型数据存入对象仓库（Objects Store） zend_objects_store_put(void *object, zend_objects_store_dtor_t dtor, zend_objects_free_object_storage_t free_storage, zend_objects_store_clone_t clone） zend_object的存储结构 1 2 3 4 5 6 typedef struct _zend_object { zend_class_entry *ce; HashTable *properties; zval **properties_table; HashTable *guards; /* protects from __get/__set .</description></item><item><title>PHP类和接口的实现</title><link>http://0x3f.org/posts/class-interface-implementation-in-php/</link><pubDate>Tue, 28 Apr 2015 18:38:00 +0000</pubDate><guid>http://0x3f.org/posts/class-interface-implementation-in-php/</guid><description>Class的实现 类的注册是在扩展的MINIT方法里。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 /* * this pointer should be put into the header file, * so other modules can access this class.</description></item><item><title>PHP数组的实现与操作</title><link>http://0x3f.org/posts/array-implementation-in-php/</link><pubDate>Fri, 24 Apr 2015 12:09:00 +0000</pubDate><guid>http://0x3f.org/posts/array-implementation-in-php/</guid><description>存储结构 和其它变量一样，PHP的数组也是一个zval。存储数据的哈希表存放在zval-&amp;gt;value-&amp;gt;ht中。
符号表操作 为实现可转换成整数的字符串键与整数键指向同一个元素，在哈希表操作的基础上封装了一层，对可转换成整数的字符串键转换成整数，然后调用zend_hash_index_*操作，否则调用zend_hash_*操作。这就是符号表操作。
用ZEND_HANDLE_NUMERIC处理整数字符串键：
1 2 3 4 5 6 static inline int zend_symtable_find( HashTable *ht, const char *arKey, uint nKeyLength, void **pData ) { ZEND_HANDLE_NUMERIC(arKey, nKeyLength, zend_hash_index_find(ht, idx, pData)); return zend_hash_find(ht, arKey, nKeyLength, pData); } 其它符号表操作函数：
1 2 3 4 5 6 7 8 static inline int zend_symtable_exists(HashTable *ht, const char *arKey, uint nKeyLength); static inline int zend_symtable_del(HashTable *ht, const char *arKey, uint nKeyLength); static inline int zend_symtable_update( HashTable *ht, const char *arKey, uint nKeyLength, void *pData, uint nDataSize, void **pDest ); static inline int zend_symtable_update_current_key_ex( HashTable *ht, const char *arKey, uint nKeyLength, int mode, HashPosition *pos ); 数组操作 初始化 1 2 3 4 5 6 7 8 9 // 初始化数组 zval *zv1; array_init(zv1); // 初始化数组并指定哈希表nTableSize的值 array_init_size(zv1, 100); // 在函数中返回数组：把返回值初始化为数组 array_init(return_value); 插入和更新 1 2 3 4 5 6 7 8 /* Insert at next index */ int add_next_index_*(zval *arg, .</description></item><item><title>PHP哈希表的实现与操作</title><link>http://0x3f.org/posts/hashtable-implementation-of-php/</link><pubDate>Thu, 23 Apr 2015 15:56:00 +0000</pubDate><guid>http://0x3f.org/posts/hashtable-implementation-of-php/</guid><description>结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 哈希表结构 typedef struct _hashtable { uint nTableSize; uint nTableMask; uint nNumOfElements; // 全部元素数 ulong nNextFreeElement; // 下一个可用的整数键 Bucket *pInternalPointer; // 枚举操作时使用，指向当前Bucket Bucket *pListHead; Bucket *pListTail; Bucket **arBuckets; dtor_func_t pDestructor; // 元素的析构函数 zend_bool persistent; // 是否在本次请求结束后保留哈希表 unsigned char nApplyCount; // 循环级别，防止循环引用导致遍历哈希表时死循环 zend_bool bApplyProtection; // 是否防止死循环 #if ZEND_DEBUG int inconsistent; #endif } HashTable; // Bucket结构 typedef struct bucket { ulong h; uint nKeyLength; void *pData; void *pDataPtr; struct bucket *pListNext; struct bucket *pListLast; struct bucket *pNext; struct bucket *pLast; char *arKey; } Bucket; 哈希冲突处理 哈希表通过计算键值的哈希值，将对应的数据映射到对应的槽上。理论上会存在不同的键的哈希值相同的情况。</description></item></channel></rss>