<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>PySide - 标签 - 晴耕雨讀</title><link>http://0x3f.org/tags/pyside/</link><description>PySide - 标签 - 晴耕雨讀</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 01 Jul 2013 00:57:00 +0000</lastBuildDate><atom:link href="http://0x3f.org/tags/pyside/" rel="self" type="application/rss+xml"/><item><title>PySide: How to Get the Position of a Widget-Value-Changed Cell in QTableWidget</title><link>http://0x3f.org/post/get-position-in-qtablewidget-for-changed-cellwidgets/</link><pubDate>Mon, 01 Jul 2013 00:57:00 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/get-position-in-qtablewidget-for-changed-cellwidgets/</guid><description><![CDATA[<p>Assume we have created an instance of QTableWidget, in which cells are filled with widgets like QComboBox, QCheckBox, etc. When values are changed, we need to get the row and column indexes of the cells. But the QTableWidget.cellChanged() and QTableWidget.itemChanged() signals are only effective for cells containing QTableWidgetItem instances, for those in which widgets are filled in with QTableWidget.setCellWidget(), this doesn&rsquo;t work.</p>
<p>This problem nearly made me crazy last weekend. So how can I make it ?</p>
<p>Here is the solution, by leveraging QSignalMapper, we can send other data to the slots instead of the default value. As the following code snippet shows, I put the row and column indexes into a string, then mapped it with the QComboBox.currentIndexChanged() slot. Notice that this slot has two generics, one accept an int type as the parameter and the other accept a string, so a <strong>QString</strong> key should be used to select the second generic.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">signalMapper</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QSignalMapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="p">)</span>
<span class="n">signalMapper</span><span class="o">.</span><span class="n">setMapping</span><span class="p">(</span><span class="n">comboWidget</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">,</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rowIdx</span><span class="p">,</span> <span class="n">colIdx</span><span class="p">))</span>
<span class="n">comboWidget</span><span class="o">.</span><span class="n">currentIndexChanged</span><span class="p">[</span><span class="s1">&#39;QString&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">signalMapper</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>
<span class="n">signalMapper</span><span class="o">.</span><span class="n">mapped</span><span class="p">[</span><span class="s1">&#39;QString&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__onCellWidgetChanged</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The only downside of this solution is, we should call QTableWidget.cellWidget() seperately to get the new value. Which I think it&rsquo;s not to much trouble.</p>
]]></description></item></channel></rss>