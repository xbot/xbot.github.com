<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>架构 - 标签 - 晴耕雨讀</title><link>http://0x3f.org/tags/%E6%9E%B6%E6%9E%84/</link><description>架构 - 标签 - 晴耕雨讀</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 06 Feb 2018 15:13:17 +0000</lastBuildDate><atom:link href="http://0x3f.org/tags/%E6%9E%B6%E6%9E%84/" rel="self" type="application/rss+xml"/><item><title>对XSS的防御更适合放在前端</title><link>http://0x3f.org/post/better-to-do-defenses-against-xss-in-front-end/</link><pubDate>Tue, 06 Feb 2018 15:13:17 +0000</pubDate><author>作者</author><guid>http://0x3f.org/post/better-to-do-defenses-against-xss-in-front-end/</guid><description><![CDATA[<p>很多项目会把转义操作放在后端接口获取参数的地方，从而忽略了这样一个问题——为什么主流框架都不在获取参数的方法里实现这一点？</p>
<p>以Laravel为例，如果可以这样获取转义后的参数：<code>$request-&gt;escape('content')</code>，代码会显得更优雅，而实际上只能用自己封装的函数手工转义：<code>my_escape($request-&gt;get('content'))</code>，很丑陋的代码。</p>
<p>事实上，主流框架并非没有提供防御XSS的封装，只是都放在模板引擎里。这样做的依据是，XSS的原理是在原本用于展示的数据里包含了可执行的文本，但不是所有展示的位置都不应该包含可执行的文本。从另一角度上说，后端应该校验前端传递的数据，但不应该篡改它。</p>
]]></description></item></channel></rss>