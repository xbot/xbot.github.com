<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>架构 on 晴耕雨讀</title><link>http://0x3f.org/tags/%E6%9E%B6%E6%9E%84/</link><description>Recent content in 架构 on 晴耕雨讀</description><generator>Hugo</generator><language>zh-cn</language><copyright>© 2007-2024 淘气</copyright><lastBuildDate>Tue, 06 Feb 2018 15:13:17 +0000</lastBuildDate><atom:link href="http://0x3f.org/tags/%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>对XSS的防御更适合放在前端</title><link>http://0x3f.org/posts/better-to-do-defenses-against-xss-in-front-end/</link><pubDate>Tue, 06 Feb 2018 15:13:17 +0000</pubDate><guid>http://0x3f.org/posts/better-to-do-defenses-against-xss-in-front-end/</guid><description>&lt;p>很多项目会把转义操作放在后端接口获取参数的地方，从而忽略了这样一个问题——为什么主流框架都不在获取参数的方法里实现这一点？&lt;/p>
&lt;p>以Laravel为例，如果可以这样获取转义后的参数：&lt;code>$request-&amp;gt;escape('content')&lt;/code>，代码会显得更优雅，而实际上只能用自己封装的函数手工转义：&lt;code>my_escape($request-&amp;gt;get('content'))&lt;/code>，很丑陋的代码。&lt;/p>
&lt;p>事实上，主流框架并非没有提供防御XSS的封装，只是都放在模板引擎里。这样做的依据是，XSS的原理是在原本用于展示的数据里包含了可执行的文本，但不是所有展示的位置都不应该包含可执行的文本。从另一角度上说，后端应该校验前端传递的数据，但不应该篡改它。&lt;/p></description></item></channel></rss>