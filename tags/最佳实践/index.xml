<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最佳实践 on 晴耕雨讀</title><link>http://0x3f.org/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><description>Recent content in 最佳实践 on 晴耕雨讀</description><generator>Hugo</generator><language>zh-cn</language><copyright>© 淘气 2022</copyright><lastBuildDate>Thu, 11 Jul 2024 17:33:26 +0800</lastBuildDate><atom:link href="http://0x3f.org/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/index.xml" rel="self" type="application/rss+xml"/><item><title>打通稍后读工作流：Readwise Reader 的 RSSHub 路由发布</title><link>http://0x3f.org/posts/rsshub-route-for-readwise-reader-is-published/</link><pubDate>Thu, 11 Jul 2024 17:33:26 +0800</pubDate><guid>http://0x3f.org/posts/rsshub-route-for-readwise-reader-is-published/</guid><description>本文聊聊在从 Inoreader 迁移到 Miniflux 后，我是怎样重建我的阅读工作流的。
原来的阅读工作流 在用过的 RSS 阅读器里，Inoreader 最符合我的阅读习惯。它有以下优点：
文章去重和过滤：由于订阅的资讯较多，这个功能能帮我节省很多时间。 接近 Vim 风格的快捷键：Vim 用户表示极度舒适。 多种布局：为不同的订阅源指定最合适的布局能极大提高阅读效率。 支持把标签输出为订阅源：方便通过 Calibre 订阅和抓取。 我在 Inoreader 里只做快速浏览，对需要阅读的文章打星标，随后集中对星标文章打标签。然后在 Calibre 里抓取指定标签的文章并生成电子书，既可以在 Calibre Content Server 的网页端阅读，也可以发送到 Kindle 离线阅读。
电脑上的阅读体验 在电脑上，我一直钟爱使用 Calibre Content Server 的网页端进行阅读。它具备以下特点：
自适应多栏布局：针对高分屏的优化，使得阅读体验更加舒适。 卡片式翻页：与传统的滚动式翻页相比，卡片式翻页在提高阅读效率的同时，也更加护眼。 自定义排版样式：可以根据自己的喜好调整阅读界面，打造个性化的阅读环境。 从 Inoreader 到 Miniflux 的转变 后来，Inoreader 的价格涨了很多，我尝试自建 Miniflux ，效果意外地好，但它有一个明显的局限性：只支持打星标，不支持打标签。这意味着我无法像使用 Inoreader 那样，通过标签对文章进行筛选和分类。
Readwise Reader 的优势 不过 Miniflux 支持集成 Readwise Reader 。它不仅支持标签功能，还提供了列表接口。这让我意识到，如果能够将 Readwise Reader 的文档输出为订阅源，那么我的稍后读工作流将更加完善。
RSSHub 路由发布 为了实现这一目标，我为 RSSHub 添加了一个路由，它可以将 Readwise Reader 的文档转换成订阅源。这样一来，我就可以在 Calibre Content Server 中愉快地阅读那些稍后阅读的文章了。</description></item><item><title>15￥ 包邮的尼龙脚踏，实现了我对休闲骑行脚踏的所有想象</title><link>http://0x3f.org/posts/wellgo-v984t-pedal/</link><pubDate>Wed, 22 May 2024 18:57:03 +0800</pubDate><guid>http://0x3f.org/posts/wellgo-v984t-pedal/</guid><description>休闲骑行脚踏的选择 休闲骑行的特点是单段持续时间较长、需要保持和队友的节奏，对车的好骑程度要求较高，对折叠便利性和折叠体积要求低。
在选择休闲骑行的脚踏时，我考虑了以下几种类型：
锁踏：由于市区路况复杂，休闲骑行不追求速度，因此锁踏并不适合。 钉踏：市面上产品众多，价格和外观选择丰富。但钉踏容易伤鞋，也容易把腿划破。之前买了用圆头防滑钉、号称不伤鞋的辉哥 J6 脚踏，骑了一个月也磨坏了运动鞋底的防滑纹。 平踏：最适合市区骑游的场景，我的期望是： 大踏面：提供舒适的踩踏体验。 抓脚但不伤鞋：在保证稳定性的同时，不伤鞋。 重量轻：对于折叠、携带的要求不高，可以牺牲快拆或折叠功能。 我了解或使用过的脚踏包括：
MKS：重量较重，价格较高。 维格 M111 类似脚踏：外观相似，采用 DU 轴或 DU + 单培林，在平踏中较为常见，视觉效果简洁，价格不贵，但踏面较小。包括： M111：外观、做工、重量表现最佳，价格最贵。 M248：做工一般，踏面和轴用螺丝结合。 M921：做工好，一体成形，漆面光滑。（下图右侧） 大行 Jifo 原装快拆脚踏：快拆设计方便，但安装复杂，且难以购买。（上图左侧） LP 的快拆脚踏：一体成形，但漆面差。 最终，我选择了维格的尼龙脚踏 V984T 。
维格提供了多种尼龙脚踏，我选择的是体积较小、重量较轻、与车外观搭配较为协调的 V984T 。它满足了我对配件和脚踏的所有选择标准，而且价格仅为 15￥ 包邮。这款脚踏的踩踏体验极为舒适，脚掌与踏面的贴合度非常好，有人体工学的感觉，超过了以往用过的所有脚踏。
关于脚踏润度的题外话 理论上，润度更高的脚踏可以提高踩踏效率，但对于我们普通人在市区道路上的骑行场景来说，追求高润度并没有太大意义。DU 轴的脚踏已经完全够用，既满足了日常需求，又保持了合理的价格。</description></item><item><title>夏季厨余垃圾防腐防虫绝招</title><link>http://0x3f.org/posts/summer-kitchen-organic-waste-preservation-insect-prevention-tips/</link><pubDate>Sat, 26 Aug 2023 19:01:49 +0800</pubDate><guid>http://0x3f.org/posts/summer-kitchen-organic-waste-preservation-insect-prevention-tips/</guid><description>做饭产生的湿垃圾，说多不多，说少不少，不想浪费垃圾袋，等快满了才扔。但是每次掀开桶盖都跟开盲盒似的，被各种难言的味儿熏一跟头，有几天吃水果比较多，打开桶盖跟天女散花一样，很多小虫子🪰。
疫情期间剩下不少酒精消毒液，最近灵机一动，每次饭后给厨余垃圾喷一点，几天下来既不生虫也没有怪味儿。🤪</description></item><item><title>保存 tweet 到 OmniFocus 的快捷指令</title><link>http://0x3f.org/posts/a-shortcuts-that-saves-tweets-to-omnifocus/</link><pubDate>Tue, 22 Nov 2022 21:34:25 +0800</pubDate><guid>http://0x3f.org/posts/a-shortcuts-that-saves-tweets-to-omnifocus/</guid><description>保存 tweet 到 OnniFocus 并提取内嵌链接的快捷指令，绕过了iOS 16 快捷指令“Make rich text from HTML”丢失编码信息导致乱码的 bug 。
https://www.icloud.com/shortcuts/fc68643daa044b44959f16b0a94ec598</description></item><item><title>用 Obsidian 写博客的方法</title><link>http://0x3f.org/posts/how-to-write-blog-with-obsidian/</link><pubDate>Sun, 23 Oct 2022 17:09:28 +0800</pubDate><guid>http://0x3f.org/posts/how-to-write-blog-with-obsidian/</guid><description>我用 Hugo + GitHub Pages 写博客，之前一直通过命令新建文章，然后在编辑器里一项一项修改 Front Matters ，最后再通过命令提交上去。有一天突然觉得这样太麻烦了，应该可以用图形界面简化一下。
Typora 收费之后，Obsidian 可能是最好的免费 Markdown 编辑器了。这里用到三个插件：QuickAdd 、 Templater 和 Obsidian Git 。
在 Hugo 目录下创建两个子目录 templates 和 scripts ，设置 Templater 的选项 Template folder location 为 templates 。
然后在 templates 目录下创建模板 New Post.md：
1 2 3 4 5 6 7 8 9 --- title: &amp;#34;{{VALUE:articleTitle}}&amp;#34; slug: &amp;#34;{{VALUE:articleSlug}}&amp;#34; date: {{VALUE:articleTimestamp}} categories: [&amp;#34;{{VALUE:articleCategory}}&amp;#34;] tags: toc: false draft: true --- 在 scripts 下创建脚本 create_new_post.js：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 module.</description></item><item><title>自动设置节假日和工作日闹钟的快捷指令</title><link>http://0x3f.org/posts/yet-another-shortcuts-that-sets-alarms-for-chinese-holidays-and-workdays-automatically/</link><pubDate>Thu, 20 Oct 2022 22:23:04 +0800</pubDate><guid>http://0x3f.org/posts/yet-another-shortcuts-that-sets-alarms-for-chinese-holidays-and-workdays-automatically/</guid><description>写了个自动设置节假日和工作日闹钟的快捷指令，数据源用的是苹果官方的“中国大陆节假日”日历。
https://www.icloud.com/shortcuts/97960ed8326e43d387b0d7bb459667dd
需要先订阅上述日历，订阅方法见这个快捷指令里的说明。
最后把它配置到自动化（比如助眠开始时执行）里就可以了。</description></item><item><title>用 Hammerspoon 收集 Arc 浏览器网页到 OmniFocus 的方法</title><link>http://0x3f.org/posts/how-to-collect-webpage-from-the-arc-browser-to-omnifocus/</link><pubDate>Wed, 19 Oct 2022 23:02:50 +0800</pubDate><guid>http://0x3f.org/posts/how-to-collect-webpage-from-the-arc-browser-to-omnifocus/</guid><description>我用 Hammerspoon 收集网页到 OmniFocus ，它的 SendToOmniFocus 对 Chrome 家族的浏览器有原生的支持，但并不适用于 Arc 浏览器。
看 SendToOmniFocus 的源码是用 Apple Script 获取 Chrome 家族浏览器中网页的信息的，但最初我没有解决怎样用同样的办法拿到 Arc 浏览器网页信息的问题。所以采取通过剪贴板中转的方式实现。
首先配置 Surfingkeys 实现把网页信息组装成特定格式复制到剪贴板：
1 2 3 4 5 6 7 8 9 10 11 mapkey(&amp;#39;yO&amp;#39;, &amp;#39;Copy OmniFocus sensible info.&amp;#39;, yankOmniFocusSensibleInfo); function yankOmniFocusSensibleInfo() { var info_arr = []; info_arr.push(&amp;#34;#omnifocus_sensible&amp;#34;); info_arr.push(document.title); info_arr.push(window.location.href); Clipboard.write(info_arr.join(&amp;#34;\n&amp;#34;)); } 然后在 Hammerspoon 中监听剪贴板，一旦发现特定格式的文本，就调用 Apple Script 填充解析到的网页信息到 OmniFocus 的对话框：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 -- Interpolate table values into a string -- From http://lua-users.</description></item><item><title>自动追剧的工作流</title><link>http://0x3f.org/posts/auto-workflow-of-following-tv-series-and-movies/</link><pubDate>Sun, 21 Nov 2021 17:16:15 +0800</pubDate><guid>http://0x3f.org/posts/auto-workflow-of-following-tv-series-and-movies/</guid><description>在 NAS 上搭了个自动追剧、追影的工作流，体验非常好。
只需要把想看的美剧或者电影添加到监控列表里，就可以在资源出现之后自动下载并通知到手机或电脑，全程无值守，回家打开电视就能看。
用到这些工具：
Jackett: BT 索引工具，负责搜索资源。 Prowlarr: Jackett 的平替，和 Radarr/Sonarr 同步 indexer 更方便，对 torrent 网站的限流机制处理得更好。 Sonarr: 电视剧管理工具，负责管理追剧列表、调用 Jackett 搜索、资源监控、下载调度。 Radarr: 电影管理工具，功能同 Sonarr 。 qBittorrent: BT 下载工具。 ChineseSubFinder: 字幕搜索工具。 Jellyfin: 媒体中心，负责影视剧转码、播放、管理。 Telegram: 接收通知。 nzb360: Android APP ， Sonarr 、 Radarr 、 qBittorrent 的客户端。 LunaSea: iOS 的 nzb360 平替，功能和用户体验稍逊后者。 Jackett 是 BT 资源索引工具，可以对添加到索引列表中的 BT 资源站点做集中搜索。
在 Jackett 因某个 indexer 由于其网站的限流措施而响应失败导致 Radarr 无法搜索且无法修改 indexer 配置后，我改用了 Prowlarr 。它不仅解决了之前遇到的问题，还可以自动同步 indexer 配置到 Radarr 和 Sonarr，并且它们的 UI 也十分统一。</description></item><item><title>用微力同步换掉了 Dropbox</title><link>http://0x3f.org/posts/replace-dropbox-with-verysync/</link><pubDate>Wed, 06 Oct 2021 01:24:41 +0800</pubDate><guid>http://0x3f.org/posts/replace-dropbox-with-verysync/</guid><description>我希望找到一种体验较好的方式，把两部手机和索尼黑卡上的照片集中同步到 NAS 上交由 PhotoPrism 托管。
需求如下：
可以方便地发送多平台照片到 NAS 。 可以单向同步手机到 NAS 并忽略手机的删除操作，以节省手机的存储空间。 可以实现内网穿透且简单稳定。 便宜。 对比了 PhotoSync 、 Resilio Sync 、 Syncthing 和微力同步（verysync）。
PhotoSync 作为专门针对同步照片的场景设计的 APP ，完美覆盖前两点，第三点可以借助 NAS 已经配置好的内网穿透实现，但是需要购买相应的 Plan ，而且 Android 和 iOS 平台要各自单独购买。
Resilio Sync 实现内网穿透需要引入新的依赖关系，不完全满足第三点。
Syncthing 看起来不错，但是没有官方的 iOS 客户端。
微力同步据说是基于 Syncthing 的，且补上了后者缺失的一环。各平台免费，只有 iOS 上需要花 12￥ 买 APP 。
我的 NAS 运行的是 Unraid ， Community Applications 里没有微力同步，在这里找到了别人配置好的模板，部署很方便。
试用后因为太好用，干脆把 Dropbox 目录也放到微力同步里，卸载了会占用很多内存且免费方案 3 个端的限制早已捉襟见肘的 Dropbox 。</description></item><item><title>改变 Vim 模式时自动切换输入法的方法</title><link>http://0x3f.org/posts/auto-switch-input-method-while-changing-vim-mode/</link><pubDate>Wed, 19 Feb 2020 21:48:15 +0000</pubDate><guid>http://0x3f.org/posts/auto-switch-input-method-while-changing-vim-mode/</guid><description>VS Code的Vim插件有个很贴心的功能，可以在切换到普通模式时自动切换到英文输入法，而当切换回插入模式时再换到此前的输入法。
设置的方法很简单。先安装im-select，然后配置如下（macOS）：
当然，在Vim里也可以利用im-select实现这个功能。</description></item><item><title>在 VS Code 中快速创建 PHPUnit 测试类的方法</title><link>http://0x3f.org/posts/quickly-create-phpunit-test-cases-with-vscode/</link><pubDate>Tue, 18 Feb 2020 22:49:45 +0000</pubDate><guid>http://0x3f.org/posts/quickly-create-phpunit-test-cases-with-vscode/</guid><description>&lt;p>通过单元测试解决问题或者调试代码，可以避开错综复杂的依赖关系、直击问题的核心，从而极大地节约时间、提高效率。&lt;/p>
&lt;p>但是，当创建测试类成为一个经常发生的操作时，每次都手动创建类、引入基类、添加测试方法就显得很烦琐。我需要这样一个解决方案，让我可以立即开始着手写测试代码。&lt;/p></description></item><item><title>用Github当图床</title><link>http://0x3f.org/posts/take-github-as-image-hosting-service/</link><pubDate>Thu, 06 Feb 2020 22:00:00 +0000</pubDate><guid>http://0x3f.org/posts/take-github-as-image-hosting-service/</guid><description>&lt;p>微博图床的域名不知道什么时候改了，Google找不到相关信息，经过排查发现原域名中的“ws”改成了“wx”，浪费了不少时间。&lt;/p>
&lt;p>于是打算换图床。&lt;/p></description></item><item><title>用C4-PlantUML画软件架构图</title><link>http://0x3f.org/posts/design-software-architecture-with-c4-plantuml/</link><pubDate>Fri, 17 Jan 2020 17:29:24 +0000</pubDate><guid>http://0x3f.org/posts/design-software-architecture-with-c4-plantuml/</guid><description>&lt;p>&lt;a href="https://c4model.com">C4 Model&lt;/a>是一种简洁有序的架构模型，四个“C”分别表示“Context”、“Container”、“Component”和“Code”，是由上而下逐步细化的四个层级。&lt;/p></description></item><item><title>用鼠须管输入日期时间的方法</title><link>http://0x3f.org/posts/input-date-and-time-with-rime/</link><pubDate>Wed, 08 Jan 2020 13:52:49 +0000</pubDate><guid>http://0x3f.org/posts/input-date-and-time-with-rime/</guid><description>&lt;p>原来在Linux下用小小输入法，输入日期时间很方便。换到Mac后，很早就在关注这个问题，直到后来鼠须管实现了嵌入Lua脚本的功能才得以解决。&lt;/p></description></item><item><title>AirPods Pro的使用感受</title><link>http://0x3f.org/posts/the-expirence-of-airpods-pro/</link><pubDate>Tue, 05 Nov 2019 16:18:54 +0000</pubDate><guid>http://0x3f.org/posts/the-expirence-of-airpods-pro/</guid><description>&lt;p>Bose QC35曾是带给我巨大幸福感的工具，并且三年来一直处于重度使用的状态。但是它的一些弱点，使得在某些细分场景下并不能得到很好的体验。首先是包耳式的设计在夏天会很热。其次，虽然有折叠的功能，但头戴式的设计对于日常通勤来说，还是不够便携。再次，QC35一代的降噪级别只能通过APP设置，很麻烦，所以我一直都保持默认开启状态，出于安全性考虑，不适合徒步或者骑行。&lt;/p>
&lt;p>于是后来买了一副AirPods（以下简称AP）。高温和骑行的体验得以改善，但一直被通勤过程中北京公交糟糕的乘坐体验所困扰。其实在购买AP之前，更想买的是带降噪功能的耳塞，当时索尼的降噪豆一代才刚上市，评测普遍反馈体验不太好，而QC30的狗圈又让我完全接受不能，除此之外，在当时并无更多的选择。AP其实是权衡之后妥协的结果。&lt;/p>
&lt;p>所以从看到AirPods Pro（以下简称APP）上市的消息到下单，并没有考虑太久。下单时提示可能一到两周才能到货，但其实第二天就发了货，次日到手。体验了几天，说说感受。&lt;/p></description></item><item><title>PHP单元测试的技巧</title><link>http://0x3f.org/posts/phpunit-tips/</link><pubDate>Tue, 13 Aug 2019 14:21:48 +0000</pubDate><guid>http://0x3f.org/posts/phpunit-tips/</guid><description>&lt;p>以下是我平时写单元测试时总结的一些最佳实践，有些是和具体的框架强相关的。&lt;/p></description></item><item><title>用ALE替换了Syntastic</title><link>http://0x3f.org/posts/replace-syntastic-with-ale/</link><pubDate>Wed, 12 Dec 2018 20:42:10 +0000</pubDate><guid>http://0x3f.org/posts/replace-syntastic-with-ale/</guid><description>&lt;p>习惯频繁地保存源码，但是每次保存都有明显的卡顿，于是用Vim自己的调优功能跟踪了一下。&lt;/p></description></item><item><title>配置鼠须管的特殊符号输入</title><link>http://0x3f.org/posts/input-punctuations-with-rime/</link><pubDate>Sat, 13 Oct 2018 11:59:50 +0000</pubDate><guid>http://0x3f.org/posts/input-punctuations-with-rime/</guid><description>开源工具最常见的问题就是文档不全，实现一个需求的时候只能苦苦Google，甚至连蒙带猜。这也是我逐渐倾向买用户体验更好的收费软件的原因。
鼠须管是自带特殊符号码表的，在用户配置目录中的symbols.yaml，但是有的码表需要手动配置。经过查资料和摸索，关键在于以下几项配置：
1 2 3 4 5 6 7 punctuator: import_preset: symbols recognizer: import_preset: default patterns: punct: &amp;#34;^/([a-z]+|[0-9]0?)$&amp;#34; 然后就可以通过【/】+【编码】的方式显示符号备选项了，具体的编码可以到symbols.yaml里看，当然一般为了方便定制该码表，会复制并重命名该文件，然后上述的配置项里也要做相应的修改。</description></item><item><title>鼠须管的美化</title><link>http://0x3f.org/posts/beautify-squrrel-input-method/</link><pubDate>Sat, 21 Apr 2018 20:52:42 +0000</pubDate><guid>http://0x3f.org/posts/beautify-squrrel-input-method/</guid><description>效果如下： 尽管鼠须管的Github仓库一直在更新，但释出版已经很久没有更新了，所以下面的美化基于网络上个人编译的版本。这篇文章里有该版本和「花园明朝」字体的下载链接，按照文中的说明替换鼠须管的程序。（注意：官方当前释出版本鼠须管不支持下文通过patch自定义配置的方式，会造成原配置信息丢失。也不支持图示的样式。）
然后参考这篇文章，把新的颜色方案移植到用户配置中。
图示样式使用「dust」方案。原色彩方案的字体设置的有点小，需要把font_point和label_font_point分别从14和10修改成18和14。原方案的第一顺序字体是「HYQiHei-55S Book」，要使用图示的花园明朝字体，可以不安装或者从配置信息中去掉该字体。由于原方案中已存在的配置项不能通过patch的方式覆盖，所以只能直接修改squirrel.yaml文件。</description></item><item><title>我在用的Safari扩展</title><link>http://0x3f.org/posts/the-safari-extensions-i-am-using/</link><pubDate>Sun, 15 Apr 2018 22:29:10 +0000</pubDate><guid>http://0x3f.org/posts/the-safari-extensions-i-am-using/</guid><description>和Chrome相比，Safari更省电、需要更少的系统资源，而且Chrome还有一些莫名其妙的问题，比如在没有运行的时候，从Alfred执行搜索会启动两个窗口，一个是之前的会话，另一个是当前的搜索页面。并且，启用了一些扩展之后Safari的体验可以改进很多。所以平时用Safari更多一些。
sVim 作为注重效率的Vim党和键盘党，这种扩展是使用任何浏览器必备的东西。最常用的就是用标记打开链接的功能。
Tampermonkey 油猴脚本管理器，应该是任何浏览器必备的东西。
AutoPagerize 用Google搜索时自动滚动到下一页。
RSS Menu 当发现当前页面有可订阅的RSS链接时，在工具栏图标上显示提示。
Instapaper 稍后读工具。
Turn Off the Lights 看视频时降低网页其余部分亮度。
Scroll To Top Button 在页面右下角显示一个浮动的跳转到页首按钮。
Push for Kindle FiveFilters.org的发送到Kindle按钮。
octotree GitHub侧边栏。
Translate 翻译当前页。
WikiWand 优化维基百科阅读体验。
Xdebug Helper PHP单步调试辅助工具。
AdBlock 广告过滤器。
Sessions 网页会话管理器。如果打开的页面太多，又可能在将来再用到，可以保存会话后清理掉，用到的时候再打开保存过的会话。虽然没有Chrome下的Session Buddy和Tab Snooze好用，但是解决关键问题也够了。</description></item><item><title>广告过滤工具AdBlock、Adblock Plus和uBlock的简单对比</title><link>http://0x3f.org/posts/a-simple-comparison-among-adblock-ublock-and-adblock-plus/</link><pubDate>Sun, 01 Apr 2018 22:47:47 +0000</pubDate><guid>http://0x3f.org/posts/a-simple-comparison-among-adblock-ublock-and-adblock-plus/</guid><description>Adblock Plus作者的那篇博客可能会影响很多人。我并不关心那些情怀的东西，只看疗效。
简单地对比了下AdBlock、Adblock Plus、uBlock在Safari for Mac上的效果，所有样本和环境均为当前最新版本。AdBlock开启Safari内容过滤后是最好的，成功地过滤掉了我常访问的一个BT下载网站上的所有广告，而不开启Safari内容过滤时，会出现部分广告先显示后隐藏的情况。uBlock漏掉了个别不容易屏蔽的。而Adblock Plus最差，缺省设置下一条都没过滤掉，在选择更多的过滤规则后才过滤掉一部分。由于样本很单一，本结论不具有普适性。
说句题外话，我觉得Adblock Plus这名字起得动机就挺不纯的，没有详细考证过，印象中这个东西是比AdBlock后出现的，而且这名字很容易让人理解成AdBlock的加强版。</description></item><item><title>iQunix F60使用感受</title><link>http://0x3f.org/posts/iqunix-f60/</link><pubDate>Sat, 17 Feb 2018 15:40:47 +0000</pubDate><guid>http://0x3f.org/posts/iqunix-f60/</guid><description>我不喜欢冗余的东西。如果桌子足够大，我能接受的极限是87键。然而我的Filco 87圣手二代黑茶已经吃灰很久了，之前的主力是Poker II白青。所以目前主要的关注点还是在60键上。
我对Poker整体上还是比较满意的，尤其是按键编程的功能很方便。但是有两点让我很不满意。一是做工一般，键帽的活动幅度较大，远远没有Filco的扎实感。二是不支持蓝牙，无线化是一个用了就回不去的东西。
iQunix F60就是这么个东西，符合我对键盘所有的核心需求：支持蓝牙、做工好、60%布局、Cherry轴、PBT键帽。用了一段时间，整体是满意的。
买的银白色，收到的是侧刻，算是个小惊喜吧，虽然不如无刻骚气，至少不像正刻那么平庸。铝合金外框加白色PBT键帽的颜值很高，整体很有质感。
做工比Poker好很多，找回了Filco的扎实感。PBT的键帽不打油，这一点超过了Filco。
续航一般，轻度使用可以持续一周。信号强度也很一般，一米的距离，已能感受到明显的延迟。不过这些在实际的使用中不是什么大问题。
功能上，不支持键盘编程，这点不如Poker。但是可以用组合键交换左侧WIN键和ALT键，对Mac很友好。代替方向键的组合键位也比Poker合理。此外，可以用组合键切换有线和无线模式，支持在3台设备之间切换。</description></item><item><title>飞利浦电动牙刷HX9903/42使用感受</title><link>http://0x3f.org/posts/philips-hx9903-42/</link><pubDate>Sat, 10 Feb 2018 17:23:15 +0000</pubDate><guid>http://0x3f.org/posts/philips-hx9903-42/</guid><description>效果虽说没别人说的夸张，也的确刷得很干净，再就是缓解了胳膊的疲劳感。
有个问题。刚开始的几天，虽然电池已经充满，但是震动强度很一般，而且手柄底部的压力警示灯一直闪，试过拔掉刷头，问题还在，说明是手柄的问题。直到提示电量紧张后第二次充电，之后才恢复正常。
App、多种刷头、多种模式、压力警示和三级震动强度都是噱头，刷个牙而已，HX6730足够了，多交的几百块钱除了智商税，也就颜值和无线充电有点价值了。
电动牙刷不是个用了就回不去的东西，不过体验确实很好，刷牙不再是例行公事和负担，而是件挺有意思的事。</description></item><item><title>用OTP Auth替换了Authy</title><link>http://0x3f.org/posts/migrate-from-authy-to-otp-auth/</link><pubDate>Tue, 06 Feb 2018 22:53:40 +0000</pubDate><guid>http://0x3f.org/posts/migrate-from-authy-to-otp-auth/</guid><description>Authy的界面很花哨，但并不实用，管理多个两步验证账号时查询效率很低。OTP Auth采用更直观的列表布局，并且支持搜索，在用户体验和效率上有更大的优势。两者之间没有批量迁移数据的方式，只能逐个手动添加，很麻烦。</description></item><item><title>Unlox：兼顾安全和体验的东西深得我心</title><link>http://0x3f.org/posts/unlox/</link><pubDate>Sun, 14 Jan 2018 16:52:11 +0000</pubDate><guid>http://0x3f.org/posts/unlox/</guid><description>买了Unlox。早就知道MacID，阴差阳错一直没买，所以这又是一次后知后觉的行为。
曾经用过一段时间ControlPlane，通过多种条件自动判断场景以启用或关闭锁屏密码。后来在一次系统升级之后就不能用了。因为这个东西本身体验也不是很好，免费的东西折腾起来太耗费精力，所以付费买体验也是个不错的选择。
有三个功能对我来说很有用。
首先是用Face ID解锁Mac。在Mac被唤醒后，iPhone X自动弹出解锁的通知，点击后Unlox被打开并自动调用Face ID，验证通过后Mac即被解锁。不过两次Face ID验证稍显繁琐，如果在iPhone锁屏界面验证通过后就自动解锁，体验会更好。不过我猜应该是iOS在这个地方不会通知到App。
其次是Tap解锁。用手指点击触摸板，点击次数和每次用的手指数目可以自定义。这个方式确实很方便。为了加强安全性，还可以设置当手机断开时禁用Tap解锁。
第三是离开时自动锁屏。可以设置当手机和Mac之间的蓝牙连接信号减弱多少时自动锁屏。虽然对于Macbook用处不大，也不失为忘记合上屏幕时的一种补救手段。
此外还有其它一些功能，例如通过手机锁定或解锁Mac、靠近时自动唤醒Mac等。
今年Apple应该会全系支持Face ID，所以这只是一个过渡方案。</description></item><item><title>密码管理的最佳实践</title><link>http://0x3f.org/posts/the-best-practice-of-password-management/</link><pubDate>Wed, 27 Dec 2017 17:26:17 +0000</pubDate><guid>http://0x3f.org/posts/the-best-practice-of-password-management/</guid><description>通密之所以不应该被过分指责，是因为有其存在的道理，没有哪种方案的管理成本比它更低，它不需要购买昂贵的1password，不需要担心临时用的时候突然想不起来，而且，只要这个密码足够强壮并且使用环境足够安全，大多数情况下也不会有什么问题。通密的问题在于它的风险成本太高，一旦一处泄漏，所有使用这个密码的地方都不安全。
另一个极端是，使用很复杂的密码，每个账号都不同，甚至用密码生成工具生成完全没有规律的随机字符串。这种方案的安全性很高，高到连你自己都记不住。
所以我需要这样一套好的方案，它应该在安全性和易用性之间取得一个比较好的平衡，并且随著方法论和工具链的进化，这个平衡可以无限逼近黄金分割点。
首先，密码应该是复杂但容易记住的。密码的复杂度和记忆负担并不成正比，例如如果你实在记不住“ppnn13%,dkstFeb1st”，那么这样呢——“娉娉袅袅十三余，豆蔻梢头二月初”。密码只是一个字符串，如果不去死记最终的值，而是字符串背后的规律，记忆的压力就会小很多。
但考虑到每个账号都想一个这样的密码是不现实的，而且怎么解决记忆密码和账号的对应关系的问题？所以进一步，可以用这样的密码当前缀，每个密码的前缀都一样，然后针对每个账号创造一个后缀，这个后缀应该是每个账号都不同的，且和账号有某种只有你自己才知道的关联，这样你可以随时根据账号计算出它的后缀。例如，可以用账号拼音首字母（当然，实际的规则应该更复杂一点）。
这样你就有了足够复杂、每个账号都不同并且很容易记住的密码。进一步地，在私有设备上可以利用文本替换功能（例如：Alfred for Mac的Snippets功能）快速输入通用前缀，某些支持按键编程的机械键盘会有更好的体验。
不过好记性不如烂笔头，为防万一，还是需要一个Plan B。主流的密码管理工具主要有这么几种：
浏览器的账号记忆功能 操作系统的keychain 在线密码管理工具 离线密码管理工具 浏览器一般是把密码以明文存储在本地的，firefox虽然有个主密码，但只是个幌子，别人仍然可以拿到它记录密码的数据库文件。这种做法的逻辑在于，设备上存储的数据的安全性由操作系统和用户负责，换句话说，用户不应该允许他人用自己的权限登录设备。但实际上很难避免这种情况，而且还要考虑到系统被入侵的可能。所以，只应该让浏览器记住那些最不重要的账号。
相对来说，操作系统的keychain一般有自动锁定的功能，会更安全一些。但是仍无法完全避免上述问题。而且keychain只能记录账号和密码，无法存储更多的附加信息。所以这种工具也只应该存储一些不重要的账号。
最著名的在线密码管理工具应该是Lastpass。关于它的安全性有很多种说法，不过我觉得但凡是敏感数据都不要存储到线上，所以这种方式不予考虑。
我倾向于使用离线的密码管理工具。1password据说很好用，但是太贵了，而且开源免费的keepass已经完全够用了。我在Mac上用KeePassXC，在iOS中用MiniKeePass，私钥文件离线存储，然后数据库文件用Dropbox同步就可以了。
此外，对于重要的账号，如果支持两步验证，一定要开启，然后用OTP Auth管理即可。
最终的方案是：
方法论：统一的复杂但有规律的前缀+根据账号计算出来的后缀 工具链：KeePass + OTP Auth + Dropbox</description></item><item><title>测试驱动开发的实际收益</title><link>http://0x3f.org/posts/the-real-income-of-tdd/</link><pubDate>Sun, 17 Dec 2017 14:20:02 +0000</pubDate><guid>http://0x3f.org/posts/the-real-income-of-tdd/</guid><description>我并不试图系统地谈TDD，因为我在这方面的经验还不足以做到这一点。但是TDD的一些方法论和工具确实解决了我在实际开发过程中遇到的一些问题。
第一个问题是健壮性。尤其是对于我这样思维发散、容易迷失又喜欢重构的人，TDD给了我一个明确的目标，在一切刚开始的时候，我要做的只是满足测试用例，让它们由红变绿。到了重构阶段，我就可以把精力放到优化代码上面，且不必对健壮性有过多的担心。在此之前，由于手动测试比较麻烦，很多时候惰性会说服潜意识告诉自己这部分逻辑很简单、不会有什么bug，结果提交测试后却一再地发生问题。
第二个问题是效率。曾经只有不忙的时候才会写测试用例，但是现在一般都会写，因为确实可以提高开发效率，而不只是保证重构的健壮性。可能对于所有对单元测试不熟悉的人来说，这都是匪夷所思的，我也曾认为单元测试只是用来保证健壮性的，必然和开发效率是一对矛盾，因为要花很多时间写测试代码。这种想法首先是因为对单元测试不熟悉，所以才需要花很多时间在上面。其次是没有看到它所带来的好处。
例如你要实现一整套退款单的功能，退款单是依赖订单的，这意味著你需要不只一条符合条件的订单数据。但是订单是有状态的，随著时间的推移、人为的操作或者开发过程中程序的影响，状态会变得不再符合你的要求，这时候你就必须停下来去做更多符合要求的订单。而创建订单也存在很多麻烦，你需要找到有库存的商品，有时候还要去库管系统中补充库存，然后下单并支付。最后花了很多时间做出来的订单，因为正在开发的退款单的程序出现的一个小问题变得不能使用！时间被大量浪费在创建所依赖的上游数据上。
这时候如果用单元测试并mock出依赖关系，就可以随时随地、无限制地执行相关的业务逻辑。对效率的提高不言而喻。
特别的，mock并不是随时可以抓起的救命稻草，它的原罪在于：不负责任地滥用mock会导致很多问题被掩盖。因此，对mock的使用应该是节制的、目标明确的。
当然，这并不包括单纯地为了提高代码覆盖率而使用mock，只所以这是个在很多强制TDD的团队里的普遍现象，归根结底是因为KPI是万恶之源，任何好的方法论，一旦沦为KPI，就离死不远了。</description></item><item><title>BaiduPCS：当前最好用的百度网盘下载工具</title><link>http://0x3f.org/posts/baidupcs/</link><pubDate>Tue, 12 Dec 2017 21:21:16 +0000</pubDate><guid>http://0x3f.org/posts/baidupcs/</guid><description>BaiduPCS是个命令行工具，用于下载百度网盘中的资源。之前用的是浏览器插件，需要先创建分享，再拿到下载链接，最后用下载工具下载。这个工具可以直接执行一条命令下载指定的资源，非常方便。
这里有安装说明，然后按照使用说明操作即可。</description></item><item><title>iOS垃圾短信过滤器：熊猫吃短信</title><link>http://0x3f.org/posts/panda-eats-sms/</link><pubDate>Sun, 10 Dec 2017 12:08:47 +0000</pubDate><guid>http://0x3f.org/posts/panda-eats-sms/</guid><description>“熊猫吃短信”是个新上架的App，用于过滤垃圾短信。据说是基于机器学习训练出来的，用了一周，识别得非常准确。
之前用的腾讯手机管家，即使把“精准识别”、“上传到云端”等选项都打开，还会有漏网之鱼，而且会牺牲隐私。这个App声称不会主动上传短信。最重要的是，这一周里所有不关心的短信都被过滤掉了，而且没有失误。</description></item><item><title>全新Kindle Oasis使用感受</title><link>http://0x3f.org/posts/the-all-new-kindle-oasis/</link><pubDate>Sat, 09 Dec 2017 14:03:08 +0000</pubDate><guid>http://0x3f.org/posts/the-all-new-kindle-oasis/</guid><description>早在Paperwhite 1的时候我就不喜欢它的工业设计：边框太宽，屏幕内陷。此外，非人体工学设计和没有实体翻页键导致单手握持体验很差。再有就是做工的问题，机身表面接缝处缝隙明显而不均匀、通体强烈的塑料感。然而还是从一代用到了三代，除了kpw是kindle全系列里性价比最高的产品线之外，还有就是没有其它任何一款产品解决了kpw的主要问题。
例如Voage，虽然屏幕不内陷了、楔形机身优化了握持感、增加了翻页键，但整体的设计只算是在kpw基础上的优化，何况各项硬件配置和kpw3几乎无差。
后来当第一代Oasis发布的时候，看了第一眼就瞬间失掉了兴趣。捆绑的充电保护壳绝对是体验杀手，装上壳比kpw还要厚重，不装的话本体的续航又很差，频繁拆装也很不方便，这样的体验连kpw都不如。所以我很不看好它，果然很快在今年六月就下架了。
十月刚看到新Oasis的消息时，马上觉得这回终于有买的价值了。
首先是7寸的屏幕，瞬间和其它产品线拉开了距离。更大的屏幕意味著能展示更多内容，增加了宽度后也更接近实体书的观感。
工业设计相对于我的kpw3当然是有了质的改变。玻璃材质的纯平表面，金属背壳，没有了kpw的塑料感，显得更精致。得益于窄边框，7寸屏的机身长度比6寸的kpw还短。虽然因为加宽了屏幕和增加了单手握持的边框导致机身宽度超过kpw很多，不过在平时携带中并没有造成很多困扰。
单手握持是ko系列的主要卖点，实际使用体验当然很好。为握持设计的宽边框加上实体翻页键非常方便。虽然因为加大屏幕和增加续航导致194g的重量远远超过1代的131g，但还是比kpw轻了10g，而且主要重量集中在单手握持的一边，杠杆效应很小。配合重力感应，随时换手可以有效缓解疲劳。当然，作为长时间单手握持的阅读设备，重量自然越轻越好，这一点上，ko还有很大优化的空间。
此外，新ko的做工远远好于kpw，没有了廉价感。12颗背光灯使得背光的均匀度比kpw强了很多，几乎不会有kpw上明显的光影。性能上是现在kindle全系列里最高的，翻页时虽然还会看到闪屏，但比以前已经快了很多。自动亮度调节算是个聊胜于无的功能吧。至于防水和有声书，我没有这方面的需求。
如果说缺点的话，还是续航。虽然相对于1代本体，续航已经达到可用的水平，但是对于被其它产品线惯坏的我们来说，新ko电量的消耗还是快了点。我没有精确的对比，但是能明显地感觉到比kpw掉得快不少。</description></item><item><title>清洁手机的最佳实践</title><link>http://0x3f.org/posts/how-to-clean-a-phone/</link><pubDate>Sun, 03 Dec 2017 22:51:42 +0000</pubDate><guid>http://0x3f.org/posts/how-to-clean-a-phone/</guid><description>以前的做法是先用湿巾清理，再用纸巾擦干。后来屏幕的触感逐渐不如开始时顺滑，也更容易沾指纹和灰尘，而且不容易清除。估计应该是湿巾的酒精会腐蚀屏幕的涂层，纸巾粗糙的表面也会造成磨损。
现在先用软毛刷扫除灰尘，然后用3M魔布擦拭。效果应该会更好。</description></item><item><title>Vim最好的PHP语法高亮插件</title><link>http://0x3f.org/posts/the-best-php-syntax-file-of-vim/</link><pubDate>Tue, 28 Nov 2017 15:55:59 +0000</pubDate><guid>http://0x3f.org/posts/the-best-php-syntax-file-of-vim/</guid><description>StanAngeloff/php.vim应该是目前最新、最全的PHP语法高亮插件了，它解决了旧版本无法高亮@throws的问题。
默认会把方法注释全部当做普通注释显示，也就是没有高亮，需要专门做配置：
1 2 3 4 5 6 7 8 9 function! PhpSyntaxOverride() hi! def link phpDocTags phpDefine hi! def link phpDocParam phpType endfunction augroup phpSyntaxOverride autocmd! autocmd FileType php call PhpSyntaxOverride() augroup END</description></item><item><title>用AlfredTweet发推</title><link>http://0x3f.org/posts/tweet-with-alfredtweet/</link><pubDate>Sun, 17 Sep 2017 09:26:41 +0000</pubDate><guid>http://0x3f.org/posts/tweet-with-alfredtweet/</guid><description>AlfredTweet是用来解决“最后一公里”问题的东西，有了它就可以随时发推了。
需要修改源码指定代理：
1 2 3 4 5 6 7 8 9 // twitteroauth.php function http($url, $method, $postfields = NULL) { // ... curl_setopt($ci, CURLOPT_HTTPPROXYTUNNEL, TRUE); curl_setopt($ci, CURLOPT_PROXY, &amp;#39;127.0.0.1:1086&amp;#39;); curl_setopt($ci, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5); // ... }</description></item><item><title>用vim-test简化单元测试的编写</title><link>http://0x3f.org/posts/make-writing-unit-tests-easier-with-vim-test/</link><pubDate>Mon, 14 Aug 2017 16:43:59 +0000</pubDate><guid>http://0x3f.org/posts/make-writing-unit-tests-easier-with-vim-test/</guid><description>vim-test允许在Vim中直接执行一个或多个单元测试，并使用预设的或自定义的执行策略。
例如，命令:TestNearest可以执行当前测试文件中离光标最近的一个测试方法。而:TestFile、:TestSuite和:TestLast分别执行整个测试文件、测试项目和最近一次执行过的测试。这在编写测试代码时能很大地提高效率。
执行策略是执行测试的方式和环境。例如缺省状态下，将使用:!执行测试命令，这会从Vim切换回终端。而在MacVim下，可以选择在iTerm或者系统自带的Terminal中执行。</description></item><item><title>用vim-laravel简化laravel下的开发</title><link>http://0x3f.org/posts/speed-up-artisan-with-vim-laravel/</link><pubDate>Fri, 11 Aug 2017 15:05:30 +0000</pubDate><guid>http://0x3f.org/posts/speed-up-artisan-with-vim-laravel/</guid><description>vim-laravel是个极简而实用的插件，只提供一个:Artisan命令。但它并不仅仅是artisan的一个wrapper，还可以实现一些贴心的自动化，利如自动打开artisan make:*创建的文件。</description></item><item><title>用vim-php-namespace管理PHP的命名空间</title><link>http://0x3f.org/posts/manage-php-namespaces-with-vim-php-namespace/</link><pubDate>Fri, 11 Aug 2017 14:56:12 +0000</pubDate><guid>http://0x3f.org/posts/manage-php-namespaces-with-vim-php-namespace/</guid><description>vim-php-namespace是个简单实用的插件，提供三种功能：
自动用use语句导入光标下的类 自动把光标下的类名扩展成完整命名空间的格式 自动排序use语句 此外，还提供一个选项控制是否在导入类后自动排序use语句。</description></item><item><title>使neocomplete和ultisnips共用tab键的方法</title><link>http://0x3f.org/posts/reconcile-neocomplete-with-ultisnips/</link><pubDate>Fri, 11 Aug 2017 14:43:14 +0000</pubDate><guid>http://0x3f.org/posts/reconcile-neocomplete-with-ultisnips/</guid><description>昨天用vim-clevertab换掉了supertab，但是实际使用中总是出莫名其妙的问题。看了一下插件源码，使用全局变量判断状态，这是个很不靠谱的方案，所以还是卸掉了。
下面的配置可以很好的解决问题：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let g:UltiSnipsExpandTrigger=&amp;#34;&amp;lt;c-tab&amp;gt;&amp;#34; let g:UltiSnipsJumpForwardTrigger=&amp;#34;&amp;lt;c-tab&amp;gt;&amp;#34; let g:UltiSnipsJumpBackwardTrigger=&amp;#34;&amp;lt;s-tab&amp;gt;&amp;#34; let g:UltiSnipsSnippetsDir=&amp;#39;~/.vim/UltiSnips&amp;#39; let g:ulti_expand_or_jump_res = 0 function! CleverTab()&amp;#34;{{{ call UltiSnips#ExpandSnippetOrJump() if g:ulti_expand_or_jump_res return &amp;#34;&amp;#34; else if pumvisible() return &amp;#34;\&amp;lt;c-n&amp;gt;&amp;#34; else return neocomplete#start_manual_complete() endif endif endfunction&amp;#34;}}} inoremap &amp;lt;silent&amp;gt; &amp;lt;tab&amp;gt; &amp;lt;c-r&amp;gt;=CleverTab()&amp;lt;cr&amp;gt; snoremap &amp;lt;silent&amp;gt; &amp;lt;tab&amp;gt; &amp;lt;esc&amp;gt;:call UltiSnips#ExpandSnippetOrJump()&amp;lt;cr&amp;gt; ultisnips没有禁用按键映射的开关，而默认的映射会干扰上述配置，所以这里把默认的映射改成了&amp;lt;c-tab&amp;gt;。</description></item><item><title>用vim-plug换掉了vim-addon-manager</title><link>http://0x3f.org/posts/replaced-vam-with-vim-plug/</link><pubDate>Mon, 31 Jul 2017 22:44:16 +0000</pubDate><guid>http://0x3f.org/posts/replaced-vam-with-vim-plug/</guid><description>四年零两个月前，我在Vim的邮件组中征询pathogen和vundle的优劣。一个人建议我试试VAM，语气幽怨——他是它的作者。
试过之后就从pathogen迁移到了VAM，因为它兼有前者和vundle的优点，在当时，这是最好的插件管理器。就这样用了很久，期间还写了点脚本简化插件的管理，VAM工作得很好。
最近发现越来越多的插件的文档里提到vim-plug，亮点是支持并行安装和更新，这真是解决了VAM最大的痛点：我叠代了十年的vimrc里用了很多插件，串行的VAM每次更新都让我很痛苦。
另外，vim-plug较VAM的另一个优势是简单。这倒不是说后者很难用，只是作者过于追求灵活性，导致有些工作实现起来相对更复杂。例如，有的插件安装之后需要做一些额外的操作，VAM需要自己实现回调函数，然后挂到post-install钩子上。而对于vim-plug，只需要在注册插件的地方增加一个选项。对于插件的懒加载，也是同样。
VAM也有自己的优势。其中之一是可以自动处理依赖关系：当一个要被安装的插件依赖别的插件时，相应的依赖也会被自动安装。还有就是对多源的支持：既可以拉取github上的插件，也可以从vim.org或其它源安装。而vim-plug就只支持github。
所以，vim-plug并没有全面超过VAM，只是没有明显的短板、功能又刚刚够用。</description></item><item><title>用choosewin.vim切换窗口</title><link>http://0x3f.org/posts/choosewin-vim/</link><pubDate>Sun, 30 Jul 2017 20:48:46 +0000</pubDate><guid>http://0x3f.org/posts/choosewin-vim/</guid><description>输入-显示每个窗口的hint，输入hint跳转，简单而高效：</description></item><item><title>利用goyo.vim专注写作</title><link>http://0x3f.org/posts/distraction-free-writing-in-vim/</link><pubDate>Sat, 29 Jul 2017 16:48:45 +0000</pubDate><guid>http://0x3f.org/posts/distraction-free-writing-in-vim/</guid><description>goyo.vim是给vim提供专注写作模式的插件，配合markdown效果不错：
最好在单独的vim实例中使用，已发现和vim-workspace配合不好的情况。
对markdown文件自动开启goyo的配置如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 function! s:auto_goyo() if &amp;amp;ft == &amp;#39;markdown&amp;#39; Goyo 80 else let bufnr = bufnr(&amp;#39;%&amp;#39;) Goyo! execute &amp;#39;b &amp;#39;.bufnr endif endfunction augroup goyo_markdown autocmd! autocmd BufNewFile,BufRead * call s:auto_goyo() augroup END</description></item><item><title>用vim-workspace换掉了session.vim</title><link>http://0x3f.org/posts/replace-session-vim-with-vim-workspace/</link><pubDate>Wed, 19 Jul 2017 17:47:30 +0000</pubDate><guid>http://0x3f.org/posts/replace-session-vim-with-vim-workspace/</guid><description>用session.vim一直有几个痛点。一是保存会话后，退出时仍然会提示保存。二是会话会记录vimrc，恢复会话后用的仍然是旧的配置。
vim-workspace没有这些问题，而且实现了更多功能。</description></item><item><title>用neocomplete换掉了YouCompleteMe</title><link>http://0x3f.org/posts/replace-youcompleteme-with-neocomplete/</link><pubDate>Sat, 15 Jul 2017 10:29:48 +0000</pubDate><guid>http://0x3f.org/posts/replace-youcompleteme-with-neocomplete/</guid><description>在尝试了多种方案后，我又一次换掉了自动补全插件。
工具应该是能提高生产力的，而不是相反，很长一段时间以来，YouCompleteMe带给我的却是个疑惑，真不知道这个东东到底是提高了我的生产力，还是反之。自动补全在提高输入速度和准确度上都有助益，但是有时候补全选项弹出的又很慢。
测试了nvim-complete-manager+LanguageClient-neovim+LanguageServer-php-neovim、deoplete+phpcd、deoplete+padawan、neocomplete+phpcomplete-extended，效果都非常不理想。最后选择了neocomplete+phpcomplete，速度可以接受，表现比YCM稳定，功能该有的都有。
相关阅读： How to Make YouCompleteMe Compatible with UltiSnips Vim的终极自动补全插件：NeoComplCache</description></item><item><title>LeaderF，也许是Vim最好的模糊查询插件</title><link>http://0x3f.org/posts/leaderf-currently-the-best-fuzzy-finder-of-vim/</link><pubDate>Thu, 13 Jul 2017 16:45:15 +0000</pubDate><guid>http://0x3f.org/posts/leaderf-currently-the-best-fuzzy-finder-of-vim/</guid><description>之前对比过几个模糊查询插件（Fuzzy Finder），最后选定了ctrlp。
用了下LeaderF，在速度和匹配的准确度上都明显超过了ctrlp，所以用它换掉了后者。
只是在交互方式上，我更喜欢ctrlp，文件列表高度是动态变化的，最匹配的行和输入焦点都在窗口的最下方。LeaderF是定高的，最匹配的行在最上方，个人认为不如前者自然。
能解决痛点的才是好东西，什么时候能换掉YouCompleteMe就好了。</description></item><item><title>CopyQ，也许是Linux最好的剪贴板管理工具</title><link>http://0x3f.org/posts/copyq/</link><pubDate>Mon, 19 Jun 2017 21:49:14 +0000</pubDate><guid>http://0x3f.org/posts/copyq/</guid><description>我对剪贴板管理工具的核心需求有四个：
记录文本 记录图片 快速搜索 独立软件包 CopyQ是Linux上唯一满足这些需求的实现，虽然体验上跟Mac下的竞品还有差距。
用法：
copyq：运行 copyq menu：显示剪贴板历史管理菜单 copyq show：显示剪贴板历史管理窗口</description></item><item><title>用Tmux的控制模式提高生产力</title><link>http://0x3f.org/posts/improve-productivity-with-tmux-control-mode/</link><pubDate>Sun, 11 Jun 2017 10:40:06 +0000</pubDate><guid>http://0x3f.org/posts/improve-productivity-with-tmux-control-mode/</guid><description>Tmux的控制模式（Control Mode）可以把tmux的窗口映射为本地虚拟终端的窗口，也就是说，用户可以像操作本地虚拟终端一样操作tmux。这对备受tmux的emacs风格的热键绑定折磨或需要嵌套tmux的人来说非常有用。
在支持这个特性的虚拟终端（例如「iTerm」）里，执行tmux -CC即可。当然也可以tmux -CC a恢复会话。</description></item><item><title>用SwitchHosts!切换主机映射方案</title><link>http://0x3f.org/posts/switch-hosts-with-switchhosts/</link><pubDate>Sun, 11 Jun 2017 09:57:54 +0000</pubDate><guid>http://0x3f.org/posts/switch-hosts-with-switchhosts/</guid><description>最近在Archlinux上开始用SwitchHosts!管理主机映射方案，它可能是Linux下做这件事的最好的工具了。
在Mac下也用它替换掉了Gas Mask，因为支持Alfred Workflow。相对的缺点是不支持在状态栏图标上显示当前方案名称，不过Alfred里可以，一定程度上缓解了这个问题。</description></item><item><title>网站签到的最佳实践</title><link>http://0x3f.org/posts/the-best-practice-of-checking-in/</link><pubDate>Wed, 24 May 2017 11:42:52 +0000</pubDate><guid>http://0x3f.org/posts/the-best-practice-of-checking-in/</guid><description>v2ex、优酷、什么值得买用qiandao.today实现。优点是依赖少，速度快，支持的范围广，可扩展。缺点是对京东和京东金融无效。
京东和京东金融使用daily-signin。缺点是依赖docker，速度慢。
淘宝签到没有有效的脚本，用淘金币一键领取。
飞猪也没有有效脚本，手工签：
http://trip.taobao.com/mytrip/?tvm=tvip http://trip.taobao.com/mytrip/ http://h5.m.taobao.com/trip/member/index.html</description></item><item><title>接口编程中记录日志的最佳实践</title><link>http://0x3f.org/posts/the-best-practice-of-logging-in-api-programming/</link><pubDate>Tue, 25 Apr 2017 15:50:41 +0000</pubDate><guid>http://0x3f.org/posts/the-best-practice-of-logging-in-api-programming/</guid><description>解决什么问题 快速定位日志 降低记录成本 提高代码可读性 日志框架是项目开始阶段应该最先搭建好的内容之一，有助于极大地节约以后解决问题的时间和成本。但这也是最让我头疼的问题之一，因为记日志不光包括用什么记、怎么记，也包括记什么内容，这恰恰是最容易被忽略的问题。
一条好的日志需要做到能让问题的跟踪者快速定位它在程序中的位置且包含关键数据。工作中不乏这样的团队成员，在移交接口问题的时候没有主动提供关键信息的意识，所谓关键信息，是指像问题发生的环境、接口名、传递的实参和返回结果这样的内容，使得面向契约编程本来是很好的开发模式，却得不到最好的应用。这时我们可以从自己接口的日志中得到一些弥补。
但是日志的记录不应该占用很大的代码量，一来降低了代码的可读性，二来会耗费太多的时间精力。
本文目的在于讨论一种日志记录的最佳实践方式，使得可以兼顾以上这些问题。
实践 这里针对Laravel实现一个日志工具类，实现以下功能：
兼容Laravel自己的日志系统 自动记录关键的业务数据 自动记录日志所属的接口名 自动记录接口的实参 记录接口的返回值 生成简洁规范的日志内容 代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 &amp;lt;?</description></item><item><title>用Raspberry Pi实现音频Airplay</title><link>http://0x3f.org/posts/implement-airplay-with-raspberry-pi/</link><pubDate>Mon, 17 Apr 2017 10:19:51 +0000</pubDate><guid>http://0x3f.org/posts/implement-airplay-with-raspberry-pi/</guid><description>用树莓派做音频airplay效果不错，老书架音箱又可以用起来了。
实现方式是shairplay-sync，利用HDMI转VGA线上的3.5mm音频输出孔，因为我的树莓派2B的3.5mm音视频输出口没有合适的转接头。
我用的是Arch Linux ARM，需要手动开启HDMI输出。修改/boot/config.txt：
1 2 3 4 hdmi_force_hotplug=1 hdmi_drive=2 config_hdmi_boost=4 dtparam=audio=on 重启后，用alsamixer把树莓派音量调整到最大值。
AUR里没有针对ARM的shairplay-sync，需要手动编译：
1 git clone https://github.com/mikebrady/shairport-sync.git 1 2 # 生成configure autoreconf -i -f 1 2 3 4 5 6 # 针对systemd编译 ./configure --sysconfdir=/etc --with-alsa --with-avahi --with-ssl=openssl --with-metadata --with-soxr --with-systemd # END 1 2 3 4 5 6 7 8 # 如果shairport-sync用户不存在，新增用户和用户组 getent group shairport-sync &amp;amp;&amp;gt;/dev/null || sudo groupadd -r shairport-sync &amp;gt;/dev/null getent passwd shairport-sync &amp;amp;&amp;gt; /dev/null || sudo useradd -r -M -g shairport-sync -s /usr/bin/nologin -G audio shairport-sync &amp;gt;/dev/null # END airplay默认的服务名和树莓派的hostname一致，可以到/etc/shairport-sync.</description></item><item><title>编写接口文档的最佳实践</title><link>http://0x3f.org/posts/the-best-practice-of-writing-api-documents/</link><pubDate>Mon, 10 Apr 2017 16:36:27 +0000</pubDate><guid>http://0x3f.org/posts/the-best-practice-of-writing-api-documents/</guid><description>前言 传统的做法是用office写接口文档，这种方式的缺点很多：
格式混乱 事实上，所有的传统富文本文档都存在这个问题，富文本的跨平台兼容性很差，很容易造成格式错乱。
版本管理困难 依赖文件系统管理文档是很落后的做法，很难保证手头的文档是最新的版本。
兼容性差 不是所有人都用windows。
低效 对效率的负面影响很大程度上已经包含在前面几项里。此外，编辑工具的臃肿、编辑内容的同时还要调整样式、缺少全文检索等，也是导致效率下降的原因。
理想情况 理想的接口文档应该有以下特征：
方便创作 文档编辑最重要的是文档的内容，而不是编辑操作本身。所以编写文档的过程应该是简单快捷的，而且最好不需要额外的学习成本。
排版简洁规范 技术文档的排版，简洁规范是最重要的，花哨的排版会降低效率。
方便查阅 应该有目录或者大纲视图，并且可以方便地全文检索。
在线协作 传统的离线文档不方便协作。
多端兼容 允许在大多数常见平台编辑和使用文档。
版本管理 可以查看什么人在什么时间改了哪些内容。
交互式文档 所见即所得。可以修改参数、发送请求并查看接口返回值。
可订阅 可以给接口打标签。用户可以订阅任意标签下的接口变更，也可以针对接口订阅。
自动生成 如果代码的可读性足够好，何必浪费时间写文档？或者至少可以自动生成。
当前实践 理想很丰满，但是目前还没有能满足以上所有需求的解决方案。权衡之下，markdown和wiki是目前比较合适的方案。
markdown 用markdown写文档有以下特点：
适合单文档形式 主流git托管平台都支持 适合个人创作 适合小型项目、需要移交开发成果的项目 下面是用markdown写的接口文档的例子： 主流markdown编辑器在转换过程中会为标题添加锚点，利用这个特性可以实现从接口列表跳转到接口详情。
最佳工具 Cmd Markdown
美观 跨平台 编辑操作支持Vim模式 wiki 用wiki写文档有这些特点：
方便多层级文档 需要自己搭建平台 适合团队创作 适合长期、大型项目 最佳工具 dokuwiki
刚刚好 结论 综上，小型的、托管在主流git平台的项目适合用markdown，公司级项目用wiki更好。但这还达不到理想的标准，需要继续探索更好的解决方案。</description></item><item><title>MacOS中切换输入法的最佳实践</title><link>http://0x3f.org/posts/the-best-practice-of-switching-input-methods-in-macos/</link><pubDate>Mon, 20 Mar 2017 14:25:00 +0000</pubDate><guid>http://0x3f.org/posts/the-best-practice-of-switching-input-methods-in-macos/</guid><description>原则：
一键切换 可以对特定应用设定初始输入状态 可以方便地确认当前输入状态 兼容外接键盘 思路：
用Karabiner Elements把右Shift修改成F19，在系统里设置用F19切换输入法 用isHUD显示输入法状态 用Keyboard Maestro自动切换键盘布局 Karabiner Elements会使系统的键盘布局失效，且不能对不同的键盘使用不同的布局，所以只有用Keyboard Maestro自动切换。
isHUD只在切换输入法时有效，理想情况是用Caps Lock键灯表示输入状态，不过目前没找到可用的解决办法。
鼠须管可以对不同的应用设置初始输入状态，但只是在切换输入法后，例如对于Alfred，如果上次鼠须管处于中文输入状态，再次打开输入框的时候不会变成英文状态，因此需要在Alfred中设置初始输入法为英文。</description></item><item><title>沙发椅，让阅读更有趣</title><link>http://0x3f.org/posts/my-new-sofa-chair/</link><pubDate>Sat, 18 Mar 2017 22:48:35 +0000</pubDate><guid>http://0x3f.org/posts/my-new-sofa-chair/</guid><description>心水沙发椅很久了，终于拔草。
因为喜欢极简，之前一直用著一张双人小沙发，但是不够舒适，也不便移动。后来坐过一间餐厅的沙发椅感觉包覆感很好，就想著换一下，于是出掉了沙发，准备入一把伊姆斯椅，偶然看到现在这把，瞬间庆幸没有草率地买前者。
在阳台上阅读变得更有趣了，这椅子和小抱枕很搭（不是照片中这个）。</description></item><item><title>Vim 查找与替换的最佳实践</title><link>http://0x3f.org/posts/the-best-practice-of-searching-in-vim/</link><pubDate>Sun, 19 Feb 2017 20:37:18 +0000</pubDate><guid>http://0x3f.org/posts/the-best-practice-of-searching-in-vim/</guid><description>更新 日期 更新内容 2022-03-16 更新 80% 的内容。包含这几年所有的配置上的更新，并且把 ag 换成了 rg 。 2017-02-19 第一版。 目标 多文件搜索和替换
使用 PCRE 正则表达式在工作目录下递归搜索 将选定文本自动转换成正则表达式 有较高的搜索速度 对搜索结果做替换 当前 buffer 内的搜索和替换
一键将选定文本自动转换成正则表达式并执行搜索或替换 依赖 Ferret：实现对搜索和替换操作的封装。 ripgrep：搜索工具，速度快。 工具和方法 Ferret Ferret 是我用过的 vim 搜索扩展里最接近理想的一个，最大的优点是不用引号包裹搜索内容，且较大程度地支持 PCRE 正则表达式。
EasyGrep 的缺点是正则表达式必须是 shellescape() 过的，手写不方便，也不直观。Ferret 在底层做了 shellescape() ，所以比 EasyGrep 简单一些。不过 Ferret 对反斜杠的处理仍然不直观，例如搜索App\Link，正则表达式是App\\Link，而Ferret里只能用App\\\\Link。原因是从输入到执行，存在著三层转义：Vim命令行、Shell、grep/ag。所以对于EasyGrep，要搜索一个\，必须输入\\\\\\\\。对于Ferret，由于底层做了shellescape()，只需要两层转义，即\\\\。当然这样也不方便，所以我用自定义函数XEscapeRegex()对选择的内容做这个事，不过最完美的方法当然是Ferret自己支持，或者自己再封装一下Ferret的命令，这样输入的正则表达式可读性就正常了。
Ferret 的另一个优点是可以对搜索结果做筛选，删除不需要做替换的行，再对剩下的行执行批量替换。当执行替换命令 :Acks 时，会自动把上一个 :Ack 命令中的正则表达式或关键词补全到命令的参数中。
Ferret 最大的问题在于，搜索使用 rg 、 ag 这样的命令行工具，而替换使用 Vim 内置的 :substitute 命令。前者使用 PCRE 正则表达式，而后者使用 Vim 自己的正则表达式。两者在格式上的不兼容导致对一些复杂的 pattern 做搜索和替换时，往往需要对 pattern 做修改才能正常对之前的搜索结果做替换。关于这个问题，后面细说。</description></item><item><title>Bose QC35，这安静有毒</title><link>http://0x3f.org/posts/the-experience-of-bose-qc35/</link><pubDate>Sat, 18 Feb 2017 20:23:28 +0000</pubDate><guid>http://0x3f.org/posts/the-experience-of-bose-qc35/</guid><description>我很容易受环境影响，即便在家里比较安静的时候，也经常集中不了注意力。小时候总是可以连续几个小时读一本书，现在已经很久没有长时间专心做一件事了。戴了一段时间QC35，又重新找回了这种感觉，干什么事都很专心，感觉很安静，心态平和很多。
之前先入手了森海大馒头，不过没有降噪的功能，所以必须一直配合白噪声使用，时间长了还是有点累的。另外，有线耳机实在不方便，所有的数码设备都应该无线化，对生活品质的提升会很大。虽然大馒头作为出街向的东西，手机也推得动，但是要发挥音质，还是得上耳放，我不是发烧友，这木耳就算了。
所以对QC35长草很久了，后来大法又出了MDR 1000X，作为对标QC35的东西，有这些优点：
独立的降噪开关 手势操作 快速反应模式 音质 QC35的优势：
穿戴更舒适 同时连接两个设备 关于耳机，我的核心需求是：
降噪效果好 无线 舒适 在满足核心需求的基础上，选择有价格优势的东西。1000X肯定更方便，不过没有这些功能好像问题也不大。而且有些噱头的实际体验究竟有多好，我是有疑问的，比如手势的误操作问题。在我看来，为这些噱头买单不值，所以最后选了QC35。
使用一段时间下来体验确实很好，已经对这久违的安静上瘾了，长时间戴也没有不适感，同时连接电脑和手机也很方便。</description></item><item><title>改用Bear记笔记</title><link>http://0x3f.org/posts/switch-to-bear/</link><pubDate>Mon, 14 Nov 2016 23:32:00 +0000</pubDate><guid>http://0x3f.org/posts/switch-to-bear/</guid><description>再次证明我是后知后觉的。
曾经对印象笔记不屑一顾，因为对所见即所得的偏见和印象笔记对技术人员的不友好。所以这些年一直用DokuWiki。
DW的编辑模式不是传统的所见即所得，自己的wiki标记简洁好用。能针对段落进行修改。可以列出大纲。插件和主题较多。使用文件存储数据，方便同步。平台无关，对Linux友好。
不过DW自身也存在一些问题：
需要搭建服务 自行处理同步 移动端访问不便 编辑和查看操作有割裂感 最近开始琢磨记笔记的最佳实践。考虑到用DW的痛点，感觉对于记笔记最重要的是是否方便记录和查看。在这点上，所见即所得的确有优势。所以我尝试转换到这类工具上。
选择Bear而不是印象笔记的原因主要是：
支持代码语法高亮 支持导出Markdown格式 极简风和多种主题 代码语法高亮是刚需，没什么可说的。导出Markdown格式可以方便写博客，这样就不需要Cmd Markdown了。极简的风格和包括Solarized在内的多种主题很毒我。
不过Bear也有不少问题：
没有大纲视图，不适合长笔记 标签只支持两级，大量标签不好管理 不支持扫描 对Linux不友好 用标签替代分类的方式我很喜欢，不过两级的限制让笔记分类很伤脑筋，而且容易造成标签太多、难以管理。扫描也是刚需，印象笔记的扫描就很好用，Bear目前没有这个功能，只能用扫描全能王暂补，割裂感很强，而且还增加了APP。
希望Bear尽快变得更好用。</description></item><item><title>CtrlP vs Unite vs Command-T vs FuzzyFinder</title><link>http://0x3f.org/posts/ctrlp-vs-unite-vs-command-t-vs-fuzzyfinder/</link><pubDate>Wed, 27 Jan 2016 16:16:00 +0000</pubDate><guid>http://0x3f.org/posts/ctrlp-vs-unite-vs-command-t-vs-fuzzyfinder/</guid><description>简述 Sublime在文件打开速度上的表现很惊艳，Vim有几个扩展可以实现类似功能，本文对这些扩展做个对比。
虽然每个扩展都或多或少地实现了一些功能，我个人用得最多的也就文件、Tag、Buffer Tag的模糊查找这三个，像MRU、buffer之类的查找不觉得有多大用处，所以提高工作效率的工具一定是在热度环节有很好表现，其余偏门功能可以交给插件实现，在这点上CtrlP和Unite做得很好。所以下面针对最常用的这三个功能做下对比，更多功能的对比见下表：
文件模糊查找 Command-T的文件索引速度最快，各方面在这几个扩展中的表现都是最好的。
CtrlP默认使用VIM自建的globpath()，需要手工配置使用ag以获取更快的速度，据说使用find命令效率更高，实际感觉和ag差别不大。
Unite也需要手工设置使用ag，而且可以实现异步索引，在这一点的体验上好于前两个，但是在模糊匹配的排序上表现不好，比如输入“php”，当然希望“/etc/php.ini”这样的结果排在“/home/peter/host/tmp.txt”前面，实际往往不是这样，Unite的几个sorter里，数rank的排序结果最接近于这个要求，但是表现仍然不如前两个。
Tag模糊查找 三个扩展都是通过ctags实现，虽然Unite的排序问题仍然存在，对于Tag这么简短的东西，问题不大。
Buffer Tag模糊查找 CtrlP的表现是最好的。
Unite需要通过unite-outline这个source实现，但是只能列出类和方法，无法定制列举类型。而且默认选中排在第一位的类名，查询方法时很不方便。
Command-T不支持此功能。
我的选择 FuzzyFinder是该类扩展里的老前辈，不过早已不维护，功能上不比其它几个出彩。Command-T虽然在文件索引速度上表现最好，但是优势并不很明显，而且支持功能最少。所以排除这两个。
在最常用的三个功能上，CtrlP的综合表现是最均衡的，所以留下它。Unite本身是一种统一的交互方式和界面，很多扩展（source）可以实现五花八门的功能，像unite-outline虽然在Buffer Tag上表现不佳，对于Markdown和Vim文档还是很有用的。
Update: 2016-02-01 FZF: 又一个文件模糊查询工具</description></item></channel></rss>